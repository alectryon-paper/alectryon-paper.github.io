<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.16: http://docutils.sourceforge.net/" />
<title>Chapter 4: Semantics via Interpreters</title>
<meta name="authors" content="Adam Chlipala" />
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
</head>
<body>
<div class="alectryon-root alectryon-standalone alectryon-centered"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><div class="document" id="chapter-4-semantics-via-interpreters">
<h1 class="title">Chapter 4: Semantics via Interpreters</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Authors:</th>
<td>Adam Chlipala</td></tr>
<tr class="summary field"><th class="docinfo-name">summary:</th><td class="field-body">A chapter from FRAP (CC-BY), used to demo Alectryon</td>
</tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<p>We begin with a return to our arithmetic language from the last chapter,
adding subtraction <a class="footnote-reference" href="#id2" id="id1">[1]</a>, which will come in handy later.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>good pun, right?</td></tr>
</tbody>
</table>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">arith</span> : <span class="kt">Set</span> :=
| Const (n : nat)
| Var (x : var)
| Plus (e1 e2 : arith)
| Minus (e1 e2 : arith)
| Times (e1 e2 : arith).</span></span></span></pre><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Example</span> <span class="nf">ex1</span> := Const <span class="mi">42</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Example</span> <span class="nf">ex2</span> := Plus (Var <span class="s2">&quot;y&quot;</span>) (Times (Var <span class="s2">&quot;x&quot;</span>) (Const <span class="mi">3</span>)).</span></span></span></pre><p>The above definition only explains what programs <em>look like</em>.
We also care about what they <em>mean</em>.
The natural meaning of an expression is the number it evaluates to.
Actually, it's not quite that simple.
We need to consider the meaning to be a function over a valuation
to the variables, which in turn is itself a finite map from variable
names to numbers.  We use the book library's <tt class="docutils literal">map</tt> type family.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">valuation</span> := fmap var nat.</span></span></span></pre><p>That is, the domain is <tt class="docutils literal">var</tt> (a synonym for <tt class="docutils literal">string</tt>) and the codomain/range
is <tt class="docutils literal">nat</tt>.</p>
<p>The interpreter is a fairly innocuous-looking recursive function:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">interp</span> (<span class="nv">e</span> : arith) (<span class="nv">v</span> : valuation) : nat :=
  <span class="kr">match</span> e <span class="kr">with</span>
  | Const n =&gt; n
  | Var x =&gt;
    <span class="c">(* Note use of infix operator to look up a key in a finite map. *)</span>
    <span class="kr">match</span> v $? x <span class="kr">with</span>
    | None =&gt; <span class="mi">0</span> <span class="c">(* goofy default value! *)</span>
    | Some n =&gt; n
    <span class="kr">end</span>
  | Plus e1 e2 =&gt; interp e1 v + interp e2 v
  | Minus e1 e2 =&gt; interp e1 v - interp e2 v
                   <span class="c">(* For anyone who&#39;s wondering: this [-] sticks at 0,</span>
<span class="c">                    * if we would otherwise underflow. *)</span>
  | Times e1 e2 =&gt; interp e1 v * interp e2 v
  <span class="kr">end</span>.</span></span></span></pre><p>Here's an example valuation, using an infix operator for map extension.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">valuation0</span> : valuation :=
  $<span class="mi">0</span> $+ (<span class="s2">&quot;x&quot;</span>, <span class="mi">17</span>) $+ (<span class="s2">&quot;y&quot;</span>, <span class="mi">3</span>).</span></span></span></pre><p>Unfortunately, we can't execute code based on finite maps, since, for
convenience, they use uncomputable features.  The reason is that we need a
comparison function, a hash function, etc., to do computable finite-map
implementation, and such things are impossible to compute automatically for
all types in Coq.  However, we can still prove theorems about execution of
finite-map programs, and the <tt class="docutils literal">simplify</tt> tactic knows how to reduce the
key constructions.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="chk0" type="checkbox"><label class="coq-input" for="chk0"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">interp_ex1</span> : interp ex1 valuation0 = <span class="mi">42</span>.</span></label><div class="coq-output" id="goal0"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp ex1 valuation0 = <span class="mi">42</span></span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk1" type="checkbox"><label class="coq-input" for="chk1"><span class="highlight"><span class="nb">simplify</span>.</span></label><div class="coq-output" id="goal1"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="mi">42</span> = <span class="mi">42</span></span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">equality</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="chk2" type="checkbox"><label class="coq-input" for="chk2"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">interp_ex2</span> : interp ex2 valuation0 = <span class="mi">54</span>.</span></label><div class="coq-output" id="goal2"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp ex2 valuation0 = <span class="mi">54</span></span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk3" type="checkbox"><label class="coq-input" for="chk3"><span class="highlight"><span class="nb">unfold</span> valuation0.</span></label><div class="coq-output" id="goal3"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp ex2 ($<span class="mi">0</span> $+ (<span class="s2">&quot;x&quot;</span>, <span class="mi">17</span>) $+ (<span class="s2">&quot;y&quot;</span>, <span class="mi">3</span>)) = <span class="mi">54</span></span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk4" type="checkbox"><label class="coq-input" for="chk4"><span class="highlight"><span class="nb">simplify</span>.</span></label><div class="coq-output" id="goal4"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="mi">54</span> = <span class="mi">54</span></span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">equality</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Here's the silly transformation we defined last time.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">commuter</span> (<span class="nv">e</span> : arith) : arith :=
  <span class="kr">match</span> e <span class="kr">with</span>
  | Const _ =&gt; e
  | Var _ =&gt; e
  | Plus e1 e2 =&gt; Plus (commuter e2) (commuter e1)
  | Minus e1 e2 =&gt; Minus (commuter e1) (commuter e2)
                   <span class="c">(* ^-- NB: didn&#39;t change the operand order here! *)</span>
  | Times e1 e2 =&gt; Times (commuter e2) (commuter e1)
  <span class="kr">end</span>.</span></span></span></pre><p>Instead of proving various odds-and-ends properties about it,
let's show what we <em>really</em> care about: it preserves the
<em>meanings</em> of expressions!</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="chk5" type="checkbox"><label class="coq-input" for="chk5"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">commuter_ok</span> : <span class="kr">forall</span> <span class="nv">v</span> <span class="nv">e</span>, interp (commuter e) v = interp e v.</span></label><div class="coq-output" id="goal5"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">v</span> : valuation) (<span class="nv">e</span> : arith),
interp (commuter e) v = interp e v</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk6" type="checkbox"><label class="coq-input" for="chk6"><span class="highlight"><span class="nb">induct</span> e; <span class="nb">simplify</span>.</span></label><div class="coq-output" id="goal6"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">n = n</span></span></span><input class="coq-extra-goals-toggle" id="chk7" type="checkbox"><label class="coq-extra-goals-label" for="chk7">4 more goals</label><div class="coq-extra-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">var</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">match</span> v $? x <span class="kr">with</span>
| Some n =&gt; n
| None =&gt; <span class="mi">0</span>
<span class="kr">end</span> = <span class="kr">match</span> v $? x <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span></span></span></span><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e1) v = interp e1 v</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e2) v = interp e2 v</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp (commuter e2) v + interp (commuter e1) v =
interp e1 v + interp e2 v</span></span></span><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e1) v = interp e1 v</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e2) v = interp e2 v</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp (commuter e1) v - interp (commuter e2) v =
interp e1 v - interp e2 v</span></span></span><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e1) v = interp e1 v</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e2) v = interp e2 v</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp (commuter e2) v * interp (commuter e1) v =
interp e1 v * interp e2 v</span></span></span></div></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk8" type="checkbox"><label class="coq-input" for="chk8"><span class="highlight">-</span></label><div class="coq-output" id="goal7"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">n = n</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">equality</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk9" type="checkbox"><label class="coq-input" for="chk9"><span class="highlight">-</span></label><div class="coq-output" id="goal8"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">var</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">match</span> v $? x <span class="kr">with</span>
| Some n =&gt; n
| None =&gt; <span class="mi">0</span>
<span class="kr">end</span> = <span class="kr">match</span> v $? x <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span></span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">equality</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chka" type="checkbox"><label class="coq-input" for="chka"><span class="highlight">-</span></label><div class="coq-output" id="goal9"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e1) v = interp e1 v</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e2) v = interp e2 v</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp (commuter e2) v + interp (commuter e1) v =
interp e1 v + interp e2 v</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">linear_arithmetic</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chkb" type="checkbox"><label class="coq-input" for="chkb"><span class="highlight">-</span></label><div class="coq-output" id="goala"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e1) v = interp e1 v</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e2) v = interp e2 v</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp (commuter e1) v - interp (commuter e2) v =
interp e1 v - interp e2 v</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">equality</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chkc" type="checkbox"><label class="coq-input" for="chkc"><span class="highlight">-</span></label><div class="coq-output" id="goalb"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e1) v = interp e1 v</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e2) v = interp e2 v</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp (commuter e2) v * interp (commuter e1) v =
interp e1 v * interp e2 v</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="chkd" type="checkbox"><label class="coq-input" for="chkd"><span class="highlight"><span class="nb">rewrite</span> IHe1.</span></label><div class="coq-output" id="goalc"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e1) v = interp e1 v</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e2) v = interp e2 v</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp (commuter e2) v * interp e1 v =
interp e1 v * interp e2 v</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chke" type="checkbox"><label class="coq-input" for="chke"><span class="highlight"><span class="nb">rewrite</span> IHe2.</span></label><div class="coq-output" id="goald"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e1) v = interp e1 v</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">interp (commuter e2) v = interp e2 v</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp e2 v * interp e1 v = interp e1 v * interp e2 v</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">ring</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Well, that's a relief! ;-)</p>
<p>Let's also revisit substitution.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">substitute</span> (<span class="nv">inThis</span> : arith)
                    (<span class="nv">replaceThis</span> : var)
                    (<span class="nv">withThis</span> : arith) : arith :=
  <span class="kr">match</span> inThis <span class="kr">with</span>
  | Const _ =&gt; inThis
  | Var x =&gt; <span class="kr">if</span> x ==v replaceThis <span class="kr">then</span> withThis <span class="kr">else</span> inThis
  | Plus e1 e2 =&gt; Plus (substitute e1 replaceThis withThis)
                       (substitute e2 replaceThis withThis)
  | Minus e1 e2 =&gt; Minus (substitute e1 replaceThis withThis)
                         (substitute e2 replaceThis withThis)
  | Times e1 e2 =&gt; Times (substitute e1 replaceThis withThis)
                         (substitute e2 replaceThis withThis)
  <span class="kr">end</span>.</span></span></span></pre><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="chkf" type="checkbox"><label class="coq-input" for="chkf"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">substitute_ok</span> : <span class="kr">forall</span> <span class="nv">v</span> <span class="nv">replaceThis</span> <span class="nv">withThis</span> <span class="nv">inThis</span>,
  interp (substitute inThis replaceThis withThis) v
  = interp inThis (v $+ (replaceThis, interp withThis v)).</span></label><div class="coq-output" id="goale"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">v</span> : valuation) (<span class="nv">replaceThis</span> : var)
  (<span class="nv">withThis</span> <span class="nv">inThis</span> : arith),
interp (substitute inThis replaceThis withThis) v =
interp inThis (v $+ (replaceThis, interp withThis v))</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk10" type="checkbox"><label class="coq-input" for="chk10"><span class="highlight"><span class="nb">induct</span> inThis; <span class="nb">simplify</span>; <span class="kp">try</span> <span class="bp">equality</span>.</span></label><div class="coq-output" id="goalf"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">replaceThis</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">var</span></span></span></span><span class="goal-hyp"><span class="hyp-names">withThis</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">var</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp (<span class="kr">if</span> x ==v replaceThis <span class="kr">then</span> withThis <span class="kr">else</span> Var x)
  v =
<span class="kr">match</span>
  (v $+ (replaceThis, interp withThis v)) $? x
<span class="kr">with</span>
| Some n =&gt; n
| None =&gt; <span class="mi">0</span>
<span class="kr">end</span></span></span></span></span></div></div></span></pre><p>One case left after our basic heuristic:
the variable case, naturally!</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">cases</span> (x ==v replaceThis); <span class="nb">simplify</span>; <span class="kp">try</span> <span class="bp">equality</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Great; we seem to have gotten that one right, too.</p>
<p>Let's also defined a pared-down version of the expression-simplificaton
functions from last chapter.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">doSomeArithmetic</span> (<span class="nv">e</span> : arith) : arith :=
  <span class="kr">match</span> e <span class="kr">with</span>
  | Const _ =&gt; e
  | Var _ =&gt; e
  | Plus (Const n1) (Const n2) =&gt; Const (n1 + n2)
  | Plus e1 e2 =&gt; Plus (doSomeArithmetic e1) (doSomeArithmetic e2)
  | Minus e1 e2 =&gt; Minus (doSomeArithmetic e1) (doSomeArithmetic e2)
  | Times (Const n1) (Const n2) =&gt; Const (n1 * n2)
  | Times e1 e2 =&gt; Times (doSomeArithmetic e1) (doSomeArithmetic e2)
  <span class="kr">end</span>.</span></span></span></pre><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="chk11" type="checkbox"><label class="coq-input" for="chk11"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">doSomeArithmetic_ok</span> :
    <span class="kr">forall</span> <span class="nv">e</span> <span class="nv">v</span>, interp (doSomeArithmetic e) v = interp e v.</span></label><div class="coq-output" id="goal10"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">e</span> : arith) (<span class="nv">v</span> : valuation),
interp (doSomeArithmetic e) v = interp e v</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk12" type="checkbox"><label class="coq-input" for="chk12"><span class="highlight"><span class="nb">induct</span> e; <span class="nb">simplify</span>; <span class="kp">try</span> <span class="bp">equality</span>.</span></label><div class="coq-output" id="goal11"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation,
interp (doSomeArithmetic e1) v0 = interp e1 v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation,
interp (doSomeArithmetic e2) v0 = interp e2 v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp
  <span class="kr">match</span> e1 <span class="kr">with</span>
  | Const n1 =&gt;
      <span class="kr">match</span> e2 <span class="kr">with</span>
      | Const n2 =&gt; Const (n1 + n2)
      | _ =&gt;
          Plus (doSomeArithmetic e1)
            (doSomeArithmetic e2)
      <span class="kr">end</span>
  | _ =&gt;
      Plus (doSomeArithmetic e1) (doSomeArithmetic e2)
  <span class="kr">end</span> v = interp e1 v + interp e2 v</span></span></span><input class="coq-extra-goals-toggle" id="chk13" type="checkbox"><label class="coq-extra-goals-label" for="chk13">1 more goal</label><div class="coq-extra-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation,
interp (doSomeArithmetic e1) v0 = interp e1 v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation,
interp (doSomeArithmetic e2) v0 = interp e2 v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp
  <span class="kr">match</span> e1 <span class="kr">with</span>
  | Const n1 =&gt;
      <span class="kr">match</span> e2 <span class="kr">with</span>
      | Const n2 =&gt; Const (n1 * n2)
      | _ =&gt;
          Times (doSomeArithmetic e1)
            (doSomeArithmetic e2)
      <span class="kr">end</span>
  | _ =&gt;
      Times (doSomeArithmetic e1)
        (doSomeArithmetic e2)
  <span class="kr">end</span> v = interp e1 v * interp e2 v</span></span></span></div></span></div></div><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk14" type="checkbox"><label class="coq-input" for="chk14"><span class="highlight">-</span></label><div class="coq-output" id="goal12"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation,
interp (doSomeArithmetic e1) v0 = interp e1 v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation,
interp (doSomeArithmetic e2) v0 = interp e2 v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp
  <span class="kr">match</span> e1 <span class="kr">with</span>
  | Const n1 =&gt;
      <span class="kr">match</span> e2 <span class="kr">with</span>
      | Const n2 =&gt; Const (n1 + n2)
      | _ =&gt;
          Plus (doSomeArithmetic e1)
            (doSomeArithmetic e2)
      <span class="kr">end</span>
  | _ =&gt;
      Plus (doSomeArithmetic e1) (doSomeArithmetic e2)
  <span class="kr">end</span> v = interp e1 v + interp e2 v</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk15" type="checkbox"><label class="coq-input" for="chk15"><span class="highlight"><span class="nb">cases</span> e1; <span class="nb">simplify</span>; <span class="kp">try</span> <span class="bp">equality</span>.</span></label><div class="coq-output" id="goal13"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation -&gt; n = n</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation,
interp (doSomeArithmetic e2) v0 = interp e2 v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp
  <span class="kr">match</span> e2 <span class="kr">with</span>
  | Const n2 =&gt; Const (n + n2)
  | _ =&gt; Plus (Const n) (doSomeArithmetic e2)
  <span class="kr">end</span> v = n + interp e2 v</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">cases</span> e2; <span class="nb">simplify</span>; <span class="bp">equality</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk16" type="checkbox"><label class="coq-input" for="chk16"><span class="highlight">-</span></label><div class="coq-output" id="goal14"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation,
interp (doSomeArithmetic e1) v0 = interp e1 v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation,
interp (doSomeArithmetic e2) v0 = interp e2 v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp
  <span class="kr">match</span> e1 <span class="kr">with</span>
  | Const n1 =&gt;
      <span class="kr">match</span> e2 <span class="kr">with</span>
      | Const n2 =&gt; Const (n1 * n2)
      | _ =&gt;
          Times (doSomeArithmetic e1)
            (doSomeArithmetic e2)
      <span class="kr">end</span>
  | _ =&gt;
      Times (doSomeArithmetic e1)
        (doSomeArithmetic e2)
  <span class="kr">end</span> v = interp e1 v * interp e2 v</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk17" type="checkbox"><label class="coq-input" for="chk17"><span class="highlight"><span class="nb">cases</span> e1; <span class="nb">simplify</span>; <span class="kp">try</span> <span class="bp">equality</span>.</span></label><div class="coq-output" id="goal15"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation -&gt; n = n</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation,
interp (doSomeArithmetic e2) v0 = interp e2 v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">interp
  <span class="kr">match</span> e2 <span class="kr">with</span>
  | Const n2 =&gt; Const (n * n2)
  | _ =&gt; Times (Const n) (doSomeArithmetic e2)
  <span class="kr">end</span> v = n * interp e2 v</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">cases</span> e2; <span class="nb">simplify</span>; <span class="bp">equality</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Of course, we're going to get bored if we confine ourselves to arithmetic
expressions for the rest of our journey.  Let's get a bit fancier and define
a <em>stack machine</em>, related to postfix calculators that some of you may have
experienced.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">instruction</span> :=
| PushConst (n : nat)
| PushVar (x : var)
| <span class="kn">Add</span>
| Subtract
| Multiply.</span></span></span></pre><p>What does it all mean?  An interpreter tells us unambiguously!</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">run1</span> (<span class="nv">i</span> : instruction)
                (<span class="nv">v</span> : valuation)
                (<span class="nv">stack</span> : list nat) : list nat :=
  <span class="kr">match</span> i <span class="kr">with</span>
  | PushConst n =&gt; n :: stack
  | PushVar x =&gt; (<span class="kr">match</span> v $? x <span class="kr">with</span>
                  | None =&gt; <span class="mi">0</span>
                  | Some n =&gt; n
                  <span class="kr">end</span>) :: stack
  | <span class="kn">Add</span> =&gt;
    <span class="kr">match</span> stack <span class="kr">with</span>
    | arg2 :: arg1 :: stack&#39; =&gt; arg1 + arg2 :: stack&#39;
    | _ =&gt; stack <span class="c">(* arbitrary behavior in erroneous case</span>
<span class="c">                    (stack underflow) *)</span>
    <span class="kr">end</span>
  | Subtract =&gt;
    <span class="kr">match</span> stack <span class="kr">with</span>
    | arg2 :: arg1 :: stack&#39; =&gt; arg1 - arg2 :: stack&#39;
    | _ =&gt; stack <span class="c">(* arbitrary behavior in erroneous case *)</span>
    <span class="kr">end</span>
  | Multiply =&gt;
    <span class="kr">match</span> stack <span class="kr">with</span>
    | arg2 :: arg1 :: stack&#39; =&gt; arg1 * arg2 :: stack&#39;
    | _ =&gt; stack <span class="c">(* arbitrary behavior in erroneous case *)</span>
    <span class="kr">end</span>
  <span class="kr">end</span>.</span></span></span></pre><p>That function explained how to run one instruction.
Here's how to run several of them.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">run</span> (<span class="nv">is</span> : list instruction)
             (<span class="nv">v</span> : valuation)
             (<span class="nv">stack</span> : list nat) : list nat :=
  <span class="kr">match</span> <span class="kr">is</span> <span class="kr">with</span>
  | nil =&gt; stack
  | i :: is&#39; =&gt; run is&#39; v (run1 i v stack)
  <span class="kr">end</span>.</span></span></span></pre><p>Instead of writing fiddly stack programs ourselves, let's <em>compile</em>
arithmetic expressions into equivalent stack programs.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">compile</span> (<span class="nv">e</span> : arith) : list instruction :=
  <span class="kr">match</span> e <span class="kr">with</span>
  | Const n =&gt; PushConst n :: nil
  | Var x =&gt; PushVar x :: nil
  | Plus e1 e2 =&gt; compile e1 ++ compile e2 ++ <span class="kn">Add</span> :: nil
  | Minus e1 e2 =&gt; compile e1 ++ compile e2 ++ Subtract :: nil
  | Times e1 e2 =&gt; compile e1 ++ compile e2 ++ Multiply :: nil
  <span class="kr">end</span>.</span></span></span></pre><p>Now, of course, we should prove our compiler correct.
Skip down to the next theorem to see the overall correctness statement.
It turns out that we need to strengthen the induction hypothesis with a
lemma, to push the proof through.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="chk18" type="checkbox"><label class="coq-input" for="chk18"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">compile_ok&#39;</span> :
    <span class="kr">forall</span> <span class="nv">e</span> <span class="nv">v</span> <span class="nv">is</span> <span class="nv">stack</span>,
    run (compile e ++ <span class="kr">is</span>) v stack = run <span class="kr">is</span> v (interp e v :: stack).</span></label><div class="coq-output" id="goal16"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">e</span> : arith) (<span class="nv">v</span> : valuation)
  (<span class="nv">is</span> : list instruction) (<span class="nv">stack</span> : list nat),
run (compile e ++ <span class="kr">is</span>) v stack =
run <span class="kr">is</span> v (interp e v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk19" type="checkbox"><label class="coq-input" for="chk19"><span class="highlight"><span class="nb">induct</span> e; <span class="nb">simplify</span>.</span></label><div class="coq-output" id="goal17"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run <span class="kr">is</span> v (n :: stack) = run <span class="kr">is</span> v (n :: stack)</span></span></span><input class="coq-extra-goals-toggle" id="chk1a" type="checkbox"><label class="coq-extra-goals-label" for="chk1a">4 more goals</label><div class="coq-extra-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">var</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run <span class="kr">is</span> v
  (<span class="kr">match</span> v $? x <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> :: stack) =
run <span class="kr">is</span> v
  (<span class="kr">match</span> v $? x <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> :: stack)</span></span></span><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run ((compile e1 ++ compile e2 ++ [<span class="kn">Add</span>]) ++ <span class="kr">is</span>) v
  stack =
run <span class="kr">is</span> v (interp e1 v + interp e2 v :: stack)</span></span></span><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run ((compile e1 ++ compile e2 ++ [Subtract]) ++ <span class="kr">is</span>) v
  stack =
run <span class="kr">is</span> v (interp e1 v - interp e2 v :: stack)</span></span></span><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run ((compile e1 ++ compile e2 ++ [Multiply]) ++ <span class="kr">is</span>) v
  stack =
run <span class="kr">is</span> v (interp e1 v * interp e2 v :: stack)</span></span></span></div></span></div></div><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk1b" type="checkbox"><label class="coq-input" for="chk1b"><span class="highlight">-</span></label><div class="coq-output" id="goal18"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run <span class="kr">is</span> v (n :: stack) = run <span class="kr">is</span> v (n :: stack)</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">equality</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk1c" type="checkbox"><label class="coq-input" for="chk1c"><span class="highlight">-</span></label><div class="coq-output" id="goal19"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">var</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run <span class="kr">is</span> v
  (<span class="kr">match</span> v $? x <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> :: stack) =
run <span class="kr">is</span> v
  (<span class="kr">match</span> v $? x <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> :: stack)</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">equality</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk1d" type="checkbox"><label class="coq-input" for="chk1d"><span class="highlight">-</span></label><div class="coq-output" id="goal1a"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run ((compile e1 ++ compile e2 ++ [<span class="kn">Add</span>]) ++ <span class="kr">is</span>) v
  stack =
run <span class="kr">is</span> v (interp e1 v + interp e2 v :: stack)</span></span></span></span></div></div></span></pre><p>Here we want to use associativity of <tt class="docutils literal">++</tt>, to get the conclusion to match
an induction hypothesis.  Let's ask Coq to search its library for lemmas
that would justify such a rewrite, giving a pattern with wildcards, to
specify the essential structure that the rewrite should match.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight">    </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk1e" type="checkbox"><label class="coq-input" for="chk1e"><span class="highlight"><span class="kn">SearchRewrite</span> ((_ ++ _) ++ _).</span></label><div class="coq-output" id="goal1b"><div class="coq-output-sticky-wrapper"><span class="coq-responses"><span class="coq-response"><span class="highlight">app_assoc_reverse:
  <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">m</span> <span class="nv">n</span> : list A),
  (l ++ m) ++ n = l ++ m ++ n</span></span><span class="coq-response"><span class="highlight">app_assoc:
  <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">m</span> <span class="nv">n</span> : list A),
  l ++ m ++ n = (l ++ m) ++ n</span></span></span><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run ((compile e1 ++ compile e2 ++ [<span class="kn">Add</span>]) ++ <span class="kr">is</span>) v
  stack =
run <span class="kr">is</span> v (interp e1 v + interp e2 v :: stack)</span></span></span></span></div></div></span></pre><p>Ah, we see just the one!</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight">    </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk1f" type="checkbox"><label class="coq-input" for="chk1f"><span class="highlight"><span class="nb">rewrite</span> app_assoc_reverse.</span></label><div class="coq-output" id="goal1c"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run (compile e1 ++ (compile e2 ++ [<span class="kn">Add</span>]) ++ <span class="kr">is</span>) v
  stack =
run <span class="kr">is</span> v (interp e1 v + interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk20" type="checkbox"><label class="coq-input" for="chk20"><span class="highlight"><span class="nb">rewrite</span> IHe1.</span></label><div class="coq-output" id="goal1d"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run ((compile e2 ++ [<span class="kn">Add</span>]) ++ <span class="kr">is</span>) v
  (interp e1 v :: stack) =
run <span class="kr">is</span> v (interp e1 v + interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk21" type="checkbox"><label class="coq-input" for="chk21"><span class="highlight"><span class="nb">rewrite</span> app_assoc_reverse.</span></label><div class="coq-output" id="goal1e"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run (compile e2 ++ [<span class="kn">Add</span>] ++ <span class="kr">is</span>) v
  (interp e1 v :: stack) =
run <span class="kr">is</span> v (interp e1 v + interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk22" type="checkbox"><label class="coq-input" for="chk22"><span class="highlight"><span class="nb">rewrite</span> IHe2.</span></label><div class="coq-output" id="goal1f"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run ([<span class="kn">Add</span>] ++ <span class="kr">is</span>) v
  (interp e2 v :: interp e1 v :: stack) =
run <span class="kr">is</span> v (interp e1 v + interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk23" type="checkbox"><label class="coq-input" for="chk23"><span class="highlight"><span class="nb">simplify</span>.</span></label><div class="coq-output" id="goal20"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run <span class="kr">is</span> v (interp e1 v + interp e2 v :: stack) =
run <span class="kr">is</span> v (interp e1 v + interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">equality</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk24" type="checkbox"><label class="coq-input" for="chk24"><span class="highlight">-</span></label><div class="coq-output" id="goal21"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run ((compile e1 ++ compile e2 ++ [Subtract]) ++ <span class="kr">is</span>) v
  stack =
run <span class="kr">is</span> v (interp e1 v - interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk25" type="checkbox"><label class="coq-input" for="chk25"><span class="highlight"><span class="nb">rewrite</span> app_assoc_reverse.</span></label><div class="coq-output" id="goal22"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run (compile e1 ++ (compile e2 ++ [Subtract]) ++ <span class="kr">is</span>) v
  stack =
run <span class="kr">is</span> v (interp e1 v - interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk26" type="checkbox"><label class="coq-input" for="chk26"><span class="highlight"><span class="nb">rewrite</span> IHe1.</span></label><div class="coq-output" id="goal23"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run ((compile e2 ++ [Subtract]) ++ <span class="kr">is</span>) v
  (interp e1 v :: stack) =
run <span class="kr">is</span> v (interp e1 v - interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk27" type="checkbox"><label class="coq-input" for="chk27"><span class="highlight"><span class="nb">rewrite</span> app_assoc_reverse.</span></label><div class="coq-output" id="goal24"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run (compile e2 ++ [Subtract] ++ <span class="kr">is</span>) v
  (interp e1 v :: stack) =
run <span class="kr">is</span> v (interp e1 v - interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk28" type="checkbox"><label class="coq-input" for="chk28"><span class="highlight"><span class="nb">rewrite</span> IHe2.</span></label><div class="coq-output" id="goal25"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run ([Subtract] ++ <span class="kr">is</span>) v
  (interp e2 v :: interp e1 v :: stack) =
run <span class="kr">is</span> v (interp e1 v - interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk29" type="checkbox"><label class="coq-input" for="chk29"><span class="highlight"><span class="nb">simplify</span>.</span></label><div class="coq-output" id="goal26"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run <span class="kr">is</span> v (interp e1 v - interp e2 v :: stack) =
run <span class="kr">is</span> v (interp e1 v - interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">equality</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk2a" type="checkbox"><label class="coq-input" for="chk2a"><span class="highlight">-</span></label><div class="coq-output" id="goal27"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run ((compile e1 ++ compile e2 ++ [Multiply]) ++ <span class="kr">is</span>) v
  stack =
run <span class="kr">is</span> v (interp e1 v * interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk2b" type="checkbox"><label class="coq-input" for="chk2b"><span class="highlight"><span class="nb">rewrite</span> app_assoc_reverse.</span></label><div class="coq-output" id="goal28"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run (compile e1 ++ (compile e2 ++ [Multiply]) ++ <span class="kr">is</span>) v
  stack =
run <span class="kr">is</span> v (interp e1 v * interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk2c" type="checkbox"><label class="coq-input" for="chk2c"><span class="highlight"><span class="nb">rewrite</span> IHe1.</span></label><div class="coq-output" id="goal29"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run ((compile e2 ++ [Multiply]) ++ <span class="kr">is</span>) v
  (interp e1 v :: stack) =
run <span class="kr">is</span> v (interp e1 v * interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk2d" type="checkbox"><label class="coq-input" for="chk2d"><span class="highlight"><span class="nb">rewrite</span> app_assoc_reverse.</span></label><div class="coq-output" id="goal2a"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run (compile e2 ++ [Multiply] ++ <span class="kr">is</span>) v
  (interp e1 v :: stack) =
run <span class="kr">is</span> v (interp e1 v * interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk2e" type="checkbox"><label class="coq-input" for="chk2e"><span class="highlight"><span class="nb">rewrite</span> IHe2.</span></label><div class="coq-output" id="goal2b"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run ([Multiply] ++ <span class="kr">is</span>) v
  (interp e2 v :: interp e1 v :: stack) =
run <span class="kr">is</span> v (interp e1 v * interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk2f" type="checkbox"><label class="coq-input" for="chk2f"><span class="highlight"><span class="nb">simplify</span>.</span></label><div class="coq-output" id="goal2c"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e1 ++ is0) v0 stack0 =
run is0 v0 (interp e1 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHe2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">v0</span> : valuation)
  (<span class="nv">is0</span> : list instruction) 
  (<span class="nv">stack0</span> : list nat),
run (compile e2 ++ is0) v0 stack0 =
run is0 v0 (interp e2 v0 :: stack0)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span><span class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list instruction</span></span></span></span><span class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run <span class="kr">is</span> v (interp e1 v * interp e2 v :: stack) =
run <span class="kr">is</span> v (interp e1 v * interp e2 v :: stack)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">equality</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>The overall theorem follows as a simple corollary.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="chk30" type="checkbox"><label class="coq-input" for="chk30"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">compile_ok</span> :
    <span class="kr">forall</span> <span class="nv">e</span> <span class="nv">v</span>, run (compile e) v nil = interp e v :: nil.</span></label><div class="coq-output" id="goal2d"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">e</span> : arith) (<span class="nv">v</span> : valuation),
run (compile e) v [] = [interp e v]</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk31" type="checkbox"><label class="coq-input" for="chk31"><span class="highlight"><span class="nb">simplify</span>.</span></label><div class="coq-output" id="goal2e"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run (compile e) v [] = [interp e v]</span></span></span></span></div></div></span></pre><p>To match the form of our lemma, we need to replace <tt class="docutils literal">compile e</tt> with
<tt class="docutils literal">compile e ++ nil</tt>, adding a &quot;pointless&quot; concatenation of the empty list.
<tt class="docutils literal">SearchRewrite</tt> again helps us find a library lemma.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk32" type="checkbox"><label class="coq-input" for="chk32"><span class="highlight"><span class="kn">SearchRewrite</span> (_ ++ nil).</span></label><div class="coq-output" id="goal2f"><div class="coq-output-sticky-wrapper"><span class="coq-responses"><span class="coq-response"><span class="highlight">app_nil_end:
  <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A), l = l ++ []</span></span><span class="coq-response"><span class="highlight">app_nil_r: <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A), l ++ [] = l</span></span></span><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run (compile e) v [] = [interp e v]</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk33" type="checkbox"><label class="coq-input" for="chk33"><span class="highlight"><span class="nb">rewrite</span> (app_nil_end (compile e)).</span></label><div class="coq-output" id="goal30"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">run (compile e ++ []) v [] = [interp e v]</span></span></span></span></div></div></span></pre><p>Note that we can use <tt class="docutils literal">rewrite</tt> with explicit values of the first few
quantified variables of a lemma.  Otherwise, <tt class="docutils literal">rewrite</tt> picks an
unhelpful place to rewrite.  (Try it and see!)</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> compile_ok&#39;.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* Direct appeal to a previously proved lemma *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Let's get a bit fancier, moving toward the level of general-purpose
imperative languages.  Here's a language of commands, building on the
language of expressions we have defined.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">cmd</span> :=
| Skip
| Assign (x : var) (e : arith)
| Sequence (c1 c2 : cmd)
| Repeat (e : arith) (body : cmd).</span></span></span></pre><p>That last constructor is for repeating a body command some number of
times.  Note that we sneakily avoid constructs that could introduce
nontermination, since Coq only accepts terminating programs, and we want to
write an interpreter for commands.
In contrast to our last one, this interpreter <em>transforms valuations</em>.
We use a helper function for self-composing a function some number of
times.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">selfCompose</span> {<span class="nv">A</span>} (<span class="nv">f</span> : A -&gt; A) (<span class="nv">n</span> : nat) : A -&gt; A :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | O =&gt; <span class="kr">fun</span> <span class="nv">x</span> =&gt; x
  | S n&#39; =&gt; <span class="kr">fun</span> <span class="nv">x</span> =&gt; selfCompose f n&#39; (f x)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">exec</span> (<span class="nv">c</span> : cmd) (<span class="nv">v</span> : valuation) : valuation :=
  <span class="kr">match</span> c <span class="kr">with</span>
  | Skip =&gt; v
  | Assign x e =&gt; v $+ (x, interp e v)
  | Sequence c1 c2 =&gt; exec c2 (exec c1 v)
  | Repeat e body =&gt; selfCompose (exec body) (interp e v) v
  <span class="kr">end</span>.</span></span></span></pre><p>Let's define some programs and prove that they operate in certain ways.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Example</span> <span class="nf">factorial_ugly</span> :=
  Sequence
    (Assign <span class="s2">&quot;output&quot;</span> (Const <span class="mi">1</span>))
    (Repeat (Var <span class="s2">&quot;input&quot;</span>)
            (Sequence
               (Assign <span class="s2">&quot;output&quot;</span> (Times (Var <span class="s2">&quot;output&quot;</span>) (Var <span class="s2">&quot;input&quot;</span>)))
               (Assign <span class="s2">&quot;input&quot;</span> (Minus (Var <span class="s2">&quot;input&quot;</span>) (Const <span class="mi">1</span>))))).</span></span></span></pre><p>Ouch; that code is hard to read.  Let's introduce some notations to make the
concrete syntax more palatable.  We won't explain the general mechanisms on
display here, but see the Coq manual for details, or try to reverse-engineer
them from our examples.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Coercion</span> <span class="nf">Const</span> : nat &gt;-&gt; arith.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Coercion</span> <span class="nf">Var</span> : var &gt;-&gt; arith.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="chk34" type="checkbox"><label class="coq-input" for="chk34"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;+&quot;</span> := Plus : arith_scope.</span></label><div class="coq-output" id="goal31"><div class="coq-output-sticky-wrapper"><span class="coq-responses"><span class="coq-response"><span class="highlight">Declaring a scope implicitly <span class="kr">is</span> deprecated; use <span class="kr">in</span>
advance an explicit <span class="s2">&quot;Declare Scope arith_scope.&quot;</span>.
[undeclared-scope,deprecated]</span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;-&quot;</span> := Minus : arith_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;*&quot;</span> := Times : arith_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Delimit Scope</span> arith_scope <span class="kr">with</span> arith.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &lt;- e&quot;</span> := (Assign x e%arith) (<span class="kn">at level</span> <span class="mi">75</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;;&quot;</span> := Sequence (<span class="kn">at level</span> <span class="mi">76</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&#39;repeat&#39; e &#39;doing&#39; body &#39;done&#39;&quot;</span> :=
  (Repeat e%arith body) (<span class="kn">at level</span> <span class="mi">75</span>).</span></span></span></pre><p>OK, let's try that program again.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Example</span> <span class="nf">factorial</span> :=
  <span class="s2">&quot;output&quot;</span> &lt;- <span class="mi">1</span>;
  <span class="kp">repeat</span> <span class="s2">&quot;input&quot;</span> doing
    <span class="s2">&quot;output&quot;</span> &lt;- <span class="s2">&quot;output&quot;</span> * <span class="s2">&quot;input&quot;</span>;
    <span class="s2">&quot;input&quot;</span> &lt;- <span class="s2">&quot;input&quot;</span> - <span class="mi">1</span>
  <span class="bp">done</span>.</span></span></span></pre><p>Now we prove that it really computes factorial.
First, a reference implementation as a functional program.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">fact</span> (<span class="nv">n</span> : nat) : nat :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | O =&gt; <span class="mi">1</span>
  | S n&#39; =&gt; n * fact n&#39;
  <span class="kr">end</span>.</span></span></span></pre><p>To prove that <tt class="docutils literal">factorial</tt> is correct, the real action is in a lemma, to be
proved by induction, showing that the loop works correctly.  So, let's first
assign a name to the loop body alone.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">factorial_body</span> :=
  <span class="s2">&quot;output&quot;</span> &lt;- <span class="s2">&quot;output&quot;</span> * <span class="s2">&quot;input&quot;</span>;
  <span class="s2">&quot;input&quot;</span> &lt;- <span class="s2">&quot;input&quot;</span> - <span class="mi">1</span>.</span></span></span></pre><p>Now for that lemma: self-composition of the body's semantics produces the
expected changes in the valuation.
Note that here we're careful to put the quantified variable <tt class="docutils literal">input</tt> <em>first</em>,
because the variables coming after it will need to <em>change</em> in the course of
the induction.  Try switching the order to see what goes wrong if we put
<tt class="docutils literal">input</tt> later.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="chk35" type="checkbox"><label class="coq-input" for="chk35"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">factorial_ok&#39;</span> : <span class="kr">forall</span> <span class="nv">input</span> <span class="nv">output</span> <span class="nv">v</span>,
  v $? <span class="s2">&quot;input&quot;</span> = Some input
  -&gt; v $? <span class="s2">&quot;output&quot;</span> = Some output
  -&gt; selfCompose (exec factorial_body) input v
     = v $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>, output * fact input).</span></label><div class="coq-output" id="goal32"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">input</span> <span class="nv">output</span> : nat) (<span class="nv">v</span> : fmap var nat),
v $? <span class="s2">&quot;input&quot;</span> = Some input -&gt;
v $? <span class="s2">&quot;output&quot;</span> = Some output -&gt;
selfCompose (exec factorial_body) input v =
v $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>, output * fact input)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk36" type="checkbox"><label class="coq-input" for="chk36"><span class="highlight"><span class="nb">induct</span> input; <span class="nb">simplify</span>.</span></label><div class="coq-output" id="goal33"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some <span class="mi">0</span></span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">v = v $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>, output * <span class="mi">1</span>)</span></span></span><input class="coq-extra-goals-toggle" id="chk37" type="checkbox"><label class="coq-extra-goals-label" for="chk37">1 more goal</label><div class="coq-extra-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHinput</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">output0</span> : nat) (<span class="nv">v0</span> : fmap var nat),
v0 $? <span class="s2">&quot;input&quot;</span> = Some input -&gt;
v0 $? <span class="s2">&quot;output&quot;</span> = Some output0 -&gt;
selfCompose
  (<span class="kr">fun</span> <span class="nv">v1</span> : valuation =&gt;
   v1 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v1 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input v0 =
v0 $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output0 * fact input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some (S input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose
  (<span class="kr">fun</span> <span class="nv">v0</span> : valuation =&gt;
   v0 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v0 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v0 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v0 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v0 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v0 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input
  (v $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span> v $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) =
v $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output * (fact input + input * fact input))</span></span></span></div></span></div></div></span></pre><div class="topic">
<p class="topic-title"><tt class="docutils literal">maps_equal</tt></p>
<p>This tactic proves that two finite maps are equal by considering all
the relevant cases for mappings of different keys.</p>
</div>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk38" type="checkbox"><label class="coq-input" for="chk38"><span class="highlight">-</span></label><div class="coq-output" id="goal34"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some <span class="mi">0</span></span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">v = v $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>, output * <span class="mi">1</span>)</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk39" type="checkbox"><label class="coq-input" for="chk39"><span class="highlight"><span class="nb">maps_equal</span>.</span></label><div class="coq-output" id="goal35"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some <span class="mi">0</span></span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some (output * <span class="mi">1</span>)</span></span></span><input class="coq-extra-goals-toggle" id="chk3a" type="checkbox"><label class="coq-extra-goals-label" for="chk3a">1 more goal</label><div class="coq-extra-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some <span class="mi">0</span></span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="s2">&quot;output&quot;</span> &lt;&gt; <span class="s2">&quot;input&quot;</span></span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some <span class="mi">0</span></span></span></span></div></span></div></div><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk3b" type="checkbox"><label class="coq-input" for="chk3b"><span class="highlight">+</span></label><div class="coq-output" id="goal36"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some <span class="mi">0</span></span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some (output * <span class="mi">1</span>)</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk3c" type="checkbox"><label class="coq-input" for="chk3c"><span class="highlight"><span class="nb">rewrite</span> H0.</span></label><div class="coq-output" id="goal37"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some <span class="mi">0</span></span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">Some output = Some (output * <span class="mi">1</span>)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="chk3d" type="checkbox"><label class="coq-input" for="chk3d"><span class="highlight"><span class="nb">f_equal</span>.</span></label><div class="coq-output" id="goal38"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some <span class="mi">0</span></span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">output = output * <span class="mi">1</span></span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">linear_arithmetic</span>.</span></span></span></pre><div class="topic">
<p class="topic-title"><tt class="docutils literal">trivial</tt></p>
<p>Coq maintains a database of simple proof steps, such as proving
a fact by direct appeal to a matching hypothesis.  <tt class="docutils literal">trivial</tt> asks to try
all such simple steps.</p>
</div>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight">    </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk3e" type="checkbox"><label class="coq-input" for="chk3e"><span class="highlight">+</span></label><div class="coq-output" id="goal39"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some <span class="mi">0</span></span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="s2">&quot;output&quot;</span> &lt;&gt; <span class="s2">&quot;input&quot;</span></span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some <span class="mi">0</span></span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk3f" type="checkbox"><label class="coq-input" for="chk3f"><span class="highlight">-</span></label><div class="coq-output" id="goal3a"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHinput</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">output0</span> : nat) (<span class="nv">v0</span> : fmap var nat),
v0 $? <span class="s2">&quot;input&quot;</span> = Some input -&gt;
v0 $? <span class="s2">&quot;output&quot;</span> = Some output0 -&gt;
selfCompose
  (<span class="kr">fun</span> <span class="nv">v1</span> : valuation =&gt;
   v1 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v1 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input v0 =
v0 $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output0 * fact input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some (S input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose
  (<span class="kr">fun</span> <span class="nv">v0</span> : valuation =&gt;
   v0 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v0 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v0 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v0 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v0 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v0 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input
  (v $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span> v $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) =
v $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output * (fact input + input * fact input))</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk40" type="checkbox"><label class="coq-input" for="chk40"><span class="highlight"><span class="nb">rewrite</span> H, H0.</span></label><div class="coq-output" id="goal3b"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHinput</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">output0</span> : nat) (<span class="nv">v0</span> : fmap var nat),
v0 $? <span class="s2">&quot;input&quot;</span> = Some input -&gt;
v0 $? <span class="s2">&quot;output&quot;</span> = Some output0 -&gt;
selfCompose
  (<span class="kr">fun</span> <span class="nv">v1</span> : valuation =&gt;
   v1 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v1 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input v0 =
v0 $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output0 * fact input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some (S input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose
  (<span class="kr">fun</span> <span class="nv">v0</span> : valuation =&gt;
   v0 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v0 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v0 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v0 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v0 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v0 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input
  (v $+ (<span class="s2">&quot;output&quot;</span>, output * S input) $+ (<span class="s2">&quot;input&quot;</span>,
   S input - <span class="mi">1</span>)) =
v $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output * (fact input + input * fact input))</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">    <span class="c">(* Note the two arguments to one ``rewrite``! *)</span>

</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk41" type="checkbox"><label class="coq-input" for="chk41"><span class="highlight"><span class="nb">rewrite</span> (IHinput (output * S input)).</span></label><div class="coq-output" id="goal3c"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHinput</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">output0</span> : nat) (<span class="nv">v0</span> : fmap var nat),
v0 $? <span class="s2">&quot;input&quot;</span> = Some input -&gt;
v0 $? <span class="s2">&quot;output&quot;</span> = Some output0 -&gt;
selfCompose
  (<span class="kr">fun</span> <span class="nv">v1</span> : valuation =&gt;
   v1 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v1 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input v0 =
v0 $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output0 * fact input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some (S input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">v $+ (<span class="s2">&quot;output&quot;</span>, output * S input) $+ (<span class="s2">&quot;input&quot;</span>,
S input - <span class="mi">1</span>) $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output * S input * fact input) =
v $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output * (fact input + input * fact input))</span></span></span><input class="coq-extra-goals-toggle" id="chk42" type="checkbox"><label class="coq-extra-goals-label" for="chk42">2 more goals</label><div class="coq-extra-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHinput</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">output0</span> : nat) (<span class="nv">v0</span> : fmap var nat),
v0 $? <span class="s2">&quot;input&quot;</span> = Some input -&gt;
v0 $? <span class="s2">&quot;output&quot;</span> = Some output0 -&gt;
selfCompose
  (<span class="kr">fun</span> <span class="nv">v1</span> : valuation =&gt;
   v1 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v1 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input v0 =
v0 $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output0 * fact input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some (S input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">(v $+ (<span class="s2">&quot;output&quot;</span>, output * S input) $+ (<span class="s2">&quot;input&quot;</span>,
 S input - <span class="mi">1</span>)) $? <span class="s2">&quot;input&quot;</span> = 
Some input</span></span></span><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHinput</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">output0</span> : nat) (<span class="nv">v0</span> : fmap var nat),
v0 $? <span class="s2">&quot;input&quot;</span> = Some input -&gt;
v0 $? <span class="s2">&quot;output&quot;</span> = Some output0 -&gt;
selfCompose
  (<span class="kr">fun</span> <span class="nv">v1</span> : valuation =&gt;
   v1 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v1 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input v0 =
v0 $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output0 * fact input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some (S input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">(v $+ (<span class="s2">&quot;output&quot;</span>, output * S input) $+ (<span class="s2">&quot;input&quot;</span>,
 S input - <span class="mi">1</span>)) $? <span class="s2">&quot;output&quot;</span> = 
Some (output * S input)</span></span></span></div></span></div></div><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">    <span class="c">(* Note the careful choice of a quantifier instantiation for the IH! *)</span>

</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk43" type="checkbox"><label class="coq-input" for="chk43"><span class="highlight"><span class="nb">maps_equal</span>.</span></label><div class="coq-output" id="goal3d"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHinput</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">output0</span> : nat) (<span class="nv">v0</span> : fmap var nat),
v0 $? <span class="s2">&quot;input&quot;</span> = Some input -&gt;
v0 $? <span class="s2">&quot;output&quot;</span> = Some output0 -&gt;
selfCompose
  (<span class="kr">fun</span> <span class="nv">v1</span> : valuation =&gt;
   v1 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v1 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input v0 =
v0 $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output0 * fact input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some (S input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">Some (output * S input * fact input) =
Some (output * (fact input + input * fact input))</span></span></span><input class="coq-extra-goals-toggle" id="chk44" type="checkbox"><label class="coq-extra-goals-label" for="chk44">2 more goals</label><div class="coq-extra-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHinput</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">output0</span> : nat) (<span class="nv">v0</span> : fmap var nat),
v0 $? <span class="s2">&quot;input&quot;</span> = Some input -&gt;
v0 $? <span class="s2">&quot;output&quot;</span> = Some output0 -&gt;
selfCompose
  (<span class="kr">fun</span> <span class="nv">v1</span> : valuation =&gt;
   v1 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v1 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input v0 =
v0 $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output0 * fact input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some (S input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">(v $+ (<span class="s2">&quot;output&quot;</span>, output * S input) $+ (<span class="s2">&quot;input&quot;</span>,
 S input - <span class="mi">1</span>)) $? <span class="s2">&quot;input&quot;</span> = 
Some input</span></span></span><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHinput</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">output0</span> : nat) (<span class="nv">v0</span> : fmap var nat),
v0 $? <span class="s2">&quot;input&quot;</span> = Some input -&gt;
v0 $? <span class="s2">&quot;output&quot;</span> = Some output0 -&gt;
selfCompose
  (<span class="kr">fun</span> <span class="nv">v1</span> : valuation =&gt;
   v1 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v1 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input v0 =
v0 $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output0 * fact input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some (S input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">(v $+ (<span class="s2">&quot;output&quot;</span>, output * S input) $+ (<span class="s2">&quot;input&quot;</span>,
 S input - <span class="mi">1</span>)) $? <span class="s2">&quot;output&quot;</span> = 
Some (output * S input)</span></span></span></div></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk45" type="checkbox"><label class="coq-input" for="chk45"><span class="highlight">+</span></label><div class="coq-output" id="goal3e"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHinput</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">output0</span> : nat) (<span class="nv">v0</span> : fmap var nat),
v0 $? <span class="s2">&quot;input&quot;</span> = Some input -&gt;
v0 $? <span class="s2">&quot;output&quot;</span> = Some output0 -&gt;
selfCompose
  (<span class="kr">fun</span> <span class="nv">v1</span> : valuation =&gt;
   v1 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v1 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input v0 =
v0 $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output0 * fact input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some (S input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">Some (output * S input * fact input) =
Some (output * (fact input + input * fact input))</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">f_equal</span>; <span class="bp">ring</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk46" type="checkbox"><label class="coq-input" for="chk46"><span class="highlight">+</span></label><div class="coq-output" id="goal3f"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHinput</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">output0</span> : nat) (<span class="nv">v0</span> : fmap var nat),
v0 $? <span class="s2">&quot;input&quot;</span> = Some input -&gt;
v0 $? <span class="s2">&quot;output&quot;</span> = Some output0 -&gt;
selfCompose
  (<span class="kr">fun</span> <span class="nv">v1</span> : valuation =&gt;
   v1 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v1 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input v0 =
v0 $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output0 * fact input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some (S input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">(v $+ (<span class="s2">&quot;output&quot;</span>, output * S input) $+ (<span class="s2">&quot;input&quot;</span>,
 S input - <span class="mi">1</span>)) $? <span class="s2">&quot;input&quot;</span> = 
Some input</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">simplify</span>; <span class="nb">f_equal</span>; <span class="bp">linear_arithmetic</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk47" type="checkbox"><label class="coq-input" for="chk47"><span class="highlight">+</span></label><div class="coq-output" id="goal40"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHinput</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">output0</span> : nat) (<span class="nv">v0</span> : fmap var nat),
v0 $? <span class="s2">&quot;input&quot;</span> = Some input -&gt;
v0 $? <span class="s2">&quot;output&quot;</span> = Some output0 -&gt;
selfCompose
  (<span class="kr">fun</span> <span class="nv">v1</span> : valuation =&gt;
   v1 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v1 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v1 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v1 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input v0 =
v0 $+ (<span class="s2">&quot;input&quot;</span>, <span class="mi">0</span>) $+ (<span class="s2">&quot;output&quot;</span>,
output0 * fact input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">output</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some (S input)</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;output&quot;</span> = Some output</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">(v $+ (<span class="s2">&quot;output&quot;</span>, output * S input) $+ (<span class="s2">&quot;input&quot;</span>,
 S input - <span class="mi">1</span>)) $? <span class="s2">&quot;output&quot;</span> = 
Some (output * S input)</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">simplify</span>; <span class="bp">equality</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Finally, we have the natural correctness condition for factorial as a whole
program.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="chk48" type="checkbox"><label class="coq-input" for="chk48"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">factorial_ok</span>
  : <span class="kr">forall</span> <span class="nv">v</span> <span class="nv">input</span>,
    v $? <span class="s2">&quot;input&quot;</span> = Some input
    -&gt; exec factorial v $? <span class="s2">&quot;output&quot;</span> = Some (fact input).</span></label><div class="coq-output" id="goal41"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">v</span> : fmap var nat) (<span class="nv">input</span> : nat),
v $? <span class="s2">&quot;input&quot;</span> = Some input -&gt;
exec factorial v $? <span class="s2">&quot;output&quot;</span> = Some (fact input)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk49" type="checkbox"><label class="coq-input" for="chk49"><span class="highlight"><span class="nb">simplify</span>.</span></label><div class="coq-output" id="goal42"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some input</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose
  (<span class="kr">fun</span> <span class="nv">v0</span> : valuation =&gt;
   v0 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v0 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v0 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v0 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v0 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v0 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>))
  <span class="kr">match</span> v $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
  | Some n =&gt; n
  | None =&gt; <span class="mi">0</span>
  <span class="kr">end</span> (v $+ (<span class="s2">&quot;output&quot;</span>, <span class="mi">1</span>)) $? <span class="s2">&quot;output&quot;</span> =
Some (fact input)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk4a" type="checkbox"><label class="coq-input" for="chk4a"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><div class="coq-output" id="goal43"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some input</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose
  (<span class="kr">fun</span> <span class="nv">v0</span> : valuation =&gt;
   v0 $+ (<span class="s2">&quot;output&quot;</span>,
   <span class="kr">match</span> v0 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> *
   <span class="kr">match</span> v0 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span>) $+ (<span class="s2">&quot;input&quot;</span>,
   <span class="kr">match</span>
     (v0 $+ (<span class="s2">&quot;output&quot;</span>,
      <span class="kr">match</span> v0 $? <span class="s2">&quot;output&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span> *
      <span class="kr">match</span> v0 $? <span class="s2">&quot;input&quot;</span> <span class="kr">with</span>
      | Some n =&gt; n
      | None =&gt; <span class="mi">0</span>
      <span class="kr">end</span>)) $? <span class="s2">&quot;input&quot;</span>
   <span class="kr">with</span>
   | Some n =&gt; n
   | None =&gt; <span class="mi">0</span>
   <span class="kr">end</span> - <span class="mi">1</span>)) input (v $+ (<span class="s2">&quot;output&quot;</span>, <span class="mi">1</span>)) $? <span class="s2">&quot;output&quot;</span> =
Some (fact input)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk4b" type="checkbox"><label class="coq-input" for="chk4b"><span class="highlight"><span class="nb">rewrite</span> (factorial_ok&#39; input <span class="mi">1</span>); <span class="nb">simplify</span>.</span></label><div class="coq-output" id="goal44"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some input</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">Some (fact input + <span class="mi">0</span>) = Some (fact input)</span></span></span><input class="coq-extra-goals-toggle" id="chk4c" type="checkbox"><label class="coq-extra-goals-label" for="chk4c">2 more goals</label><div class="coq-extra-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some input</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some input</span></span></span><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some input</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">Some <span class="mi">1</span> = Some <span class="mi">1</span></span></span></span></div></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk4d" type="checkbox"><label class="coq-input" for="chk4d"><span class="highlight"><span class="nb">f_equal</span>; <span class="bp">linear_arithmetic</span>.</span></label><div class="coq-output" id="goal45"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some input</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some input</span></span></span><input class="coq-extra-goals-toggle" id="chk4e" type="checkbox"><label class="coq-extra-goals-label" for="chk4e">1 more goal</label><div class="coq-extra-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some input</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">Some <span class="mi">1</span> = Some <span class="mi">1</span></span></span></span></div></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk4f" type="checkbox"><label class="coq-input" for="chk4f"><span class="highlight"><span class="nb">trivial</span>.</span></label><div class="coq-output" id="goal46"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">fmap var nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">v $? <span class="s2">&quot;input&quot;</span> = Some input</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">Some <span class="mi">1</span> = Some <span class="mi">1</span></span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span></pre><p>One last example: let's try to do loop unrolling, for constant iteration
counts.  That is, we can duplicate the loop body instead of using an explicit
loop.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">seqself</span> (<span class="nv">c</span> : cmd) (<span class="nv">n</span> : nat) : cmd :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | O =&gt; Skip
  | S n&#39; =&gt; Sequence c (seqself c n&#39;)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">unroll</span> (<span class="nv">c</span> : cmd) : cmd :=
  <span class="kr">match</span> c <span class="kr">with</span>
  | Skip =&gt; c
  | Assign _ _ =&gt; c
  | Sequence c1 c2 =&gt; Sequence (unroll c1) (unroll c2)
  | Repeat (Const n) c1 =&gt; seqself (unroll c1) n
  <span class="c">(* ^-- the crucial case! *)</span>
  | Repeat e c1 =&gt; Repeat e (unroll c1)
  <span class="kr">end</span>.</span></span></span></pre><p>This obvious-sounding fact will come in handy: self-composition gives the
same result, when passed two functions that map equal inputs to equal
outputs.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="chk50" type="checkbox"><label class="coq-input" for="chk50"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">selfCompose_extensional</span> : <span class="kr">forall</span> {<span class="nv">A</span>} (<span class="nv">f</span> <span class="nv">g</span> : A -&gt; A) <span class="nv">n</span> <span class="nv">x</span>,
    (<span class="kr">forall</span> <span class="nv">y</span>, f y = g y)
    -&gt; selfCompose f n x = selfCompose g n x.</span></label><div class="coq-output" id="goal47"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : A -&gt; A) (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A),
(<span class="kr">forall</span> <span class="nv">y</span> : A, f y = g y) -&gt;
selfCompose f n x = selfCompose g n x</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk51" type="checkbox"><label class="coq-input" for="chk51"><span class="highlight"><span class="nb">induct</span> n; <span class="nb">simplify</span>; <span class="kp">try</span> <span class="bp">equality</span>.</span></label><div class="coq-output" id="goal48"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></span><span class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; A</span></span></span></span><span class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : A,
(<span class="kr">forall</span> <span class="nv">y</span> : A, f y = g y) -&gt; selfCompose f n x0 = selfCompose g n x0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, f y = g y</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose f n (f x) = selfCompose g n (g x)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk52" type="checkbox"><label class="coq-input" for="chk52"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><div class="coq-output" id="goal49"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></span><span class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; A</span></span></span></span><span class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : A,
(<span class="kr">forall</span> <span class="nv">y</span> : A, f y = g y) -&gt; selfCompose f n x0 = selfCompose g n x0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, f y = g y</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose f n (g x) = selfCompose g n (g x)</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk53" type="checkbox"><label class="coq-input" for="chk53"><span class="highlight"><span class="nb">apply</span> IHn.</span></label><div class="coq-output" id="goal4a"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></span><span class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; A</span></span></span></span><span class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : A,
(<span class="kr">forall</span> <span class="nv">y</span> : A, f y = g y) -&gt; selfCompose f n x0 = selfCompose g n x0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></span><span class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, f y = g y</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, f y = g y</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Crucial lemma: <tt class="docutils literal">seqself</tt> is acting just like <tt class="docutils literal">selfCompose</tt>, in a suitable
sense.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="chk54" type="checkbox"><label class="coq-input" for="chk54"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">seqself_ok</span> : <span class="kr">forall</span> <span class="nv">c</span> <span class="nv">n</span> <span class="nv">v</span>,
    exec (seqself c n) v = selfCompose (exec c) n v.</span></label><div class="coq-output" id="goal4b"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">c</span> : cmd) (<span class="nv">n</span> : nat) (<span class="nv">v</span> : valuation),
exec (seqself c n) v = selfCompose (exec c) n v</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">induct</span> n; <span class="nb">simplify</span>; <span class="bp">equality</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>The two lemmas we just proved are the main ingredients to prove the natural
correctness condition for <tt class="docutils literal">unroll</tt>.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="chk55" type="checkbox"><label class="coq-input" for="chk55"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">unroll_ok</span> : <span class="kr">forall</span> <span class="nv">c</span> <span class="nv">v</span>, exec (unroll c) v = exec c v.</span></label><div class="coq-output" id="goal4c"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">c</span> : cmd) (<span class="nv">v</span> : valuation),
exec (unroll c) v = exec c v</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk56" type="checkbox"><label class="coq-input" for="chk56"><span class="highlight"><span class="nb">induct</span> c; <span class="nb">simplify</span>; <span class="kp">try</span> <span class="bp">equality</span>.</span></label><div class="coq-output" id="goal4d"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">exec
  <span class="kr">match</span> e <span class="kr">with</span>
  | Const n =&gt; seqself (unroll c) n
  | _ =&gt; <span class="kp">repeat</span> e doing unroll c <span class="bp">done</span>
  <span class="kr">end</span> v = selfCompose (exec c) (interp e v) v</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk57" type="checkbox"><label class="coq-input" for="chk57"><span class="highlight"><span class="nb">cases</span> e; <span class="nb">simplify</span>; <span class="kp">try</span> <span class="bp">equality</span>.</span></label><div class="coq-output" id="goal4e"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">exec (seqself (unroll c) n) v =
selfCompose (exec c) n v</span></span></span><input class="coq-extra-goals-toggle" id="chk58" type="checkbox"><label class="coq-extra-goals-label" for="chk58">4 more goals</label><div class="coq-extra-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">var</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose (exec (unroll c))
  <span class="kr">match</span> v $? x <span class="kr">with</span>
  | Some n =&gt; n
  | None =&gt; <span class="mi">0</span>
  <span class="kr">end</span> v =
selfCompose (exec c)
  <span class="kr">match</span> v $? x <span class="kr">with</span>
  | Some n =&gt; n
  | None =&gt; <span class="mi">0</span>
  <span class="kr">end</span> v</span></span></span><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose (exec (unroll c))
  (interp e1 v + interp e2 v) v =
selfCompose (exec c) (interp e1 v + interp e2 v) v</span></span></span><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose (exec (unroll c))
  (interp e1 v - interp e2 v) v =
selfCompose (exec c) (interp e1 v - interp e2 v) v</span></span></span><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose (exec (unroll c))
  (interp e1 v * interp e2 v) v =
selfCompose (exec c) (interp e1 v * interp e2 v) v</span></span></span></div></span></div></div><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk59" type="checkbox"><label class="coq-input" for="chk59"><span class="highlight">-</span></label><div class="coq-output" id="goal4f"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">exec (seqself (unroll c) n) v =
selfCompose (exec c) n v</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk5a" type="checkbox"><label class="coq-input" for="chk5a"><span class="highlight"><span class="nb">rewrite</span> seqself_ok.</span></label><div class="coq-output" id="goal50"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose (exec (unroll c)) n v =
selfCompose (exec c) n v</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="chk5b" type="checkbox"><label class="coq-input" for="chk5b"><span class="highlight"><span class="nb">apply</span> selfCompose_extensional.</span></label><div class="coq-output" id="goal51"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : valuation, exec (unroll c) y = exec c y</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk5c" type="checkbox"><label class="coq-input" for="chk5c"><span class="highlight">-</span></label><div class="coq-output" id="goal52"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">var</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose (exec (unroll c))
  <span class="kr">match</span> v $? x <span class="kr">with</span>
  | Some n =&gt; n
  | None =&gt; <span class="mi">0</span>
  <span class="kr">end</span> v =
selfCompose (exec c)
  <span class="kr">match</span> v $? x <span class="kr">with</span>
  | Some n =&gt; n
  | None =&gt; <span class="mi">0</span>
  <span class="kr">end</span> v</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk5d" type="checkbox"><label class="coq-input" for="chk5d"><span class="highlight"><span class="nb">apply</span> selfCompose_extensional.</span></label><div class="coq-output" id="goal53"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">var</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : valuation, exec (unroll c) y = exec c y</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk5e" type="checkbox"><label class="coq-input" for="chk5e"><span class="highlight">-</span></label><div class="coq-output" id="goal54"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose (exec (unroll c))
  (interp e1 v + interp e2 v) v =
selfCompose (exec c) (interp e1 v + interp e2 v) v</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk5f" type="checkbox"><label class="coq-input" for="chk5f"><span class="highlight"><span class="nb">apply</span> selfCompose_extensional.</span></label><div class="coq-output" id="goal55"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : valuation, exec (unroll c) y = exec c y</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk60" type="checkbox"><label class="coq-input" for="chk60"><span class="highlight">-</span></label><div class="coq-output" id="goal56"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose (exec (unroll c))
  (interp e1 v - interp e2 v) v =
selfCompose (exec c) (interp e1 v - interp e2 v) v</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk61" type="checkbox"><label class="coq-input" for="chk61"><span class="highlight"><span class="nb">apply</span> selfCompose_extensional.</span></label><div class="coq-output" id="goal57"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : valuation, exec (unroll c) y = exec c y</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="chk62" type="checkbox"><label class="coq-input" for="chk62"><span class="highlight">-</span></label><div class="coq-output" id="goal58"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight">selfCompose (exec (unroll c))
  (interp e1 v * interp e2 v) v =
selfCompose (exec c) (interp e1 v * interp e2 v) v</span></span></span></span></div></div><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="chk63" type="checkbox"><label class="coq-input" for="chk63"><span class="highlight"><span class="nb">apply</span> selfCompose_extensional.</span></label><div class="coq-output" id="goal59"><div class="coq-output-sticky-wrapper"><span class="coq-goals"><span class="coq-goal"><span class="goal-hyps"><span class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">arith</span></span></span></span><span class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cmd</span></span></span></span><span class="goal-hyp"><span class="hyp-names">IHc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">v0</span> : valuation, exec (unroll c) v0 = exec c v0</span></span></span></span><span class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">valuation</span></span></span></span></span><span class="goal-separator"><hr></span><span class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : valuation, exec (unroll c) y = exec c y</span></span></span></span></div></div><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div>
</div>
</div></body>
</html>
