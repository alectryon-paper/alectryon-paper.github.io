<!DOCTYPE html>
<html><head><title>Basics.v</title><meta charset="utf-8"><meta content="Alectryon v0.2" name="generator"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet"><link href="https://unpkg.com/firacode/distr/fira_code.css" rel="stylesheet"><link href="alectryon.css" rel="stylesheet"><script src="alectryon.js"></script><style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-standalone alectryon-centered alectryon-coqdoc"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><div class="doc">
<a name="lab1"></a><h1 class="section">Basics: Functional Programming in Coq</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* REMINDER:</span>

<span class="c">          #####################################################</span>
<span class="c">          ###  PLEASE DO NOT DISTRIBUTE SOLUTIONS PUBLICLY  ###</span>
<span class="c">          #####################################################</span>

<span class="c">   (See the [Preface] for why.)</span>
<span class="c">*)</span>

<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab2"></a><h1 class="section">Introduction</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The functional programming style is founded on simple, everyday
    mathematical intuition: If a procedure or method has no side
    effects, then (ignoring efficiency) all we need to understand
    about it is how it maps inputs to outputs -- that is, we can think
    of it as just a concrete method for computing a mathematical
    function.  This is one sense of the word "functional" in
    "functional programming."  The direct connection between programs
    and simple mathematical objects supports both formal correctness
    proofs and sound informal reasoning about program behavior.

<div class="paragraph"> </div>

    The other sense in which functional programming is "functional" is
    that it emphasizes the use of functions (or methods) as
    <i>first-class</i> values -- i.e., values that can be passed as
    arguments to other functions, returned as results, included in
    data structures, etc.  The recognition that functions can be
    treated as data gives rise to a host of useful and powerful
    programming idioms.

<div class="paragraph"> </div>

    Other common features of functional languages include <i>algebraic
    data types</i> and <i>pattern matching</i>, which make it easy to
    construct and manipulate rich data structures, and sophisticated
    <i>polymorphic type systems</i> supporting abstraction and code reuse.
    Coq offers all of these features.

<div class="paragraph"> </div>

    The first half of this chapter introduces the most essential
    elements of Coq's functional programming language, called
    <i>Gallina</i>.  The second half introduces some basic <i>tactics</i> that
    can be used to prove properties of Coq programs. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab3"></a><h1 class="section">Data and Functions</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab4"></a><h2 class="section">Enumerated Types</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
One notable aspect of Coq is that its set of built-in
    features is <i>extremely</i> small.  For example, instead of providing
    the usual palette of atomic data types (booleans, integers,
    strings, etc.), Coq offers a powerful mechanism for defining new
    data types from scratch, with all these familiar types as
    instances.

<div class="paragraph"> </div>

    Naturally, the Coq distribution comes preloaded with an extensive
    standard library providing definitions of booleans, numbers, and
    many common data structures like lists and hash tables.  But there
    is nothing magic or primitive about these library definitions.  To
    illustrate this, we will explicitly recapitulate all the
    definitions we need in this course, rather than just getting them
    implicitly from the library. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab5"></a><h2 class="section">Days of the Week</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
To see how this definition mechanism works, let's start with
    a very simple example.  The following declaration tells Coq that
    we are defining a new set of data values -- a <i>type</i>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">day</span> : <span class="kt">Type</span> :=
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  | sunday.</span></span></span></pre><div class="doc">
The type is called <span class="inlinecode"><span class="id" title="var">day</span></span>, and its members are <span class="inlinecode"><span class="id" title="var">monday</span></span>,
    <span class="inlinecode"><span class="id" title="var">tuesday</span></span>, etc. 

<div class="paragraph"> </div>

    Having defined <span class="inlinecode"><span class="id" title="var">day</span></span>, we can write functions that operate on
    days. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">next_weekday</span> (<span class="nv">d</span>:day) : day :=
  <span class="kr">match</span> d <span class="kr">with</span>
  | monday    =&gt; tuesday
  | tuesday   =&gt; wednesday
  | wednesday =&gt; thursday
  | thursday  =&gt; friday
  | friday    =&gt; monday
  | saturday  =&gt; monday
  | sunday    =&gt; monday
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
One thing to note is that the argument and return types of
    this function are explicitly declared.  Like most functional
    programming languages, Coq can often figure out these types for
    itself when they are not given explicitly -- i.e., it can do <i>type
    inference</i> -- but we'll generally include them to make reading
    easier. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Having defined a function, we should check that it works on
    some examples.  There are actually three different ways to do this
    in Coq.  First, we can use the command <span class="inlinecode"><span class="id" title="keyword">Compute</span></span> to evaluate a
    compound expression involving <span class="inlinecode"><span class="id" title="var">next_weekday</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Basics-v-chk0" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk0"><span class="highlight"><span class="kn">Compute</span> (next_weekday friday).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">= monday
: day</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* ==&gt; monday : day *)</span>

</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Basics-v-chk1" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk1"><span class="highlight"><span class="kn">Compute</span> (next_weekday (next_weekday saturday)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">= tuesday
: day</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* ==&gt; tuesday : day *)</span></span></span></pre><div class="doc">
(We show Coq's responses in comments, but, if you have a
    computer handy, this would be an excellent moment to fire up the
    Coq interpreter under your favorite IDE -- either CoqIde or Proof
    General -- and try this for yourself.  Load this file, <span class="inlinecode"><span class="id" title="var">Basics.v</span></span>,
    from the book's Coq sources, find the above example, submit it to
    Coq, and observe the result.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Second, we can record what we <i>expect</i> the result to be in the
    form of a Coq example: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk2" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk2"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_next_weekday</span>:
  (next_weekday (next_weekday saturday)) = tuesday.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">next_weekday (next_weekday saturday) = tuesday</span></div></blockquote></div></div></small></span></pre><div class="doc">
This declaration does two things: it makes an
    assertion (that the second weekday after <span class="inlinecode"><span class="id" title="var">saturday</span></span> is <span class="inlinecode"><span class="id" title="var">tuesday</span></span>),
    and it gives the assertion a name that can be used to refer to it
    later.  Having made the assertion, we can also ask Coq to verify
    it, like this: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk3" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">next_weekday (next_weekday saturday) = tuesday</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk4" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk4"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">tuesday = tuesday</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The details are not important for now (we'll come back to
    them in a bit), but essentially this can be read as "The assertion
    we've just made can be proved by observing that both sides of the
    equality evaluate to the same thing, after some simplification."

<div class="paragraph"> </div>

    Third, we can ask Coq to <i>extract</i>, from our <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>, a
    program in some other, more conventional, programming
    language (OCaml, Scheme, or Haskell) with a high-performance
    compiler.  This facility is very interesting, since it gives us a
    way to go from proved-correct algorithms written in Gallina to
    efficient machine code.  (Of course, we are trusting the
    correctness of the OCaml/Haskell/Scheme compiler, and of Coq's
    extraction facility itself, but this is still a big step forward
    from the way most software is developed today.) Indeed, this is
    one of the main uses for which Coq was developed.  We'll come back
    to this topic in later chapters. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab6"></a><h2 class="section">Homework Submission Guidelines</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
If you are using <i>Software Foundations</i> in a course, your
    instructor may use automatic scripts to help grade your homework
    assignments.  In order for these scripts to work correctly (so
    that you get full credit for your work!), please be careful to
    follow these rules:
<ul class="doclist">
<li> The grading scripts work by extracting marked regions of the
        <span class="inlinecode">.<span class="id" title="var">v</span></span> files that you submit.  It is therefore important that
        you do not alter the "markup" that delimits exercises: the
        Exercise header, the name of the exercise, the "empty square
        bracket" marker at the end, etc.  Please leave this markup
        exactly as you find it.

</li>
<li> Do not delete exercises.  If you skip an exercise (e.g.,
        because it is marked Optional, or because you can't solve it),
        it is OK to leave a partial proof in your <span class="inlinecode">.<span class="id" title="var">v</span></span> file, but in
        this case please make sure it ends with <span class="inlinecode"><span class="id" title="var">Admitted</span></span> (not, for
        example <span class="inlinecode"><span class="id" title="keyword">Abort</span></span>).

</li>
<li> It is fine to use additional definitions (of helper functions,
        useful lemmas, etc.) in your solutions.  You can put these
        between the exercise header and the theorem you are asked to
        prove.

</li>
</ul>
<div class="paragraph"> </div>

    You will also notice that each chapter (like <span class="inlinecode"><span class="id" title="var">Basics.v</span></span>) is
    accompanied by a <i>test script</i> (<span class="inlinecode"><span class="id" title="var">BasicsTest.v</span></span>) that automatically
    calculates points for the finished homework problems in the
    chapter.  These scripts are mostly for the auto-grading
    infrastructure that your instructor may use to help process
    assignments, but you may also like to use them to double-check
    that your file is well formatted before handing it in.  In a
    terminal window either type <span class="inlinecode"><span class="id" title="var">make</span></span> <span class="inlinecode"><span class="id" title="var">BasicsTest.vo</span></span> or do the
    following:

<div class="paragraph"> </div>

       coqc -Q . LF Basics.v
       coqc -Q . LF BasicsTest.v

<div class="paragraph"> </div>

    There is no need to hand in <span class="inlinecode"><span class="id" title="var">BasicsTest.v</span></span> itself (or <span class="inlinecode"><span class="id" title="var">Preface.v</span></span>).

<div class="paragraph"> </div>
<i>If your class is using the Canvas system to hand in assignments</i>:
<ul class="doclist">
<li> If you submit multiple versions of the assignment, you may
        notice that they are given different names.  This is fine: The
        most recent submission is the one that will be graded.

</li>
<li> To hand in multiple files at the same time (if more than one
        chapter is assigned in the same week), you need to make a
        single submission with all the files at once using the button
        "Add another file" just above the comment box. 
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab7"></a><h2 class="section">Booleans</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
In a similar way, we can define the standard type <span class="inlinecode"><span class="id" title="var">bool</span></span> of
    booleans, with members <span class="inlinecode"><span class="id" title="var">true</span></span> and <span class="inlinecode"><span class="id" title="var">false</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">bool</span> : <span class="kt">Type</span> :=
  | true
  | false.</span></span></span></pre><div class="doc">
Although we are rolling our own booleans here for the sake
    of building up everything from scratch, Coq does, of course,
    provide a default implementation of the booleans, together with a
    multitude of useful functions and lemmas.  (Take a look at
    <span class="inlinecode"><span class="id" title="var">Coq.Init.Datatypes</span></span> in the Coq library documentation if you're
    interested.)  Whenever possible, we'll name our own definitions
    and theorems so that they exactly coincide with the ones in the
    standard library.

<div class="paragraph"> </div>

    Functions over booleans can be defined in the same way as
    above: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">negb</span> (<span class="nv">b</span>:bool) : bool :=
  <span class="kr">match</span> b <span class="kr">with</span>
  | true =&gt; false
  | false =&gt; true
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">andb</span> (<span class="nv">b1</span>:bool) (<span class="nv">b2</span>:bool) : bool :=
  <span class="kr">match</span> b1 <span class="kr">with</span>
  | true =&gt; b2
  | false =&gt; false
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">orb</span> (<span class="nv">b1</span>:bool) (<span class="nv">b2</span>:bool) : bool :=
  <span class="kr">match</span> b1 <span class="kr">with</span>
  | true =&gt; true
  | false =&gt; b2
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
The last two of these illustrate Coq's syntax for
    multi-argument function definitions.  The corresponding
    multi-argument application syntax is illustrated by the following
    "unit tests," which constitute a complete specification -- a truth
    table -- for the <span class="inlinecode"><span class="id" title="var">orb</span></span> function: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk5" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk5"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_orb1</span>:  (orb true  false) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">orb true false = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk6" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">orb true false = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk7" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk7"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk8" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk8"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_orb2</span>:  (orb false false) = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">orb false false = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk9" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">orb false false = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chka" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chka"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkb" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkb"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_orb3</span>:  (orb false true)  = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">orb false true = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkc" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkc"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">orb false true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkd" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkd"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chke" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chke"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_orb4</span>:  (orb true  true)  = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">orb true true = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkf" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkf"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">orb true true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk10" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk10"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
We can also introduce some familiar syntax for the boolean
    operations we have just defined. The <span class="inlinecode"><span class="id" title="keyword">Notation</span></span> command defines a new
    symbolic notation for an existing definition. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &amp;&amp; y&quot;</span> := (andb x y).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x || y&quot;</span> := (orb x y).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk11" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk11"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_orb5</span>:  false || false || true = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false || false || true = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk12" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk12"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false || false || true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk13" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk13"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<i>A note on notation</i>: In <span class="inlinecode">.<span class="id" title="var">v</span></span> files, we use square brackets
    to delimit fragments of Coq code within comments; this convention,
    also used by the <span class="inlinecode"><span class="id" title="var">coqdoc</span></span> documentation tool, keeps them visually
    separate from the surrounding text.  In the HTML version of the
    files, these pieces of text appear in a <span class="inlinecode"><span class="id" title="var">different</span></span> <span class="inlinecode"><span class="id" title="var">font</span></span>.

<div class="paragraph"> </div>

    The command <span class="inlinecode"><span class="id" title="var">Admitted</span></span> can be used as a placeholder for an
    incomplete proof.  We'll use it in exercises, to indicate the
    parts that we're leaving for you -- i.e., your job is to replace
    <span class="inlinecode"><span class="id" title="var">Admitted</span></span>s with real proofs. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab8"></a><h4 class="section">Exercise: 1 star, standard (nandb)</h4>
<div class="paragraph"> </div>

    Remove "<span class="inlinecode"><span class="id" title="var">Admitted</span>.</span>" and complete the definition of the following
    function; then make sure that the <span class="inlinecode"><span class="id" title="keyword">Example</span></span> assertions below can
    each be verified by Coq.  (I.e., fill in each proof, following the
    model of the <span class="inlinecode"><span class="id" title="var">orb</span></span> tests above.) The function should return <span class="inlinecode"><span class="id" title="var">true</span></span>
    if either or both of its inputs are <span class="inlinecode"><span class="id" title="var">false</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk14" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk14"><span class="highlight"><span class="kn">Definition</span> <span class="nf">nandb</span> (<span class="nv">b1</span>:bool) (<span class="nv">b2</span>:bool) : bool
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b1, b2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">bool</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk15" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk15"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_nandb1</span>:               (nandb true false) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">nandb true false = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk16" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk16"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_nandb2</span>:               (nandb false false) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">nandb false false = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk17" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk17"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_nandb3</span>:               (nandb false true) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">nandb false true = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk18" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk18"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_nandb4</span>:               (nandb true true) = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">nandb true true = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab9"></a><h4 class="section">Exercise: 1 star, standard (andb3)</h4>
<div class="paragraph"> </div>

    Do the same for the <span class="inlinecode"><span class="id" title="var">andb3</span></span> function below. This function should
    return <span class="inlinecode"><span class="id" title="var">true</span></span> when all of its inputs are <span class="inlinecode"><span class="id" title="var">true</span></span>, and <span class="inlinecode"><span class="id" title="var">false</span></span>
    otherwise. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk19" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk19"><span class="highlight"><span class="kn">Definition</span> <span class="nf">andb3</span> (<span class="nv">b1</span>:bool) (<span class="nv">b2</span>:bool) (<span class="nv">b3</span>:bool) : bool
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b1, b2, b3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">bool</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk1a" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk1a"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_andb31</span>:                 (andb3 true true true) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">andb3 true true true = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk1b"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_andb32</span>:                 (andb3 false true true) = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">andb3 false true true = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk1c"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_andb33</span>:                 (andb3 true false true) = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">andb3 true false true = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk1d" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk1d"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_andb34</span>:                 (andb3 true true false) = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">andb3 true true false = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab10"></a><h2 class="section">Types</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Every expression in Coq has a type, describing what sort of
    thing it computes. The <span class="inlinecode"><span class="id" title="keyword">Check</span></span> command asks Coq to print the type
    of an expression. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Basics-v-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk1e"><span class="highlight"><span class="kn">Check</span> true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">true
     : bool</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Basics-v-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk1f"><span class="highlight"><span class="kn">Check</span> (negb true).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">negb true
     : bool</span></blockquote></div></div></small></span></pre><div class="doc">
Functions like <span class="inlinecode"><span class="id" title="var">negb</span></span> itself are also data values, just like
    <span class="inlinecode"><span class="id" title="var">true</span></span> and <span class="inlinecode"><span class="id" title="var">false</span></span>.  Their types are called <i>function types</i>, and
    they are written with arrows. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Basics-v-chk20" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk20"><span class="highlight"><span class="kn">Check</span> negb.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">negb
     : bool -&gt; bool</span></blockquote></div></div></small></span></pre><div class="doc">
The type of <span class="inlinecode"><span class="id" title="var">negb</span></span>, written <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> and pronounced
    "<span class="inlinecode"><span class="id" title="var">bool</span></span> arrow <span class="inlinecode"><span class="id" title="var">bool</span></span>," can be read, "Given an input of type
    <span class="inlinecode"><span class="id" title="var">bool</span></span>, this function produces an output of type <span class="inlinecode"><span class="id" title="var">bool</span></span>."
    Similarly, the type of <span class="inlinecode"><span class="id" title="var">andb</span></span>, written <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, can
    be read, "Given two inputs, both of type <span class="inlinecode"><span class="id" title="var">bool</span></span>, this function
    produces an output of type <span class="inlinecode"><span class="id" title="var">bool</span></span>." 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab11"></a><h2 class="section">New Types from Old</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The types we have defined so far are examples of "enumerated
    types": their definitions explicitly enumerate a finite set of
    elements, each of which is just a bare constructor.  Here is a
    more interesting type definition, where one of the constructors
    takes an argument: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">rgb</span> : <span class="kt">Type</span> :=
  | <span class="nb">red</span>
  | green
  | blue.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">color</span> : <span class="kt">Type</span> :=
  | black
  | white
  | primary (p : rgb).</span></span></span></pre><div class="doc">
Let's look at this in a little more detail.

<div class="paragraph"> </div>

    Every inductively defined type (<span class="inlinecode"><span class="id" title="var">day</span></span>, <span class="inlinecode"><span class="id" title="var">bool</span></span>, <span class="inlinecode"><span class="id" title="var">rgb</span></span>, <span class="inlinecode"><span class="id" title="var">color</span></span>,
    etc.) contains a set of <i>constructor expressions</i> built from
    <i>constructors</i> like <span class="inlinecode"><span class="id" title="tactic">red</span></span>, <span class="inlinecode"><span class="id" title="var">primary</span></span>, <span class="inlinecode"><span class="id" title="var">true</span></span>, <span class="inlinecode"><span class="id" title="var">false</span></span>, <span class="inlinecode"><span class="id" title="var">monday</span></span>,
    etc. 

<div class="paragraph"> </div>

    The definitions of <span class="inlinecode"><span class="id" title="var">rgb</span></span> and <span class="inlinecode"><span class="id" title="var">color</span></span> say how expressions in the
    sets <span class="inlinecode"><span class="id" title="var">rgb</span></span> and <span class="inlinecode"><span class="id" title="var">color</span></span> can be built:

<div class="paragraph"> </div>
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="tactic">red</span></span>, <span class="inlinecode"><span class="id" title="var">green</span></span>, and <span class="inlinecode"><span class="id" title="var">blue</span></span> are the constructors of <span class="inlinecode"><span class="id" title="var">rgb</span></span>;

</li>
<li> <span class="inlinecode"><span class="id" title="var">black</span></span>, <span class="inlinecode"><span class="id" title="var">white</span></span>, and <span class="inlinecode"><span class="id" title="var">primary</span></span> are the constructors of <span class="inlinecode"><span class="id" title="var">color</span></span>;

</li>
<li> the expression <span class="inlinecode"><span class="id" title="tactic">red</span></span> belongs to the set <span class="inlinecode"><span class="id" title="var">rgb</span></span>, as do the
      expressions <span class="inlinecode"><span class="id" title="var">green</span></span> and <span class="inlinecode"><span class="id" title="var">blue</span></span>;

</li>
<li> the expressions <span class="inlinecode"><span class="id" title="var">black</span></span> and <span class="inlinecode"><span class="id" title="var">white</span></span> belong to the set <span class="inlinecode"><span class="id" title="var">color</span></span>;

</li>
<li> if <span class="inlinecode"><span class="id" title="var">p</span></span> is an expression belonging to the set <span class="inlinecode"><span class="id" title="var">rgb</span></span>, then
      <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> (pronounced "the constructor <span class="inlinecode"><span class="id" title="var">primary</span></span> applied to
      the argument <span class="inlinecode"><span class="id" title="var">p</span></span>") is an expression belonging to the set
      <span class="inlinecode"><span class="id" title="var">color</span></span>; and

</li>
<li> expressions formed in these ways are the <i>only</i> ones belonging
      to the sets <span class="inlinecode"><span class="id" title="var">rgb</span></span> and <span class="inlinecode"><span class="id" title="var">color</span></span>. 
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We can define functions on colors using pattern matching just as
    we have done for <span class="inlinecode"><span class="id" title="var">day</span></span> and <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">monochrome</span> (<span class="nv">c</span> : color) : bool :=
  <span class="kr">match</span> c <span class="kr">with</span>
  | black =&gt; true
  | white =&gt; true
  | primary q =&gt; false
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Since the <span class="inlinecode"><span class="id" title="var">primary</span></span> constructor takes an argument, a pattern
    matching <span class="inlinecode"><span class="id" title="var">primary</span></span> should include either a variable (as above --
    note that we can choose its name freely) or a constant of
    appropriate type (as below). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">isred</span> (<span class="nv">c</span> : color) : bool :=
  <span class="kr">match</span> c <span class="kr">with</span>
  | black =&gt; false
  | white =&gt; false
  | primary <span class="nb">red</span> =&gt; true
  | primary _ =&gt; false
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
The pattern <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> here is shorthand for "<span class="inlinecode"><span class="id" title="var">primary</span></span> applied
    to any <span class="inlinecode"><span class="id" title="var">rgb</span></span> constructor except <span class="inlinecode"><span class="id" title="tactic">red</span></span>."  (The wildcard pattern <span class="inlinecode"><span class="id" title="var">_</span></span>
    has the same effect as the dummy pattern variable <span class="inlinecode"><span class="id" title="var">p</span></span> in the
    definition of <span class="inlinecode"><span class="id" title="var">monochrome</span></span>.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab12"></a><h2 class="section">Tuples</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
A single constructor with multiple parameters can be used
    to create a tuple type. As an example, consider representing
    the four bits in a nybble (half a byte). We first define
    a datatype <span class="inlinecode"><span class="id" title="var">bit</span></span> that resembles <span class="inlinecode"><span class="id" title="var">bool</span></span> (using the
    constructors <span class="inlinecode"><span class="id" title="var">B0</span></span> and <span class="inlinecode"><span class="id" title="var">B1</span></span> for the two possible bit values),
    and then define the datatype <span class="inlinecode"><span class="id" title="var">nybble</span></span>, which is essentially
    a tuple of four bits. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">bit</span> : <span class="kt">Type</span> :=
  | B0
  | B1.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">nybble</span> : <span class="kt">Type</span> :=
  | bits (b0 b1 b2 b3 : bit).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Basics-v-chk21" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk21"><span class="highlight"><span class="kn">Check</span> (bits B1 B0 B1 B0).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">bits B1 B0 B1 B0
     : nybble</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* ==&gt; bits B1 B0 B1 B0 : nybble *)</span></span></span></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">bits</span></span> constructor acts as a wrapper for its contents.
    Unwrapping can be done by pattern-matching, as in the <span class="inlinecode"><span class="id" title="var">all_zero</span></span>
    function which tests a nybble to see if all its bits are O.
    Note that we are using underscore (_) as a <i>wildcard pattern</i> to
    avoid inventing variable names that will not be used. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">all_zero</span> (<span class="nv">nb</span> : nybble) : bool :=
  <span class="kr">match</span> nb <span class="kr">with</span>
    | (bits B0 B0 B0 B0) =&gt; true
    | (bits _ _ _ _) =&gt; false
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Basics-v-chk22" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk22"><span class="highlight"><span class="kn">Compute</span> (all_zero (bits B1 B0 B1 B0)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">= false
: bool</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Basics-v-chk23" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk23"><span class="highlight"><span class="kn">Compute</span> (all_zero (bits B0 B0 B0 B0)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">= true
: bool</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">

<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab13"></a><h2 class="section">Modules</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Coq provides a <i>module system</i>, to aid in organizing large
    developments.  In this course we won't need most of its features,
    but one is useful: If we enclose a collection of declarations
    between <span class="inlinecode"><span class="id" title="keyword">Module</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> and <span class="inlinecode"><span class="id" title="keyword">End</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> markers, then, in the remainder of
    the file after the <span class="inlinecode"><span class="id" title="keyword">End</span></span>, these definitions are referred to by
    names like <span class="inlinecode"><span class="id" title="var">X.foo</span></span> instead of just <span class="inlinecode"><span class="id" title="var">foo</span></span>.  We will use this
    feature to introduce the definition of the type <span class="inlinecode"><span class="id" title="var">nat</span></span> in an inner
    module so that it does not interfere with the one from the
    standard library (which we want to use in the rest because it
    comes with a tiny bit of convenient special notation).  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">NatPlayground</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab14"></a><h2 class="section">Numbers</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The types we have defined so far, "enumerated types" such as
    <span class="inlinecode"><span class="id" title="var">day</span></span>, <span class="inlinecode"><span class="id" title="var">bool</span></span>, and <span class="inlinecode"><span class="id" title="var">bit</span></span>, and tuple types such as <span class="inlinecode"><span class="id" title="var">nybble</span></span> built
    from them, share the property that each type has a finite set of
    values. The natural numbers are an infinite set, and we need to
    represent all of them in a datatype with a finite number of
    constructors. There are many representations of numbers to choose
    from. We are most familiar with decimal notation (base 10), using
    the digits 0 through 9, for example, to form the number 123.  You
    may have encountered hexadecimal notation (base 16), in which the
    same number is represented as 7B, or octal (base 8), where it is
    173, or binary (base 2), where it is 1111011. Using an enumerated
    type to represent digits, we could use any of these to represent
    natural numbers. There are circumstances where each of these
    choices can be useful.

<div class="paragraph"> </div>

    Binary is valuable in computer hardware because it can in turn be
    represented with two voltage levels, resulting in simple
    circuitry. Analogously, we wish here to choose a representation
    that makes <i>proofs</i> simpler.

<div class="paragraph"> </div>

    Indeed, there is a representation of numbers that is even simpler
    than binary, namely unary (base 1), in which only a single digit
    is used (as one might do while counting days in prison by scratching
    on the walls). To represent unary with a Coq datatype, we use
    two constructors. The capital-letter <span class="inlinecode"><span class="id" title="var">O</span></span> constructor represents zero.
    When the <span class="inlinecode"><span class="id" title="var">S</span></span> constructor is applied to the representation of the
    natural number <i>n</i>, the result is the representation of <i>n+1</i>.
    (<span class="inlinecode"><span class="id" title="var">S</span></span> stands for "successor", or "scratch" if one is in prison.)
    Here is the complete datatype definition. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">nat</span> : <span class="kt">Type</span> :=
  | O
  | S (n : nat).</span></span></span></pre><div class="doc">
With this definition, 0 is represented by <span class="inlinecode"><span class="id" title="var">O</span></span>, 1 by <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span></span>,
    2 by <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>)</span>, and so on. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The clauses of this definition can be read:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">O</span></span> is a natural number (note that this is the letter "<span class="inlinecode"><span class="id" title="var">O</span></span>,"
        not the numeral "<span class="inlinecode">0</span>").

</li>
<li> <span class="inlinecode"><span class="id" title="var">S</span></span> can be put in front of a natural number to yield another
        one -- if <span class="inlinecode"><span class="id" title="var">n</span></span> is a natural number, then <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> is too. 
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Again, let's look at this in a little more detail.  The definition
    of <span class="inlinecode"><span class="id" title="var">nat</span></span> says how expressions in the set <span class="inlinecode"><span class="id" title="var">nat</span></span> can be built:

<div class="paragraph"> </div>
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">O</span></span> and <span class="inlinecode"><span class="id" title="var">S</span></span> are constructors;

</li>
<li> the expression <span class="inlinecode"><span class="id" title="var">O</span></span> belongs to the set <span class="inlinecode"><span class="id" title="var">nat</span></span>;

</li>
<li> if <span class="inlinecode"><span class="id" title="var">n</span></span> is an expression belonging to the set <span class="inlinecode"><span class="id" title="var">nat</span></span>, then <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>
      is also an expression belonging to the set <span class="inlinecode"><span class="id" title="var">nat</span></span>; and

</li>
<li> expressions formed in these two ways are the only ones belonging
      to the set <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The same rules apply for our definitions of <span class="inlinecode"><span class="id" title="var">day</span></span>, <span class="inlinecode"><span class="id" title="var">bool</span></span>,
    <span class="inlinecode"><span class="id" title="var">color</span></span>, etc.

<div class="paragraph"> </div>

    The above conditions are the precise force of the <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>
    declaration.  They imply that the expression <span class="inlinecode"><span class="id" title="var">O</span></span>, the expression
    <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span></span>, the expression <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>)</span>, the expression <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>))</span>, and
    so on all belong to the set <span class="inlinecode"><span class="id" title="var">nat</span></span>, while other expressions built
    from data constructors, like <span class="inlinecode"><span class="id" title="var">true</span></span>, <span class="inlinecode"><span class="id" title="var">andb</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span>, <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span>
<span class="inlinecode"><span class="id" title="var">false</span>)</span>, and <span class="inlinecode"><span class="id" title="var">O</span></span> <span class="inlinecode">(<span class="id" title="var">O</span></span> <span class="inlinecode">(<span class="id" title="var">O</span></span> <span class="inlinecode"><span class="id" title="var">S</span>))</span> do not.

<div class="paragraph"> </div>

    A critical point here is that what we've done so far is just to
    define a <i>representation</i> of numbers: a way of writing them down.
    The names <span class="inlinecode"><span class="id" title="var">O</span></span> and <span class="inlinecode"><span class="id" title="var">S</span></span> are arbitrary, and at this point they have
    no special meaning -- they are just two different marks that we
    can use to write down numbers (together with a rule that says any
    <span class="inlinecode"><span class="id" title="var">nat</span></span> will be written as some string of <span class="inlinecode"><span class="id" title="var">S</span></span> marks followed by an
    <span class="inlinecode"><span class="id" title="var">O</span></span>).  If we like, we can write essentially the same definition
    this way: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">nat&#39;</span> : <span class="kt">Type</span> :=
  | stop
  | tick (foo : nat&#39;).</span></span></span></pre><div class="doc">
The <i>interpretation</i> of these marks comes from how we use them to
    compute. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We can do this by writing functions that pattern match on
    representations of natural numbers just as we did above with
    booleans and days -- for example, here is the predecessor
    function: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">pred</span> (<span class="nv">n</span> : nat) : nat :=
  <span class="kr">match</span> n <span class="kr">with</span>
    | O =&gt; O
    | S n&#39; =&gt; n&#39;
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
The second branch can be read: "if <span class="inlinecode"><span class="id" title="var">n</span></span> has the form <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>
    for some <span class="inlinecode"><span class="id" title="var">n'</span></span>, then return <span class="inlinecode"><span class="id" title="var">n'</span></span>."  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">NatPlayground</span>.</span></span></span></pre><div class="doc">
Because natural numbers are such a pervasive form of data,
    Coq provides a tiny bit of built-in magic for parsing and printing
    them: ordinary decimal numerals can be used as an alternative to
    the "unary" notation defined by the constructors <span class="inlinecode"><span class="id" title="var">S</span></span> and <span class="inlinecode"><span class="id" title="var">O</span></span>.  Coq
    prints numbers in decimal form by default: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Basics-v-chk24" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk24"><span class="highlight"><span class="kn">Check</span> (S (S (S (S O)))).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight"><span class="mi">4</span>
     : nat</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">minustwo</span> (<span class="nv">n</span> : nat) : nat :=
  <span class="kr">match</span> n <span class="kr">with</span>
    | O =&gt; O
    | S O =&gt; O
    | S (S n&#39;) =&gt; n&#39;
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Basics-v-chk25" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk25"><span class="highlight"><span class="kn">Compute</span> (minustwo <span class="mi">4</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">= <span class="mi">2</span>
: nat</span></blockquote></div></div></small></span></pre><div class="doc">
The constructor <span class="inlinecode"><span class="id" title="var">S</span></span> has the type <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, just like
    <span class="inlinecode"><span class="id" title="var">pred</span></span> and functions like <span class="inlinecode"><span class="id" title="var">minustwo</span></span>: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Basics-v-chk26" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk26"><span class="highlight"><span class="kn">Check</span> S.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">S
     : nat -&gt; nat</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Basics-v-chk27" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk27"><span class="highlight"><span class="kn">Check</span> pred.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">Nat.pred
     : nat -&gt; nat</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Basics-v-chk28" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk28"><span class="highlight"><span class="kn">Check</span> minustwo.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">minustwo
     : nat -&gt; nat</span></blockquote></div></div></small></span></pre><div class="doc">
These are all things that can be applied to a number to yield a
    number.  However, there is a fundamental difference between the
    first one and the other two: functions like <span class="inlinecode"><span class="id" title="var">pred</span></span> and <span class="inlinecode"><span class="id" title="var">minustwo</span></span>
    come with <i>computation rules</i> -- e.g., the definition of <span class="inlinecode"><span class="id" title="var">pred</span></span>
    says that <span class="inlinecode"><span class="id" title="var">pred</span></span> <span class="inlinecode">2</span> can be simplified to <span class="inlinecode">1</span> -- while the
    definition of <span class="inlinecode"><span class="id" title="var">S</span></span> has no such behavior attached.  Although it is
    like a function in the sense that it can be applied to an
    argument, it does not <i>do</i> anything at all!  It is just a way of
    writing down numbers.  (Think about standard decimal numerals: the
    numeral <span class="inlinecode">1</span> is not a computation; it's a piece of data.  When we
    write <span class="inlinecode">111</span> to mean the number one hundred and eleven, we are
    using <span class="inlinecode">1</span>, three times, to write down a concrete representation of
    a number.)

<div class="paragraph"> </div>

    For most function definitions over numbers, just pattern matching
    is not enough: we also need recursion.  For example, to check that
    a number <span class="inlinecode"><span class="id" title="var">n</span></span> is even, we may need to recursively check whether
    <span class="inlinecode"><span class="id" title="var">n</span>-2</span> is even.  To write such functions, we use the keyword
    <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">evenb</span> (<span class="nv">n</span>:nat) : bool :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | O        =&gt; true
  | S O      =&gt; false
  | S (S n&#39;) =&gt; evenb n&#39;
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
We can define <span class="inlinecode"><span class="id" title="var">oddb</span></span> by a similar <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> declaration, but here
    is a simpler definition: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">oddb</span> (<span class="nv">n</span>:nat) : bool   :=   negb (evenb n).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk29" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk29"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_oddb1</span>:    oddb <span class="mi">1</span> = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">oddb <span class="mi">1</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk2a" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk2a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">oddb <span class="mi">1</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk2b" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk2b"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">oddb <span class="mi">1</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk2c" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk2c"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_oddb2</span>:    oddb <span class="mi">4</span> = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">oddb <span class="mi">4</span> = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk2d" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk2d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">oddb <span class="mi">4</span> = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk2e"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">oddb <span class="mi">4</span> = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
(You will notice if you step through these proofs that
    <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> actually has no effect on the goal -- all of the work is
    done by <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>.  We'll see more about why that is shortly.)

<div class="paragraph"> </div>

    Naturally, we can also define multi-argument functions by
    recursion.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">NatPlayground2</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">plus</span> (<span class="nv">n</span> : nat) (<span class="nv">m</span> : nat) : nat :=
  <span class="kr">match</span> n <span class="kr">with</span>
    | O =&gt; m
    | S n&#39; =&gt; S (plus n&#39; m)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Adding three to two now gives us five, as we'd expect. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Basics-v-chk2f" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk2f"><span class="highlight"><span class="kn">Compute</span> (plus <span class="mi">3</span> <span class="mi">2</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">= <span class="mi">5</span>
: nat</span></blockquote></div></div></small></span></pre><div class="doc">
The simplification that Coq performs to reach this conclusion can
    be visualized as follows: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(*  [plus (S (S (S O))) (S (S O))]</span>
<span class="c">==&gt; [S (plus (S (S O)) (S (S O)))]</span>
<span class="c">      by the second clause of the [match]</span>
<span class="c">==&gt; [S (S (plus (S O) (S (S O))))]</span>
<span class="c">      by the second clause of the [match]</span>
<span class="c">==&gt; [S (S (S (plus O (S (S O)))))]</span>
<span class="c">      by the second clause of the [match]</span>
<span class="c">==&gt; [S (S (S (S (S O))))]</span>
<span class="c">      by the first clause of the [match]</span>
<span class="c">*)</span></span></span></pre><div class="doc">
As a notational convenience, if two or more arguments have
    the same type, they can be written together.  In the following
    definition, <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> means just the same as if we had written
    <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">(<span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">mult</span> (<span class="nv">n</span> <span class="nv">m</span> : nat) : nat :=
  <span class="kr">match</span> n <span class="kr">with</span>
    | O =&gt; O
    | S n&#39; =&gt; plus m (mult n&#39; m)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk30" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk30"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_mult1</span>: (mult <span class="mi">3</span> <span class="mi">3</span>) = <span class="mi">9</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">mult <span class="mi">3</span> <span class="mi">3</span> = <span class="mi">9</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk31" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk31"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">mult <span class="mi">3</span> <span class="mi">3</span> = <span class="mi">9</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk32" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk32"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">9</span> = <span class="mi">9</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
You can match two expressions at once by putting a comma
    between them: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">minus</span> (<span class="nv">n</span> <span class="nv">m</span>:nat) : nat :=
  <span class="kr">match</span> n, m <span class="kr">with</span>
  | O   , _    =&gt; O
  | S _ , O    =&gt; n
  | S n&#39;, S m&#39; =&gt; minus n&#39; m&#39;
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">NatPlayground2</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">exp</span> (<span class="nv">base</span> <span class="nv">power</span> : nat) : nat :=
  <span class="kr">match</span> power <span class="kr">with</span>
    | O =&gt; S O
    | S p =&gt; mult base (exp base p)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab15"></a><h4 class="section">Exercise: 1 star, standard (factorial)</h4>
<div class="paragraph"> </div>

    Recall the standard mathematical factorial function:

<div class="paragraph"> </div>

       factorial(0)  =  1
       factorial(n)  =  n * factorial(n-1)     (if n&gt;0)

<div class="paragraph"> </div>

    Translate this into Coq. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk33" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk33"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">factorial</span> (<span class="nv">n</span>:nat) : nat
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">factorial</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">nat</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk34" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk34"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_factorial1</span>:          (factorial <span class="mi">3</span>) = <span class="mi">6</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">factorial <span class="mi">3</span> = <span class="mi">6</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk35" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk35"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_factorial2</span>:          (factorial <span class="mi">5</span>) = (mult <span class="mi">10</span> <span class="mi">12</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">factorial <span class="mi">5</span> = <span class="mi">10</span> * <span class="mi">12</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Again, we can make numerical expressions easier to read and write
    by introducing notations for addition, multiplication, and
    subtraction. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x + y&quot;</span> := (plus x y)
                       (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">left associativity</span>)
                       : nat_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x - y&quot;</span> := (minus x y)
                       (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">left associativity</span>)
                       : nat_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x * y&quot;</span> := (mult x y)
                       (<span class="kn">at level</span> <span class="mi">40</span>, <span class="kn">left associativity</span>)
                       : nat_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Basics-v-chk36" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk36"><span class="highlight"><span class="kn">Check</span> ((<span class="mi">0</span> + <span class="mi">1</span>) + <span class="mi">1</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight"><span class="mi">0</span> + <span class="mi">1</span> + <span class="mi">1</span>
     : nat</span></blockquote></div></div></small></span></pre><div class="doc">
(The <span class="inlinecode"><span class="id" title="keyword">level</span></span>, <span class="inlinecode"><span class="id" title="keyword">associativity</span></span>, and <span class="inlinecode"><span class="id" title="var">nat_scope</span></span> annotations
    control how these notations are treated by Coq's parser.  The
    details are not important for our purposes, but interested readers
    can refer to the "More on Notation" section at the end of this
    chapter.)

<div class="paragraph"> </div>

    Note that these do not change the definitions we've already made:
    they are simply instructions to the Coq parser to accept <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">y</span></span>
    in place of <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> and, conversely, to the Coq pretty-printer
    to display <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> as <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">y</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
When we say that Coq comes with almost nothing built-in, we really
    mean it: even equality testing is a user-defined operation!

<div class="paragraph"> </div>

    Here is a function <span class="inlinecode"><span class="id" title="var">eqb</span></span>, which tests natural numbers for
    <span class="inlinecode"><span class="id" title="var">eq</span></span>uality, yielding a <span class="inlinecode"><span class="id" title="var">b</span></span>oolean.  Note the use of nested
    <span class="inlinecode"><span class="id" title="keyword">match</span></span>es (we could also have used a simultaneous match, as we did
    in <span class="inlinecode"><span class="id" title="var">minus</span></span>.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">eqb</span> (<span class="nv">n</span> <span class="nv">m</span> : nat) : bool :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | O =&gt; <span class="kr">match</span> m <span class="kr">with</span>
         | O =&gt; true
         | S m&#39; =&gt; false
         <span class="kr">end</span>
  | S n&#39; =&gt; <span class="kr">match</span> m <span class="kr">with</span>
            | O =&gt; false
            | S m&#39; =&gt; eqb n&#39; m&#39;
            <span class="kr">end</span>
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Similarly, the <span class="inlinecode"><span class="id" title="var">leb</span></span> function tests whether its first argument is
    less than or equal to its second argument, yielding a boolean. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">leb</span> (<span class="nv">n</span> <span class="nv">m</span> : nat) : bool :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | O =&gt; true
  | S n&#39; =&gt;
      <span class="kr">match</span> m <span class="kr">with</span>
      | O =&gt; false
      | S m&#39; =&gt; leb n&#39; m&#39;
      <span class="kr">end</span>
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk37" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk37"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_leb1</span>:             (leb <span class="mi">2</span> <span class="mi">2</span>) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">leb <span class="mi">2</span> <span class="mi">2</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk38" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk38"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">leb <span class="mi">2</span> <span class="mi">2</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk39" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk39"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk3a" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk3a"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_leb2</span>:             (leb <span class="mi">2</span> <span class="mi">4</span>) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">leb <span class="mi">2</span> <span class="mi">4</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk3b" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk3b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">leb <span class="mi">2</span> <span class="mi">4</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk3c" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk3c"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk3d" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk3d"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_leb3</span>:             (leb <span class="mi">4</span> <span class="mi">2</span>) = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">leb <span class="mi">4</span> <span class="mi">2</span> = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk3e" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk3e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">leb <span class="mi">4</span> <span class="mi">2</span> = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk3f" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk3f"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Since we'll be using these (especially <span class="inlinecode"><span class="id" title="var">eqb</span></span>) a lot, let's give
    them infix notations. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x =? y&quot;</span> := (eqb x y) (<span class="kn">at level</span> <span class="mi">70</span>) : nat_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &lt;=? y&quot;</span> := (leb x y) (<span class="kn">at level</span> <span class="mi">70</span>) : nat_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk40" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk40"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_leb3&#39;</span>:             (<span class="mi">4</span> &lt;=? <span class="mi">2</span>) = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="mi">4</span> &lt;=? <span class="mi">2</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk41" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk41"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="mi">4</span> &lt;=? <span class="mi">2</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk42" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk42"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab16"></a><h4 class="section">Exercise: 1 star, standard (ltb)</h4>
<div class="paragraph"> </div>

    The <span class="inlinecode"><span class="id" title="var">ltb</span></span> function tests natural numbers for <span class="inlinecode"><span class="id" title="var">l</span></span>ess-<span class="inlinecode"><span class="id" title="var">t</span></span>han,
    yielding a <span class="inlinecode"><span class="id" title="var">b</span></span>oolean.  Instead of making up a new <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> for
    this one, define it in terms of a previously defined
    function.  (It can be done with just one previously defined
    function, but you can use two if you need to.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk43" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk43"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ltb</span> (<span class="nv">n</span> <span class="nv">m</span> : nat) : bool
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">bool</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &lt;? y&quot;</span> := (ltb x y) (<span class="kn">at level</span> <span class="mi">70</span>) : nat_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk44" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk44"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_ltb1</span>:             (ltb <span class="mi">2</span> <span class="mi">2</span>) = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="mi">2</span> &lt;? <span class="mi">2</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk45" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk45"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_ltb2</span>:             (ltb <span class="mi">2</span> <span class="mi">4</span>) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="mi">2</span> &lt;? <span class="mi">4</span>) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk46" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk46"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_ltb3</span>:             (ltb <span class="mi">4</span> <span class="mi">2</span>) = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="mi">4</span> &lt;? <span class="mi">2</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab17"></a><h1 class="section">Proof by Simplification</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Now that we've defined a few datatypes and functions, let's
    turn to stating and proving properties of their behavior.
    Actually, we've already started doing this: each <span class="inlinecode"><span class="id" title="keyword">Example</span></span> in the
    previous sections makes a precise claim about the behavior of some
    function on some particular inputs.  The proofs of these claims
    were always the same: use <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> to simplify both sides of the
    equation, then use <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> to check that both sides contain
    identical values.

<div class="paragraph"> </div>

    The same sort of "proof by simplification" can be used to prove
    more interesting properties as well.  For example, the fact that
    <span class="inlinecode">0</span> is a "neutral element" for <span class="inlinecode">+</span> on the left can be proved just
    by observing that <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> reduces to <span class="inlinecode"><span class="id" title="var">n</span></span> no matter what <span class="inlinecode"><span class="id" title="var">n</span></span> is, a
    fact that can be read directly off the definition of <span class="inlinecode"><span class="id" title="var">plus</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk47" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk47"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">plus_O_n</span> : <span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="mi">0</span> + n = n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="mi">0</span> + n = n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk48" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk48"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="mi">0</span> + n = n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk49" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk49"><span class="highlight"><span class="nb">intros</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> + n = n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk4a" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk4a"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n = n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
(You may notice that the above statement looks different in
    the <span class="inlinecode">.<span class="id" title="var">v</span></span> file in your IDE than it does in the HTML rendition in
    your browser, if you are viewing both. In <span class="inlinecode">.<span class="id" title="var">v</span></span> files, we write the
    <span class="inlinecode"><span class="id" title="keyword">‚àÄ</span></span> universal quantifier using the reserved identifier
    "forall."  When the <span class="inlinecode">.<span class="id" title="var">v</span></span> files are converted to HTML, this gets
    transformed into an upside-down-A symbol.)

<div class="paragraph"> </div>

    This is a good place to mention that <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> is a bit
    more powerful than we have admitted. In the examples we have seen,
    the calls to <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> were actually not needed, because
    <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> can perform some simplification automatically when
    checking that two sides are equal; <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> was just added so that
    we could see the intermediate state -- after simplification but
    before finishing the proof.  Here is a shorter proof of the
    theorem: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk4b" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk4b"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">plus_O_n&#39;</span> : <span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="mi">0</span> + n = n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="mi">0</span> + n = n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk4c" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk4c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="mi">0</span> + n = n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk4d" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk4d"><span class="highlight"><span class="nb">intros</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> + n = n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Moreover, it will be useful later to know that <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>
    does somewhat <i>more</i> simplification than <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> does -- for
    example, it tries "unfolding" defined terms, replacing them with
    their right-hand sides.  The reason for this difference is that,
    if reflexivity succeeds, the whole goal is finished and we don't
    need to look at whatever expanded expressions <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> has
    created by all this simplification and unfolding; by contrast,
    <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> is used in situations where we may have to read and
    understand the new goal that it creates, so we would not want it
    blindly expanding definitions and leaving the goal in a messy
    state.

<div class="paragraph"> </div>

    The form of the theorem we just stated and its proof are almost
    exactly the same as the simpler examples we saw earlier; there are
    just a few differences.

<div class="paragraph"> </div>

    First, we've used the keyword <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> instead of <span class="inlinecode"><span class="id" title="keyword">Example</span></span>.
    This difference is mostly a matter of style; the keywords
    <span class="inlinecode"><span class="id" title="keyword">Example</span></span> and <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> (and a few others, including <span class="inlinecode"><span class="id" title="keyword">Lemma</span></span>,
    <span class="inlinecode"><span class="id" title="keyword">Fact</span></span>, and <span class="inlinecode"><span class="id" title="keyword">Remark</span></span>) mean pretty much the same thing to Coq.

<div class="paragraph"> </div>

    Second, we've added the quantifier <span class="inlinecode"><span class="id" title="keyword">‚àÄ</span></span> <span class="inlinecode"><span class="id" title="var">n</span>:<span class="id" title="var">nat</span></span>, so that our
    theorem talks about <i>all</i> natural numbers <span class="inlinecode"><span class="id" title="var">n</span></span>.  Informally, to
    prove theorems of this form, we generally start by saying "Suppose
    <span class="inlinecode"><span class="id" title="var">n</span></span> is some number..."  Formally, this is achieved in the proof by
    <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, which moves <span class="inlinecode"><span class="id" title="var">n</span></span> from the quantifier in the goal to a
    <i>context</i> of current assumptions.

<div class="paragraph"> </div>

    The keywords <span class="inlinecode"><span class="id" title="tactic">intros</span></span>, <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>, and <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> are examples of
    <i>tactics</i>.  A tactic is a command that is used between <span class="inlinecode"><span class="id" title="keyword">Proof</span></span> and
    <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> to guide the process of checking some claim we are making.
    We will see several more tactics in the rest of this chapter and
    yet more in future chapters. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Other similar theorems can be proved with the same pattern. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk4e" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk4e"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">plus_1_l</span> : <span class="kr">forall</span> <span class="nv">n</span>:nat, <span class="mi">1</span> + n = S n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="mi">1</span> + n = S n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk4f" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk4f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="mi">1</span> + n = S n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk50" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk50"><span class="highlight"><span class="nb">intros</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> + n = S n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk51" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk51"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">mult_0_l</span> : <span class="kr">forall</span> <span class="nv">n</span>:nat, <span class="mi">0</span> * n = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="mi">0</span> * n = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk52" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk52"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="mi">0</span> * n = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk53" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk53"><span class="highlight"><span class="nb">intros</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> * n = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">_l</span></span> suffix in the names of these theorems is
    pronounced "on the left." 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
It is worth stepping through these proofs to observe how the
    context and the goal change.  You may want to add calls to <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>
    before <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> to see the simplifications that Coq performs
    on the terms before checking that they are equal. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab18"></a><h1 class="section">Proof by Rewriting</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
This theorem is a bit more interesting than the others we've
    seen: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk54" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk54"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">plus_id_example</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>:nat,
  n = m -&gt;
  n + n = m + m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = m -&gt; n + n = m + m</span></div></blockquote></div></div></small></span></pre><div class="doc">
Instead of making a universal claim about all numbers <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">m</span></span>,
    it talks about a more specialized property that only holds when <span class="inlinecode"><span class="id" title="var">n</span></span>
<span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>.  The arrow symbol is pronounced "implies."

<div class="paragraph"> </div>

    As before, we need to be able to reason by assuming we are given such
    numbers <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">m</span></span>.  We also need to assume the hypothesis
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>. The <span class="inlinecode"><span class="id" title="tactic">intros</span></span> tactic will serve to move all three of these
    from the goal into assumptions in the current context.

<div class="paragraph"> </div>

    Since <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">m</span></span> are arbitrary numbers, we can't just use
    simplification to prove this theorem.  Instead, we prove it by
    observing that, if we are assuming <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>, then we can replace
    <span class="inlinecode"><span class="id" title="var">n</span></span> with <span class="inlinecode"><span class="id" title="var">m</span></span> in the goal statement and obtain an equality with the
    same expression on both sides.  The tactic that tells Coq to
    perform this replacement is called <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk55" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk55"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = m -&gt; n + n = m + m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* move both quantifiers into the context: *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk56" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk56"><span class="highlight"><span class="nb">intros</span> n m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n = m -&gt; n + n = m + m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* move the hypothesis into the context: *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk57" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk57"><span class="highlight"><span class="nb">intros</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n + n = m + m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* rewrite the goal using the hypothesis: *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk58" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk58"><span class="highlight"><span class="nb">rewrite</span> -&gt; H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">m + m = m + m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The first line of the proof moves the universally quantified
    variables <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">m</span></span> into the context.  The second moves the
    hypothesis <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> into the context and gives it the name <span class="inlinecode"><span class="id" title="var">H</span></span>.
    The third tells Coq to rewrite the current goal (<span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span>)
    by replacing the left side of the equality hypothesis <span class="inlinecode"><span class="id" title="var">H</span></span> with the
    right side.

<div class="paragraph"> </div>

    (The arrow symbol in the <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> has nothing to do with
    implication: it tells Coq to apply the rewrite from left to right.
    To rewrite from right to left, you can use <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">&lt;-</span>.  Try
    making this change in the above proof and see what difference it
    makes.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab19"></a><h4 class="section">Exercise: 1 star, standard (plus_id_exercise)</h4>
<div class="paragraph"> </div>

    Remove "<span class="inlinecode"><span class="id" title="var">Admitted</span>.</span>" and fill in the proof. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk59" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk59"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">plus_id_exercise</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">o</span> : nat,
  n = m -&gt; m = o -&gt; n + m = m + o.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">o</span> : nat, n = m -&gt; m = o -&gt; n + m = m + o</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk5a" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk5a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">o</span> : nat, n = m -&gt; m = o -&gt; n + m = m + o</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">Admitted</span></span> command tells Coq that we want to skip trying
    to prove this theorem and just accept it as a given.  This can be
    useful for developing longer proofs, since we can state subsidiary
    lemmas that we believe will be useful for making some larger
    argument, use <span class="inlinecode"><span class="id" title="var">Admitted</span></span> to accept them on faith for the moment,
    and continue working on the main argument until we are sure it
    makes sense; then we can go back and fill in the proofs we
    skipped.  Be careful, though: every time you say <span class="inlinecode"><span class="id" title="var">Admitted</span></span> you
    are leaving a door open for total nonsense to enter Coq's nice,
    rigorous, formally checked world! 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We can also use the <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> tactic with a previously proved
    theorem instead of a hypothesis from the context. If the statement
    of the previously proved theorem involves quantified variables,
    as in the example below, Coq tries to instantiate them
    by matching with the current goal. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk5b" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk5b"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">mult_0_plus</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
  (<span class="mi">0</span> + n) * m = n * m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, (<span class="mi">0</span> + n) * m = n * m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk5c" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk5c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, (<span class="mi">0</span> + n) * m = n * m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk5d" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk5d"><span class="highlight"><span class="nb">intros</span> n m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="mi">0</span> + n) * m = n * m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk5e" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk5e"><span class="highlight"><span class="nb">rewrite</span> -&gt; plus_O_n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n * m = n * m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab20"></a><h4 class="section">Exercise: 2 stars, standard (mult_S_1)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk5f" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk5f"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">mult_S_1</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
  m = S n -&gt;
  m * (<span class="mi">1</span> + n) = m * m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, m = S n -&gt; m * (<span class="mi">1</span> + n) = m * m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk60" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk60"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, m = S n -&gt; m * (<span class="mi">1</span> + n) = m * m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
  <span class="c">(* (N.b. This proof can actually be completed with tactics other than</span>
<span class="c">     [rewrite], but please do use [rewrite] for the sake of the exercise.) </span>

<span class="c">    [] *)</span>

<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab21"></a><h1 class="section">Proof by Case Analysis</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Of course, not everything can be proved by simple
    calculation and rewriting: In general, unknown, hypothetical
    values (arbitrary numbers, booleans, lists, etc.) can block
    simplification.  For example, if we try to prove the following
    fact using the <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> tactic as above, we get stuck.  (We then
    use the <span class="inlinecode"><span class="id" title="keyword">Abort</span></span> command to give up on it for the moment.)
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk61" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk61"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">plus_1_neq_0_firsttry</span> : <span class="kr">forall</span> <span class="nv">n</span> : nat,
  (n + <span class="mi">1</span>) =? <span class="mi">0</span> = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, (n + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk62" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk62"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, (n + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk63" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk63"><span class="highlight"><span class="nb">intros</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(n + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk64" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk64"><span class="highlight"><span class="nb">simpl</span>.  <span class="c">(* does nothing! *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(n + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><div class="doc">
The reason for this is that the definitions of both
    <span class="inlinecode"><span class="id" title="var">eqb</span></span> and <span class="inlinecode">+</span> begin by performing a <span class="inlinecode"><span class="id" title="keyword">match</span></span> on their first
    argument.  But here, the first argument to <span class="inlinecode">+</span> is the unknown
    number <span class="inlinecode"><span class="id" title="var">n</span></span> and the argument to <span class="inlinecode"><span class="id" title="var">eqb</span></span> is the compound
    expression <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span>; neither can be simplified.

<div class="paragraph"> </div>

    To make progress, we need to consider the possible forms of <span class="inlinecode"><span class="id" title="var">n</span></span>
    separately.  If <span class="inlinecode"><span class="id" title="var">n</span></span> is <span class="inlinecode"><span class="id" title="var">O</span></span>, then we can calculate the final result
    of <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> <span class="inlinecode">=?</span> <span class="inlinecode">0</span> and check that it is, indeed, <span class="inlinecode"><span class="id" title="var">false</span></span>.  And
    if <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> for some <span class="inlinecode"><span class="id" title="var">n'</span></span>, then, although we don't know exactly
    what number <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> yields, we can calculate that, at least, it
    will begin with one <span class="inlinecode"><span class="id" title="var">S</span></span>, and this is enough to calculate that,
    again, <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> <span class="inlinecode">=?</span> <span class="inlinecode">0</span> will yield <span class="inlinecode"><span class="id" title="var">false</span></span>.

<div class="paragraph"> </div>

    The tactic that tells Coq to consider, separately, the cases where
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">O</span></span> and where <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> is called <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk65" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk65"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">plus_1_neq_0</span> : <span class="kr">forall</span> <span class="nv">n</span> : nat,
  (n + <span class="mi">1</span>) =? <span class="mi">0</span> = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, (n + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk66" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk66"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, (n + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk67" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk67"><span class="highlight"><span class="nb">intros</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(n + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk68" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk68"><span class="highlight"><span class="nb">destruct</span> n <span class="kr">as</span> [| n&#39;] <span class="nb">eqn</span>:E.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="mi">0</span> + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chk69" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = S n&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chk69"><hr></label><div class="goal-conclusion"><span class="highlight">(S n&#39; + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk6a" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk6a"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="mi">0</span> + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk6b" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk6b"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = S n&#39;</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(S n&#39; + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">   </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> generates <i>two</i> subgoals, which we must then
    prove, separately, in order to get Coq to accept the theorem.

<div class="paragraph"> </div>

    The annotation "<span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[|</span> <span class="inlinecode"><span class="id" title="var">n'</span>]</span>" is called an <i>intro pattern</i>.  It
    tells Coq what variable names to introduce in each subgoal.  In
    general, what goes between the square brackets is a <i>list of
    lists</i> of names, separated by <span class="inlinecode">|</span>.  In this case, the first
    component is empty, since the <span class="inlinecode"><span class="id" title="var">O</span></span> constructor is nullary (it
    doesn't have any arguments).  The second component gives a single
    name, <span class="inlinecode"><span class="id" title="var">n'</span></span>, since <span class="inlinecode"><span class="id" title="var">S</span></span> is a unary constructor.

<div class="paragraph"> </div>

    In each subgoal, Coq remembers the assumption about <span class="inlinecode"><span class="id" title="var">n</span></span> that is
    relevant for this subgoal -- either <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> or <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> for some
    n'.  The <span class="inlinecode"><span class="id" title="var">eqn</span>:<span class="id" title="var">E</span></span> annotation tells <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> to give the name <span class="inlinecode"><span class="id" title="var">E</span></span> to
    this equation.  (Leaving off the <span class="inlinecode"><span class="id" title="var">eqn</span>:<span class="id" title="var">E</span></span> annotation causes Coq to
    elide these assumptions in the subgoals.  This slightly
    streamlines proofs where the assumptions are not explicitly used,
    but it is better practice to keep them for the sake of
    documentation, as they can help keep you oriented when working
    with the subgoals.)

<div class="paragraph"> </div>

    The <span class="inlinecode">-</span> signs on the second and third lines are called <i>bullets</i>,
    and they mark the parts of the proof that correspond to each
    generated subgoal.  The proof script that comes after a bullet is
    the entire proof for a subgoal.  In this example, each of the
    subgoals is easily proved by a single use of <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>, which
    itself performs some simplification -- e.g., the second one
    simplifies <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> <span class="inlinecode">=?</span> <span class="inlinecode">0</span> to <span class="inlinecode"><span class="id" title="var">false</span></span> by first rewriting <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>
<span class="inlinecode">+</span> <span class="inlinecode">1)</span> to <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span>, then unfolding <span class="inlinecode"><span class="id" title="var">eqb</span></span>, and then simplifying
    the <span class="inlinecode"><span class="id" title="keyword">match</span></span>.

<div class="paragraph"> </div>

    Marking cases with bullets is entirely optional: if bullets are
    not present, Coq simply asks you to prove each subgoal in
    sequence, one at a time. But it is a good idea to use bullets.
    For one thing, they make the structure of a proof apparent, making
    it more readable. Also, bullets instruct Coq to ensure that a
    subgoal is complete before trying to verify the next one,
    preventing proofs for different subgoals from getting mixed
    up. These issues become especially important in large
    developments, where fragile proofs lead to long debugging
    sessions.

<div class="paragraph"> </div>

    There are no hard and fast rules for how proofs should be
    formatted in Coq -- in particular, where lines should be broken
    and how sections of the proof should be indented to indicate their
    nested structure.  However, if the places where multiple subgoals
    are generated are marked with explicit bullets at the beginning of
    lines, then the proof will be readable almost no matter what
    choices are made about other aspects of layout.

<div class="paragraph"> </div>

    This is also a good place to mention one other piece of somewhat
    obvious advice about line lengths.  Beginning Coq users sometimes
    tend to the extremes, either writing each tactic on its own line
    or writing entire proofs on one line.  Good style lies somewhere
    in the middle.  One reasonable convention is to limit yourself to
    80-character lines.

<div class="paragraph"> </div>

    The <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> tactic can be used with any inductively defined
    datatype.  For example, we use it next to prove that boolean
    negation is involutive -- i.e., that negation is its own
    inverse. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk6c" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk6c"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">negb_involutive</span> : <span class="kr">forall</span> <span class="nv">b</span> : bool,
  negb (negb b) = b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : bool, negb (negb b) = b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk6d" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk6d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : bool, negb (negb b) = b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk6e" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk6e"><span class="highlight"><span class="nb">intros</span> b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">negb (negb b) = b</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk6f" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk6f"><span class="highlight"><span class="nb">destruct</span> b <span class="nb">eqn</span>:E.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">negb (negb true) = true</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chk70" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chk70"><hr></label><div class="goal-conclusion"><span class="highlight">negb (negb false) = false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk71" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk71"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">negb (negb true) = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk72" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk72"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">negb (negb false) = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Note that the <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> here has no <span class="inlinecode"><span class="id" title="keyword">as</span></span> clause because
    none of the subcases of the <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> need to bind any variables,
    so there is no need to specify any names.  (We could also have
    written <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[|]</span>, or <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[]</span>.)  In fact, we can omit the <span class="inlinecode"><span class="id" title="keyword">as</span></span>
    clause from <i>any</i> <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> and Coq will fill in variable names
    automatically.  This is generally considered bad style, since Coq
    often makes confusing choices of names when left to its own
    devices.

<div class="paragraph"> </div>

    It is sometimes useful to invoke <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> inside a subgoal,
    generating yet more proof obligations. In this case, we use
    different kinds of bullets to mark goals on different "levels."
    For example: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk73" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk73"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">andb_commutative</span> : <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span>, andb b c = andb c b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> : bool, b &amp;&amp; c = c &amp;&amp; b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk74" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk74"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> : bool, b &amp;&amp; c = c &amp;&amp; b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk75" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk75"><span class="highlight"><span class="nb">intros</span> b c.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">b &amp;&amp; c = c &amp;&amp; b</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk76" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk76"><span class="highlight"><span class="nb">destruct</span> b <span class="nb">eqn</span>:Eb.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; c = c &amp;&amp; true</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chk77" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chk77"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; c = c &amp;&amp; false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk78" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk78"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; c = c &amp;&amp; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk79" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk79"><span class="highlight"><span class="nb">destruct</span> c <span class="nb">eqn</span>:Ec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; true = true &amp;&amp; true</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chk7a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chk7a"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; false = false &amp;&amp; true</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk7b" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk7b"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; true = true &amp;&amp; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk7c" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk7c"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; false = false &amp;&amp; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk7d" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk7d"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; c = c &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk7e" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk7e"><span class="highlight"><span class="nb">destruct</span> c <span class="nb">eqn</span>:Ec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; true = true &amp;&amp; false</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chk7f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chk7f"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; false = false &amp;&amp; false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk80" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk80"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; true = true &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk81" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk81"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; false = false &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Each pair of calls to <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> corresponds to the
    subgoals that were generated after the execution of the <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span>
    line right above it. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Besides <span class="inlinecode">-</span> and <span class="inlinecode">+</span>, we can use <span class="inlinecode">√ó</span> (asterisk) as a third kind of
    bullet.  We can also enclose sub-proofs in curly braces, which is
    useful in case we ever encounter a proof that generates more than
    three levels of subgoals: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk82" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk82"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">andb_commutative&#39;</span> : <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span>, andb b c = andb c b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> : bool, b &amp;&amp; c = c &amp;&amp; b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk83" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk83"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> : bool, b &amp;&amp; c = c &amp;&amp; b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk84" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk84"><span class="highlight"><span class="nb">intros</span> b c.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">b &amp;&amp; c = c &amp;&amp; b</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk85" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk85"><span class="highlight"><span class="nb">destruct</span> b <span class="nb">eqn</span>:Eb.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; c = c &amp;&amp; true</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chk86" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chk86"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; c = c &amp;&amp; false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk87" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk87"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; c = c &amp;&amp; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk88" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk88"><span class="highlight"><span class="nb">destruct</span> c <span class="nb">eqn</span>:Ec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; true = true &amp;&amp; true</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chk89" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chk89"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; false = false &amp;&amp; true</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk8a" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk8a"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; true = true &amp;&amp; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk8b" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk8b"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; false = false &amp;&amp; true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk8c" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk8c"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; false = false &amp;&amp; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">}</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk8d" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk8d"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; c = c &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk8e" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk8e"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; c = c &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk8f" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk8f"><span class="highlight"><span class="nb">destruct</span> c <span class="nb">eqn</span>:Ec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; true = true &amp;&amp; false</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chk90" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chk90"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; false = false &amp;&amp; false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk91" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk91"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; true = true &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk92" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk92"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; false = false &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk93" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk93"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; false = false &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">}</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">}</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Since curly braces mark both the beginning and the end of a
    proof, they can be used for multiple subgoal levels, as this
    example shows. Furthermore, curly braces allow us to reuse the
    same bullet shapes at multiple levels in a proof: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk94" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk94"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">andb3_exchange</span> :
  <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span>, andb (andb b c) d = andb (andb b d) c.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : bool, b &amp;&amp; c &amp;&amp; d = b &amp;&amp; d &amp;&amp; c</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk95" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk95"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : bool, b &amp;&amp; c &amp;&amp; d = b &amp;&amp; d &amp;&amp; c</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk96" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk96"><span class="highlight"><span class="nb">intros</span> b c d.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">b &amp;&amp; c &amp;&amp; d = b &amp;&amp; d &amp;&amp; c</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk97" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk97"><span class="highlight"><span class="nb">destruct</span> b <span class="nb">eqn</span>:Eb.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; c &amp;&amp; d = true &amp;&amp; d &amp;&amp; c</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chk98" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chk98"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; c &amp;&amp; d = false &amp;&amp; d &amp;&amp; c</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk99" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk99"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; c &amp;&amp; d = true &amp;&amp; d &amp;&amp; c</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk9a" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk9a"><span class="highlight"><span class="nb">destruct</span> c <span class="nb">eqn</span>:Ec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; true &amp;&amp; d = true &amp;&amp; d &amp;&amp; true</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chk9b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chk9b"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; false &amp;&amp; d = true &amp;&amp; d &amp;&amp; false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk9c" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk9c"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; true &amp;&amp; d = true &amp;&amp; d &amp;&amp; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk9d" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk9d"><span class="highlight"><span class="nb">destruct</span> d <span class="nb">eqn</span>:Ed.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; true &amp;&amp; true = true &amp;&amp; true &amp;&amp; true</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chk9e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chk9e"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; true &amp;&amp; false = true &amp;&amp; false &amp;&amp; true</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chk9f" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chk9f"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; true &amp;&amp; true = true &amp;&amp; true &amp;&amp; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chka0" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chka0"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; true &amp;&amp; false = true &amp;&amp; false &amp;&amp; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chka1" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chka1"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; false &amp;&amp; d = true &amp;&amp; d &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chka2" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chka2"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; false &amp;&amp; d = true &amp;&amp; d &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chka3" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chka3"><span class="highlight"><span class="nb">destruct</span> d <span class="nb">eqn</span>:Ed.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; false &amp;&amp; true = true &amp;&amp; true &amp;&amp; false</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chka4" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chka4"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; false &amp;&amp; false = true &amp;&amp; false &amp;&amp; false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chka5" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chka5"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; false &amp;&amp; true = true &amp;&amp; true &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chka6" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chka6"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; false &amp;&amp; false = true &amp;&amp; false &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">}</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chka7" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chka7"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; c &amp;&amp; d = false &amp;&amp; d &amp;&amp; c</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chka8" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chka8"><span class="highlight"><span class="nb">destruct</span> c <span class="nb">eqn</span>:Ec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; true &amp;&amp; d = false &amp;&amp; d &amp;&amp; true</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chka9" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chka9"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; false &amp;&amp; d = false &amp;&amp; d &amp;&amp; false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkaa" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkaa"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; true &amp;&amp; d = false &amp;&amp; d &amp;&amp; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkab" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkab"><span class="highlight"><span class="nb">destruct</span> d <span class="nb">eqn</span>:Ed.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; true &amp;&amp; true = false &amp;&amp; true &amp;&amp; true</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chkac" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chkac"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; true &amp;&amp; false = false &amp;&amp; false &amp;&amp; true</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkad" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkad"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; true &amp;&amp; true = false &amp;&amp; true &amp;&amp; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkae" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkae"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; true &amp;&amp; false = false &amp;&amp; false &amp;&amp; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkaf" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkaf"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; false &amp;&amp; d = false &amp;&amp; d &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkb0" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkb0"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; false &amp;&amp; d = false &amp;&amp; d &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkb1" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkb1"><span class="highlight"><span class="nb">destruct</span> d <span class="nb">eqn</span>:Ed.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; false &amp;&amp; true = false &amp;&amp; true &amp;&amp; false</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chkb2" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chkb2"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; false &amp;&amp; false = false &amp;&amp; false &amp;&amp; false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkb3" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkb3"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; false &amp;&amp; true = false &amp;&amp; true &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkb4" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkb4"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">c = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ed</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = false</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; false &amp;&amp; false = false &amp;&amp; false &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">}</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Before closing the chapter, let's mention one final
    convenience.  As you may have noticed, many proofs perform case
    analysis on a variable right after introducing it:

<div class="paragraph"> </div>

       intros x y. destruct y as <span class="inlinecode">|<span class="id" title="var">y</span></span> eqn:E.

<div class="paragraph"> </div>

    This pattern is so common that Coq provides a shorthand for it: we
    can perform case analysis on a variable when introducing it by
    using an intro pattern instead of a variable name. For instance,
    here is a shorter proof of the <span class="inlinecode"><span class="id" title="var">plus_1_neq_0</span></span> theorem
    above.  (You'll also note one downside of this shorthand: we lose
    the equation recording the assumption we are making in each
    subgoal, which we previously got from the <span class="inlinecode"><span class="id" title="var">eqn</span>:<span class="id" title="var">E</span></span> annotation.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkb5" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkb5"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">plus_1_neq_0&#39;</span> : <span class="kr">forall</span> <span class="nv">n</span> : nat,
  (n + <span class="mi">1</span>) =? <span class="mi">0</span> = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, (n + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkb6" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkb6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, (n + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkb7" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkb7"><span class="highlight"><span class="nb">intros</span> [|n].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="mi">0</span> + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chkb8" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chkb8"><hr></label><div class="goal-conclusion"><span class="highlight">(S n + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkb9" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkb9"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="mi">0</span> + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkba" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkba"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(S n + <span class="mi">1</span> =? <span class="mi">0</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
If there are no arguments to name, we can just write <span class="inlinecode">[]</span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkbb" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkbb"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">andb_commutative&#39;&#39;</span> :
  <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span>, andb b c = andb c b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> : bool, b &amp;&amp; c = c &amp;&amp; b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkbc" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkbc"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> : bool, b &amp;&amp; c = c &amp;&amp; b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkbd" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkbd"><span class="highlight"><span class="nb">intros</span> [] [].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; true = true &amp;&amp; true</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Basics-v-chkbe" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chkbe"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; false = false &amp;&amp; true</span></div></blockquote><input class="coq-extra-goal-toggle" id="Basics-v-chkbf" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chkbf"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; true = true &amp;&amp; false</span></div></blockquote><input class="coq-extra-goal-toggle" id="Basics-v-chkc0" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="Basics-v-chkc0"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; false = false &amp;&amp; false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkc1" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkc1"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; true = true &amp;&amp; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkc2" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkc2"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; false = false &amp;&amp; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkc3" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkc3"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; true = true &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkc4" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkc4"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false &amp;&amp; false = false &amp;&amp; false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab22"></a><h4 class="section">Exercise: 2 stars, standard (andb_true_elim2)</h4>
<div class="paragraph"> </div>

    Prove the following claim, marking cases (and subcases) with
    bullets when you use <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkc5" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkc5"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">andb_true_elim2</span> : <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> : bool,
  andb b c = true -&gt; c = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> : bool, b &amp;&amp; c = true -&gt; c = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkc6" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkc6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> : bool, b &amp;&amp; c = true -&gt; c = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab23"></a><h4 class="section">Exercise: 1 star, standard (zero_nbeq_plus_1)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkc7" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkc7"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">zero_nbeq_plus_1</span> : <span class="kr">forall</span> <span class="nv">n</span> : nat,
  <span class="mi">0</span> =? (n + <span class="mi">1</span>) = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, (<span class="mi">0</span> =? n + <span class="mi">1</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkc8" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkc8"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, (<span class="mi">0</span> =? n + <span class="mi">1</span>) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab24"></a><h2 class="section">More on Notation (Optional)</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
(In general, sections marked Optional are not needed to follow the
    rest of the book, except possibly other Optional sections.  On a
    first reading, you might want to skim these sections so that you
    know what's there for future reference.)

<div class="paragraph"> </div>

    Recall the notation definitions for infix plus and times: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x + y&quot;</span> := (plus x y)
                       (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">left associativity</span>)
                       : nat_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x * y&quot;</span> := (mult x y)
                       (<span class="kn">at level</span> <span class="mi">40</span>, <span class="kn">left associativity</span>)
                       : nat_scope.</span></span></span></pre><div class="doc">
For each notation symbol in Coq, we can specify its <i>precedence
    level</i> and its <i>associativity</i>.  The precedence level <span class="inlinecode"><span class="id" title="var">n</span></span> is
    specified by writing <span class="inlinecode"><span class="id" title="tactic">at</span></span> <span class="inlinecode"><span class="id" title="keyword">level</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>; this helps Coq parse compound
    expressions.  The associativity setting helps to disambiguate
    expressions containing multiple occurrences of the same
    symbol. For example, the parameters specified above for <span class="inlinecode">+</span> and
    <span class="inlinecode">√ó</span> say that the expression <span class="inlinecode">1+2*3*4</span> is shorthand for
    <span class="inlinecode">(1+((2*3)*4))</span>. Coq uses precedence levels from 0 to 100, and
    <i>left</i>, <i>right</i>, or <i>no</i> associativity.  We will see more examples
    of this later, e.g., in the <span class="inlinecode"><span class="id" title="var">Lists</span></span>
    chapter.

<div class="paragraph"> </div>

    Each notation symbol is also associated with a <i>notation scope</i>.
    Coq tries to guess what scope is meant from context, so when it
    sees <span class="inlinecode"><span class="id" title="var">S</span>(<span class="id" title="var">O</span>√ó<span class="id" title="var">O</span>)</span> it guesses <span class="inlinecode"><span class="id" title="var">nat_scope</span></span>, but when it sees the
    cartesian product (tuple) type <span class="inlinecode"><span class="id" title="var">bool</span>√ó<span class="id" title="var">bool</span></span> (which we'll see in
    later chapters) it guesses <span class="inlinecode"><span class="id" title="var">type_scope</span></span>.  Occasionally, it is
    necessary to help it out with percent-notation by writing
    <span class="inlinecode">(<span class="id" title="var">x</span>√ó<span class="id" title="var">y</span>)%<span class="id" title="var">nat</span></span>, and sometimes in what Coq prints it will use <span class="inlinecode">%<span class="id" title="var">nat</span></span>
    to indicate what scope a notation is in.

<div class="paragraph"> </div>

    Notation scopes also apply to numeral notation (<span class="inlinecode">3</span>, <span class="inlinecode">4</span>, <span class="inlinecode">5</span>,
    etc.), so you may sometimes see <span class="inlinecode">0%<span class="id" title="var">nat</span></span>, which means <span class="inlinecode"><span class="id" title="var">O</span></span> (the
    natural number <span class="inlinecode">0</span> that we're using in this chapter), or <span class="inlinecode">0%<span class="id" title="var">Z</span></span>,
    which means the Integer zero (which comes from a different part of
    the standard library).

<div class="paragraph"> </div>

    Pro tip: Coq's notation mechanism is not especially powerful.
    Don't expect too much from it! 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab25"></a><h2 class="section">Fixpoints and Structural Recursion (Optional)</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Here is a copy of the definition of addition: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">plus&#39;</span> (<span class="nv">n</span> : nat) (<span class="nv">m</span> : nat) : nat :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | O =&gt; m
  | S n&#39; =&gt; S (plus&#39; n&#39; m)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
When Coq checks this definition, it notes that <span class="inlinecode"><span class="id" title="var">plus'</span></span> is
    "decreasing on 1st argument."  What this means is that we are
    performing a <i>structural recursion</i> over the argument <span class="inlinecode"><span class="id" title="var">n</span></span> -- i.e.,
    that we make recursive calls only on strictly smaller values of
    <span class="inlinecode"><span class="id" title="var">n</span></span>.  This implies that all calls to <span class="inlinecode"><span class="id" title="var">plus'</span></span> will eventually
    terminate.  Coq demands that some argument of <i>every</i> <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>
    definition is "decreasing."

<div class="paragraph"> </div>

    This requirement is a fundamental feature of Coq's design: In
    particular, it guarantees that every function that can be defined
    in Coq will terminate on all inputs.  However, because Coq's
    "decreasing analysis" is not very sophisticated, it is sometimes
    necessary to write functions in slightly unnatural ways. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab26"></a><h4 class="section">Exercise: 2 stars, standard, optional (decreasing)</h4>
<div class="paragraph"> </div>

    To get a concrete sense of this, find a way to write a sensible
    <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> definition (of a simple function on numbers, say) that
    <i>does</i> terminate on all inputs, but that Coq will reject because
    of this restriction.  (If you choose to turn in this optional
    exercise as part of a homework assignment, make sure you comment
    out your solution so that it doesn't cause Coq to reject the whole
    file!) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE </span>

<span class="c">    [] *)</span>

<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab27"></a><h1 class="section">More Exercises</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Each SF chapter comes with a tester file (e.g.  <span class="inlinecode"><span class="id" title="var">BasicsTest.v</span></span>),
    containing scripts that check most of the exercises. You can run
    <span class="inlinecode"><span class="id" title="var">make</span></span> <span class="inlinecode"><span class="id" title="var">BasicsTest.vo</span></span> in a terminal and check its output to make
    sure you didn't miss anything. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab28"></a><h4 class="section">Exercise: 1 star, standard (indentity_fn_applied_twice)</h4>
<div class="paragraph"> </div>

    Use the tactics you have learned so far to prove the following
    theorem about boolean functions. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkc9" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkc9"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">identity_fn_applied_twice</span> :
  <span class="kr">forall</span> (<span class="nv">f</span> : bool -&gt; bool),
  (<span class="kr">forall</span> (<span class="nv">x</span> : bool), f x = x) -&gt;
  <span class="kr">forall</span> (<span class="nv">b</span> : bool), f (f b) = b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">f</span> : bool -&gt; bool,
(<span class="kr">forall</span> <span class="nv">x</span> : bool, f x = x) -&gt;
<span class="kr">forall</span> <span class="nv">b</span> : bool, f (f b) = b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkca" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkca"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">f</span> : bool -&gt; bool,
(<span class="kr">forall</span> <span class="nv">x</span> : bool, f x = x) -&gt;
<span class="kr">forall</span> <span class="nv">b</span> : bool, f (f b) = b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab29"></a><h4 class="section">Exercise: 1 star, standard (negation_fn_applied_twice)</h4>
<div class="paragraph"> </div>

    Now state and prove a theorem <span class="inlinecode"><span class="id" title="var">negation_fn_applied_twice</span></span> similar
    to the previous one but where the second hypothesis says that the
    function <span class="inlinecode"><span class="id" title="var">f</span></span> has the property that <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE *)</span>
<span class="c">(* The [Import] statement on the next line tells Coq to use the</span>
<span class="c">   standard library String module.  We&#39;ll use strings more in later</span>
<span class="c">   chapters, but for the moment we just need syntax for literal</span>
<span class="c">   strings for the grader comments. *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Export</span> String.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
<span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_negation_fn_applied_twice</span> : option (nat*string) := None.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab30"></a><h4 class="section">Exercise: 3 stars, standard, optional (andb_eq_orb)</h4>
<div class="paragraph"> </div>

    Prove the following theorem.  (Hint: This one can be a bit tricky,
    depending on how you approach it.  You will probably need both
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> and <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>, but destructing everything in sight is
    not the best way.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkcb" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkcb"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">andb_eq_orb</span> :
  <span class="kr">forall</span> (<span class="nv">b</span> <span class="nv">c</span> : bool),
  (andb b c = orb b c) -&gt;
  b = c.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> : bool, b &amp;&amp; c = b || c -&gt; b = c</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkcc" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkcc"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> : bool, b &amp;&amp; c = b || c -&gt; b = c</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab31"></a><h4 class="section">Exercise: 3 stars, standard (binary)</h4>
<div class="paragraph"> </div>

    We can generalize our unary representation of natural numbers to
    the more efficient binary representation by treating a binary
    number as a sequence of constructors <span class="inlinecode"><span class="id" title="var">A</span></span> and <span class="inlinecode"><span class="id" title="var">B</span></span> (representing 0s
    and 1s), terminated by a <span class="inlinecode"><span class="id" title="var">Z</span></span>. For comparison, in the unary
    representation, a number is a sequence of <span class="inlinecode"><span class="id" title="var">S</span></span>s terminated by an
    <span class="inlinecode"><span class="id" title="var">O</span></span>.

<div class="paragraph"> </div>

    For example:

<div class="paragraph"> </div>

        decimal            binary                           unary
           0                   Z                              O
           1                 B Z                            S O
           2              A (B Z)                        S (S O)
           3              B (B Z)                     S (S (S O))
           4           A (A (B Z))                 S (S (S (S O)))
           5           B (A (B Z))              S (S (S (S (S O))))
           6           A (B (B Z))           S (S (S (S (S (S O)))))
           7           B (B (B Z))        S (S (S (S (S (S (S O))))))
           8        A (A (A (B Z)))    S (S (S (S (S (S (S (S O)))))))

<div class="paragraph"> </div>

    Note that the low-order bit is on the left and the high-order bit
    is on the right -- the opposite of the way binary numbers are
    usually written.  This choice makes them easier to manipulate. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">bin</span> : <span class="kt">Type</span> :=
  | Z
  | A (n : bin)
  | B (n : bin).</span></span></span></pre><div class="doc">
(a) Complete the definitions below of an increment function <span class="inlinecode"><span class="id" title="var">incr</span></span>
        for binary numbers, and a function <span class="inlinecode"><span class="id" title="var">bin_to_nat</span></span> to convert
        binary numbers to unary numbers. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkcd" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkcd"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">incr</span> (<span class="nv">m</span>:bin) : bin
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">incr</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bin -&gt; bin</span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bin</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">bin</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Basics-v-chkce" style="display: none" type="checkbox"><label class="coq-input" for="Basics-v-chkce"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">bin_to_nat</span> (<span class="nv">m</span>:bin) : nat
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">bin_to_nat</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bin -&gt; nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bin</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">nat</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
   (b) Write five unit tests <span class="inlinecode"><span class="id" title="var">test_bin_incr1</span></span>, <span class="inlinecode"><span class="id" title="var">test_bin_incr2</span></span>, etc.
        for your increment and binary-to-unary functions.  (A "unit
        test" in Coq is a specific <span class="inlinecode"><span class="id" title="keyword">Example</span></span> that can be proved with
        just <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>, as we've done for several of our
        definitions.)  Notice that incrementing a binary number and
        then converting it to unary should yield the same result as
        first converting it to unary and then incrementing. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE *)</span>

<span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_binary</span> : option (nat*string) := None.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* Wed Jan 9 12:02:44 EST 2019 *)</span></span></span></pre></article></body></html>