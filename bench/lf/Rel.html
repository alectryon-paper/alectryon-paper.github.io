<!DOCTYPE html>
<html><head><title>Rel.v</title><meta charset="utf-8"><meta content="Alectryon v0.2" name="generator"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet"><link href="https://unpkg.com/firacode/distr/fira_code.css" rel="stylesheet"><link href="alectryon.css" rel="stylesheet"><script src="alectryon.js"></script><style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-standalone alectryon-centered alectryon-coqdoc"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><div class="doc">
<a name="lab1"></a><h1 class="section">Rel: Properties of Relations</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
This short (and optional) chapter develops some basic definitions
    and a few theorems about binary relations in Coq.  The key
    definitions are repeated where they are actually used (in the
    <span class="inlinecode"><span class="id" title="var">Smallstep</span></span> chapter of <i>Programming Language Foundations</i>),
    so readers who are already comfortable with these ideas can safely
    skim or skip this chapter.  However, relations are also a good
    source of exercises for developing facility with Coq's basic
    reasoning facilities, so it may be useful to look at this material
    just after the <span class="inlinecode"><span class="id" title="var">IndProp</span></span> chapter. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Set Warnings</span> <span class="s2">&quot;-notation-overridden,-parsing&quot;</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> LF <span class="kn">Require Export</span> IndProp.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab2"></a><h1 class="section">Relations</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
A binary <i>relation</i> on a set <span class="inlinecode"><span class="id" title="var">X</span></span> is a family of propositions
    parameterized by two elements of <span class="inlinecode"><span class="id" title="var">X</span></span> -- i.e., a proposition about
    pairs of elements of <span class="inlinecode"><span class="id" title="var">X</span></span>.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">relation</span> (<span class="nv">X</span>: <span class="kt">Type</span>) := X -&gt; X -&gt; <span class="kt">Prop</span>.</span></span></span></pre><div class="doc">
Confusingly, the Coq standard library hijacks the generic term
    "relation" for this specific instance of the idea. To maintain
    consistency with the library, we will do the same.  So, henceforth
    the Coq identifier <span class="inlinecode"><span class="id" title="var">relation</span></span> will always refer to a binary
    relation between some set and itself, whereas the English word
    "relation" can refer either to the specific Coq concept or the
    more general concept of a relation between any number of possibly
    different sets.  The context of the discussion should always make
    clear which is meant. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
An example relation on <span class="inlinecode"><span class="id" title="var">nat</span></span> is <span class="inlinecode"><span class="id" title="var">le</span></span>, the less-than-or-equal-to
    relation, which we usually write <span class="inlinecode"><span class="id" title="var">n1</span></span> <span class="inlinecode">‚â§</span> <span class="inlinecode"><span class="id" title="var">n2</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Rel-v-chk0" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk0"><span class="highlight"><span class="kn">Print</span> le.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">le</span> (<span class="nv">n</span> : nat) : nat -&gt; <span class="kt">Prop</span> :=
    le_n : n &lt;= n
  | le_S : <span class="kr">forall</span> <span class="nv">m</span> : nat, n &lt;= m -&gt; n &lt;= S m

For le: Argument scopes are [nat_scope nat_scope]
For le_n: Argument scope <span class="kr">is</span> [nat_scope]
For le_S: Argument scopes are [nat_scope nat_scope _]</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Rel-v-chk1" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk1"><span class="highlight"><span class="kn">Check</span> le : nat -&gt; nat -&gt; <span class="kt">Prop</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">le : nat -&gt; nat -&gt; <span class="kt">Prop</span>
     : nat -&gt; nat -&gt; <span class="kt">Prop</span></span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Rel-v-chk2" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk2"><span class="highlight"><span class="kn">Check</span> le : relation nat.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">le : relation nat
     : relation nat</span></blockquote></div></div></small></span></pre><div class="doc">
(Why did we write it this way instead of starting with <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>
<span class="inlinecode"><span class="id" title="var">le</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">relation</span></span> <span class="inlinecode"><span class="id" title="var">nat</span>...</span>?  Because we wanted to put the first <span class="inlinecode"><span class="id" title="var">nat</span></span>
    to the left of the <span class="inlinecode">:</span>, which makes Coq generate a somewhat nicer
    induction principle for reasoning about <span class="inlinecode">‚â§</span>.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab3"></a><h1 class="section">Basic Properties</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
As anyone knows who has taken an undergraduate discrete math
    course, there is a lot to be said about relations in general,
    including ways of classifying relations (as reflexive, transitive,
    etc.), theorems that can be proved generically about certain sorts
    of relations, constructions that build one relation from another,
    etc.  For example... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab4"></a><h3 class="section">Partial Functions</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
A relation <span class="inlinecode"><span class="id" title="var">R</span></span> on a set <span class="inlinecode"><span class="id" title="var">X</span></span> is a <i>partial function</i> if, for every
    <span class="inlinecode"><span class="id" title="var">x</span></span>, there is at most one <span class="inlinecode"><span class="id" title="var">y</span></span> such that <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> -- i.e., <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y1</span></span>
    and <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y2</span></span> together imply <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y2</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">partial_function</span> {<span class="nv">X</span>: <span class="kt">Type</span>} (<span class="nv">R</span>: relation X) :=
  <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y1</span> <span class="nv">y2</span> : X, R x y1 -&gt; R x y2 -&gt; y1 = y2.</span></span></span></pre><div class="doc">
For example, the <span class="inlinecode"><span class="id" title="var">next_nat</span></span> relation defined earlier is a partial
    function. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Rel-v-chk3" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk3"><span class="highlight"><span class="kn">Print</span> next_nat.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">next_nat</span> : nat -&gt; nat -&gt; <span class="kt">Prop</span> :=
    nn : <span class="kr">forall</span> <span class="nv">n</span> : nat, next_nat n (S n)

For next_nat: Argument scopes are [nat_scope
                nat_scope]
For nn: Argument scope <span class="kr">is</span> [nat_scope]</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Rel-v-chk4" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk4"><span class="highlight"><span class="kn">Check</span> next_nat : relation nat.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">next_nat : relation nat
     : relation nat</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk5" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk5"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">next_nat_partial_function</span> :
   partial_function next_nat.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">partial_function next_nat</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk6" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">partial_function next_nat</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk7" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk7"><span class="highlight"><span class="nb">unfold</span> partial_function.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y1</span> <span class="nv">y2</span> : nat,
next_nat x y1 -&gt; next_nat x y2 -&gt; y1 = y2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk8" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk8"><span class="highlight"><span class="nb">intros</span> x y1 y2 H1 H2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y1, y2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">next_nat x y1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">next_nat x y2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">y1 = y2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk9" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk9"><span class="highlight"><span class="nb">inversion</span> H1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y1, y2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">next_nat x y1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">next_nat x y2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S x = y1</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">S x = y2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chka" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chka"><span class="highlight"><span class="nb">inversion</span> H2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y1, y2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">next_nat x y1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">next_nat x y2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S x = y1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n0 = x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S x = y2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">S x = S x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
However, the <span class="inlinecode">‚â§</span> relation on numbers is not a partial
    function.  (Assume, for a contradiction, that <span class="inlinecode">‚â§</span> is a partial
    function.  But then, since <span class="inlinecode">0</span> <span class="inlinecode">‚â§</span> <span class="inlinecode">0</span> and <span class="inlinecode">0</span> <span class="inlinecode">‚â§</span> <span class="inlinecode">1</span>, it follows that
    <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">1</span>.  This is nonsense, so our assumption was
    contradictory.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chkb" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chkb"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">le_not_a_partial_function</span> :
  ~ (partial_function le).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ partial_function le</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chkc" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chkc"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ partial_function le</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chkd" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chkd"><span class="highlight"><span class="nb">unfold</span> not.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">partial_function le -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chke" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chke"><span class="highlight"><span class="nb">unfold</span> partial_function.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y1</span> <span class="nv">y2</span> : nat, x &lt;= y1 -&gt; x &lt;= y2 -&gt; y1 = y2) -&gt;
<span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chkf" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chkf"><span class="highlight"><span class="nb">intros</span> Hc.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">Hc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y1</span> <span class="nv">y2</span> : nat,
x &lt;= y1 -&gt; x &lt;= y2 -&gt; y1 = y2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk10" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk10"><span class="highlight"><span class="nb">assert</span> (<span class="mi">0</span> = <span class="mi">1</span>) <span class="kr">as</span> Nonsense.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">Hc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y1</span> <span class="nv">y2</span> : nat,
x &lt;= y1 -&gt; x &lt;= y2 -&gt; y1 = y2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">1</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Rel-v-chk11" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">Hc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y1</span> <span class="nv">y2</span> : nat,
x &lt;= y1 -&gt; x &lt;= y2 -&gt; y1 = y2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Nonsense</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = <span class="mi">1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk11"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk12" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk12"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">Hc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y1</span> <span class="nv">y2</span> : nat,
x &lt;= y1 -&gt; x &lt;= y2 -&gt; y1 = y2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk13" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk13"><span class="highlight"><span class="nb">apply</span> Hc <span class="kr">with</span> (x := <span class="mi">0</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">Hc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y1</span> <span class="nv">y2</span> : nat,
x &lt;= y1 -&gt; x &lt;= y2 -&gt; y1 = y2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt;= <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Rel-v-chk14" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">Hc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y1</span> <span class="nv">y2</span> : nat,
x &lt;= y1 -&gt; x &lt;= y2 -&gt; y1 = y2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk14"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt;= <span class="mi">1</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk15" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk15"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">Hc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y1</span> <span class="nv">y2</span> : nat,
x &lt;= y1 -&gt; x &lt;= y2 -&gt; y1 = y2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt;= <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> le_n.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk16" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk16"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">Hc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y1</span> <span class="nv">y2</span> : nat,
x &lt;= y1 -&gt; x &lt;= y2 -&gt; y1 = y2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt;= <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk17" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk17"><span class="highlight"><span class="nb">apply</span> le_S.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">Hc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y1</span> <span class="nv">y2</span> : nat,
x &lt;= y1 -&gt; x &lt;= y2 -&gt; y1 = y2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt;= <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> le_n.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk18" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk18"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">Hc</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y1</span> <span class="nv">y2</span> : nat,
x &lt;= y1 -&gt; x &lt;= y2 -&gt; y1 = y2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Nonsense</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = <span class="mi">1</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span> Nonsense.</span></span><span class="coq-wsp">   </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab5"></a><h4 class="section">Exercise: 2 stars, standard, optional (total_relation_not_partial)</h4>
<div class="paragraph"> </div>

    Show that the <span class="inlinecode"><span class="id" title="var">total_relation</span></span> defined in (an exercise in)
    <span class="inlinecode"><span class="id" title="var">IndProp</span></span> is not a partial function. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE </span>

<span class="c">    [] *)</span></span></span></pre><div class="doc">
<a name="lab6"></a><h4 class="section">Exercise: 2 stars, standard, optional (empty_relation_partial)</h4>
<div class="paragraph"> </div>

    Show that the <span class="inlinecode"><span class="id" title="var">empty_relation</span></span> defined in (an exercise in)
    <span class="inlinecode"><span class="id" title="var">IndProp</span></span> is a partial function. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* FILL IN HERE </span>

<span class="c">    [] *)</span>

<span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab7"></a><h3 class="section">Reflexive Relations</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
A <i>reflexive</i> relation on a set <span class="inlinecode"><span class="id" title="var">X</span></span> is one for which every element
    of <span class="inlinecode"><span class="id" title="var">X</span></span> is related to itself. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">reflexive</span> {<span class="nv">X</span>: <span class="kt">Type</span>} (<span class="nv">R</span>: relation X) :=
  <span class="kr">forall</span> <span class="nv">a</span> : X, R a a.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk19" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk19"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">le_reflexive</span> :
  reflexive le.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">reflexive le</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk1a" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk1a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">reflexive le</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk1b"><span class="highlight"><span class="nb">unfold</span> reflexive.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : nat, a &lt;= a</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk1c"><span class="highlight"><span class="nb">intros</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> le_n.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
<span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab8"></a><h3 class="section">Transitive Relations</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
A relation <span class="inlinecode"><span class="id" title="var">R</span></span> is <i>transitive</i> if <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> holds whenever <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>
    and <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> do. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">transitive</span> {<span class="nv">X</span>: <span class="kt">Type</span>} (<span class="nv">R</span>: relation X) :=
  <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : X, (R a b) -&gt; (R b c) -&gt; (R a c).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk1d" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk1d"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">le_trans</span> :
  transitive le.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">transitive le</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk1e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">transitive le</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk1f"><span class="highlight"><span class="nb">intros</span> n m o Hnm Hmo.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, o</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m &lt;= o</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= o</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk20" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk20"><span class="highlight"><span class="nb">induction</span> Hmo.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= m</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Rel-v-chk21" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">m0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m &lt;= m0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHHmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m0</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk21"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= S m0</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk22" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk22"><span class="highlight">- <span class="c">(* le_n *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> Hnm.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk23" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk23"><span class="highlight">- <span class="c">(* le_S *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">m0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m &lt;= m0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHHmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= S m0</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk24" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk24"><span class="highlight"><span class="nb">apply</span> le_S.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">m0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m &lt;= m0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHHmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= m0</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> IHHmo.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk25" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk25"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">lt_trans</span>:
  transitive lt.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">transitive lt</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk26" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk26"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">transitive lt</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk27" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk27"><span class="highlight"><span class="nb">unfold</span> lt.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">transitive (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">m</span> : nat =&gt; S n &lt;= m)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk28" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk28"><span class="highlight"><span class="nb">unfold</span> transitive.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : nat, S a &lt;= b -&gt; S b &lt;= c -&gt; S a &lt;= c</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk29" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk29"><span class="highlight"><span class="nb">intros</span> n m o Hnm Hmo.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, o</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S m &lt;= o</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">S n &lt;= o</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk2a" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk2a"><span class="highlight"><span class="nb">apply</span> le_S <span class="kr">in</span> Hnm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, o</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= S m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S m &lt;= o</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">S n &lt;= o</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk2b" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk2b"><span class="highlight"><span class="nb">apply</span> le_trans <span class="kr">with</span> (a := (S n)) (b := (S m)) (c := o).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, o</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= S m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S m &lt;= o</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">S n &lt;= S m</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Rel-v-chk2c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, o</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= S m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S m &lt;= o</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk2c"><hr></label><div class="goal-conclusion"><span class="highlight">S m &lt;= o</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk2d" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk2d"><span class="highlight"><span class="nb">apply</span> Hnm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, o</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= S m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S m &lt;= o</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">S m &lt;= o</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> Hmo.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab9"></a><h4 class="section">Exercise: 2 stars, standard, optional (le_trans_hard_way)</h4>
<div class="paragraph"> </div>

    We can also prove <span class="inlinecode"><span class="id" title="var">lt_trans</span></span> more laboriously by induction,
    without using <span class="inlinecode"><span class="id" title="var">le_trans</span></span>.  Do this. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk2e"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">lt_trans&#39;</span> :
  transitive lt.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">transitive lt</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk2f" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk2f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">transitive lt</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* Prove this by induction on evidence that [m] is less than [o]. *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk30" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk30"><span class="highlight"><span class="nb">unfold</span> lt.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">transitive (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">m</span> : nat =&gt; S n &lt;= m)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk31" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk31"><span class="highlight"><span class="nb">unfold</span> transitive.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : nat, S a &lt;= b -&gt; S b &lt;= c -&gt; S a &lt;= c</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk32" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk32"><span class="highlight"><span class="nb">intros</span> n m o Hnm Hmo.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, o</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S m &lt;= o</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">S n &lt;= o</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk33" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk33"><span class="highlight"><span class="nb">induction</span> Hmo <span class="kr">as</span> [| m&#39; Hm&#39;o].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">S n &lt;= S m</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Rel-v-chk34" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">m'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm'o</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S m &lt;= m&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHHm'o</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk34"><hr></label><div class="goal-conclusion"><span class="highlight">S n &lt;= S m&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">    <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab10"></a><h4 class="section">Exercise: 2 stars, standard, optional (lt_trans'')</h4>
<div class="paragraph"> </div>

    Prove the same thing again by induction on <span class="inlinecode"><span class="id" title="var">o</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk35" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk35"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">lt_trans&#39;&#39;</span> :
  transitive lt.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">transitive lt</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk36" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk36"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">transitive lt</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk37" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk37"><span class="highlight"><span class="nb">unfold</span> lt.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">transitive (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">m</span> : nat =&gt; S n &lt;= m)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk38" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk38"><span class="highlight"><span class="nb">unfold</span> transitive.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : nat, S a &lt;= b -&gt; S b &lt;= c -&gt; S a &lt;= c</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk39" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk39"><span class="highlight"><span class="nb">intros</span> n m o Hnm Hmo.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, o</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S m &lt;= o</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">S n &lt;= o</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk3a" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk3a"><span class="highlight"><span class="nb">induction</span> o <span class="kr">as</span> [| o&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S m &lt;= <span class="mi">0</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">S n &lt;= <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Rel-v-chk3b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, o'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S m &lt;= S o&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHo'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S m &lt;= o&#39; -&gt; S n &lt;= o&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk3b"><hr></label><div class="goal-conclusion"><span class="highlight">S n &lt;= S o&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The transitivity of <span class="inlinecode"><span class="id" title="var">le</span></span>, in turn, can be used to prove some facts
    that will be useful later (e.g., for the proof of antisymmetry
    below)... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk3c" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk3c"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">le_Sn_le</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>, S n &lt;= m -&gt; n &lt;= m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, S n &lt;= m -&gt; n &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk3d" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk3d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, S n &lt;= m -&gt; n &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk3e" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk3e"><span class="highlight"><span class="nb">intros</span> n m H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk3f" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk3f"><span class="highlight"><span class="nb">apply</span> le_trans <span class="kr">with</span> (S n).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= S n</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Rel-v-chk40" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk40"><hr></label><div class="goal-conclusion"><span class="highlight">S n &lt;= m</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk41" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk41"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= S n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk42" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk42"><span class="highlight"><span class="nb">apply</span> le_S.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> le_n.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk43" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk43"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">S n &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab11"></a><h4 class="section">Exercise: 1 star, standard, optional (le_S_n)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk44" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk44"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">le_S_n</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>,
  (S n &lt;= S m) -&gt; (n &lt;= m).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, S n &lt;= S m -&gt; n &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk45" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk45"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, S n &lt;= S m -&gt; n &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab12"></a><h4 class="section">Exercise: 2 stars, standard, optional (le_Sn_n_inf)</h4>
<div class="paragraph"> </div>

    Provide an informal proof of the following theorem:

<div class="paragraph"> </div>

    Theorem: For every <span class="inlinecode"><span class="id" title="var">n</span></span>, <span class="inlinecode">¬¨</span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">‚â§</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>
<div class="paragraph"> </div>

    A formal proof of this is an optional exercise below, but try
    writing an informal proof without doing the formal proof first.

<div class="paragraph"> </div>

    Proof: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight">    <span class="c">(* FILL IN HERE </span>

<span class="c">    [] *)</span></span></span></pre><div class="doc">
<a name="lab13"></a><h4 class="section">Exercise: 1 star, standard, optional (le_Sn_n)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk46" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk46"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">le_Sn_n</span> : <span class="kr">forall</span> <span class="nv">n</span>,
  ~ (S n &lt;= n).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, ~ S n &lt;= n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk47" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk47"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, ~ S n &lt;= n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Reflexivity and transitivity are the main concepts we'll need for
    later chapters, but, for a bit of additional practice working with
    relations in Coq, let's look at a few other common ones... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab14"></a><h3 class="section">Symmetric and Antisymmetric Relations</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
A relation <span class="inlinecode"><span class="id" title="var">R</span></span> is <i>symmetric</i> if <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> implies <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">symmetric</span> {<span class="nv">X</span>: <span class="kt">Type</span>} (<span class="nv">R</span>: relation X) :=
  <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : X, (R a b) -&gt; (R b a).</span></span></span></pre><div class="doc">
<a name="lab15"></a><h4 class="section">Exercise: 2 stars, standard, optional (le_not_symmetric)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk48" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk48"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">le_not_symmetric</span> :
  ~ (symmetric le).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ symmetric le</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk49" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk49"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ symmetric le</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
A relation <span class="inlinecode"><span class="id" title="var">R</span></span> is <i>antisymmetric</i> if <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> and <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> together
    imply <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> -- that is, if the only "cycles" in <span class="inlinecode"><span class="id" title="var">R</span></span> are trivial
    ones. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">antisymmetric</span> {<span class="nv">X</span>: <span class="kt">Type</span>} (<span class="nv">R</span>: relation X) :=
  <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : X, (R a b) -&gt; (R b a) -&gt; a = b.</span></span></span></pre><div class="doc">
<a name="lab16"></a><h4 class="section">Exercise: 2 stars, standard, optional (le_antisymmetric)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk4a" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk4a"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">le_antisymmetric</span> :
  antisymmetric le.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">antisymmetric le</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk4b" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk4b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">antisymmetric le</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab17"></a><h4 class="section">Exercise: 2 stars, standard, optional (le_step)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk4c" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk4c"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">le_step</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span>,
  n &lt; m -&gt;
  m &lt;= S p -&gt;
  n &lt;= p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span> : nat, n &lt; m -&gt; m &lt;= S p -&gt; n &lt;= p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk4d" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk4d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span> : nat, n &lt; m -&gt; m &lt;= S p -&gt; n &lt;= p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab18"></a><h3 class="section">Equivalence Relations</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
A relation is an <i>equivalence</i> if it's reflexive, symmetric, and
    transitive.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivalence</span> {<span class="nv">X</span>:<span class="kt">Type</span>} (<span class="nv">R</span>: relation X) :=
  (reflexive R) /\ (symmetric R) /\ (transitive R).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
<span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab19"></a><h3 class="section">Partial Orders and Preorders</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
A relation is a <i>partial order</i> when it's reflexive,
    <i>anti</i>-symmetric, and transitive.  In the Coq standard library
    it's called just "order" for short. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">order</span> {<span class="nv">X</span>:<span class="kt">Type</span>} (<span class="nv">R</span>: relation X) :=
  (reflexive R) /\ (antisymmetric R) /\ (transitive R).</span></span></span></pre><div class="doc">
A preorder is almost like a partial order, but doesn't have to be
    antisymmetric. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">preorder</span> {<span class="nv">X</span>:<span class="kt">Type</span>} (<span class="nv">R</span>: relation X) :=
  (reflexive R) /\ (transitive R).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk4e" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk4e"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">le_order</span> :
  order le.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">order le</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk4f" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk4f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">order le</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk50" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk50"><span class="highlight"><span class="nb">unfold</span> order.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">reflexive le /\ antisymmetric le /\ transitive le</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk51" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk51"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">reflexive le</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Rel-v-chk52" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk52"><hr></label><div class="goal-conclusion"><span class="highlight">antisymmetric le /\ transitive le</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk53" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk53"><span class="highlight">- <span class="c">(* refl *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">reflexive le</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> le_reflexive.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk54" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk54"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">antisymmetric le /\ transitive le</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk55" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk55"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">antisymmetric le</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Rel-v-chk56" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk56"><hr></label><div class="goal-conclusion"><span class="highlight">transitive le</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk57" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk57"><span class="highlight">+ <span class="c">(* antisym *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">antisymmetric le</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> le_antisymmetric.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk58" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk58"><span class="highlight">+ <span class="c">(* transitive. *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">transitive le</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> le_trans.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab20"></a><h1 class="section">Reflexive, Transitive Closure</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <i>reflexive, transitive closure</i> of a relation <span class="inlinecode"><span class="id" title="var">R</span></span> is the
    smallest relation that contains <span class="inlinecode"><span class="id" title="var">R</span></span> and that is both reflexive and
    transitive.  Formally, it is defined like this in the Relations
    module of the Coq standard library: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">clos_refl_trans</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">R</span>: relation A) : relation A :=
    | rt_step x y (H : R x y) : clos_refl_trans R x y
    | rt_refl x : clos_refl_trans R x x
    | rt_trans x y z
          (Hxy : clos_refl_trans R x y)
          (Hyz : clos_refl_trans R y z) :
          clos_refl_trans R x z.</span></span></span></pre><div class="doc">
For example, the reflexive and transitive closure of the
    <span class="inlinecode"><span class="id" title="var">next_nat</span></span> relation coincides with the <span class="inlinecode"><span class="id" title="var">le</span></span> relation. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk59" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk59"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">next_nat_closure_is_le</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>,
  (n &lt;= m) &lt;-&gt; ((clos_refl_trans next_nat) n m).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
n &lt;= m &lt;-&gt; clos_refl_trans next_nat n m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk5a" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk5a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat,
n &lt;= m &lt;-&gt; clos_refl_trans next_nat n m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk5b" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk5b"><span class="highlight"><span class="nb">intros</span> n m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= m &lt;-&gt; clos_refl_trans next_nat n m</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk5c" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk5c"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= m -&gt; clos_refl_trans next_nat n m</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Rel-v-chk5d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk5d"><hr></label><div class="goal-conclusion"><span class="highlight">clos_refl_trans next_nat n m -&gt; n &lt;= m</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk5e" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk5e"><span class="highlight">- <span class="c">(* -&gt; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= m -&gt; clos_refl_trans next_nat n m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk5f" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk5f"><span class="highlight"><span class="nb">intro</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">clos_refl_trans next_nat n m</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk60" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk60"><span class="highlight"><span class="nb">induction</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">clos_refl_trans next_nat n n</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Rel-v-chk61" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat n m</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk61"><hr></label><div class="goal-conclusion"><span class="highlight">clos_refl_trans next_nat n (S m)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk62" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk62"><span class="highlight">+ <span class="c">(* le_n *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">clos_refl_trans next_nat n n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> rt_refl.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk63" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk63"><span class="highlight">+ <span class="c">(* le_S *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat n m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">clos_refl_trans next_nat n (S m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk64" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk64"><span class="highlight"><span class="nb">apply</span> rt_trans <span class="kr">with</span> m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat n m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">clos_refl_trans next_nat n m</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Rel-v-chk65" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat n m</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk65"><hr></label><div class="goal-conclusion"><span class="highlight">clos_refl_trans next_nat m (S m)</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk66" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk66"><span class="highlight"><span class="nb">apply</span> IHle.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat n m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">clos_refl_trans next_nat m (S m)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk67" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk67"><span class="highlight"><span class="nb">apply</span> rt_step.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat n m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">next_nat m (S m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> nn.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk68" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk68"><span class="highlight">- <span class="c">(* &lt;- *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">clos_refl_trans next_nat n m -&gt; n &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk69" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk69"><span class="highlight"><span class="nb">intro</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat n m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk6a" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk6a"><span class="highlight"><span class="nb">induction</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">next_nat x y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt;= y</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Rel-v-chk6b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk6b"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt;= x</span></div></blockquote><input class="coq-extra-goal-toggle" id="Rel-v-chk6c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat x y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat y z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHclos_refl_trans1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;= y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHclos_refl_trans2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y &lt;= z</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk6c"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt;= z</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk6d" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk6d"><span class="highlight">+ <span class="c">(* rt_step *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">next_nat x y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt;= y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk6e" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk6e"><span class="highlight"><span class="nb">inversion</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">next_nat x y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S x = y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt;= S x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk6f" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk6f"><span class="highlight"><span class="nb">apply</span> le_S.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">next_nat x y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S x = y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt;= x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> le_n.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk70" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk70"><span class="highlight">+ <span class="c">(* rt_refl *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt;= x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> le_n.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk71" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk71"><span class="highlight">+ <span class="c">(* rt_trans *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat x y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat y z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHclos_refl_trans1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;= y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHclos_refl_trans2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y &lt;= z</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt;= z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk72" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk72"><span class="highlight"><span class="nb">apply</span> le_trans <span class="kr">with</span> y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat x y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat y z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHclos_refl_trans1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;= y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHclos_refl_trans2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y &lt;= z</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt;= y</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Rel-v-chk73" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat x y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat y z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHclos_refl_trans1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;= y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHclos_refl_trans2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y &lt;= z</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk73"><hr></label><div class="goal-conclusion"><span class="highlight">y &lt;= z</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk74" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk74"><span class="highlight"><span class="nb">apply</span> IHclos_refl_trans1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat x y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">clos_refl_trans next_nat y z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHclos_refl_trans1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;= y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHclos_refl_trans2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y &lt;= z</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">y &lt;= z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> IHclos_refl_trans2.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The above definition of reflexive, transitive closure is natural:
    it says, explicitly, that the reflexive and transitive closure of
    <span class="inlinecode"><span class="id" title="var">R</span></span> is the least relation that includes <span class="inlinecode"><span class="id" title="var">R</span></span> and that is closed
    under rules of reflexivity and transitivity.  But it turns out
    that this definition is not very convenient for doing proofs,
    since the "nondeterminism" of the <span class="inlinecode"><span class="id" title="var">rt_trans</span></span> rule can sometimes
    lead to tricky inductions.  Here is a more useful definition: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">clos_refl_trans_1n</span> {<span class="nv">A</span> : <span class="kt">Type</span>}
                             (<span class="nv">R</span> : relation A) (<span class="nv">x</span> : A)
                             : A -&gt; <span class="kt">Prop</span> :=
  | rt1n_refl : clos_refl_trans_1n R x x
  | rt1n_trans (y z : A)
      (Hxy : R x y) (Hrest : clos_refl_trans_1n R y z) :
      clos_refl_trans_1n R x z.</span></span></span></pre><div class="doc">
Our new definition of reflexive, transitive closure "bundles"
    the <span class="inlinecode"><span class="id" title="var">rt_step</span></span> and <span class="inlinecode"><span class="id" title="var">rt_trans</span></span> rules into the single rule step.
    The left-hand premise of this step is a single use of <span class="inlinecode"><span class="id" title="var">R</span></span>,
    leading to a much simpler induction principle.

<div class="paragraph"> </div>

    Before we go on, we should check that the two definitions do
    indeed define the same relation...

<div class="paragraph"> </div>

    First, we prove two lemmas showing that <span class="inlinecode"><span class="id" title="var">clos_refl_trans_1n</span></span> mimics
    the behavior of the two "missing" <span class="inlinecode"><span class="id" title="var">clos_refl_trans</span></span>
    constructors.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk75" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk75"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">rsc_R</span> : <span class="kr">forall</span> (<span class="nv">X</span>:<span class="kt">Type</span>) (<span class="nv">R</span>:relation X) (<span class="nv">x</span> <span class="nv">y</span> : X),
       R x y -&gt; clos_refl_trans_1n R x y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : relation X) (<span class="nv">x</span> <span class="nv">y</span> : X),
R x y -&gt; clos_refl_trans_1n R x y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk76" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk76"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : relation X) (<span class="nv">x</span> <span class="nv">y</span> : X),
R x y -&gt; clos_refl_trans_1n R x y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk77" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk77"><span class="highlight"><span class="nb">intros</span> X R x y H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">relation X</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">X</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R x y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">clos_refl_trans_1n R x y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk78" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk78"><span class="highlight"><span class="nb">apply</span> rt1n_trans <span class="kr">with</span> y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">relation X</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">X</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R x y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">R x y</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Rel-v-chk79" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">relation X</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">X</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R x y</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Rel-v-chk79"><hr></label><div class="goal-conclusion"><span class="highlight">clos_refl_trans_1n R y y</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk7a" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk7a"><span class="highlight"><span class="nb">apply</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">relation X</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">X</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R x y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">clos_refl_trans_1n R y y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> rt1n_refl.</span></span><span class="coq-wsp">   </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab21"></a><h4 class="section">Exercise: 2 stars, standard, optional (rsc_trans)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk7b" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk7b"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">rsc_trans</span> :
  <span class="kr">forall</span> (<span class="nv">X</span>:<span class="kt">Type</span>) (<span class="nv">R</span>: relation X) (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : X),
      clos_refl_trans_1n R x y  -&gt;
      clos_refl_trans_1n R y z -&gt;
      clos_refl_trans_1n R x z.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : relation X) (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : X),
clos_refl_trans_1n R x y -&gt;
clos_refl_trans_1n R y z -&gt; clos_refl_trans_1n R x z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk7c" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk7c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : relation X) (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : X),
clos_refl_trans_1n R x y -&gt;
clos_refl_trans_1n R y z -&gt; clos_refl_trans_1n R x z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Then we use these facts to prove that the two definitions of
    reflexive, transitive closure do indeed define the same
    relation. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab22"></a><h4 class="section">Exercise: 3 stars, standard, optional (rtc_rsc_coincide)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk7d" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk7d"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">rtc_rsc_coincide</span> :
         <span class="kr">forall</span> (<span class="nv">X</span>:<span class="kt">Type</span>) (<span class="nv">R</span>: relation X) (<span class="nv">x</span> <span class="nv">y</span> : X),
  clos_refl_trans R x y &lt;-&gt; clos_refl_trans_1n R x y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : relation X) (<span class="nv">x</span> <span class="nv">y</span> : X),
clos_refl_trans R x y &lt;-&gt; clos_refl_trans_1n R x y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Rel-v-chk7e" style="display: none" type="checkbox"><label class="coq-input" for="Rel-v-chk7e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : relation X) (<span class="nv">x</span> <span class="nv">y</span> : X),
clos_refl_trans R x y &lt;-&gt; clos_refl_trans_1n R x y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="c">(* Wed Jan 9 12:02:46 EST 2019 *)</span></span></span></pre></article></body></html>