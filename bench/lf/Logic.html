<!DOCTYPE html>
<html><head><title>Logic.v</title><meta charset="utf-8"><meta content="Alectryon v0.2" name="generator"><link href="alectryon.css" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script><style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-standalone alectryon-centered alectryon-coqdoc"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><div class="doc">
<a name="lab1"></a><h1 class="section">Logic: Logic in Coq</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Set Warnings</span> <span class="s2">&quot;-notation-overridden,-parsing&quot;</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> LF <span class="kn">Require Export</span> Tactics.</span></span></span></pre><div class="doc">
In previous chapters, we have seen many examples of factual
    claims (<i>propositions</i>) and ways of presenting evidence of their
    truth (<i>proofs</i>).  In particular, we have worked extensively with
    <i>equality propositions</i> of the form <span class="inlinecode"><span class="id" title="var">e1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">e2</span></span>, with
    implications (<span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">Q</span></span>), and with quantified propositions (<span class="inlinecode"><span class="id" title="keyword">‚àÄ</span></span>
<span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span>).  In this chapter, we will see how Coq can be used to carry
    out other familiar forms of logical reasoning.

<div class="paragraph"> </div>

    Before diving into details, let's talk a bit about the status of
    mathematical statements in Coq.  Recall that Coq is a <i>typed</i>
    language, which means that every sensible expression in its world
    has an associated type.  Logical claims are no exception: any
    statement we might try to prove in Coq has a type, namely <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>,
    the type of <i>propositions</i>.  We can see this with the <span class="inlinecode"><span class="id" title="keyword">Check</span></span>
    command: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Logic-v-chk0" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk0"><span class="highlight"><span class="kn">Check</span> <span class="mi">3</span> = <span class="mi">3</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight"><span class="mi">3</span> = <span class="mi">3</span>
     : <span class="kt">Prop</span></span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Logic-v-chk1" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1"><span class="highlight"><span class="kn">Check</span> <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n
     : <span class="kt">Prop</span></span></blockquote></div></div></small></span></pre><div class="doc">
Note that <i>all</i> syntactically well-formed propositions have type
    <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> in Coq, regardless of whether they are true. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Simply <i>being</i> a proposition is one thing; being <i>provable</i> is
    something else! 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Logic-v-chk2" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk2"><span class="highlight"><span class="kn">Check</span> <span class="mi">2</span> = <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight"><span class="mi">2</span> = <span class="mi">2</span>
     : <span class="kt">Prop</span></span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Logic-v-chk3" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk3"><span class="highlight"><span class="kn">Check</span> <span class="kr">forall</span> <span class="nv">n</span> : nat, n = <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, n = <span class="mi">2</span>
     : <span class="kt">Prop</span></span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Logic-v-chk4" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk4"><span class="highlight"><span class="kn">Check</span> <span class="mi">3</span> = <span class="mi">4</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight"><span class="mi">3</span> = <span class="mi">4</span>
     : <span class="kt">Prop</span></span></blockquote></div></div></small></span></pre><div class="doc">
Indeed, propositions don't just have types: they are
    <i>first-class objects</i> that can be manipulated in the same ways as
    the other entities in Coq's world. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
So far, we've seen one primary place that propositions can appear:
    in <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> (and <span class="inlinecode"><span class="id" title="keyword">Lemma</span></span> and <span class="inlinecode"><span class="id" title="keyword">Example</span></span>) declarations. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk5" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk5"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">plus_2_2_is_4</span> :
  <span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">4</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk6" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
But propositions can be used in many other ways.  For example, we
    can give a name to a proposition using a <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>, just as we
    have given names to expressions of other sorts. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">plus_fact</span> : <span class="kt">Prop</span> := <span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">4</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Logic-v-chk7" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk7"><span class="highlight"><span class="kn">Check</span> plus_fact.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">plus_fact
     : <span class="kt">Prop</span></span></blockquote></div></div></small></span></pre><div class="doc">
We can later use this name in any situation where a proposition is
    expected -- for example, as the claim in a <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> declaration. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk8" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk8"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">plus_fact_is_true</span> :
  plus_fact.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">plus_fact</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk9" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">plus_fact</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
We can also write <i>parameterized</i> propositions -- that is,
    functions that take arguments of some type and return a
    proposition. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
For instance, the following function takes a number
    and returns a proposition asserting that this number is equal to
    three: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">is_three</span> (<span class="nv">n</span> : nat) : <span class="kt">Prop</span> :=
  n = <span class="mi">3</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Logic-v-chka" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chka"><span class="highlight"><span class="kn">Check</span> is_three.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">is_three
     : nat -&gt; <span class="kt">Prop</span></span></blockquote></div></div></small></span></pre><div class="doc">
In Coq, functions that return propositions are said to define
    <i>properties</i> of their arguments.

<div class="paragraph"> </div>

    For instance, here's a (polymorphic) property defining the
    familiar notion of an <i>injective function</i>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">injective</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) :=
  <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y -&gt; x = y.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkb" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkb"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">succ_inj</span> : injective S.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">injective S</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkc" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkc"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">injective S</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkd" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkd"><span class="highlight"><span class="nb">intros</span> n m H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n = S m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = m</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chke" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chke"><span class="highlight"><span class="nb">injection</span> H <span class="kr">as</span> H1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = m</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H1.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The equality operator <span class="inlinecode">=</span> is also a function that returns a
    <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.

<div class="paragraph"> </div>

    The expression <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> is syntactic sugar for <span class="inlinecode"><span class="id" title="var">eq</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> (defined
    using Coq's <span class="inlinecode"><span class="id" title="keyword">Notation</span></span> mechanism). Because <span class="inlinecode"><span class="id" title="var">eq</span></span> can be used with
    elements of any type, it is also polymorphic: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Logic-v-chkf" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkf"><span class="highlight"><span class="kn">Check</span> @eq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">@eq
     : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; A -&gt; <span class="kt">Prop</span></span></blockquote></div></div></small></span></pre><div class="doc">
(Notice that we wrote <span class="inlinecode">@<span class="id" title="var">eq</span></span> instead of <span class="inlinecode"><span class="id" title="var">eq</span></span>: The type
    argument <span class="inlinecode"><span class="id" title="var">A</span></span> to <span class="inlinecode"><span class="id" title="var">eq</span></span> is declared as implicit, so we need to turn
    off implicit arguments to see the full type of <span class="inlinecode"><span class="id" title="var">eq</span></span>.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab2"></a><h1 class="section">Logical Connectives</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab3"></a><h2 class="section">Conjunction</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <i>conjunction</i>, or <i>logical and</i>, of propositions <span class="inlinecode"><span class="id" title="var">A</span></span> and <span class="inlinecode"><span class="id" title="var">B</span></span>
    is written <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">‚àß</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, representing the claim that both <span class="inlinecode"><span class="id" title="var">A</span></span> and <span class="inlinecode"><span class="id" title="var">B</span></span>
    are true. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk10" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk10"><span class="highlight"><span class="kn">Example</span> <span class="nf">and_example</span> : <span class="mi">3</span> + <span class="mi">4</span> = <span class="mi">7</span> /\ <span class="mi">2</span> * <span class="mi">2</span> = <span class="mi">4</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> + <span class="mi">4</span> = <span class="mi">7</span> /\ <span class="mi">2</span> * <span class="mi">2</span> = <span class="mi">4</span></span></div></blockquote></div></div></small></span></pre><div class="doc">
To prove a conjunction, use the <span class="inlinecode"><span class="id" title="tactic">split</span></span> tactic.  It will generate
    two subgoals, one for each part of the statement: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk11" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk11"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> + <span class="mi">4</span> = <span class="mi">7</span> /\ <span class="mi">2</span> * <span class="mi">2</span> = <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk12" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk12"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> + <span class="mi">4</span> = <span class="mi">7</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk13" style="display: none" type="checkbox"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> * <span class="mi">2</span> = <span class="mi">4</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk14" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk14"><span class="highlight">- <span class="c">(* 3 + 4 = 7 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> + <span class="mi">4</span> = <span class="mi">7</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk15" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk15"><span class="highlight">- <span class="c">(* 2 + 2 = 4 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> * <span class="mi">2</span> = <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
For any propositions <span class="inlinecode"><span class="id" title="var">A</span></span> and <span class="inlinecode"><span class="id" title="var">B</span></span>, if we assume that <span class="inlinecode"><span class="id" title="var">A</span></span> is true
    and we assume that <span class="inlinecode"><span class="id" title="var">B</span></span> is true, we can conclude that <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">‚àß</span> <span class="inlinecode"><span class="id" title="var">B</span></span> is
    also true. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk16" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk16"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">and_intro</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Prop</span>, A -&gt; B -&gt; A /\ B.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Prop</span>, A -&gt; B -&gt; A /\ B</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk17" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk17"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Prop</span>, A -&gt; B -&gt; A /\ B</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk18" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk18"><span class="highlight"><span class="nb">intros</span> A B HA HB.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HB</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">B</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A /\ B</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk19" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk19"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HB</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">B</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk1a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HB</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">B</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chk1a"><hr></label><div class="goal-conclusion"><span class="highlight">B</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1b"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HB</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">B</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> HA.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1c"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HB</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">B</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">B</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> HB.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Since applying a theorem with hypotheses to some goal has the
    effect of generating as many subgoals as there are hypotheses for
    that theorem, we can apply <span class="inlinecode"><span class="id" title="var">and_intro</span></span> to achieve the same effect
    as <span class="inlinecode"><span class="id" title="tactic">split</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1d"><span class="highlight"><span class="kn">Example</span> <span class="nf">and_example&#39;</span> : <span class="mi">3</span> + <span class="mi">4</span> = <span class="mi">7</span> /\ <span class="mi">2</span> * <span class="mi">2</span> = <span class="mi">4</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> + <span class="mi">4</span> = <span class="mi">7</span> /\ <span class="mi">2</span> * <span class="mi">2</span> = <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> + <span class="mi">4</span> = <span class="mi">7</span> /\ <span class="mi">2</span> * <span class="mi">2</span> = <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1f"><span class="highlight"><span class="nb">apply</span> and_intro.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> + <span class="mi">4</span> = <span class="mi">7</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk20" style="display: none" type="checkbox"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> * <span class="mi">2</span> = <span class="mi">4</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk21" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk21"><span class="highlight">- <span class="c">(* 3 + 4 = 7 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> + <span class="mi">4</span> = <span class="mi">7</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk22" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk22"><span class="highlight">- <span class="c">(* 2 + 2 = 4 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> * <span class="mi">2</span> = <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab4"></a><h4 class="section">Exercise: 2 stars, standard (and_exercise)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk23" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk23"><span class="highlight"><span class="kn">Example</span> <span class="nf">and_exercise</span> :
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = <span class="mi">0</span> -&gt; n = <span class="mi">0</span> /\ m = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = <span class="mi">0</span> -&gt; n = <span class="mi">0</span> /\ m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk24" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk24"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = <span class="mi">0</span> -&gt; n = <span class="mi">0</span> /\ m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
So much for proving conjunctive statements.  To go in the other
    direction -- i.e., to <i>use</i> a conjunctive hypothesis to help prove
    something else -- we employ the <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> tactic.

<div class="paragraph"> </div>

    If the proof context contains a hypothesis <span class="inlinecode"><span class="id" title="var">H</span></span> of the form
    <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">‚àß</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, writing <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[<span class="id" title="var">HA</span></span> <span class="inlinecode"><span class="id" title="var">HB</span>]</span> will remove <span class="inlinecode"><span class="id" title="var">H</span></span> from the
    context and add two new hypotheses: <span class="inlinecode"><span class="id" title="var">HA</span></span>, stating that <span class="inlinecode"><span class="id" title="var">A</span></span> is
    true, and <span class="inlinecode"><span class="id" title="var">HB</span></span>, stating that <span class="inlinecode"><span class="id" title="var">B</span></span> is true.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk25" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk25"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">and_example2</span> :
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = <span class="mi">0</span> /\ m = <span class="mi">0</span> -&gt; n + m = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = <span class="mi">0</span> /\ m = <span class="mi">0</span> -&gt; n + m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk26" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk26"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = <span class="mi">0</span> /\ m = <span class="mi">0</span> -&gt; n + m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk27" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk27"><span class="highlight"><span class="nb">intros</span> n m H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span> /\ m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n + m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk28" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk28"><span class="highlight"><span class="nb">destruct</span> H <span class="kr">as</span> [Hn Hm].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n + m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk29" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk29"><span class="highlight"><span class="nb">rewrite</span> Hn.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> + m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk2a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk2a"><span class="highlight"><span class="nb">rewrite</span> Hm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> + <span class="mi">0</span> = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
As usual, we can also destruct <span class="inlinecode"><span class="id" title="var">H</span></span> right when we introduce it,
    instead of introducing and then destructing it: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk2b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk2b"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">and_example2&#39;</span> :
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = <span class="mi">0</span> /\ m = <span class="mi">0</span> -&gt; n + m = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = <span class="mi">0</span> /\ m = <span class="mi">0</span> -&gt; n + m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk2c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk2c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = <span class="mi">0</span> /\ m = <span class="mi">0</span> -&gt; n + m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk2d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk2d"><span class="highlight"><span class="nb">intros</span> n m [Hn Hm].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n + m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk2e"><span class="highlight"><span class="nb">rewrite</span> Hn.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> + m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk2f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk2f"><span class="highlight"><span class="nb">rewrite</span> Hm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> + <span class="mi">0</span> = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
You may wonder why we bothered packing the two hypotheses <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>
    and <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> into a single conjunction, since we could have also
    stated the theorem with two separate premises: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk30" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk30"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">and_example2&#39;&#39;</span> :
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = <span class="mi">0</span> -&gt; m = <span class="mi">0</span> -&gt; n + m = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = <span class="mi">0</span> -&gt; m = <span class="mi">0</span> -&gt; n + m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk31" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk31"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = <span class="mi">0</span> -&gt; m = <span class="mi">0</span> -&gt; n + m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk32" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk32"><span class="highlight"><span class="nb">intros</span> n m Hn Hm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n + m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk33" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk33"><span class="highlight"><span class="nb">rewrite</span> Hn.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> + m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk34" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk34"><span class="highlight"><span class="nb">rewrite</span> Hm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> + <span class="mi">0</span> = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
For this theorem, both formulations are fine.  But it's important
    to understand how to work with conjunctive hypotheses because
    conjunctions often arise from intermediate steps in proofs,
    especially in bigger developments.  Here's a simple example: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk35" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk35"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">and_example3</span> :
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = <span class="mi">0</span> -&gt; n * m = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = <span class="mi">0</span> -&gt; n * m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk36" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk36"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = <span class="mi">0</span> -&gt; n * m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk37" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk37"><span class="highlight"><span class="nb">intros</span> n m H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n + m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n * m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk38" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk38"><span class="highlight"><span class="nb">assert</span> (H&#39; : n = <span class="mi">0</span> /\ m = <span class="mi">0</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n + m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = <span class="mi">0</span> /\ m = <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk39" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n + m = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span> /\ m = <span class="mi">0</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chk39"><hr></label><div class="goal-conclusion"><span class="highlight">n * m = <span class="mi">0</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk3a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk3a"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n + m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = <span class="mi">0</span> /\ m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk3b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk3b"><span class="highlight"><span class="nb">apply</span> and_exercise.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n + m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n + m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk3c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk3c"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n + m = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span> /\ m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n * m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk3d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk3d"><span class="highlight"><span class="nb">destruct</span> H&#39; <span class="kr">as</span> [Hn Hm].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n + m = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n * m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk3e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk3e"><span class="highlight"><span class="nb">rewrite</span> Hn.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n + m = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> * m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Another common situation with conjunctions is that we know
    <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">‚àß</span> <span class="inlinecode"><span class="id" title="var">B</span></span> but in some context we need just <span class="inlinecode"><span class="id" title="var">A</span></span> (or just <span class="inlinecode"><span class="id" title="var">B</span></span>).
    The following lemmas are useful in such cases: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk3f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk3f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">proj1</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>,
  P /\ Q -&gt; P.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P /\ Q -&gt; P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk40" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk40"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P /\ Q -&gt; P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk41" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk41"><span class="highlight"><span class="nb">intros</span> P Q [HP HQ].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HQ</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> HP.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab5"></a><h4 class="section">Exercise: 1 star, standard, optional (proj2)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk42" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk42"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">proj2</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>,
  P /\ Q -&gt; Q.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P /\ Q -&gt; Q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk43" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk43"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P /\ Q -&gt; Q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Finally, we sometimes need to rearrange the order of conjunctions
    and/or the grouping of multi-way conjunctions.  The following
    commutativity and associativity theorems are handy in such
    cases. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk44" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk44"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">and_commut</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>,
  P /\ Q -&gt; Q /\ P.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P /\ Q -&gt; Q /\ P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk45" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk45"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P /\ Q -&gt; Q /\ P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk46" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk46"><span class="highlight"><span class="nb">intros</span> P Q [HP HQ].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HQ</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q /\ P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk47" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk47"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HQ</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk48" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HQ</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chk48"><hr></label><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk49" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk49"><span class="highlight">- <span class="c">(* left *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HQ</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> HQ.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk4a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk4a"><span class="highlight">- <span class="c">(* right *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HQ</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> HP.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab6"></a><h4 class="section">Exercise: 2 stars, standard (and_assoc)</h4>
<div class="paragraph"> </div>

    (In the following proof of associativity, notice how the <i>nested</i>
<span class="inlinecode"><span class="id" title="tactic">intros</span></span> pattern breaks the hypothesis <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">‚àß</span> <span class="inlinecode">(<span class="id" title="var">Q</span></span> <span class="inlinecode">‚àß</span> <span class="inlinecode"><span class="id" title="var">R</span>)</span> down into
    <span class="inlinecode"><span class="id" title="var">HP</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span>, <span class="inlinecode"><span class="id" title="var">HQ</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Q</span></span>, and <span class="inlinecode"><span class="id" title="var">HR</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">R</span></span>.  Finish the proof from
    there.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk4b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk4b"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">and_assoc</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>,
  P /\ (Q /\ R) -&gt; (P /\ Q) /\ R.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>, P /\ Q /\ R -&gt; (P /\ Q) /\ R</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk4c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk4c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>, P /\ Q /\ R -&gt; (P /\ Q) /\ R</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk4d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk4d"><span class="highlight"><span class="nb">intros</span> P Q R [HP [HQ HR]].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HQ</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HR</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(P /\ Q) /\ R</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
By the way, the infix notation <span class="inlinecode">‚àß</span> is actually just syntactic
    sugar for <span class="inlinecode"><span class="id" title="var">and</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>.  That is, <span class="inlinecode"><span class="id" title="var">and</span></span> is a Coq operator that takes
    two propositions as arguments and yields a proposition. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Logic-v-chk4e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk4e"><span class="highlight"><span class="kn">Check</span> <span class="kn">and</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight"><span class="kn">and</span>
     : <span class="kt">Prop</span> -&gt; <span class="kt">Prop</span> -&gt; <span class="kt">Prop</span></span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab7"></a><h2 class="section">Disjunction</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Another important connective is the <i>disjunction</i>, or <i>logical or</i>,
    of two propositions: <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">‚à®</span> <span class="inlinecode"><span class="id" title="var">B</span></span> is true when either <span class="inlinecode"><span class="id" title="var">A</span></span> or <span class="inlinecode"><span class="id" title="var">B</span></span>
    is.  (This infix notation stands for <span class="inlinecode"><span class="id" title="var">or</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>, where <span class="inlinecode"><span class="id" title="var">or</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> <span class="inlinecode">‚Üí</span>
<span class="inlinecode"><span class="id" title="keyword">Prop</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
To use a disjunctive hypothesis in a proof, we proceed by case
    analysis, which, as for <span class="inlinecode"><span class="id" title="var">nat</span></span> or other data types, can be done
    explicitly with <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> or implicitly with an <span class="inlinecode"><span class="id" title="tactic">intros</span></span> pattern: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk4f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk4f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">or_example</span> :
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = <span class="mi">0</span> \/ m = <span class="mi">0</span> -&gt; n * m = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = <span class="mi">0</span> \/ m = <span class="mi">0</span> -&gt; n * m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk50" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk50"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = <span class="mi">0</span> \/ m = <span class="mi">0</span> -&gt; n * m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* This pattern implicitly does case analysis on</span>
<span class="c">     [n = 0 \/ m = 0] *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk51" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk51"><span class="highlight"><span class="nb">intros</span> n m [Hn | Hm].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n * m = <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk52" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chk52"><hr></label><div class="goal-conclusion"><span class="highlight">n * m = <span class="mi">0</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk53" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk53"><span class="highlight">- <span class="c">(* Here, [n = 0] *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n * m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk54" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk54"><span class="highlight"><span class="nb">rewrite</span> Hn.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> * m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk55" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk55"><span class="highlight">- <span class="c">(* Here, [m = 0] *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n * m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk56" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk56"><span class="highlight"><span class="nb">rewrite</span> Hm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n * <span class="mi">0</span> = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk57" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk57"><span class="highlight"><span class="nb">rewrite</span> &lt;- mult_n_O.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Conversely, to show that a disjunction holds, we need to show that
    one of its sides does. This is done via two tactics, <span class="inlinecode"><span class="id" title="tactic">left</span></span> and
    <span class="inlinecode"><span class="id" title="tactic">right</span></span>.  As their names imply, the first one requires
    proving the left side of the disjunction, while the second
    requires proving its right side.  Here is a trivial use... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk58" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk58"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">or_intro</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Prop</span>, A -&gt; A \/ B.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Prop</span>, A -&gt; A \/ B</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk59" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk59"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Prop</span>, A -&gt; A \/ B</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk5a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk5a"><span class="highlight"><span class="nb">intros</span> A B HA.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A \/ B</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk5b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk5b"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> HA.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
... and here is a slightly more interesting example requiring both
    <span class="inlinecode"><span class="id" title="tactic">left</span></span> and <span class="inlinecode"><span class="id" title="tactic">right</span></span>: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk5c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk5c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">zero_or_succ</span> :
  <span class="kr">forall</span> <span class="nv">n</span> : nat, n = <span class="mi">0</span> \/ n = S (pred n).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, n = <span class="mi">0</span> \/ n = S (Nat.pred n)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk5d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk5d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, n = <span class="mi">0</span> \/ n = S (Nat.pred n)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk5e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk5e"><span class="highlight"><span class="nb">intros</span> [|n].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span> \/ <span class="mi">0</span> = S (Nat.pred <span class="mi">0</span>)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk5f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chk5f"><hr></label><div class="goal-conclusion"><span class="highlight">S n = <span class="mi">0</span> \/ S n = S (Nat.pred (S n))</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk60" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk60"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span> \/ <span class="mi">0</span> = S (Nat.pred <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk61" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk61"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk62" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk62"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">S n = <span class="mi">0</span> \/ S n = S (Nat.pred (S n))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk63" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk63"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">S n = S (Nat.pred (S n))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab8"></a><h4 class="section">Exercise: 1 star, standard (mult_eq_0)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk64" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk64"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">mult_eq_0</span> :
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>, n * m = <span class="mi">0</span> -&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n * m = <span class="mi">0</span> -&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk65" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk65"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n * m = <span class="mi">0</span> -&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab9"></a><h4 class="section">Exercise: 1 star, standard (or_commut)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk66" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk66"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">or_commut</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>,
  P \/ Q  -&gt; Q \/ P.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P \/ Q -&gt; Q \/ P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk67" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk67"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P \/ Q -&gt; Q \/ P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab10"></a><h2 class="section">Falsehood and Negation</h2>
<div class="paragraph"> </div>

    So far, we have mostly been concerned with proving that certain
    things are <i>true</i> -- addition is commutative, appending lists is
    associative, etc.  Of course, we may also be interested in
    negative results, showing that some given proposition is <i>not</i>
    true. In Coq, such statements are expressed with the negation
    operator <span class="inlinecode">¬¨</span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
To see how negation works, recall the <i>principle of explosion</i>
    from the <span class="inlinecode"><span class="id" title="var">Tactics</span></span> chapter; it asserts that, if we assume a
    contradiction, then any other proposition can be derived.

<div class="paragraph"> </div>

    Following this intuition, we could define <span class="inlinecode">¬¨</span> <span class="inlinecode"><span class="id" title="var">P</span></span> ("not <span class="inlinecode"><span class="id" title="var">P</span></span>") as
    <span class="inlinecode"><span class="id" title="keyword">‚àÄ</span></span> <span class="inlinecode"><span class="id" title="var">Q</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">Q</span></span>.

<div class="paragraph"> </div>

    Coq actually makes a slightly different (but equivalent) choice,
    defining <span class="inlinecode">¬¨</span> <span class="inlinecode"><span class="id" title="var">P</span></span> as <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">False</span></span>, where <span class="inlinecode"><span class="id" title="var">False</span></span> is a specific
    contradictory proposition defined in the standard library. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">MyNot</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">not</span> (<span class="nv">P</span>:<span class="kt">Prop</span>) := P -&gt; <span class="kt">False</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;~ x&quot;</span> := (not x) : type_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Logic-v-chk68" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk68"><span class="highlight"><span class="kn">Check</span> not.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">not
     : <span class="kt">Prop</span> -&gt; <span class="kt">Prop</span></span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">MyNot</span>.</span></span></span></pre><div class="doc">
Since <span class="inlinecode"><span class="id" title="var">False</span></span> is a contradictory proposition, the principle of
    explosion also applies to it. If we get <span class="inlinecode"><span class="id" title="var">False</span></span> into the proof
    context, we can use <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> on it to complete any goal: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk69" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk69"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">ex_falso_quodlibet</span> : <span class="kr">forall</span> (<span class="nv">P</span>:<span class="kt">Prop</span>),
  <span class="kt">False</span> -&gt; P.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, <span class="kt">False</span> -&gt; P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk6a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk6a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, <span class="kt">False</span> -&gt; P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk6b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk6b"><span class="highlight"><span class="nb">intros</span> P contra.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">contra</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">False</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> contra.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The Latin <i>ex falso quodlibet</i> means, literally, "from falsehood
    follows whatever you like"; this is another common name for the
    principle of explosion. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab11"></a><h4 class="section">Exercise: 2 stars, standard, optional (not_implies_our_not)</h4>
<div class="paragraph"> </div>

    Show that Coq's definition of negation implies the intuitive one
    mentioned above: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk6c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk6c"><span class="highlight"><span class="kn">Fact</span> <span class="nf">not_implies_our_not</span> : <span class="kr">forall</span> (<span class="nv">P</span>:<span class="kt">Prop</span>),
  ~ P -&gt; (<span class="kr">forall</span> (<span class="nv">Q</span>:<span class="kt">Prop</span>), P -&gt; Q).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, ~ P -&gt; <span class="kr">forall</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P -&gt; Q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk6d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk6d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, ~ P -&gt; <span class="kr">forall</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P -&gt; Q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Inequality is a frequent enough example of negated statement
    that there is a special notation for it, <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">‚â†</span> <span class="inlinecode"><span class="id" title="var">y</span></span>:

<div class="paragraph"> </div>

      Notation "x &lt;&gt; y" := (~(x = y)).

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We can use <span class="inlinecode"><span class="id" title="var">not</span></span> to state that <span class="inlinecode">0</span> and <span class="inlinecode">1</span> are different elements
    of <span class="inlinecode"><span class="id" title="var">nat</span></span>: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk6e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk6e"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">zero_not_one</span> : <span class="mi">0</span> &lt;&gt; <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt;&gt; <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk6f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk6f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt;&gt; <span class="mi">1</span></span></div></blockquote></div></div></small></span></pre><div class="doc">
The proposition <span class="inlinecode">0</span> <span class="inlinecode">‚â†</span> <span class="inlinecode">1</span> is exactly the same as
      <span class="inlinecode">~(0</span> <span class="inlinecode">=</span> <span class="inlinecode">1)</span>, that is <span class="inlinecode"><span class="id" title="var">not</span></span> <span class="inlinecode">(0</span> <span class="inlinecode">=</span> <span class="inlinecode">1)</span>, which unfolds to
      <span class="inlinecode">(0</span> <span class="inlinecode">=</span> <span class="inlinecode">1)</span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">False</span></span>. (We use <span class="inlinecode"><span class="id" title="tactic">unfold</span></span> <span class="inlinecode"><span class="id" title="var">not</span></span> explicitly here
      to illustrate that point, but generally it can be omitted.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk70" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk70"><span class="highlight"><span class="nb">unfold</span> not.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">1</span> -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small></span></pre><div class="doc">
To prove an inequality, we may assume the opposite
      equality... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk71" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk71"><span class="highlight"><span class="nb">intros</span> contra.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">contra</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = <span class="mi">1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small></span></pre><div class="doc">
... and deduce a contradiction from it. Here, the
      equality <span class="inlinecode"><span class="id" title="var">O</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span></span> contradicts the disjointness of
      constructors <span class="inlinecode"><span class="id" title="var">O</span></span> and <span class="inlinecode"><span class="id" title="var">S</span></span>, so <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span> takes care
      of it. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span> contra.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
It takes a little practice to get used to working with negation in
    Coq.  Even though you can see perfectly well why a statement
    involving negation is true, it can be a little tricky at first to
    get things into the right configuration so that Coq can understand
    it!  Here are proofs of a few familiar facts to get you warmed
    up. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk72" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk72"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">not_False</span> :
  ~ <span class="kt">False</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk73" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk73"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk74" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk74"><span class="highlight"><span class="nb">unfold</span> not.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span> -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk75" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk75"><span class="highlight"><span class="nb">intros</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">False</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> H.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk76" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk76"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">contradiction_implies_anything</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>,
  (P /\ ~P) -&gt; Q.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P /\ ~ P -&gt; Q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk77" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk77"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P /\ ~ P -&gt; Q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk78" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk78"><span class="highlight"><span class="nb">intros</span> P Q [HP HNA].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HNA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk79" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk79"><span class="highlight"><span class="nb">unfold</span> not <span class="kr">in</span> HNA.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HNA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P -&gt; <span class="kt">False</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk7a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk7a"><span class="highlight"><span class="nb">apply</span> HNA <span class="kr">in</span> HP.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HNA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P -&gt; <span class="kt">False</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> HP.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk7b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk7b"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">double_neg</span> : <span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>,
  P -&gt; ~~P.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, P -&gt; ~ ~ P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk7c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk7c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, P -&gt; ~ ~ P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk7d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk7d"><span class="highlight"><span class="nb">intros</span> P H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ ~ P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk7e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk7e"><span class="highlight"><span class="nb">unfold</span> not.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(P -&gt; <span class="kt">False</span>) -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk7f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk7f"><span class="highlight"><span class="nb">intros</span> G.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P -&gt; <span class="kt">False</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk80" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk80"><span class="highlight"><span class="nb">apply</span> G.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P -&gt; <span class="kt">False</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab12"></a><h4 class="section">Exercise: 2 stars, advanced (double_neg_inf)</h4>
<div class="paragraph"> </div>

    Write an informal proof of <span class="inlinecode"><span class="id" title="var">double_neg</span></span>:

<div class="paragraph"> </div>
<i>Theorem</i>: <span class="inlinecode"><span class="id" title="var">P</span></span> implies <span class="inlinecode">~~<span class="id" title="var">P</span></span>, for any proposition <span class="inlinecode"><span class="id" title="var">P</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span>

<span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_double_neg_inf</span> : option (nat*string) := None.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab13"></a><h4 class="section">Exercise: 2 stars, standard, recommended (contrapositive)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk81" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk81"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">contrapositive</span> : <span class="kr">forall</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>),
  (P -&gt; Q) -&gt; (~Q -&gt; ~P).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, (P -&gt; Q) -&gt; ~ Q -&gt; ~ P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk82" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk82"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, (P -&gt; Q) -&gt; ~ Q -&gt; ~ P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab14"></a><h4 class="section">Exercise: 1 star, standard (not_both_true_and_false)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk83" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk83"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">not_both_true_and_false</span> : <span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>,
  ~ (P /\ ~P).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, ~ (P /\ ~ P)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk84" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk84"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, ~ (P /\ ~ P)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab15"></a><h4 class="section">Exercise: 1 star, advanced (informal_not_PNP)</h4>
<div class="paragraph"> </div>

    Write an informal proof (in English) of the proposition <span class="inlinecode"><span class="id" title="keyword">‚àÄ</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span>
<span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>,</span> <span class="inlinecode">~(<span class="id" title="var">P</span></span> <span class="inlinecode">‚àß</span> <span class="inlinecode">¬¨<span class="id" title="var">P</span>)</span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span>

<span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_informal_not_PNP</span> : option (nat*string) := None.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Similarly, since inequality involves a negation, it requires a
    little practice to be able to work with it fluently.  Here is one
    useful trick.  If you are trying to prove a goal that is
    nonsensical (e.g., the goal state is <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>), apply
    <span class="inlinecode"><span class="id" title="var">ex_falso_quodlibet</span></span> to change the goal to <span class="inlinecode"><span class="id" title="var">False</span></span>.  This makes it
    easier to use assumptions of the form <span class="inlinecode">¬¨<span class="id" title="var">P</span></span> that may be available
    in the context -- in particular, assumptions of the form
    <span class="inlinecode"><span class="id" title="var">x</span>‚â†<span class="id" title="var">y</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk85" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk85"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">not_true_is_false</span> : <span class="kr">forall</span> <span class="nv">b</span> : bool,
  b &lt;&gt; true -&gt; b = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : bool, b &lt;&gt; true -&gt; b = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk86" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk86"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : bool, b &lt;&gt; true -&gt; b = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk87" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk87"><span class="highlight"><span class="nb">intros</span> [] H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">true &lt;&gt; true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = false</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk88" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">false &lt;&gt; true</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chk88"><hr></label><div class="goal-conclusion"><span class="highlight">false = false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk89" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk89"><span class="highlight">- <span class="c">(* b = true *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">true &lt;&gt; true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk8a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk8a"><span class="highlight"><span class="nb">unfold</span> not <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">true = true -&gt; <span class="kt">False</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk8b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk8b"><span class="highlight"><span class="nb">apply</span> ex_falso_quodlibet.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">true = true -&gt; <span class="kt">False</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk8c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk8c"><span class="highlight"><span class="nb">apply</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">true = true -&gt; <span class="kt">False</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk8d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk8d"><span class="highlight">- <span class="c">(* b = false *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">false &lt;&gt; true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">false = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Since reasoning with <span class="inlinecode"><span class="id" title="var">ex_falso_quodlibet</span></span> is quite common, Coq
    provides a built-in tactic, <span class="inlinecode"><span class="id" title="var">exfalso</span></span>, for applying it. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk8e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk8e"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">not_true_is_false&#39;</span> : <span class="kr">forall</span> <span class="nv">b</span> : bool,
  b &lt;&gt; true -&gt; b = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : bool, b &lt;&gt; true -&gt; b = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk8f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk8f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : bool, b &lt;&gt; true -&gt; b = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk90" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk90"><span class="highlight"><span class="nb">intros</span> [] H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">true &lt;&gt; true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = false</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk91" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">false &lt;&gt; true</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chk91"><hr></label><div class="goal-conclusion"><span class="highlight">false = false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk92" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk92"><span class="highlight">- <span class="c">(* b = true *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">true &lt;&gt; true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk93" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk93"><span class="highlight"><span class="nb">unfold</span> not <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">true = true -&gt; <span class="kt">False</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk94" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk94"><span class="highlight"><span class="nb">exfalso</span>.                <span class="c">(* &lt;=== *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">true = true -&gt; <span class="kt">False</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk95" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk95"><span class="highlight"><span class="nb">apply</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">true = true -&gt; <span class="kt">False</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk96" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk96"><span class="highlight">- <span class="c">(* b = false *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">false &lt;&gt; true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">false = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab16"></a><h2 class="section">Truth</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Besides <span class="inlinecode"><span class="id" title="var">False</span></span>, Coq's standard library also defines <span class="inlinecode"><span class="id" title="var">True</span></span>, a
    proposition that is trivially true. To prove it, we use the
    predefined constant <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">True</span></span>: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk97" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk97"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">True_is_true</span> : <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk98" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk98"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> I.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Unlike <span class="inlinecode"><span class="id" title="var">False</span></span>, which is used extensively, <span class="inlinecode"><span class="id" title="var">True</span></span> is used quite
    rarely, since it is trivial (and therefore uninteresting) to prove
    as a goal, and it carries no useful information as a hypothesis. 

<div class="paragraph"> </div>

    But it can be quite useful when defining complex <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>s using
    conditionals or as a parameter to higher-order <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>s.
    We will see examples of such uses of <span class="inlinecode"><span class="id" title="var">True</span></span> later on. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab17"></a><h2 class="section">Logical Equivalence</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The handy "if and only if" connective, which asserts that two
    propositions have the same truth value, is just the conjunction of
    two implications. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">MyIff</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">iff</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) := (P -&gt; Q) /\ (Q -&gt; P).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;P &lt;-&gt; Q&quot;</span> := (iff P Q)
                      (<span class="kn">at level</span> <span class="mi">95</span>, <span class="kn">no associativity</span>)
                      : type_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">MyIff</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk99" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk99"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">iff_sym</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>,
  (P &lt;-&gt; Q) -&gt; (Q &lt;-&gt; P).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P &lt;-&gt; Q -&gt; Q &lt;-&gt; P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk9a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk9a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P &lt;-&gt; Q -&gt; Q &lt;-&gt; P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk9b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk9b"><span class="highlight"><span class="nb">intros</span> P Q [HAB HBA].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HAB</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P -&gt; Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HBA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q -&gt; P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q &lt;-&gt; P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk9c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk9c"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HAB</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P -&gt; Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HBA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q -&gt; P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q -&gt; P</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk9d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HAB</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P -&gt; Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HBA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q -&gt; P</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chk9d"><hr></label><div class="goal-conclusion"><span class="highlight">P -&gt; Q</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk9e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk9e"><span class="highlight">- <span class="c">(* -&gt; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HAB</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P -&gt; Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HBA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q -&gt; P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q -&gt; P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> HBA.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk9f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk9f"><span class="highlight">- <span class="c">(* &lt;- *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HAB</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P -&gt; Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HBA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q -&gt; P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P -&gt; Q</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> HAB.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chka0" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chka0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">not_true_iff_false</span> : <span class="kr">forall</span> <span class="nv">b</span>,
  b &lt;&gt; true &lt;-&gt; b = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : bool, b &lt;&gt; true &lt;-&gt; b = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chka1" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chka1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : bool, b &lt;&gt; true &lt;-&gt; b = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chka2" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chka2"><span class="highlight"><span class="nb">intros</span> b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &lt;&gt; true &lt;-&gt; b = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chka3" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chka3"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &lt;&gt; true -&gt; b = false</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chka4" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chka4"><hr></label><div class="goal-conclusion"><span class="highlight">b = false -&gt; b &lt;&gt; true</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chka5" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chka5"><span class="highlight">- <span class="c">(* -&gt; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &lt;&gt; true -&gt; b = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> not_true_is_false.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chka6" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chka6"><span class="highlight">- <span class="c">(* &lt;- *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b = false -&gt; b &lt;&gt; true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chka7" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chka7"><span class="highlight"><span class="nb">intros</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &lt;&gt; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chka8" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chka8"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">false &lt;&gt; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chka9" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chka9"><span class="highlight"><span class="nb">intros</span> H&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">false = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span> H&#39;.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab18"></a><h4 class="section">Exercise: 1 star, standard, optional (iff_properties)</h4>
<div class="paragraph"> </div>

    Using the above proof that <span class="inlinecode">‚Üî</span> is symmetric (<span class="inlinecode"><span class="id" title="var">iff_sym</span></span>) as
    a guide, prove that it is also reflexive and transitive. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkaa" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkaa"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">iff_refl</span> : <span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>,
  P &lt;-&gt; P.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, P &lt;-&gt; P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkab" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkab"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, P &lt;-&gt; P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkac" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkac"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">iff_trans</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>,
  (P &lt;-&gt; Q) -&gt; (Q &lt;-&gt; R) -&gt; (P &lt;-&gt; R).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>, P &lt;-&gt; Q -&gt; Q &lt;-&gt; R -&gt; P &lt;-&gt; R</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkad" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkad"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>, P &lt;-&gt; Q -&gt; Q &lt;-&gt; R -&gt; P &lt;-&gt; R</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab19"></a><h4 class="section">Exercise: 3 stars, standard (or_distributes_over_and)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkae" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkae"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">or_distributes_over_and</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>,
  P \/ (Q /\ R) &lt;-&gt; (P \/ Q) /\ (P \/ R).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>,
P \/ Q /\ R &lt;-&gt; (P \/ Q) /\ (P \/ R)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkaf" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkaf"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>,
P \/ Q /\ R &lt;-&gt; (P \/ Q) /\ (P \/ R)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Some of Coq's tactics treat <span class="inlinecode"><span class="id" title="var">iff</span></span> statements specially, avoiding
    the need for some low-level proof-state manipulation.  In
    particular, <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> and <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> can be used with <span class="inlinecode"><span class="id" title="var">iff</span></span>
    statements, not just equalities.  To enable this behavior, we need
    to import a Coq library that supports it: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Setoids.Setoid.</span></span></span></pre><div class="doc">
Here is a simple example demonstrating how these tactics work with
    <span class="inlinecode"><span class="id" title="var">iff</span></span>.  First, let's prove a couple of basic iff equivalences... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkb0" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkb0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">mult_0</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>, n * m = <span class="mi">0</span> &lt;-&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n * m = <span class="mi">0</span> &lt;-&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkb1" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkb1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n * m = <span class="mi">0</span> &lt;-&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkb2" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkb2"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n * m = <span class="mi">0</span> -&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chkb3" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chkb3"><hr></label><div class="goal-conclusion"><span class="highlight">n = <span class="mi">0</span> \/ m = <span class="mi">0</span> -&gt; n * m = <span class="mi">0</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkb4" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkb4"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n * m = <span class="mi">0</span> -&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> mult_eq_0.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkb5" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkb5"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = <span class="mi">0</span> \/ m = <span class="mi">0</span> -&gt; n * m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> or_example.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkb6" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkb6"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">or_assoc</span> :
  <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>, P \/ (Q \/ R) &lt;-&gt; (P \/ Q) \/ R.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>, P \/ Q \/ R &lt;-&gt; (P \/ Q) \/ R</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkb7" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkb7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>, P \/ Q \/ R &lt;-&gt; (P \/ Q) \/ R</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkb8" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkb8"><span class="highlight"><span class="nb">intros</span> P Q R.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P \/ Q \/ R &lt;-&gt; (P \/ Q) \/ R</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkb9" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkb9"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P \/ Q \/ R -&gt; (P \/ Q) \/ R</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chkba" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chkba"><hr></label><div class="goal-conclusion"><span class="highlight">(P \/ Q) \/ R -&gt; P \/ Q \/ R</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkbb" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkbb"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P \/ Q \/ R -&gt; (P \/ Q) \/ R</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkbc" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkbc"><span class="highlight"><span class="nb">intros</span> [H | [H | H]].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(P \/ Q) \/ R</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chkbd" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chkbd"><hr></label><div class="goal-conclusion"><span class="highlight">(P \/ Q) \/ R</span></div></blockquote><input class="coq-extra-goal-toggle" id="Logic-v-chkbe" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chkbe"><hr></label><div class="goal-conclusion"><span class="highlight">(P \/ Q) \/ R</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkbf" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkbf"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(P \/ Q) \/ R</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkc0" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkc0"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P \/ Q</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkc1" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkc1"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkc2" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkc2"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(P \/ Q) \/ R</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkc3" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkc3"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P \/ Q</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkc4" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkc4"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkc5" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkc5"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(P \/ Q) \/ R</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkc6" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkc6"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">R</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkc7" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkc7"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(P \/ Q) \/ R -&gt; P \/ Q \/ R</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkc8" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkc8"><span class="highlight"><span class="nb">intros</span> [[H | H] | H].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P \/ Q \/ R</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chkc9" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chkc9"><hr></label><div class="goal-conclusion"><span class="highlight">P \/ Q \/ R</span></div></blockquote><input class="coq-extra-goal-toggle" id="Logic-v-chkca" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chkca"><hr></label><div class="goal-conclusion"><span class="highlight">P \/ Q \/ R</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkcb" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkcb"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P \/ Q \/ R</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkcc" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkcc"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkcd" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkcd"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P \/ Q \/ R</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkce" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkce"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q \/ R</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkcf" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkcf"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkd0" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkd0"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P \/ Q \/ R</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkd1" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkd1"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q \/ R</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkd2" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkd2"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">R</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
We can now use these facts with <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> and <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> to
    give smooth proofs of statements involving equivalences.  Here is
    a ternary version of the previous <span class="inlinecode"><span class="id" title="var">mult_0</span></span> result: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkd3" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkd3"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">mult_0_3</span> :
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span>, n * m * p = <span class="mi">0</span> &lt;-&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span> \/ p = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span> : nat,
n * m * p = <span class="mi">0</span> &lt;-&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span> \/ p = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkd4" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkd4"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span> : nat,
n * m * p = <span class="mi">0</span> &lt;-&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span> \/ p = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkd5" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkd5"><span class="highlight"><span class="nb">intros</span> n m p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n * m * p = <span class="mi">0</span> &lt;-&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span> \/ p = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkd6" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkd6"><span class="highlight"><span class="nb">rewrite</span> mult_0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n * m = <span class="mi">0</span> \/ p = <span class="mi">0</span> &lt;-&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span> \/ p = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkd7" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkd7"><span class="highlight"><span class="nb">rewrite</span> mult_0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(n = <span class="mi">0</span> \/ m = <span class="mi">0</span>) \/ p = <span class="mi">0</span> &lt;-&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span> \/ p = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkd8" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkd8"><span class="highlight"><span class="nb">rewrite</span> or_assoc.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(n = <span class="mi">0</span> \/ m = <span class="mi">0</span>) \/ p = <span class="mi">0</span> &lt;-&gt;
(n = <span class="mi">0</span> \/ m = <span class="mi">0</span>) \/ p = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="tactic">apply</span></span> tactic can also be used with <span class="inlinecode">‚Üî</span>. When given an
    equivalence as its argument, <span class="inlinecode"><span class="id" title="tactic">apply</span></span> tries to guess which side of
    the equivalence to use. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkd9" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkd9"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">apply_iff_example</span> :
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n * m = <span class="mi">0</span> -&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n * m = <span class="mi">0</span> -&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkda" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkda"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n * m = <span class="mi">0</span> -&gt; n = <span class="mi">0</span> \/ m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkdb" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkdb"><span class="highlight"><span class="nb">intros</span> n m H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n * m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = <span class="mi">0</span> \/ m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkdc" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkdc"><span class="highlight"><span class="nb">apply</span> mult_0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n * m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n * m = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab20"></a><h2 class="section">Existential Quantification</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Another important logical connective is <i>existential
    quantification</i>.  To say that there is some <span class="inlinecode"><span class="id" title="var">x</span></span> of type <span class="inlinecode"><span class="id" title="var">T</span></span> such
    that some property <span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode"><span class="id" title="var">x</span></span>, we write <span class="inlinecode"><span class="id" title="tactic">‚àÉ</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span>
<span class="inlinecode"><span class="id" title="var">P</span></span>. As with <span class="inlinecode"><span class="id" title="keyword">‚àÄ</span></span>, the type annotation <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> can be omitted if
    Coq is able to infer from the context what the type of <span class="inlinecode"><span class="id" title="var">x</span></span> should
    be. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
To prove a statement of the form <span class="inlinecode"><span class="id" title="tactic">‚àÉ</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span>, we must show that
    <span class="inlinecode"><span class="id" title="var">P</span></span> holds for some specific choice of value for <span class="inlinecode"><span class="id" title="var">x</span></span>, known as the
    <i>witness</i> of the existential.  This is done in two steps: First,
    we explicitly tell Coq which witness <span class="inlinecode"><span class="id" title="var">t</span></span> we have in mind by
    invoking the tactic <span class="inlinecode"><span class="id" title="tactic">‚àÉ</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>.  Then we prove that <span class="inlinecode"><span class="id" title="var">P</span></span> holds after
    all occurrences of <span class="inlinecode"><span class="id" title="var">x</span></span> are replaced by <span class="inlinecode"><span class="id" title="var">t</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkdd" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkdd"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">four_is_even</span> : <span class="kr">exists</span> <span class="nv">n</span> : nat, <span class="mi">4</span> = n + n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">n</span> : nat, <span class="mi">4</span> = n + n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkde" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkde"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">n</span> : nat, <span class="mi">4</span> = n + n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkdf" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkdf"><span class="highlight"><span class="kr">exists</span> <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">4</span> = <span class="mi">2</span> + <span class="mi">2</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Conversely, if we have an existential hypothesis <span class="inlinecode"><span class="id" title="tactic">‚àÉ</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> in
    the context, we can destruct it to obtain a witness <span class="inlinecode"><span class="id" title="var">x</span></span> and a
    hypothesis stating that <span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode"><span class="id" title="var">x</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chke0" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chke0"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">exists_example_2</span> : <span class="kr">forall</span> <span class="nv">n</span>,
  (<span class="kr">exists</span> <span class="nv">m</span>, n = <span class="mi">4</span> + m) -&gt;
  (<span class="kr">exists</span> <span class="nv">o</span>, n = <span class="mi">2</span> + o).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">exists</span> <span class="nv">m</span> : nat, n = <span class="mi">4</span> + m) -&gt;
<span class="kr">exists</span> <span class="nv">o</span> : nat, n = <span class="mi">2</span> + o</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chke1" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chke1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">exists</span> <span class="nv">m</span> : nat, n = <span class="mi">4</span> + m) -&gt;
<span class="kr">exists</span> <span class="nv">o</span> : nat, n = <span class="mi">2</span> + o</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chke2" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chke2"><span class="highlight"><span class="nb">intros</span> n [m Hm]. <span class="c">(* note implicit [destruct] here *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">4</span> + m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">o</span> : nat, n = <span class="mi">2</span> + o</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chke3" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chke3"><span class="highlight"><span class="kr">exists</span> (<span class="mi">2</span> + m).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">4</span> + m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = <span class="mi">2</span> + (<span class="mi">2</span> + m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> Hm.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab21"></a><h4 class="section">Exercise: 1 star, standard, recommended (dist_not_exists)</h4>
<div class="paragraph"> </div>

    Prove that "<span class="inlinecode"><span class="id" title="var">P</span></span> holds for all <span class="inlinecode"><span class="id" title="var">x</span></span>" implies "there is no <span class="inlinecode"><span class="id" title="var">x</span></span> for
    which <span class="inlinecode"><span class="id" title="var">P</span></span> does not hold."  (Hint: <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[<span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">E</span>]</span> works on
    existential assumptions!)  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chke4" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chke4"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">dist_not_exists</span> : <span class="kr">forall</span> (<span class="nv">X</span>:<span class="kt">Type</span>) (<span class="nv">P</span> : X -&gt; <span class="kt">Prop</span>),
  (<span class="kr">forall</span> <span class="nv">x</span>, P x) -&gt; ~ (<span class="kr">exists</span> <span class="nv">x</span>, ~ P x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : X -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">x</span> : X, P x) -&gt; ~ (<span class="kr">exists</span> <span class="nv">x</span> : X, ~ P x)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chke5" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chke5"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : X -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">x</span> : X, P x) -&gt; ~ (<span class="kr">exists</span> <span class="nv">x</span> : X, ~ P x)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab22"></a><h4 class="section">Exercise: 2 stars, standard (dist_exists_or)</h4>
<div class="paragraph"> </div>

    Prove that existential quantification distributes over
    disjunction. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chke6" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chke6"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">dist_exists_or</span> : <span class="kr">forall</span> (<span class="nv">X</span>:<span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span> : X -&gt; <span class="kt">Prop</span>),
  (<span class="kr">exists</span> <span class="nv">x</span>, P x \/ Q x) &lt;-&gt; (<span class="kr">exists</span> <span class="nv">x</span>, P x) \/ (<span class="kr">exists</span> <span class="nv">x</span>, Q x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span> : X -&gt; <span class="kt">Prop</span>),
(<span class="kr">exists</span> <span class="nv">x</span> : X, P x \/ Q x) &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">x</span> : X, P x) \/ (<span class="kr">exists</span> <span class="nv">x</span> : X, Q x)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chke7" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chke7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span> : X -&gt; <span class="kt">Prop</span>),
(<span class="kr">exists</span> <span class="nv">x</span> : X, P x \/ Q x) &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">x</span> : X, P x) \/ (<span class="kr">exists</span> <span class="nv">x</span> : X, Q x)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">   <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab23"></a><h1 class="section">Programming with Propositions</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The logical connectives that we have seen provide a rich
    vocabulary for defining complex propositions from simpler ones.
    To illustrate, let's look at how to express the claim that an
    element <span class="inlinecode"><span class="id" title="var">x</span></span> occurs in a list <span class="inlinecode"><span class="id" title="var">l</span></span>.  Notice that this property has a
    simple recursive structure: 

<div class="paragraph"> </div>
<ul class="doclist">
<li> If <span class="inlinecode"><span class="id" title="var">l</span></span> is the empty list, then <span class="inlinecode"><span class="id" title="var">x</span></span> cannot occur on it, so the
         property "<span class="inlinecode"><span class="id" title="var">x</span></span> appears in <span class="inlinecode"><span class="id" title="var">l</span></span>" is simply false. 

<div class="paragraph"> </div>
</li>
<li> Otherwise, <span class="inlinecode"><span class="id" title="var">l</span></span> has the form <span class="inlinecode"><span class="id" title="var">x'</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="var">l'</span></span>.  In this case, <span class="inlinecode"><span class="id" title="var">x</span></span>
         occurs in <span class="inlinecode"><span class="id" title="var">l</span></span> if either it is equal to <span class="inlinecode"><span class="id" title="var">x'</span></span> or it occurs in
         <span class="inlinecode"><span class="id" title="var">l'</span></span>. 
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We can translate this directly into a straightforward recursive
    function taking an element and a list and returning a proposition: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">In</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">x</span> : A) (<span class="nv">l</span> : list A) : <span class="kt">Prop</span> :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; <span class="kt">False</span>
  | x&#39; :: l&#39; =&gt; x&#39; = x \/ In x l&#39;
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
When <span class="inlinecode"><span class="id" title="var">In</span></span> is applied to a concrete list, it expands into a
    concrete sequence of nested disjunctions. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chke8" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chke8"><span class="highlight"><span class="kn">Example</span> <span class="nf">In_example_1</span> : In <span class="mi">4</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>; <span class="mi">5</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In <span class="mi">4</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>; <span class="mi">5</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chke9" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chke9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In <span class="mi">4</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>; <span class="mi">5</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkea" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkea"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> = <span class="mi">4</span> \/ <span class="mi">2</span> = <span class="mi">4</span> \/ <span class="mi">3</span> = <span class="mi">4</span> \/ <span class="mi">4</span> = <span class="mi">4</span> \/ <span class="mi">5</span> = <span class="mi">4</span> \/ <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkeb" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkeb"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> = <span class="mi">4</span> \/ <span class="mi">3</span> = <span class="mi">4</span> \/ <span class="mi">4</span> = <span class="mi">4</span> \/ <span class="mi">5</span> = <span class="mi">4</span> \/ <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkec" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkec"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> = <span class="mi">4</span> \/ <span class="mi">4</span> = <span class="mi">4</span> \/ <span class="mi">5</span> = <span class="mi">4</span> \/ <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chked" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chked"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">4</span> = <span class="mi">4</span> \/ <span class="mi">5</span> = <span class="mi">4</span> \/ <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkee" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkee"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">4</span> = <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkef" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkef"><span class="highlight"><span class="kn">Example</span> <span class="nf">In_example_2</span> :
  <span class="kr">forall</span> <span class="nv">n</span>, In n [<span class="mi">2</span>; <span class="mi">4</span>] -&gt;
  <span class="kr">exists</span> <span class="nv">n&#39;</span>, n = <span class="mi">2</span> * n&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
In n [<span class="mi">2</span>; <span class="mi">4</span>] -&gt; <span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, n = <span class="mi">2</span> * n&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkf0" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkf0"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
In n [<span class="mi">2</span>; <span class="mi">4</span>] -&gt; <span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, n = <span class="mi">2</span> * n&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkf1" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkf1"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
<span class="mi">2</span> = n \/ <span class="mi">4</span> = n \/ <span class="kt">False</span> -&gt;
<span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, n = n&#39; + (n&#39; + <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkf2" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkf2"><span class="highlight"><span class="nb">intros</span> n [H | [H | []]].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">2</span> = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, n = n&#39; + (n&#39; + <span class="mi">0</span>)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chkf3" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">4</span> = n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chkf3"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, n = n&#39; + (n&#39; + <span class="mi">0</span>)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkf4" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkf4"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">2</span> = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, n = n&#39; + (n&#39; + <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkf5" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkf5"><span class="highlight"><span class="kr">exists</span> <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">2</span> = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = <span class="mi">1</span> + (<span class="mi">1</span> + <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkf6" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkf6"><span class="highlight"><span class="nb">rewrite</span> &lt;- H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">2</span> = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> = <span class="mi">1</span> + (<span class="mi">1</span> + <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkf7" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkf7"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">4</span> = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, n = n&#39; + (n&#39; + <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkf8" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkf8"><span class="highlight"><span class="kr">exists</span> <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">4</span> = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = <span class="mi">2</span> + (<span class="mi">2</span> + <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkf9" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkf9"><span class="highlight"><span class="nb">rewrite</span> &lt;- H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">4</span> = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">4</span> = <span class="mi">2</span> + (<span class="mi">2</span> + <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
(Notice the use of the empty pattern to discharge the last case
    <i>en passant</i>.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We can also prove more generic, higher-level lemmas about <span class="inlinecode"><span class="id" title="var">In</span></span>.

<div class="paragraph"> </div>

    Note, in the next, how <span class="inlinecode"><span class="id" title="var">In</span></span> starts out applied to a variable and
    only gets expanded when we do case analysis on this variable: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkfa" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkfa"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">In_map</span> :
  <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">l</span> : list A) (<span class="nv">x</span> : A),
    In x l -&gt;
    In (f x) (map f l).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">l</span> : list A) (<span class="nv">x</span> : A),
In x l -&gt; In (f x) (map f l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkfb" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkfb"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">l</span> : list A) (<span class="nv">x</span> : A),
In x l -&gt; In (f x) (map f l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkfc" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkfc"><span class="highlight"><span class="nb">intros</span> A B f l x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x l -&gt; In (f x) (map f l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkfd" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkfd"><span class="highlight"><span class="nb">induction</span> l <span class="kr">as</span> [|x&#39; l&#39; IHl&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x [ ] -&gt; In (f x) (map f [ ])</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chkfe" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l&#39; -&gt; In (f x) (map f l&#39;)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chkfe"><hr></label><div class="goal-conclusion"><span class="highlight">In x (x&#39; :: l&#39;) -&gt; In (f x) (map f (x&#39; :: l&#39;))</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chkff" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chkff"><span class="highlight">- <span class="c">(* l = nil, contradiction *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x [ ] -&gt; In (f x) (map f [ ])</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk100" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk100"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span> -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span> [].</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk101" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk101"><span class="highlight">- <span class="c">(* l = x&#39; :: l&#39; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l&#39; -&gt; In (f x) (map f l&#39;)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (x&#39; :: l&#39;) -&gt; In (f x) (map f (x&#39; :: l&#39;))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk102" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk102"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l&#39; -&gt; In (f x) (map f l&#39;)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x&#39; = x \/ In x l&#39; -&gt; f x&#39; = f x \/ In (f x) (map f l&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk103" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk103"><span class="highlight"><span class="nb">intros</span> [H | H].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l&#39; -&gt; In (f x) (map f l&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x&#39; = x</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f x&#39; = f x \/ In (f x) (map f l&#39;)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk104" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l&#39; -&gt; In (f x) (map f l&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chk104"><hr></label><div class="goal-conclusion"><span class="highlight">f x&#39; = f x \/ In (f x) (map f l&#39;)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk105" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk105"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l&#39; -&gt; In (f x) (map f l&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x&#39; = x</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f x&#39; = f x \/ In (f x) (map f l&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk106" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk106"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l&#39; -&gt; In (f x) (map f l&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x&#39; = x</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f x = f x \/ In (f x) (map f l&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk107" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk107"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l&#39; -&gt; In (f x) (map f l&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x&#39; = x</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f x = f x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk108" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk108"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l&#39; -&gt; In (f x) (map f l&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f x&#39; = f x \/ In (f x) (map f l&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk109" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk109"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l&#39; -&gt; In (f x) (map f l&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In (f x) (map f l&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk10a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk10a"><span class="highlight"><span class="nb">apply</span> IHl&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l&#39; -&gt; In (f x) (map f l&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
This way of defining propositions recursively, though convenient
    in some cases, also has some drawbacks.  In particular, it is
    subject to Coq's usual restrictions regarding the definition of
    recursive functions, e.g., the requirement that they be "obviously
    terminating."  In the next chapter, we will see how to define
    propositions <i>inductively</i>, a different technique with its own set
    of strengths and limitations. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab24"></a><h4 class="section">Exercise: 2 stars, standard (In_map_iff)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk10b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk10b"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">In_map_iff</span> :
  <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">l</span> : list A) (<span class="nv">y</span> : B),
    In y (map f l) &lt;-&gt;
    <span class="kr">exists</span> <span class="nv">x</span>, f x = y /\ In x l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">l</span> : list A) (<span class="nv">y</span> : B),
In y (map f l) &lt;-&gt; (<span class="kr">exists</span> <span class="nv">x</span> : A, f x = y /\ In x l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk10c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk10c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">l</span> : list A) (<span class="nv">y</span> : B),
In y (map f l) &lt;-&gt; (<span class="kr">exists</span> <span class="nv">x</span> : A, f x = y /\ In x l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab25"></a><h4 class="section">Exercise: 2 stars, standard (In_app_iff)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk10d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk10d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">In_app_iff</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">l</span> <span class="nv">l&#39;</span> (<span class="nv">a</span>:A),
  In a (l++l&#39;) &lt;-&gt; In a l \/ In a l&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A) (<span class="nv">a</span> : A),
In a (l ++ l&#39;) &lt;-&gt; In a l \/ In a l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk10e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk10e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A) (<span class="nv">a</span> : A),
In a (l ++ l&#39;) &lt;-&gt; In a l \/ In a l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab26"></a><h4 class="section">Exercise: 3 stars, standard, recommended (All)</h4>
<div class="paragraph"> </div>

    Recall that functions returning propositions can be seen as
    <i>properties</i> of their arguments. For instance, if <span class="inlinecode"><span class="id" title="var">P</span></span> has type
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, then <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> states that property <span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Drawing inspiration from <span class="inlinecode"><span class="id" title="var">In</span></span>, write a recursive function <span class="inlinecode"><span class="id" title="keyword">All</span></span>
    stating that some property <span class="inlinecode"><span class="id" title="var">P</span></span> holds of all elements of a list
    <span class="inlinecode"><span class="id" title="var">l</span></span>. To make sure your definition is correct, prove the <span class="inlinecode"><span class="id" title="var">All_In</span></span>
    lemma below.  (Of course, your definition should <i>not</i> just
    restate the left-hand side of <span class="inlinecode"><span class="id" title="var">All_In</span></span>.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk10f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk10f"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">All</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) (<span class="nv">l</span> : list T) : <span class="kt">Prop</span>
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">All</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">T0</span> : <span class="kt">Type</span>, (T0 -&gt; <span class="kt">Prop</span>) -&gt; list T0 -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">Prop</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk110" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk110"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">All_In</span> :
  <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) (<span class="nv">l</span> : list T),
    (<span class="kr">forall</span> <span class="nv">x</span>, In x l -&gt; P x) &lt;-&gt;
    All P l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) (<span class="nv">l</span> : list T),
(<span class="kr">forall</span> <span class="nv">x</span> : T, In x l -&gt; P x) &lt;-&gt; All P l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk111" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk111"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : T -&gt; <span class="kt">Prop</span>) (<span class="nv">l</span> : list T),
(<span class="kr">forall</span> <span class="nv">x</span> : T, In x l -&gt; P x) &lt;-&gt; All P l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab27"></a><h4 class="section">Exercise: 3 stars, standard (combine_odd_even)</h4>
<div class="paragraph"> </div>

    Complete the definition of the <span class="inlinecode"><span class="id" title="var">combine_odd_even</span></span> function below.
    It takes as arguments two properties of numbers, <span class="inlinecode"><span class="id" title="var">Podd</span></span> and
    <span class="inlinecode"><span class="id" title="var">Peven</span></span>, and it should return a property <span class="inlinecode"><span class="id" title="var">P</span></span> such that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> is
    equivalent to <span class="inlinecode"><span class="id" title="var">Podd</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> when <span class="inlinecode"><span class="id" title="var">n</span></span> is odd and equivalent to <span class="inlinecode"><span class="id" title="var">Peven</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>
    otherwise. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk112" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk112"><span class="highlight"><span class="kn">Definition</span> <span class="nf">combine_odd_even</span> (<span class="nv">Podd</span> <span class="nv">Peven</span> : nat -&gt; <span class="kt">Prop</span>) : nat -&gt; <span class="kt">Prop</span>
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">Podd, Peven</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; <span class="kt">Prop</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nat -&gt; <span class="kt">Prop</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
To test your definition, prove the following facts: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk113" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk113"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">combine_odd_even_intro</span> :
  <span class="kr">forall</span> (<span class="nv">Podd</span> <span class="nv">Peven</span> : nat -&gt; <span class="kt">Prop</span>) (<span class="nv">n</span> : nat),
    (oddb n = true -&gt; Podd n) -&gt;
    (oddb n = false -&gt; Peven n) -&gt;
    combine_odd_even Podd Peven n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Podd</span> <span class="nv">Peven</span> : nat -&gt; <span class="kt">Prop</span>) (<span class="nv">n</span> : nat),
(oddb n = true -&gt; Podd n) -&gt;
(oddb n = false -&gt; Peven n) -&gt;
combine_odd_even Podd Peven n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk114" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk114"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Podd</span> <span class="nv">Peven</span> : nat -&gt; <span class="kt">Prop</span>) (<span class="nv">n</span> : nat),
(oddb n = true -&gt; Podd n) -&gt;
(oddb n = false -&gt; Peven n) -&gt;
combine_odd_even Podd Peven n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk115" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk115"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">combine_odd_even_elim_odd</span> :
  <span class="kr">forall</span> (<span class="nv">Podd</span> <span class="nv">Peven</span> : nat -&gt; <span class="kt">Prop</span>) (<span class="nv">n</span> : nat),
    combine_odd_even Podd Peven n -&gt;
    oddb n = true -&gt;
    Podd n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Podd</span> <span class="nv">Peven</span> : nat -&gt; <span class="kt">Prop</span>) (<span class="nv">n</span> : nat),
combine_odd_even Podd Peven n -&gt;
oddb n = true -&gt; Podd n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk116" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk116"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Podd</span> <span class="nv">Peven</span> : nat -&gt; <span class="kt">Prop</span>) (<span class="nv">n</span> : nat),
combine_odd_even Podd Peven n -&gt;
oddb n = true -&gt; Podd n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk117" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk117"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">combine_odd_even_elim_even</span> :
  <span class="kr">forall</span> (<span class="nv">Podd</span> <span class="nv">Peven</span> : nat -&gt; <span class="kt">Prop</span>) (<span class="nv">n</span> : nat),
    combine_odd_even Podd Peven n -&gt;
    oddb n = false -&gt;
    Peven n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Podd</span> <span class="nv">Peven</span> : nat -&gt; <span class="kt">Prop</span>) (<span class="nv">n</span> : nat),
combine_odd_even Podd Peven n -&gt;
oddb n = false -&gt; Peven n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk118" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk118"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Podd</span> <span class="nv">Peven</span> : nat -&gt; <span class="kt">Prop</span>) (<span class="nv">n</span> : nat),
combine_odd_even Podd Peven n -&gt;
oddb n = false -&gt; Peven n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab28"></a><h1 class="section">Applying Theorems to Arguments</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
One feature of Coq that distinguishes it from some other
    popular proof assistants (e.g., ACL2 and Isabelle) is that it
    treats <i>proofs</i> as first-class objects.

<div class="paragraph"> </div>

    There is a great deal to be said about this, but it is not
    necessary to understand it all in detail in order to use Coq.  This
    section gives just a taste, while a deeper exploration can be
    found in the optional chapters <span class="inlinecode"><span class="id" title="var">ProofObjects</span></span> and
    <span class="inlinecode"><span class="id" title="var">IndPrinciples</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We have seen that we can use the <span class="inlinecode"><span class="id" title="keyword">Check</span></span> command to ask Coq to
    print the type of an expression.  We can also use <span class="inlinecode"><span class="id" title="keyword">Check</span></span> to ask
    what theorem a particular identifier refers to. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Logic-v-chk119" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk119"><span class="highlight"><span class="kn">Check</span> plus_comm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">plus_comm
     : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n</span></blockquote></div></div></small></span></pre><div class="doc">
Coq prints the <i>statement</i> of the <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> theorem in the same
    way that it prints the <i>type</i> of any term that we ask it to
    <span class="inlinecode"><span class="id" title="keyword">Check</span></span>.  Why? 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The reason is that the identifier <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> actually refers to a
    <i>proof object</i> -- a data structure that represents a logical
    derivation establishing of the truth of the statement <span class="inlinecode"><span class="id" title="keyword">‚àÄ</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>
<span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span>.  The type of this object <i>is</i> the statement
    of the theorem that it is a proof of. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Intuitively, this makes sense because the statement of a theorem
    tells us what we can use that theorem for, just as the type of a
    computational object tells us what we can do with that object --
    e.g., if we have a term of type <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, we can give
    it two <span class="inlinecode"><span class="id" title="var">nat</span></span>s as arguments and get a <span class="inlinecode"><span class="id" title="var">nat</span></span> back.  Similarly, if we
    have an object of type <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span> and we provide it
    an "argument" of type <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>, we can derive <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Operationally, this analogy goes even further: by applying a
    theorem, as if it were a function, to hypotheses with matching
    types, we can specialize its result without having to resort to
    intermediate assertions.  For example, suppose we wanted to prove
    the following result: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk11a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk11a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">plus_comm3</span> :
  <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, x + (y + z) = (z + y) + x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : nat, x + (y + z) = z + y + x</span></div></blockquote></div></div></small></span></pre><div class="doc">
It appears at first sight that we ought to be able to prove this
    by rewriting with <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> twice to make the two sides match.
    The problem, however, is that the second <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> will undo the
    effect of the first. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk11b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk11b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : nat, x + (y + z) = z + y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk11c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk11c"><span class="highlight"><span class="nb">intros</span> x y z.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x + (y + z) = z + y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk11d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk11d"><span class="highlight"><span class="nb">rewrite</span> plus_comm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y + z + x = z + y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk11e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk11e"><span class="highlight"><span class="nb">rewrite</span> plus_comm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x + (y + z) = z + y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* We are back where we started... *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><div class="doc">
One simple way of fixing this problem, using only tools that we
    already know, is to use <span class="inlinecode"><span class="id" title="tactic">assert</span></span> to derive a specialized version
    of <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> that can be used to rewrite exactly where we
    want. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk11f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk11f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">plus_comm3_take2</span> :
  <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, x + (y + z) = (z + y) + x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : nat, x + (y + z) = z + y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk120" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk120"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : nat, x + (y + z) = z + y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk121" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk121"><span class="highlight"><span class="nb">intros</span> x y z.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x + (y + z) = z + y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk122" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk122"><span class="highlight"><span class="nb">rewrite</span> plus_comm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y + z + x = z + y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk123" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk123"><span class="highlight"><span class="nb">assert</span> (H : y + z = z + y).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y + z = z + y</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk124" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y + z = z + y</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chk124"><hr></label><div class="goal-conclusion"><span class="highlight">y + z + x = z + y + x</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk125" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk125"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y + z = z + y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk126" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk126"><span class="highlight"><span class="nb">rewrite</span> plus_comm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">z + y = z + y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk127" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk127"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y + z = z + y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y + z + x = z + y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk128" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk128"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y + z = z + y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">z + y + x = z + y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
A more elegant alternative is to apply <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> directly to the
    arguments we want to instantiate it with, in much the same way as
    we apply a polymorphic function to a type argument. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk129" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk129"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">plus_comm3_take3</span> :
  <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, x + (y + z) = (z + y) + x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : nat, x + (y + z) = z + y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk12a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk12a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : nat, x + (y + z) = z + y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk12b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk12b"><span class="highlight"><span class="nb">intros</span> x y z.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x + (y + z) = z + y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk12c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk12c"><span class="highlight"><span class="nb">rewrite</span> plus_comm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y + z + x = z + y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk12d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk12d"><span class="highlight"><span class="nb">rewrite</span> (plus_comm y z).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">z + y + x = z + y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Let us show another example of using a theorem or lemma
    like a function. The following theorem says: any list <span class="inlinecode"><span class="id" title="var">l</span></span>
    containing some element must be nonempty. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk12e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk12e"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">in_not_nil</span> :
  <span class="kr">forall</span> <span class="nv">A</span> (<span class="nv">x</span> : A) (<span class="nv">l</span> : list A), In x l -&gt; l &lt;&gt; [].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : A) (<span class="nv">l</span> : list A),
In x l -&gt; l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk12f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk12f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : A) (<span class="nv">l</span> : list A),
In x l -&gt; l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk130" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk130"><span class="highlight"><span class="nb">intros</span> A x l H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk131" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk131"><span class="highlight"><span class="nb">unfold</span> not.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">l = [ ] -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk132" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk132"><span class="highlight"><span class="nb">intro</span> Hl.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">l = [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk133" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk133"><span class="highlight"><span class="nb">destruct</span> l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x [ ]</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">[ ] = [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk134" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, x0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x (x0 :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x0 :: l = [ ]</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chk134"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk135" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk135"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x [ ]</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">[ ] = [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk136" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk136"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">[ ] = [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk137" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk137"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, x0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x (x0 :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x0 :: l = [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span> Hl.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
What makes this interesting is that one quantified variable
    (<span class="inlinecode"><span class="id" title="var">x</span></span>) does not appear in the conclusion (<span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">‚â†</span> <span class="inlinecode">[]</span>). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We can use this lemma to prove the special case where <span class="inlinecode"><span class="id" title="var">x</span></span>
    is <span class="inlinecode">42</span>. Naively, the tactic <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">in_not_nil</span></span> will fail because
    it cannot infer the value of <span class="inlinecode"><span class="id" title="var">x</span></span>. There are several ways to work
    around that... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk138" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk138"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">in_not_nil_42</span> :
  <span class="kr">forall</span> <span class="nv">l</span> : list nat, In <span class="mi">42</span> l -&gt; l &lt;&gt; [].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list nat, In <span class="mi">42</span> l -&gt; l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk139" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk139"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list nat, In <span class="mi">42</span> l -&gt; l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk13a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk13a"><span class="highlight"><span class="nb">intros</span> l H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In <span class="mi">42</span> l</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Logic-v-chk13b" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="Logic-v-chk13b"><span class="highlight"><span class="nb">apply</span> in_not_nil.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">Unable to find an instance <span class="kr">for</span> the variable x.</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* [apply ... with ...] *)</span>
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk13c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk13c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">in_not_nil_42_take2</span> :
  <span class="kr">forall</span> <span class="nv">l</span> : list nat, In <span class="mi">42</span> l -&gt; l &lt;&gt; [].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list nat, In <span class="mi">42</span> l -&gt; l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk13d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk13d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list nat, In <span class="mi">42</span> l -&gt; l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk13e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk13e"><span class="highlight"><span class="nb">intros</span> l H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In <span class="mi">42</span> l</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk13f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk13f"><span class="highlight"><span class="nb">apply</span> in_not_nil <span class="kr">with</span> (x := <span class="mi">42</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In <span class="mi">42</span> l</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In <span class="mi">42</span> l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* [apply ... in ...] *)</span>
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk140" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk140"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">in_not_nil_42_take3</span> :
  <span class="kr">forall</span> <span class="nv">l</span> : list nat, In <span class="mi">42</span> l -&gt; l &lt;&gt; [].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list nat, In <span class="mi">42</span> l -&gt; l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk141" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk141"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list nat, In <span class="mi">42</span> l -&gt; l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk142" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk142"><span class="highlight"><span class="nb">intros</span> l H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In <span class="mi">42</span> l</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk143" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk143"><span class="highlight"><span class="nb">apply</span> in_not_nil <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">l &lt;&gt; [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* Explicitly apply the lemma to the value for [x]. *)</span>
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk144" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk144"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">in_not_nil_42_take4</span> :
  <span class="kr">forall</span> <span class="nv">l</span> : list nat, In <span class="mi">42</span> l -&gt; l &lt;&gt; [].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list nat, In <span class="mi">42</span> l -&gt; l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk145" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk145"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list nat, In <span class="mi">42</span> l -&gt; l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk146" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk146"><span class="highlight"><span class="nb">intros</span> l H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In <span class="mi">42</span> l</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk147" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk147"><span class="highlight"><span class="nb">apply</span> (in_not_nil nat <span class="mi">42</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In <span class="mi">42</span> l</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In <span class="mi">42</span> l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* Explicitly apply the lemma to a hypothesis. *)</span>
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk148" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk148"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">in_not_nil_42_take5</span> :
  <span class="kr">forall</span> <span class="nv">l</span> : list nat, In <span class="mi">42</span> l -&gt; l &lt;&gt; [].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list nat, In <span class="mi">42</span> l -&gt; l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk149" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk149"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list nat, In <span class="mi">42</span> l -&gt; l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk14a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk14a"><span class="highlight"><span class="nb">intros</span> l H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In <span class="mi">42</span> l</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">l &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> (in_not_nil _ _ _ H).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
You can "use theorems as functions" in this way with almost all
    tactics that take a theorem name as an argument.  Note also that
    theorem application uses the same inference mechanisms as function
    application; thus, it is possible, for example, to supply
    wildcards as arguments to be inferred, or to declare some
    hypotheses to a theorem as implicit by default.  These features
    are illustrated in the proof below. (The details of how this proof
    works are not critical -- the goal here is just to illustrate what
    can be done.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk14b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk14b"><span class="highlight"><span class="kn">Example</span> <span class="nf">lemma_application_ex</span> :
  <span class="kr">forall</span> {<span class="nv">n</span> : nat} {<span class="nv">ns</span> : list nat},
    In n (map (<span class="kr">fun</span> <span class="nv">m</span> =&gt; m * <span class="mi">0</span>) ns) -&gt;
    n = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">ns</span> : list nat),
In n (map (<span class="kr">fun</span> <span class="nv">m</span> : nat =&gt; m * <span class="mi">0</span>) ns) -&gt; n = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk14c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk14c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">ns</span> : list nat),
In n (map (<span class="kr">fun</span> <span class="nv">m</span> : nat =&gt; m * <span class="mi">0</span>) ns) -&gt; n = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk14d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk14d"><span class="highlight"><span class="nb">intros</span> n ns H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">ns</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In n (map (<span class="kr">fun</span> <span class="nv">m</span> : nat =&gt; m * <span class="mi">0</span>) ns)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk14e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk14e"><span class="highlight"><span class="nb">destruct</span> (proj1 _ _ (In_map_iff _ _ _ _ _) H)
           <span class="kr">as</span> [m [Hm _]].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">ns</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In n (map (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt; m0 * <span class="mi">0</span>) ns)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m * <span class="mi">0</span> = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk14f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk14f"><span class="highlight"><span class="nb">rewrite</span> mult_0_r <span class="kr">in</span> Hm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">ns</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In n (map (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt; m0 * <span class="mi">0</span>) ns)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk150" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk150"><span class="highlight"><span class="nb">rewrite</span> &lt;- Hm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">ns</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In n (map (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt; m0 * <span class="mi">0</span>) ns)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
We will see many more examples in later chapters. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab29"></a><h1 class="section">Coq vs. Set Theory</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Coq's logical core, the <i>Calculus of Inductive
    Constructions</i>, differs in some important ways from other formal
    systems that are used by mathematicians to write down precise and
    rigorous proofs.  For example, in the most popular foundation for
    paper-and-pencil mathematics, Zermelo-Fraenkel Set Theory (ZFC), a
    mathematical object can potentially be a member of many different
    sets; a term in Coq's logic, on the other hand, is a member of at
    most one type.  This difference often leads to slightly different
    ways of capturing informal mathematical concepts, but these are,
    by and large, about equally natural and easy to work with.  For
    example, instead of saying that a natural number <span class="inlinecode"><span class="id" title="var">n</span></span> belongs to
    the set of even numbers, we would say in Coq that <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> holds,
    where <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> is a property describing even numbers.

<div class="paragraph"> </div>

    However, there are some cases where translating standard
    mathematical reasoning into Coq can be cumbersome or sometimes
    even impossible, unless we enrich the core logic with additional
    axioms.

<div class="paragraph"> </div>

    We conclude this chapter with a brief discussion of some of the
    most significant differences between the two worlds. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab30"></a><h2 class="section">Functional Extensionality</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The equality assertions that we have seen so far mostly have
    concerned elements of inductive types (<span class="inlinecode"><span class="id" title="var">nat</span></span>, <span class="inlinecode"><span class="id" title="var">bool</span></span>, etc.).  But
    since Coq's equality operator is polymorphic, these are not the
    only possibilities -- in particular, we can write propositions
    claiming that two <i>functions</i> are equal to each other: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk151" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk151"><span class="highlight"><span class="kn">Example</span> <span class="nf">function_equality_ex1</span> :
  (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="mi">3</span> + x) = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (pred <span class="mi">4</span>) + x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; <span class="mi">3</span> + x) =
(<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; Nat.pred <span class="mi">4</span> + x)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk152" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk152"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; <span class="mi">3</span> + x) =
(<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; Nat.pred <span class="mi">4</span> + x)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
In common mathematical practice, two functions <span class="inlinecode"><span class="id" title="var">f</span></span> and <span class="inlinecode"><span class="id" title="var">g</span></span> are
    considered equal if they produce the same outputs:

<div class="paragraph"> </div>

    (forall x, f x = g x) -&gt; f = g

<div class="paragraph"> </div>

    This is known as the principle of <i>functional extensionality</i>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Informally speaking, an "extensional property" is one that
    pertains to an object's observable behavior.  Thus, functional
    extensionality simply means that a function's identity is
    completely determined by what we can observe from it -- i.e., in
    Coq terms, the results we obtain after applying it. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Functional extensionality is not part of Coq's built-in logic.
    This means that some "reasonable" propositions are not provable. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk153" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk153"><span class="highlight"><span class="kn">Example</span> <span class="nf">function_equality_ex2</span> :
  (<span class="kr">fun</span> <span class="nv">x</span> =&gt; plus x <span class="mi">1</span>) = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; plus <span class="mi">1</span> x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x + <span class="mi">1</span>) = (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; <span class="mi">1</span> + x)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk154" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk154"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x + <span class="mi">1</span>) = (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; <span class="mi">1</span> + x)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">   <span class="c">(* Stuck *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><div class="doc">
However, we can add functional extensionality to Coq's core using
    the <span class="inlinecode"><span class="id" title="keyword">Axiom</span></span> command. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">functional_extensionality</span> : <span class="kr">forall</span> {<span class="nv">X</span> <span class="nv">Y</span>: <span class="kt">Type</span>}
                                    {<span class="nv">f</span> <span class="nv">g</span> : X -&gt; Y},
  (<span class="kr">forall</span> (<span class="nv">x</span>:X), f x = g x) -&gt; f = g.</span></span></span></pre><div class="doc">
Using <span class="inlinecode"><span class="id" title="keyword">Axiom</span></span> has the same effect as stating a theorem and
    skipping its proof using <span class="inlinecode"><span class="id" title="var">Admitted</span></span>, but it alerts the reader that
    this isn't just something we're going to come back and fill in
    later! 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We can now invoke functional extensionality in proofs: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk155" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk155"><span class="highlight"><span class="kn">Example</span> <span class="nf">function_equality_ex2</span> :
  (<span class="kr">fun</span> <span class="nv">x</span> =&gt; plus x <span class="mi">1</span>) = (<span class="kr">fun</span> <span class="nv">x</span> =&gt; plus <span class="mi">1</span> x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x + <span class="mi">1</span>) = (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; <span class="mi">1</span> + x)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk156" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk156"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x + <span class="mi">1</span>) = (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; <span class="mi">1</span> + x)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk157" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk157"><span class="highlight"><span class="nb">apply</span> functional_extensionality.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : nat, x + <span class="mi">1</span> = <span class="mi">1</span> + x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk158" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk158"><span class="highlight"><span class="nb">intros</span> x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x + <span class="mi">1</span> = <span class="mi">1</span> + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> plus_comm.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Naturally, we must be careful when adding new axioms into Coq's
    logic, as they may render it <i>inconsistent</i> -- that is, they may
    make it possible to prove every proposition, including <span class="inlinecode"><span class="id" title="var">False</span></span>,
    <span class="inlinecode">2+2=5</span>, etc.!

<div class="paragraph"> </div>

    Unfortunately, there is no simple way of telling whether an axiom
    is safe to add: hard work by highly-trained trained experts is
    generally required to establish the consistency of any particular
    combination of axioms.

<div class="paragraph"> </div>

    Fortunately, it is known that adding functional extensionality, in
    particular, <i>is</i> consistent. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
To check whether a particular proof relies on any additional
    axioms, use the <span class="inlinecode"><span class="id" title="keyword">Print</span></span> <span class="inlinecode"><span class="id" title="keyword">Assumptions</span></span> command.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Logic-v-chk159" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk159"><span class="highlight"><span class="kn">Print Assumptions</span> function_equality_ex2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight"><span class="kn">Axioms</span>:
plus_comm : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n
functional_extensionality : <span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>)
                              (<span class="nv">f</span> <span class="nv">g</span> : X -&gt; Y),
                            (<span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x) -&gt;
                            f = g</span></blockquote></div></div></small></span></pre><div class="doc">
<a name="lab31"></a><h4 class="section">Exercise: 4 stars, standard (tr_rev_correct)</h4>
<div class="paragraph"> </div>

    One problem with the definition of the list-reversing function
    <span class="inlinecode"><span class="id" title="var">rev</span></span> that we have is that it performs a call to <span class="inlinecode"><span class="id" title="var">app</span></span> on each
    step; running <span class="inlinecode"><span class="id" title="var">app</span></span> takes time asymptotically linear in the size
    of the list, which means that <span class="inlinecode"><span class="id" title="var">rev</span></span> has quadratic running time.
    We can improve this with the following definition: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">rev_append</span> {<span class="nv">X</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list X) : list X :=
  <span class="kr">match</span> l1 <span class="kr">with</span>
  | [] =&gt; l2
  | x :: l1&#39; =&gt; rev_append l1&#39; (x :: l2)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">tr_rev</span> {<span class="nv">X</span>} (<span class="nv">l</span> : list X) : list X :=
  rev_append l [].</span></span></span></pre><div class="doc">
This version is said to be <i>tail-recursive</i>, because the recursive
    call to the function is the last operation that needs to be
    performed (i.e., we don't have to execute <span class="inlinecode">++</span> after the recursive
    call); a decent compiler will generate very efficient code in this
    case.  Prove that the two definitions are indeed equivalent. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk15a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk15a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">tr_rev_correct</span> : <span class="kr">forall</span> <span class="nv">X</span>, @tr_rev X = @rev X.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, tr_rev = rev</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab32"></a><h2 class="section">Propositions and Booleans</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We've seen two different ways of expressing logical claims in Coq:
    with <i>booleans</i> (of type <span class="inlinecode"><span class="id" title="var">bool</span></span>), and with <i>propositions</i> (of type
    <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>).

<div class="paragraph"> </div>

    For instance, to claim that a number <span class="inlinecode"><span class="id" title="var">n</span></span> is even, we can say
    either... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
... that <span class="inlinecode"><span class="id" title="var">evenb</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> evaluates to <span class="inlinecode"><span class="id" title="var">true</span></span>... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk15b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk15b"><span class="highlight"><span class="kn">Example</span> <span class="nf">even_42_bool</span> : evenb <span class="mi">42</span> = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb <span class="mi">42</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk15c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk15c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb <span class="mi">42</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
... or that there exists some <span class="inlinecode"><span class="id" title="var">k</span></span> such that <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">double</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk15d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk15d"><span class="highlight"><span class="kn">Example</span> <span class="nf">even_42_prop</span> : <span class="kr">exists</span> <span class="nv">k</span>, <span class="mi">42</span> = double k.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, <span class="mi">42</span> = double k</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk15e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk15e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, <span class="mi">42</span> = double k</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk15f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk15f"><span class="highlight"><span class="kr">exists</span> <span class="mi">21</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">42</span> = double <span class="mi">21</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Of course, it would be pretty strange if these two
    characterizations of evenness did not describe the same set of
    natural numbers!  Fortunately, we can prove that they do... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We first need two helper lemmas. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk160" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk160"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">evenb_double</span> : <span class="kr">forall</span> <span class="nv">k</span>, evenb (double k) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : nat, evenb (double k) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk161" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk161"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : nat, evenb (double k) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk162" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk162"><span class="highlight"><span class="nb">intros</span> k.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb (double k) = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk163" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk163"><span class="highlight"><span class="nb">induction</span> k <span class="kr">as</span> [|k&#39; IHk&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb (double <span class="mi">0</span>) = true</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk164" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">k'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">evenb (double k&#39;) = true</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chk164"><hr></label><div class="goal-conclusion"><span class="highlight">evenb (double (S k&#39;)) = true</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk165" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk165"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb (double <span class="mi">0</span>) = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk166" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk166"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">k'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">evenb (double k&#39;) = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb (double (S k&#39;)) = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk167" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk167"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">k'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">evenb (double k&#39;) = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb (double k&#39;) = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> IHk&#39;.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab33"></a><h4 class="section">Exercise: 3 stars, standard (evenb_double_conv)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk168" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk168"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">evenb_double_conv</span> : <span class="kr">forall</span> <span class="nv">n</span>,
  <span class="kr">exists</span> <span class="nv">k</span>, n = <span class="kr">if</span> evenb n <span class="kr">then</span> double k
                <span class="kr">else</span> S (double k).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
<span class="kr">exists</span> <span class="nv">k</span> : nat,
  n = (<span class="kr">if</span> evenb n <span class="kr">then</span> double k <span class="kr">else</span> S (double k))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk169" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk169"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
<span class="kr">exists</span> <span class="nv">k</span> : nat,
  n = (<span class="kr">if</span> evenb n <span class="kr">then</span> double k <span class="kr">else</span> S (double k))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* Hint: Use the [evenb_S] lemma from [Induction.v]. *)</span>
  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk16a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk16a"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">even_bool_prop</span> : <span class="kr">forall</span> <span class="nv">n</span>,
  evenb n = true &lt;-&gt; <span class="kr">exists</span> <span class="nv">k</span>, n = double k.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
evenb n = true &lt;-&gt; (<span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk16b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk16b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
evenb n = true &lt;-&gt; (<span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk16c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk16c"><span class="highlight"><span class="nb">intros</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb n = true &lt;-&gt; (<span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk16d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk16d"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb n = true -&gt; <span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk16e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chk16e"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k) -&gt; evenb n = true</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk16f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk16f"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb n = true -&gt; <span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk170" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk170"><span class="highlight"><span class="nb">intros</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">evenb n = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk171" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk171"><span class="highlight"><span class="nb">destruct</span> (evenb_double_conv n) <span class="kr">as</span> [k Hk].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">evenb n = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hk</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = (<span class="kr">if</span> evenb n <span class="kr">then</span> double k <span class="kr">else</span> S (double k))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k0</span> : nat, n = double k0</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk172" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk172"><span class="highlight"><span class="nb">rewrite</span> Hk.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">evenb n = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hk</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = (<span class="kr">if</span> evenb n <span class="kr">then</span> double k <span class="kr">else</span> S (double k))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k0</span> : nat,
  (<span class="kr">if</span> evenb n <span class="kr">then</span> double k <span class="kr">else</span> S (double k)) =
  double k0</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk173" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk173"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">evenb n = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hk</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = (<span class="kr">if</span> evenb n <span class="kr">then</span> double k <span class="kr">else</span> S (double k))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k0</span> : nat, double k = double k0</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk174" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk174"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">evenb n = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hk</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = (<span class="kr">if</span> evenb n <span class="kr">then</span> double k <span class="kr">else</span> S (double k))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">double k = double k</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk175" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk175"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k) -&gt; evenb n = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk176" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk176"><span class="highlight"><span class="nb">intros</span> [k Hk].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, k</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hk</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = double k</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb n = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk177" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk177"><span class="highlight"><span class="nb">rewrite</span> Hk.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, k</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hk</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = double k</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb (double k) = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> evenb_double.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
In view of this theorem, we say that the boolean computation
    <span class="inlinecode"><span class="id" title="var">evenb</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> is reflected in the truth of the proposition <span class="inlinecode"><span class="id" title="tactic">‚àÉ</span></span> <span class="inlinecode"><span class="id" title="var">k</span>,</span>
<span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">double</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Similarly, to state that two numbers <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">m</span></span> are equal, we can
    say either
<ul class="doclist">
<li> (1) that <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span></span> returns <span class="inlinecode"><span class="id" title="var">true</span></span>, or

</li>
<li> (2) that <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>.

</li>
</ul>
    Again, these two notions are equivalent. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk178" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk178"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">eqb_eq</span> : <span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat,
  n1 =? n2 = true &lt;-&gt; n1 = n2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, (n1 =? n2) = true &lt;-&gt; n1 = n2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk179" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk179"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, (n1 =? n2) = true &lt;-&gt; n1 = n2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk17a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk17a"><span class="highlight"><span class="nb">intros</span> n1 n2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(n1 =? n2) = true &lt;-&gt; n1 = n2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk17b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk17b"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(n1 =? n2) = true -&gt; n1 = n2</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk17c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chk17c"><hr></label><div class="goal-conclusion"><span class="highlight">n1 = n2 -&gt; (n1 =? n2) = true</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk17d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk17d"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(n1 =? n2) = true -&gt; n1 = n2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> eqb_true.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk17e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk17e"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n1 = n2 -&gt; (n1 =? n2) = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk17f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk17f"><span class="highlight"><span class="nb">intros</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n1 = n2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(n1 =? n2) = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk180" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk180"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n1 = n2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(n2 =? n2) = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk181" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk181"><span class="highlight"><span class="nb">rewrite</span> &lt;- eqb_refl.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n1 = n2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
However, even when the boolean and propositional formulations of a
    claim are equivalent from a purely logical perspective, they may
    not be equivalent <i>operationally</i>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
In the case of even numbers above, when proving the
    backwards direction of <span class="inlinecode"><span class="id" title="var">even_bool_prop</span></span> (i.e., <span class="inlinecode"><span class="id" title="var">evenb_double</span></span>,
    going from the propositional to the boolean claim), we used a
    simple induction on <span class="inlinecode"><span class="id" title="var">k</span></span>.  On the other hand, the converse (the
    <span class="inlinecode"><span class="id" title="var">evenb_double_conv</span></span> exercise) required a clever generalization,
    since we can't directly prove
    <span class="inlinecode">(<span class="id" title="var">evenb</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span>)</span> <span class="inlinecode">‚Üí</span> <span class="inlinecode">(<span class="id" title="tactic">‚àÉ</span></span> <span class="inlinecode"><span class="id" title="var">k</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">double</span></span> <span class="inlinecode"><span class="id" title="var">k</span>)</span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
For these examples, the propositional claims are more useful than
    their boolean counterparts, but this is not always the case.  For
    instance, we cannot test whether a general proposition is true or
    not in a function definition; as a consequence, the following code
    fragment is rejected: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Logic-v-chk182" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="Logic-v-chk182"><span class="highlight"><span class="kn">Definition</span> <span class="nf">is_even_prime</span> <span class="nv">n</span> :=
  <span class="kr">if</span> n = <span class="mi">2</span> <span class="kr">then</span> true
  <span class="kr">else</span> false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">The term <span class="s2">&quot;n = 2&quot;</span> has type <span class="s2">&quot;Prop&quot;</span>
which <span class="kr">is</span> not a (co-)inductive type.</span></blockquote></div></div></small></span></pre><div class="doc">
Coq complains that <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">2</span> has type <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, while it expects
    an element of <span class="inlinecode"><span class="id" title="var">bool</span></span> (or some other inductive type with two
    elements).  The reason for this error message has to do with the
    <i>computational</i> nature of Coq's core language, which is designed
    so that every function that it can express is computable and
    total.  One reason for this is to allow the extraction of
    executable programs from Coq developments.  As a consequence,
    <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> in Coq does <i>not</i> have a universal case analysis operation
    telling whether any given proposition is true or false, since such
    an operation would allow us to write non-computable functions.

<div class="paragraph"> </div>

    Although general non-computable properties cannot be phrased as
    boolean computations, it is worth noting that even many
    <i>computable</i> properties are easier to express using <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> than
    <span class="inlinecode"><span class="id" title="var">bool</span></span>, since recursive function definitions are subject to
    significant restrictions in Coq.  For instance, the next chapter
    shows how to define the property that a regular expression matches
    a given string using <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.  Doing the same with <span class="inlinecode"><span class="id" title="var">bool</span></span> would
    amount to writing a regular expression matcher, which would be
    more complicated, harder to understand, and harder to reason
    about.

<div class="paragraph"> </div>

    Conversely, an important side benefit of stating facts using
    booleans is enabling some proof automation through computation
    with Coq terms, a technique known as <i>proof by
    reflection</i>.  Consider the following statement: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk183" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk183"><span class="highlight"><span class="kn">Example</span> <span class="nf">even_1000</span> : <span class="kr">exists</span> <span class="nv">k</span>, <span class="mi">1000</span> = double k.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, <span class="mi">1000</span> = double k</span></div></blockquote></div></div></small></span></pre><div class="doc">
The most direct proof of this fact is to give the value of <span class="inlinecode"><span class="id" title="var">k</span></span>
    explicitly. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk184" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk184"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, <span class="mi">1000</span> = double k</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk185" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk185"><span class="highlight"><span class="kr">exists</span> <span class="mi">500</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">1000</span> = double <span class="mi">500</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
On the other hand, the proof of the corresponding boolean
    statement is even simpler: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk186" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk186"><span class="highlight"><span class="kn">Example</span> <span class="nf">even_1000&#39;</span> : evenb <span class="mi">1000</span> = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb <span class="mi">1000</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk187" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk187"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb <span class="mi">1000</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
What is interesting is that, since the two notions are equivalent,
    we can use the boolean formulation to prove the other one without
    mentioning the value 500 explicitly: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk188" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk188"><span class="highlight"><span class="kn">Example</span> <span class="nf">even_1000&#39;&#39;</span> : <span class="kr">exists</span> <span class="nv">k</span>, <span class="mi">1000</span> = double k.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, <span class="mi">1000</span> = double k</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk189" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk189"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, <span class="mi">1000</span> = double k</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk18a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk18a"><span class="highlight"><span class="nb">apply</span> even_bool_prop.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb <span class="mi">1000</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Although we haven't gained much in terms of proof-script
    size in this case, larger proofs can often be made considerably
    simpler by the use of reflection.  As an extreme example, the Coq
    proof of the famous <i>4-color theorem</i> uses reflection to reduce
    the analysis of hundreds of different cases to a boolean
    computation. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Another notable difference is that the negation of a "boolean
    fact" is straightforward to state and prove: simply flip the
    expected boolean result. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk18b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk18b"><span class="highlight"><span class="kn">Example</span> <span class="nf">not_even_1001</span> : evenb <span class="mi">1001</span> = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb <span class="mi">1001</span> = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk18c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk18c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb <span class="mi">1001</span> = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
In contrast, propositional negation may be more difficult
    to grasp. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk18d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk18d"><span class="highlight"><span class="kn">Example</span> <span class="nf">not_even_1001&#39;</span> : ~(<span class="kr">exists</span> <span class="nv">k</span>, <span class="mi">1001</span> = double k).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (<span class="kr">exists</span> <span class="nv">k</span> : nat, <span class="mi">1001</span> = double k)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk18e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk18e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (<span class="kr">exists</span> <span class="nv">k</span> : nat, <span class="mi">1001</span> = double k)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk18f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk18f"><span class="highlight"><span class="nb">rewrite</span> &lt;- even_bool_prop.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb <span class="mi">1001</span> &lt;&gt; true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk190" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk190"><span class="highlight"><span class="nb">unfold</span> not.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">evenb <span class="mi">1001</span> = true -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk191" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk191"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">false = true -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk192" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk192"><span class="highlight"><span class="nb">intro</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">false = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Equality provides a complementary example: knowing that
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> is generally of little direct help in the middle
    of a proof involving <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">m</span></span>; however, if we convert the
    statement to the equivalent form <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>, we can rewrite with it.
 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk193" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk193"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">plus_eqb_example</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span> : nat,
    n =? m = true -&gt; n + p =? m + p = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span> : nat,
(n =? m) = true -&gt; (n + p =? m + p) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk194" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk194"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span> : nat,
(n =? m) = true -&gt; (n + p =? m + p) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk195" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk195"><span class="highlight"><span class="nb">intros</span> n m p H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(n =? m) = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(n + p =? m + p) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk196" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk196"><span class="highlight"><span class="nb">rewrite</span> eqb_eq <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(n + p =? m + p) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk197" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk197"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m + p =? m + p) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk198" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk198"><span class="highlight"><span class="nb">rewrite</span> eqb_eq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m + p = m + p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
We won't cover reflection in much detail, but it serves as a good
    example showing the complementary strengths of booleans and
    general propositions. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab34"></a><h4 class="section">Exercise: 2 stars, standard (logical_connectives)</h4>
<div class="paragraph"> </div>

    The following lemmas relate the propositional connectives studied
    in this chapter to the corresponding boolean operations. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk199" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk199"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">andb_true_iff</span> : <span class="kr">forall</span> <span class="nv">b1</span> <span class="nv">b2</span>:bool,
  b1 &amp;&amp; b2 = true &lt;-&gt; b1 = true /\ b2 = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b1</span> <span class="nv">b2</span> : bool,
b1 &amp;&amp; b2 = true &lt;-&gt; b1 = true /\ b2 = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk19a" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk19a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b1</span> <span class="nv">b2</span> : bool,
b1 &amp;&amp; b2 = true &lt;-&gt; b1 = true /\ b2 = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk19b" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk19b"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">orb_true_iff</span> : <span class="kr">forall</span> <span class="nv">b1</span> <span class="nv">b2</span>,
  b1 || b2 = true &lt;-&gt; b1 = true \/ b2 = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b1</span> <span class="nv">b2</span> : bool,
b1 || b2 = true &lt;-&gt; b1 = true \/ b2 = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk19c" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk19c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b1</span> <span class="nv">b2</span> : bool,
b1 || b2 = true &lt;-&gt; b1 = true \/ b2 = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab35"></a><h4 class="section">Exercise: 1 star, standard (eqb_neq)</h4>
<div class="paragraph"> </div>

    The following theorem is an alternate "negative" formulation of
    <span class="inlinecode"><span class="id" title="var">eqb_eq</span></span> that is more convenient in certain
    situations (we'll see examples in later chapters). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk19d" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk19d"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">eqb_neq</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : nat,
  x =? y = false &lt;-&gt; x &lt;&gt; y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : nat, (x =? y) = false &lt;-&gt; x &lt;&gt; y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk19e" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk19e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : nat, (x =? y) = false &lt;-&gt; x &lt;&gt; y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab36"></a><h4 class="section">Exercise: 3 stars, standard (eqb_list)</h4>
<div class="paragraph"> </div>

    Given a boolean operator <span class="inlinecode"><span class="id" title="var">eqb</span></span> for testing equality of elements of
    some type <span class="inlinecode"><span class="id" title="var">A</span></span>, we can define a function <span class="inlinecode"><span class="id" title="var">eqb_list</span></span> for testing
    equality of lists with elements in <span class="inlinecode"><span class="id" title="var">A</span></span>.  Complete the definition
    of the <span class="inlinecode"><span class="id" title="var">eqb_list</span></span> function below.  To make sure that your
    definition is correct, prove the lemma <span class="inlinecode"><span class="id" title="var">eqb_list_true_iff</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk19f" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk19f"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">eqb_list</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">eqb</span> : A -&gt; A -&gt; bool)
                  (<span class="nv">l1</span> <span class="nv">l2</span> : list A) : bool
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">eqb_list</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">A0</span> : <span class="kt">Type</span>,
(A0 -&gt; A0 -&gt; bool) -&gt;
list A0 -&gt; list A0 -&gt; bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; A -&gt; bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1, l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">bool</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1a0" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1a0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">eqb_list_true_iff</span> :
  <span class="kr">forall</span> <span class="nv">A</span> (<span class="nv">eqb</span> : A -&gt; A -&gt; bool),
    (<span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span>, eqb a1 a2 = true &lt;-&gt; a1 = a2) -&gt;
    <span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span>, eqb_list eqb l1 l2 = true &lt;-&gt; l1 = l2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">eqb</span> : A -&gt; A -&gt; bool),
(<span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : A, eqb a1 a2 = true &lt;-&gt; a1 = a2) -&gt;
<span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
eqb_list eqb l1 l2 = true &lt;-&gt; l1 = l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1a1" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1a1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">eqb</span> : A -&gt; A -&gt; bool),
(<span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : A, eqb a1 a2 = true &lt;-&gt; a1 = a2) -&gt;
<span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
eqb_list eqb l1 l2 = true &lt;-&gt; l1 = l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab37"></a><h4 class="section">Exercise: 2 stars, standard, recommended (All_forallb)</h4>
<div class="paragraph"> </div>

    Recall the function <span class="inlinecode"><span class="id" title="var">forallb</span></span>, from the exercise
    <span class="inlinecode"><span class="id" title="var">forall_exists_challenge</span></span> in chapter <span class="inlinecode"><span class="id" title="var">Tactics</span></span>: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">forallb</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">test</span> : X -&gt; bool) (<span class="nv">l</span> : list X) : bool :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; true
  | x :: l&#39; =&gt; andb (test x) (forallb test l&#39;)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Prove the theorem below, which relates <span class="inlinecode"><span class="id" title="var">forallb</span></span> to the <span class="inlinecode"><span class="id" title="keyword">All</span></span>
    property of the above exercise. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1a2" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1a2"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">forallb_true_iff</span> : <span class="kr">forall</span> <span class="nv">X</span> <span class="nv">test</span> (<span class="nv">l</span> : list X),
   forallb test l = true &lt;-&gt; All (<span class="kr">fun</span> <span class="nv">x</span> =&gt; test x = true) l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">test</span> : X -&gt; bool) (<span class="nv">l</span> : list X),
forallb test l = true &lt;-&gt;
All (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; test x = true) l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1a3" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1a3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">test</span> : X -&gt; bool) (<span class="nv">l</span> : list X),
forallb test l = true &lt;-&gt;
All (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; test x = true) l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
Are there any important properties of the function <span class="inlinecode"><span class="id" title="var">forallb</span></span> which
    are not captured by this specification? 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE </span>

<span class="c">    [] *)</span>

<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab38"></a><h2 class="section">Classical vs. Constructive Logic</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We have seen that it is not possible to test whether or not a
    proposition <span class="inlinecode"><span class="id" title="var">P</span></span> holds while defining a Coq function.  You may be
    surprised to learn that a similar restriction applies to <i>proofs</i>!
    In other words, the following intuitive reasoning principle is not
    derivable in Coq: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">excluded_middle</span> := <span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>,
  P \/ ~ P.</span></span></span></pre><div class="doc">
To understand operationally why this is the case, recall
    that, to prove a statement of the form <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">‚à®</span> <span class="inlinecode"><span class="id" title="var">Q</span></span>, we use the <span class="inlinecode"><span class="id" title="tactic">left</span></span>
    and <span class="inlinecode"><span class="id" title="tactic">right</span></span> tactics, which effectively require knowing which side
    of the disjunction holds.  But the universally quantified <span class="inlinecode"><span class="id" title="var">P</span></span> in
    <span class="inlinecode"><span class="id" title="var">excluded_middle</span></span> is an <i>arbitrary</i> proposition, which we know
    nothing about.  We don't have enough information to choose which
    of <span class="inlinecode"><span class="id" title="tactic">left</span></span> or <span class="inlinecode"><span class="id" title="tactic">right</span></span> to apply, just as Coq doesn't have enough
    information to mechanically decide whether <span class="inlinecode"><span class="id" title="var">P</span></span> holds or not inside
    a function. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
However, if we happen to know that <span class="inlinecode"><span class="id" title="var">P</span></span> is reflected in some
    boolean term <span class="inlinecode"><span class="id" title="var">b</span></span>, then knowing whether it holds or not is trivial:
    we just have to check the value of <span class="inlinecode"><span class="id" title="var">b</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1a4" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1a4"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">restricted_excluded_middle</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">b</span>,
  (P &lt;-&gt; b = true) -&gt; P \/ ~ P.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">b</span> : bool),
P &lt;-&gt; b = true -&gt; P \/ ~ P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1a5" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1a5"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">b</span> : bool),
P &lt;-&gt; b = true -&gt; P \/ ~ P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1a6" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1a6"><span class="highlight"><span class="nb">intros</span> P [] H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; true = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P \/ ~ P</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Logic-v-chk1a7" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; false = true</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Logic-v-chk1a7"><hr></label><div class="goal-conclusion"><span class="highlight">P \/ ~ P</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1a8" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1a8"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; true = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P \/ ~ P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1a9" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1a9"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; true = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1aa" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1aa"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; true = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1ab" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1ab"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; false = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P \/ ~ P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1ac" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1ac"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; false = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1ad" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1ad"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; false = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">false &lt;&gt; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1ae" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1ae"><span class="highlight"><span class="nb">intros</span> contra.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; false = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">contra</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">false = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span> contra.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
In particular, the excluded middle is valid for equations <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>,
    between natural numbers <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1af" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1af"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">restricted_excluded_middle_eq</span> : <span class="kr">forall</span> (<span class="nv">n</span> <span class="nv">m</span> : nat),
  n = m \/ n &lt;&gt; m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = m \/ n &lt;&gt; m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1b0" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1b0"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = m \/ n &lt;&gt; m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1b1" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1b1"><span class="highlight"><span class="nb">intros</span> n m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = m \/ n &lt;&gt; m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1b2" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1b2"><span class="highlight"><span class="nb">apply</span> (restricted_excluded_middle (n = m) (n =? m)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = m &lt;-&gt; (n =? m) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1b3" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1b3"><span class="highlight"><span class="nb">symmetry</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(n =? m) = true &lt;-&gt; n = m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> eqb_eq.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
It may seem strange that the general excluded middle is not
    available by default in Coq; after all, any given claim must be
    either true or false.  Nonetheless, there is an advantage in not
    assuming the excluded middle: statements in Coq can make stronger
    claims than the analogous statements in standard mathematics.
    Notably, if there is a Coq proof of <span class="inlinecode"><span class="id" title="tactic">‚àÉ</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, it is
    possible to explicitly exhibit a value of <span class="inlinecode"><span class="id" title="var">x</span></span> for which we can
    prove <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> -- in other words, every proof of existence is
    necessarily <i>constructive</i>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Logics like Coq's, which do not assume the excluded middle, are
    referred to as <i>constructive logics</i>.

<div class="paragraph"> </div>

    More conventional logical systems such as ZFC, in which the
    excluded middle does hold for arbitrary propositions, are referred
    to as <i>classical</i>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The following example illustrates why assuming the excluded middle
    may lead to non-constructive proofs:

<div class="paragraph"> </div>
<i>Claim</i>: There exist irrational numbers <span class="inlinecode"><span class="id" title="var">a</span></span> and <span class="inlinecode"><span class="id" title="var">b</span></span> such that <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">^</span>
<span class="inlinecode"><span class="id" title="var">b</span></span> is rational.

<div class="paragraph"> </div>
<i>Proof</i>: It is not difficult to show that <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> is irrational.
    If <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> is rational, it suffices to take <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span>
<span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> and we are done.  Otherwise, <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> is
    irrational.  In this case, we can take <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> and
    <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span>, since <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode">(<span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">√ó</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span>
<span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">2</span>.  <font size="-2">‚òê</font>
<div class="paragraph"> </div>

    Do you see what happened here?  We used the excluded middle to
    consider separately the cases where <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> is rational
    and where it is not, without knowing which one actually holds!
    Because of that, we wind up knowing that such <span class="inlinecode"><span class="id" title="var">a</span></span> and <span class="inlinecode"><span class="id" title="var">b</span></span> exist
    but we cannot determine what their actual values are (at least,
    using this line of argument).

<div class="paragraph"> </div>

    As useful as constructive logic is, it does have its limitations:
    There are many statements that can easily be proven in classical
    logic but that have much more complicated constructive proofs, and
    there are some that are known to have no constructive proof at
    all!  Fortunately, like functional extensionality, the excluded
    middle is known to be compatible with Coq's logic, allowing us to
    add it safely as an axiom.  However, we will not need to do so in
    this book: the results that we cover can be developed entirely
    within constructive logic at negligible extra cost.

<div class="paragraph"> </div>

    It takes some practice to understand which proof techniques must
    be avoided in constructive reasoning, but arguments by
    contradiction, in particular, are infamous for leading to
    non-constructive proofs.  Here's a typical example: suppose that
    we want to show that there exists <span class="inlinecode"><span class="id" title="var">x</span></span> with some property <span class="inlinecode"><span class="id" title="var">P</span></span>,
    i.e., such that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.  We start by assuming that our conclusion
    is false; that is, <span class="inlinecode">¬¨</span> <span class="inlinecode"><span class="id" title="tactic">‚àÉ</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. From this premise, it is not
    hard to derive <span class="inlinecode"><span class="id" title="keyword">‚àÄ</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode">¬¨</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.  If we manage to show that this
    intermediate fact results in a contradiction, we arrive at an
    existence proof without ever exhibiting a value of <span class="inlinecode"><span class="id" title="var">x</span></span> for which
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> holds!

<div class="paragraph"> </div>

    The technical flaw here, from a constructive standpoint, is that
    we claimed to prove <span class="inlinecode"><span class="id" title="tactic">‚àÉ</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> using a proof of
    <span class="inlinecode">¬¨</span> <span class="inlinecode">¬¨</span> <span class="inlinecode">(<span class="id" title="tactic">‚àÉ</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span>.  Allowing ourselves to remove double
    negations from arbitrary statements is equivalent to assuming the
    excluded middle, as shown in one of the exercises below.  Thus,
    this line of reasoning cannot be encoded in Coq without assuming
    additional axioms. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab39"></a><h4 class="section">Exercise: 3 stars, standard (excluded_middle_irrefutable)</h4>
<div class="paragraph"> </div>

    Proving the consistency of Coq with the general excluded middle
    axiom requires complicated reasoning that cannot be carried out
    within Coq itself.  However, the following theorem implies that it
    is always safe to assume a decidability axiom (i.e., an instance
    of excluded middle) for any <i>particular</i> Prop <span class="inlinecode"><span class="id" title="var">P</span></span>.  Why?  Because
    we cannot prove the negation of such an axiom.  If we could, we
    would have both <span class="inlinecode">¬¨</span> <span class="inlinecode">(<span class="id" title="var">P</span></span> <span class="inlinecode">‚à®</span> <span class="inlinecode">¬¨<span class="id" title="var">P</span>)</span> and <span class="inlinecode">¬¨</span> <span class="inlinecode">¬¨</span> <span class="inlinecode">(<span class="id" title="var">P</span></span> <span class="inlinecode">‚à®</span> <span class="inlinecode">¬¨<span class="id" title="var">P</span>)</span> (since <span class="inlinecode"><span class="id" title="var">P</span></span>
    implies <span class="inlinecode">¬¨</span> <span class="inlinecode">¬¨</span> <span class="inlinecode"><span class="id" title="var">P</span></span>, by the exercise below), which would be a
    contradiction.  But since we can't, it is safe to add <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">‚à®</span> <span class="inlinecode">¬¨<span class="id" title="var">P</span></span> as
    an axiom. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1b4" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1b4"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">excluded_middle_irrefutable</span>: <span class="kr">forall</span> (<span class="nv">P</span>:<span class="kt">Prop</span>),
  ~ ~ (P \/ ~ P).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, ~ ~ (P \/ ~ P)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1b5" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1b5"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, ~ ~ (P \/ ~ P)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab40"></a><h4 class="section">Exercise: 3 stars, advanced (not_exists_dist)</h4>
<div class="paragraph"> </div>

    It is a theorem of classical logic that the following two
    assertions are equivalent:

<div class="paragraph"> </div>

    ~ (exists x, ~ P x)
    forall x, P x

<div class="paragraph"> </div>

    The <span class="inlinecode"><span class="id" title="var">dist_not_exists</span></span> theorem above proves one side of this
    equivalence. Interestingly, the other direction cannot be proved
    in constructive logic. Your job is to show that it is implied by
    the excluded middle. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1b6" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1b6"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">not_exists_dist</span> :
  excluded_middle -&gt;
  <span class="kr">forall</span> (<span class="nv">X</span>:<span class="kt">Type</span>) (<span class="nv">P</span> : X -&gt; <span class="kt">Prop</span>),
    ~ (<span class="kr">exists</span> <span class="nv">x</span>, ~ P x) -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, P x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">excluded_middle -&gt;
<span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : X -&gt; <span class="kt">Prop</span>),
~ (<span class="kr">exists</span> <span class="nv">x</span> : X, ~ P x) -&gt; <span class="kr">forall</span> <span class="nv">x</span> : X, P x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Logic-v-chk1b7" style="display: none" type="checkbox"><label class="coq-input" for="Logic-v-chk1b7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">excluded_middle -&gt;
<span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : X -&gt; <span class="kt">Prop</span>),
~ (<span class="kr">exists</span> <span class="nv">x</span> : X, ~ P x) -&gt; <span class="kr">forall</span> <span class="nv">x</span> : X, P x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab41"></a><h4 class="section">Exercise: 5 stars, standard, optional (classical_axioms)</h4>
<div class="paragraph"> </div>

    For those who like a challenge, here is an exercise taken from the
    Coq'Art book by Bertot and Casteran (p. 123).  Each of the
    following four statements, together with <span class="inlinecode"><span class="id" title="var">excluded_middle</span></span>, can be
    considered as characterizing classical logic.  We can't prove any
    of them in Coq, but we can consistently add any one of them as an
    axiom if we wish to work in classical logic.

<div class="paragraph"> </div>

    Prove that all five propositions (these four plus
    <span class="inlinecode"><span class="id" title="var">excluded_middle</span></span>) are equivalent. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">peirce</span> := <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span>: <span class="kt">Prop</span>,
  ((P-&gt;Q)-&gt;P)-&gt;P.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">double_negation_elimination</span> := <span class="kr">forall</span> <span class="nv">P</span>:<span class="kt">Prop</span>,
  ~~P -&gt; P.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">de_morgan_not_and_not</span> := <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span>:<span class="kt">Prop</span>,
  ~(~P /\ ~Q) -&gt; P\/Q.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">implies_to_or</span> := <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span>:<span class="kt">Prop</span>,
  (P-&gt;Q) -&gt; (~P\/Q).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* FILL IN HERE </span>

<span class="c">    [] *)</span>

<span class="c">(* Wed Jan 9 12:02:45 EST 2019 *)</span></span></span></pre></article></body></html>