<!DOCTYPE html>
<html><head><title>Maps.v</title><meta charset="utf-8"><meta content="Alectryon v0.2" name="generator"><link href="alectryon.css" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script><style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-standalone alectryon-centered alectryon-coqdoc"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><div class="doc">
<a name="lab1"></a><h1 class="section">Maps: Total and Partial Maps</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<i>Maps</i> (or <i>dictionaries</i>) are ubiquitous data structures both
    generally and in the theory of programming languages in
    particular; we're going to need them in many places in the coming
    chapters.  They also make a nice case study using ideas we've seen
    in previous chapters, including building data structures out of
    higher-order functions (from <span class="inlinecode"><span class="id" title="var">Basics</span></span> and <span class="inlinecode"><span class="id" title="var">Poly</span></span>) and the use of
    reflection to streamline proofs (from <span class="inlinecode"><span class="id" title="var">IndProp</span></span>).

<div class="paragraph"> </div>

    We'll define two flavors of maps: <i>total</i> maps, which include a
    "default" element to be returned when a key being looked up
    doesn't exist, and <i>partial</i> maps, which return an <span class="inlinecode"><span class="id" title="var">option</span></span> to
    indicate success or failure.  The latter is defined in terms of
    the former, using <span class="inlinecode"><span class="id" title="var">None</span></span> as the default element. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab2"></a><h1 class="section">The Coq Standard Library</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
One small digression before we begin...

<div class="paragraph"> </div>

    Unlike the chapters we have seen so far, this one does not
    <span class="inlinecode"><span class="id" title="keyword">Require</span></span> <span class="inlinecode"><span class="id" title="keyword">Import</span></span> the chapter before it (and, transitively, all the
    earlier chapters).  Instead, in this chapter and from now, on
    we're going to import the definitions and theorems we need
    directly from Coq's standard library stuff.  You should not notice
    much difference, though, because we've been careful to name our
    own definitions and theorems the same as their counterparts in the
    standard library, wherever they overlap. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Arith.Arith.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Bool.Bool.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Export</span> Coq.Strings.String.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Logic.FunctionalExtensionality.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Lists.List.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Import</span> ListNotations.</span></span></span></pre><div class="doc">
Documentation for the standard library can be found at
    http://coq.inria.fr/library/.

<div class="paragraph"> </div>

    The <span class="inlinecode"><span class="id" title="keyword">Search</span></span> command is a good way to look for theorems involving
    objects of specific types.  Take a minute now to experiment with it. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab3"></a><h1 class="section">Identifiers</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
First, we need a type for the keys that we use to index into our
    maps.  In <span class="inlinecode"><span class="id" title="var">Lists.v</span></span> we introduced a fresh type <span class="inlinecode"><span class="id" title="var">id</span></span> for a similar
    purpose; here and for the rest of <i>Software Foundations</i> we will
    use the <span class="inlinecode"><span class="id" title="var">string</span></span> type from Coq's standard library. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
To compare strings, we define the function <span class="inlinecode"><span class="id" title="var">eqb_string</span></span>, which
    internally uses the function <span class="inlinecode"><span class="id" title="var">string_dec</span></span> from Coq's string
    library. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eqb_string</span> (<span class="nv">x</span> <span class="nv">y</span> : string) : bool :=
  <span class="kr">if</span> string_dec x y <span class="kr">then</span> true <span class="kr">else</span> false.</span></span></span></pre><div class="doc">
(The function <span class="inlinecode"><span class="id" title="var">string_dec</span></span> comes from Coq's string library.
    If you check the result type of <span class="inlinecode"><span class="id" title="var">string_dec</span></span>, you'll see that it
    does not actually return a <span class="inlinecode"><span class="id" title="var">bool</span></span>, but rather a type that looks
    like <span class="inlinecode">{<span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span>}</span> <span class="inlinecode">+</span> <span class="inlinecode">{<span class="id" title="var">x</span></span> <span class="inlinecode">‚â†</span> <span class="inlinecode"><span class="id" title="var">y</span>}</span>, called a <span class="inlinecode"><span class="id" title="var">sumbool</span></span>, which can be
    thought of as an "evidence-carrying boolean."  Formally, an
    element of <span class="inlinecode"><span class="id" title="var">sumbool</span></span> is either a proof that two things are equal
    or a proof that they are unequal, together with a tag indicating
    which.  But for present purposes you can think of it as just a
    fancy <span class="inlinecode"><span class="id" title="var">bool</span></span>.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Now we need a few basic properties of string equality... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk0" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk0"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">eqb_string_refl</span> : <span class="kr">forall</span> <span class="nv">s</span> : string, true = eqb_string s s.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s</span> : string, true = eqb_string s s</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk1" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s</span> : string, true = eqb_string s s</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk2" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk2"><span class="highlight"><span class="nb">intros</span> s.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = eqb_string s s</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk3" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk3"><span class="highlight"><span class="nb">unfold</span> eqb_string.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = (<span class="kr">if</span> string_dec s s <span class="kr">then</span> true <span class="kr">else</span> false)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk4" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk4"><span class="highlight"><span class="nb">destruct</span> (string_dec s s) <span class="kr">as</span> [|Hs].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s = s</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Maps-v-chk5" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s &lt;&gt; s</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Maps-v-chk5"><hr></label><div class="goal-conclusion"><span class="highlight">true = false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk6" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk6"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s = s</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk7" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk7"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s &lt;&gt; s</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk8" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk8"><span class="highlight"><span class="nb">destruct</span> Hs.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s = s</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The following useful property follows from an analogous
    lemma about strings: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk9" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk9"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">eqb_string_true_iff</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : string,
    eqb_string x y = true &lt;-&gt; x = y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : string, eqb_string x y = true &lt;-&gt; x = y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chka" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chka"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : string, eqb_string x y = true &lt;-&gt; x = y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chkb" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chkb"><span class="highlight"><span class="nb">intros</span> x y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eqb_string x y = true &lt;-&gt; x = y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chkc" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chkc"><span class="highlight"><span class="nb">unfold</span> eqb_string.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">if</span> string_dec x y <span class="kr">then</span> true <span class="kr">else</span> false) = true &lt;-&gt;
x = y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chkd" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chkd"><span class="highlight"><span class="nb">destruct</span> (string_dec x y) <span class="kr">as</span> [|Hs].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = true &lt;-&gt; x = y</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Maps-v-chke" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;&gt; y</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Maps-v-chke"><hr></label><div class="goal-conclusion"><span class="highlight">false = true &lt;-&gt; x = y</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chkf" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chkf"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = true &lt;-&gt; x = y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk10" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk10"><span class="highlight"><span class="nb">subst</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = true &lt;-&gt; y = y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk11" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk11"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = true -&gt; y = y</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Maps-v-chk12" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Maps-v-chk12"><hr></label><div class="goal-conclusion"><span class="highlight">y = y -&gt; true = true</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk13" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk13"><span class="highlight"><span class="bp">reflexivity</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y = y -&gt; true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk14" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk14"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;&gt; y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">false = true &lt;-&gt; x = y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk15" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk15"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;&gt; y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">false = true -&gt; x = y</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Maps-v-chk16" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;&gt; y</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Maps-v-chk16"><hr></label><div class="goal-conclusion"><span class="highlight">x = y -&gt; false = true</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk17" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk17"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;&gt; y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">false = true -&gt; x = y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk18" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk18"><span class="highlight"><span class="nb">intros</span> contra.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">contra</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">false = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span> contra.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk19" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk19"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;&gt; y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = y -&gt; false = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk1a" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk1a"><span class="highlight"><span class="nb">intros</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">false = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk1b"><span class="highlight"><span class="nb">rewrite</span> H <span class="kr">in</span> Hs.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">false = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk1c"><span class="highlight"><span class="nb">destruct</span> Hs.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y = y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Similarly: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk1d" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk1d"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">eqb_string_false_iff</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : string,
    eqb_string x y = false &lt;-&gt; x &lt;&gt; y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : string, eqb_string x y = false &lt;-&gt; x &lt;&gt; y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk1e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : string, eqb_string x y = false &lt;-&gt; x &lt;&gt; y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk1f"><span class="highlight"><span class="nb">intros</span> x y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eqb_string x y = false &lt;-&gt; x &lt;&gt; y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk20" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk20"><span class="highlight"><span class="nb">rewrite</span> &lt;- eqb_string_true_iff.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eqb_string x y = false &lt;-&gt; eqb_string x y &lt;&gt; true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk21" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk21"><span class="highlight"><span class="nb">rewrite</span> not_true_iff_false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eqb_string x y = false &lt;-&gt; eqb_string x y = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
This handy variant follows just by rewriting: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk22" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk22"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">false_eqb_string</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : string,
   x &lt;&gt; y -&gt; eqb_string x y = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : string, x &lt;&gt; y -&gt; eqb_string x y = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk23" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk23"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : string, x &lt;&gt; y -&gt; eqb_string x y = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk24" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk24"><span class="highlight"><span class="nb">intros</span> x y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x &lt;&gt; y -&gt; eqb_string x y = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk25" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk25"><span class="highlight"><span class="nb">rewrite</span> eqb_string_false_iff.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x &lt;&gt; y -&gt; x &lt;&gt; y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk26" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk26"><span class="highlight"><span class="nb">intros</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;&gt; y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x &lt;&gt; y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab4"></a><h1 class="section">Total Maps</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Our main job in this chapter will be to build a definition of
    partial maps that is similar in behavior to the one we saw in the
    <span class="inlinecode"><span class="id" title="var">Lists</span></span> chapter, plus accompanying lemmas about its behavior.

<div class="paragraph"> </div>

    This time around, though, we're going to use <i>functions</i>, rather
    than lists of key-value pairs, to build maps.  The advantage of
    this representation is that it offers a more <i>extensional</i> view of
    maps, where two maps that respond to queries in the same way will
    be represented as literally the same thing (the very same function),
    rather than just "equivalent" data structures.  This, in turn,
    simplifies proofs that use maps. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We build partial maps in two steps.  First, we define a type of
    <i>total maps</i> that return a default value when we look up a key
    that is not present in the map. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">total_map</span> (<span class="nv">A</span> : <span class="kt">Type</span>) := string -&gt; A.</span></span></span></pre><div class="doc">
Intuitively, a total map over an element type <span class="inlinecode"><span class="id" title="var">A</span></span> is just a
    function that can be used to look up <span class="inlinecode"><span class="id" title="var">string</span></span>s, yielding <span class="inlinecode"><span class="id" title="var">A</span></span>s. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The function <span class="inlinecode"><span class="id" title="var">t_empty</span></span> yields an empty total map, given a default
    element; this map always returns the default element when applied
    to any string. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">t_empty</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">v</span> : A) : total_map A :=
  (<span class="kr">fun</span> <span class="nv">_</span> =&gt; v).</span></span></span></pre><div class="doc">
More interesting is the <span class="inlinecode"><span class="id" title="var">update</span></span> function, which (as before) takes
    a map <span class="inlinecode"><span class="id" title="var">m</span></span>, a key <span class="inlinecode"><span class="id" title="var">x</span></span>, and a value <span class="inlinecode"><span class="id" title="var">v</span></span> and returns a new map that
    takes <span class="inlinecode"><span class="id" title="var">x</span></span> to <span class="inlinecode"><span class="id" title="var">v</span></span> and takes every other key to whatever <span class="inlinecode"><span class="id" title="var">m</span></span> does. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">t_update</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">m</span> : total_map A)
                    (<span class="nv">x</span> : string) (<span class="nv">v</span> : A) :=
  <span class="kr">fun</span> <span class="nv">x&#39;</span> =&gt; <span class="kr">if</span> eqb_string x x&#39; <span class="kr">then</span> v <span class="kr">else</span> m x&#39;.</span></span></span></pre><div class="doc">
This definition is a nice example of higher-order programming:
    <span class="inlinecode"><span class="id" title="var">t_update</span></span> takes a <i>function</i> <span class="inlinecode"><span class="id" title="var">m</span></span> and yields a new function
    <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x'</span></span> <span class="inlinecode">‚áí</span> <span class="inlinecode">...</span> that behaves like the desired map. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
For example, we can build a map taking <span class="inlinecode"><span class="id" title="var">string</span></span>s to <span class="inlinecode"><span class="id" title="var">bool</span></span>s, where
    <span class="inlinecode">"<span class="id" title="var">foo</span>"</span> and <span class="inlinecode">"<span class="id" title="var">bar</span>"</span> are mapped to <span class="inlinecode"><span class="id" title="var">true</span></span> and every other key is
    mapped to <span class="inlinecode"><span class="id" title="var">false</span></span>, like this: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">examplemap</span> :=
  t_update (t_update (t_empty false) <span class="s2">&quot;foo&quot;</span> true)
           <span class="s2">&quot;bar&quot;</span> true.</span></span></span></pre><div class="doc">
Next, let's introduce some new notations to facilitate working
    with maps. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
First, we will use the following notation to create an empty
    total map with a default value. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&#39;_&#39; &#39;!-&gt;&#39; v&quot;</span> := (t_empty v)
  (<span class="kn">at level</span> <span class="mi">100</span>, <span class="kn">right associativity</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Example</span> <span class="nf">example_empty</span> := (_ !-&gt; false).</span></span></span></pre><div class="doc">
We then introduce a convenient notation for extending an existing
    map with some bindings. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &#39;!-&gt;&#39; v &#39;;&#39; m&quot;</span> := (t_update m x v)
                              (<span class="kn">at level</span> <span class="mi">100</span>, v <span class="kn">at next level</span>, <span class="kn">right associativity</span>).</span></span></span></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">examplemap</span></span> above can now be defined as follows: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">examplemap&#39;</span> :=
  ( <span class="s2">&quot;bar&quot;</span> !-&gt; true;
    <span class="s2">&quot;foo&quot;</span> !-&gt; true;
    _     !-&gt; false
  ).</span></span></span></pre><div class="doc">
This completes the definition of total maps.  Note that we
    don't need to define a <span class="inlinecode"><span class="id" title="var">find</span></span> operation because it is just
    function application! 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk27" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk27"><span class="highlight"><span class="kn">Example</span> <span class="nf">update_example1</span> : examplemap&#39; <span class="s2">&quot;baz&quot;</span> = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">examplemap&#39; <span class="s2">&quot;baz&quot;</span> = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk28" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk28"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">examplemap&#39; <span class="s2">&quot;baz&quot;</span> = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk29" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk29"><span class="highlight"><span class="kn">Example</span> <span class="nf">update_example2</span> : examplemap&#39; <span class="s2">&quot;foo&quot;</span> = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">examplemap&#39; <span class="s2">&quot;foo&quot;</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk2a" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk2a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">examplemap&#39; <span class="s2">&quot;foo&quot;</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk2b" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk2b"><span class="highlight"><span class="kn">Example</span> <span class="nf">update_example3</span> : examplemap&#39; <span class="s2">&quot;quux&quot;</span> = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">examplemap&#39; <span class="s2">&quot;quux&quot;</span> = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk2c" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk2c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">examplemap&#39; <span class="s2">&quot;quux&quot;</span> = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk2d" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk2d"><span class="highlight"><span class="kn">Example</span> <span class="nf">update_example4</span> : examplemap&#39; <span class="s2">&quot;bar&quot;</span> = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">examplemap&#39; <span class="s2">&quot;bar&quot;</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk2e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">examplemap&#39; <span class="s2">&quot;bar&quot;</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
To use maps in later chapters, we'll need several fundamental
    facts about how they behave. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Even if you don't work the following exercises, make sure
    you thoroughly understand the statements of the lemmas! 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
(Some of the proofs require the functional extensionality axiom,
    which is discussed in the <span class="inlinecode"><span class="id" title="var">Logic</span></span> chapter.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab5"></a><h4 class="section">Exercise: 1 star, standard, optional (t_apply_empty)</h4>
<div class="paragraph"> </div>

    First, the empty map returns its default element for all keys: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk2f" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk2f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">t_apply_empty</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : string) (<span class="nv">v</span> : A),
    (_ !-&gt; v) x = v.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : string) (<span class="nv">v</span> : A),
(_ !-&gt; v) x = v</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk30" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk30"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : string) (<span class="nv">v</span> : A),
(_ !-&gt; v) x = v</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab6"></a><h4 class="section">Exercise: 2 stars, standard, optional (t_update_eq)</h4>
<div class="paragraph"> </div>

    Next, if we update a map <span class="inlinecode"><span class="id" title="var">m</span></span> at a key <span class="inlinecode"><span class="id" title="var">x</span></span> with a new value <span class="inlinecode"><span class="id" title="var">v</span></span>
    and then look up <span class="inlinecode"><span class="id" title="var">x</span></span> in the map resulting from the <span class="inlinecode"><span class="id" title="var">update</span></span>, we
    get back <span class="inlinecode"><span class="id" title="var">v</span></span>: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk31" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk31"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">t_update_eq</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : total_map A) <span class="nv">x</span> <span class="nv">v</span>,
    (x !-&gt; v ; m) x = v.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : total_map A) (<span class="nv">x</span> : string)
  (<span class="nv">v</span> : A), (x !-&gt; v; m) x = v</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk32" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk32"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : total_map A) (<span class="nv">x</span> : string)
  (<span class="nv">v</span> : A), (x !-&gt; v; m) x = v</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab7"></a><h4 class="section">Exercise: 2 stars, standard, optional (t_update_neq)</h4>
<div class="paragraph"> </div>

    On the other hand, if we update a map <span class="inlinecode"><span class="id" title="var">m</span></span> at a key <span class="inlinecode"><span class="id" title="var">x1</span></span> and then
    look up a <i>different</i> key <span class="inlinecode"><span class="id" title="var">x2</span></span> in the resulting map, we get the
    same result that <span class="inlinecode"><span class="id" title="var">m</span></span> would have given: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk33" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk33"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">t_update_neq</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : total_map A) <span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">v</span>,
    x1 &lt;&gt; x2 -&gt;
    (x1 !-&gt; v ; m) x2 = m x2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : total_map A) (<span class="nv">x1</span> <span class="nv">x2</span> : string)
  (<span class="nv">v</span> : A), x1 &lt;&gt; x2 -&gt; (x1 !-&gt; v; m) x2 = m x2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk34" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk34"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : total_map A) (<span class="nv">x1</span> <span class="nv">x2</span> : string)
  (<span class="nv">v</span> : A), x1 &lt;&gt; x2 -&gt; (x1 !-&gt; v; m) x2 = m x2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab8"></a><h4 class="section">Exercise: 2 stars, standard, optional (t_update_shadow)</h4>
<div class="paragraph"> </div>

    If we update a map <span class="inlinecode"><span class="id" title="var">m</span></span> at a key <span class="inlinecode"><span class="id" title="var">x</span></span> with a value <span class="inlinecode"><span class="id" title="var">v1</span></span> and then
    update again with the same key <span class="inlinecode"><span class="id" title="var">x</span></span> and another value <span class="inlinecode"><span class="id" title="var">v2</span></span>, the
    resulting map behaves the same (gives the same result when applied
    to any key) as the simpler map obtained by performing just
    the second <span class="inlinecode"><span class="id" title="var">update</span></span> on <span class="inlinecode"><span class="id" title="var">m</span></span>: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk35" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk35"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">t_update_shadow</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : total_map A) <span class="nv">x</span> <span class="nv">v1</span> <span class="nv">v2</span>,
    (x !-&gt; v2 ; x !-&gt; v1 ; m) = (x !-&gt; v2 ; m).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : total_map A) (<span class="nv">x</span> : string)
  (<span class="nv">v1</span> <span class="nv">v2</span> : A), (x !-&gt; v2; x !-&gt; v1; m) = (x !-&gt; v2; m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk36" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk36"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : total_map A) (<span class="nv">x</span> : string)
  (<span class="nv">v1</span> <span class="nv">v2</span> : A), (x !-&gt; v2; x !-&gt; v1; m) = (x !-&gt; v2; m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
For the final two lemmas about total maps, it's convenient to use
    the reflection idioms introduced in chapter <span class="inlinecode"><span class="id" title="var">IndProp</span></span>.  We begin
    by proving a fundamental <i>reflection lemma</i> relating the equality
    proposition on <span class="inlinecode"><span class="id" title="var">id</span></span>s with the boolean function <span class="inlinecode"><span class="id" title="var">eqb_id</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab9"></a><h4 class="section">Exercise: 2 stars, standard, optional (eqb_stringP)</h4>
<div class="paragraph"> </div>

    Use the proof of <span class="inlinecode"><span class="id" title="var">eqbP</span></span> in chapter <span class="inlinecode"><span class="id" title="var">IndProp</span></span> as a template to
    prove the following: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk37" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk37"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">eqb_stringP</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : string,
    reflect (x = y) (eqb_string x y).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : string, reflect (x = y) (eqb_string x y)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk38" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk38"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : string, reflect (x = y) (eqb_string x y)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Now, given <span class="inlinecode"><span class="id" title="var">string</span></span>s <span class="inlinecode"><span class="id" title="var">x1</span></span> and <span class="inlinecode"><span class="id" title="var">x2</span></span>, we can use the tactic
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode">(<span class="id" title="var">eqb_stringP</span></span> <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode"><span class="id" title="var">x2</span>)</span> to simultaneously perform case
    analysis on the result of <span class="inlinecode"><span class="id" title="var">eqb_string</span></span> <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode"><span class="id" title="var">x2</span></span> and generate
    hypotheses about the equality (in the sense of <span class="inlinecode">=</span>) of <span class="inlinecode"><span class="id" title="var">x1</span></span>
    and <span class="inlinecode"><span class="id" title="var">x2</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab10"></a><h4 class="section">Exercise: 2 stars, standard (t_update_same)</h4>
<div class="paragraph"> </div>

    With the example in chapter <span class="inlinecode"><span class="id" title="var">IndProp</span></span> as a template, use
    <span class="inlinecode"><span class="id" title="var">eqb_stringP</span></span> to prove the following theorem, which states that
    if we update a map to assign key <span class="inlinecode"><span class="id" title="var">x</span></span> the same value as it already
    has in <span class="inlinecode"><span class="id" title="var">m</span></span>, then the result is equal to <span class="inlinecode"><span class="id" title="var">m</span></span>: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk39" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk39"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">t_update_same</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : total_map A) <span class="nv">x</span>,
    (x !-&gt; m x ; m) = m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : total_map A) (<span class="nv">x</span> : string),
(x !-&gt; m x; m) = m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk3a" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk3a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : total_map A) (<span class="nv">x</span> : string),
(x !-&gt; m x; m) = m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab11"></a><h4 class="section">Exercise: 3 stars, standard, recommended (t_update_permute)</h4>
<div class="paragraph"> </div>

    Use <span class="inlinecode"><span class="id" title="var">eqb_stringP</span></span> to prove one final property of the <span class="inlinecode"><span class="id" title="var">update</span></span>
    function: If we update a map <span class="inlinecode"><span class="id" title="var">m</span></span> at two distinct keys, it doesn't
    matter in which order we do the updates. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk3b" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk3b"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">t_update_permute</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : total_map A)
                                  <span class="nv">v1</span> <span class="nv">v2</span> <span class="nv">x1</span> <span class="nv">x2</span>,
    x2 &lt;&gt; x1 -&gt;
    (x1 !-&gt; v1 ; x2 !-&gt; v2 ; m)
    =
    (x2 !-&gt; v2 ; x1 !-&gt; v1 ; m).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : total_map A) (<span class="nv">v1</span> <span class="nv">v2</span> : A)
  (<span class="nv">x1</span> <span class="nv">x2</span> : string),
x2 &lt;&gt; x1 -&gt;
(x1 !-&gt; v1; x2 !-&gt; v2; m) = (x2 !-&gt; v2; x1 !-&gt; v1; m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk3c" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk3c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : total_map A) (<span class="nv">v1</span> <span class="nv">v2</span> : A)
  (<span class="nv">x1</span> <span class="nv">x2</span> : string),
x2 &lt;&gt; x1 -&gt;
(x1 !-&gt; v1; x2 !-&gt; v2; m) = (x2 !-&gt; v2; x1 !-&gt; v1; m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab12"></a><h1 class="section">Partial maps</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Finally, we define <i>partial maps</i> on top of total maps.  A partial
    map with elements of type <span class="inlinecode"><span class="id" title="var">A</span></span> is simply a total map with elements
    of type <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> and default element <span class="inlinecode"><span class="id" title="var">None</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">partial_map</span> (<span class="nv">A</span> : <span class="kt">Type</span>) := total_map (option A).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">empty</span> {<span class="nv">A</span> : <span class="kt">Type</span>} : partial_map A :=
  t_empty None.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">update</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">m</span> : partial_map A)
           (<span class="nv">x</span> : string) (<span class="nv">v</span> : A) :=
  (x !-&gt; Some v ; m).</span></span></span></pre><div class="doc">
We introduce a similar notation for partial maps: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &#39;|-&gt;&#39; v &#39;;&#39; m&quot;</span> := (update m x v)
  (<span class="kn">at level</span> <span class="mi">100</span>, v <span class="kn">at next level</span>, <span class="kn">right associativity</span>).</span></span></span></pre><div class="doc">
We can also hide the last case when it is empty. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &#39;|-&gt;&#39; v&quot;</span> := (update empty x v)
  (<span class="kn">at level</span> <span class="mi">100</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Example</span> <span class="nf">examplepmap</span> :=
  (<span class="s2">&quot;Church&quot;</span> |-&gt; true ; <span class="s2">&quot;Turing&quot;</span> |-&gt; false).</span></span></span></pre><div class="doc">
We now straightforwardly lift all of the basic lemmas about total
    maps to partial maps.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk3d" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk3d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">apply_empty</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : string),
    @empty A x = None.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : string), empty x = None</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk3e" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk3e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : string), empty x = None</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk3f" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk3f"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">empty x = None</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk40" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk40"><span class="highlight"><span class="nb">unfold</span> empty.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(_ !-&gt; None) x = None</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk41" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk41"><span class="highlight"><span class="nb">rewrite</span> t_apply_empty.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">None = None</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk42" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk42"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">update_eq</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : partial_map A) <span class="nv">x</span> <span class="nv">v</span>,
    (x |-&gt; v ; m) x = Some v.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : partial_map A) (<span class="nv">x</span> : string)
  (<span class="nv">v</span> : A), (x |-&gt; v; m) x = Some v</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk43" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk43"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : partial_map A) (<span class="nv">x</span> : string)
  (<span class="nv">v</span> : A), (x |-&gt; v; m) x = Some v</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk44" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk44"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(x |-&gt; v; m) x = Some v</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk45" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk45"><span class="highlight"><span class="nb">unfold</span> update.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(x !-&gt; Some v; m) x = Some v</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk46" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk46"><span class="highlight"><span class="nb">rewrite</span> t_update_eq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Some v = Some v</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk47" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk47"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">update_neq</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : partial_map A) <span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">v</span>,
    x2 &lt;&gt; x1 -&gt;
    (x2 |-&gt; v ; m) x1 = m x1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : partial_map A) (<span class="nv">x1</span> <span class="nv">x2</span> : string)
  (<span class="nv">v</span> : A), x2 &lt;&gt; x1 -&gt; (x2 |-&gt; v; m) x1 = m x1</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk48" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk48"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : partial_map A) (<span class="nv">x1</span> <span class="nv">x2</span> : string)
  (<span class="nv">v</span> : A), x2 &lt;&gt; x1 -&gt; (x2 |-&gt; v; m) x1 = m x1</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk49" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk49"><span class="highlight"><span class="nb">intros</span> A m x1 x2 v H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x2 &lt;&gt; x1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(x2 |-&gt; v; m) x1 = m x1</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk4a" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk4a"><span class="highlight"><span class="nb">unfold</span> update.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x2 &lt;&gt; x1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(x2 !-&gt; Some v; m) x1 = m x1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk4b" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk4b"><span class="highlight"><span class="nb">rewrite</span> t_update_neq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x2 &lt;&gt; x1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m x1 = m x1</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Maps-v-chk4c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x2 &lt;&gt; x1</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Maps-v-chk4c"><hr></label><div class="goal-conclusion"><span class="highlight">x2 &lt;&gt; x1</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk4d" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk4d"><span class="highlight"><span class="bp">reflexivity</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x2 &lt;&gt; x1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x2 &lt;&gt; x1</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk4e" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk4e"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">update_shadow</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : partial_map A) <span class="nv">x</span> <span class="nv">v1</span> <span class="nv">v2</span>,
    (x |-&gt; v2 ; x |-&gt; v1 ; m) = (x |-&gt; v2 ; m).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : partial_map A) (<span class="nv">x</span> : string)
  (<span class="nv">v1</span> <span class="nv">v2</span> : A), (x |-&gt; v2; x |-&gt; v1; m) = (x |-&gt; v2; m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk4f" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk4f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : partial_map A) (<span class="nv">x</span> : string)
  (<span class="nv">v1</span> <span class="nv">v2</span> : A), (x |-&gt; v2; x |-&gt; v1; m) = (x |-&gt; v2; m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk50" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk50"><span class="highlight"><span class="nb">intros</span> A m x v1 v2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v1, v2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(x |-&gt; v2; x |-&gt; v1; m) = (x |-&gt; v2; m)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk51" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk51"><span class="highlight"><span class="nb">unfold</span> update.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v1, v2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(x !-&gt; Some v2; x !-&gt; Some v1; m) = (x !-&gt; Some v2; m)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk52" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk52"><span class="highlight"><span class="nb">rewrite</span> t_update_shadow.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v1, v2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(x !-&gt; Some v2; m) = (x !-&gt; Some v2; m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk53" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk53"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">update_same</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : partial_map A) <span class="nv">x</span> <span class="nv">v</span>,
    m x = Some v -&gt;
    (x |-&gt; v ; m) = m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : partial_map A) (<span class="nv">x</span> : string)
  (<span class="nv">v</span> : A), m x = Some v -&gt; (x |-&gt; v; m) = m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk54" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk54"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : partial_map A) (<span class="nv">x</span> : string)
  (<span class="nv">v</span> : A), m x = Some v -&gt; (x |-&gt; v; m) = m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk55" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk55"><span class="highlight"><span class="nb">intros</span> A m x v H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m x = Some v</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(x |-&gt; v; m) = m</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk56" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk56"><span class="highlight"><span class="nb">unfold</span> update.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m x = Some v</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(x !-&gt; Some v; m) = m</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk57" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk57"><span class="highlight"><span class="nb">rewrite</span> &lt;- H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m x = Some v</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(x !-&gt; m x; m) = m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> t_update_same.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk58" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk58"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">update_permute</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : partial_map A)
                                <span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">v1</span> <span class="nv">v2</span>,
    x2 &lt;&gt; x1 -&gt;
    (x1 |-&gt; v1 ; x2 |-&gt; v2 ; m) = (x2 |-&gt; v2 ; x1 |-&gt; v1 ; m).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : partial_map A) (<span class="nv">x1</span> <span class="nv">x2</span> : string)
  (<span class="nv">v1</span> <span class="nv">v2</span> : A),
x2 &lt;&gt; x1 -&gt;
(x1 |-&gt; v1; x2 |-&gt; v2; m) = (x2 |-&gt; v2; x1 |-&gt; v1; m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk59" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk59"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">m</span> : partial_map A) (<span class="nv">x1</span> <span class="nv">x2</span> : string)
  (<span class="nv">v1</span> <span class="nv">v2</span> : A),
x2 &lt;&gt; x1 -&gt;
(x1 |-&gt; v1; x2 |-&gt; v2; m) = (x2 |-&gt; v2; x1 |-&gt; v1; m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk5a" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk5a"><span class="highlight"><span class="nb">intros</span> A m x1 x2 v1 v2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v1, v2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x2 &lt;&gt; x1 -&gt;
(x1 |-&gt; v1; x2 |-&gt; v2; m) = (x2 |-&gt; v2; x1 |-&gt; v1; m)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Maps-v-chk5b" style="display: none" type="checkbox"><label class="coq-input" for="Maps-v-chk5b"><span class="highlight"><span class="nb">unfold</span> update.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">partial_map A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v1, v2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x2 &lt;&gt; x1 -&gt;
(x1 !-&gt; Some v1; x2 !-&gt; Some v2; m) =
(x2 !-&gt; Some v2; x1 !-&gt; Some v1; m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> t_update_permute.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* Wed Jan 9 12:02:45 EST 2019 *)</span></span></span></pre></article></body></html>