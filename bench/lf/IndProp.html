<!DOCTYPE html>
<html><head><title>IndProp.v</title><meta charset="utf-8"><meta content="Alectryon v0.2" name="generator"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet"><link href="https://unpkg.com/firacode/distr/fira_code.css" rel="stylesheet"><link href="alectryon.css" rel="stylesheet"><script src="alectryon.js"></script><style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-standalone alectryon-centered alectryon-coqdoc"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><div class="doc">
<a name="lab1"></a><h1 class="section">IndProp: Inductively Defined Propositions</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Set Warnings</span> <span class="s2">&quot;-notation-overridden,-parsing&quot;</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> LF <span class="kn">Require Export</span> Logic.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require</span> Coq.<span class="bp">omega</span>.Omega.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab2"></a><h1 class="section">Inductively Defined Propositions</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
In the <span class="inlinecode"><span class="id" title="var">Logic</span></span> chapter, we looked at several ways of writing
    propositions, including conjunction, disjunction, and existential
    quantification.  In this chapter, we bring yet another new tool
    into the mix: <i>inductive definitions</i>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
In past chapters, we have seen two ways of stating that a number
    <span class="inlinecode"><span class="id" title="var">n</span></span> is even: We can say

<div class="paragraph"> </div>

      (1) <span class="inlinecode"><span class="id" title="var">evenb</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>, or

<div class="paragraph"> </div>

      (2) <span class="inlinecode"><span class="id" title="tactic">‚àÉ</span></span> <span class="inlinecode"><span class="id" title="var">k</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">double</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span>.

<div class="paragraph"> </div>

    Yet another possibility is to say that <span class="inlinecode"><span class="id" title="var">n</span></span> is even if we can
    establish its evenness from the following rules:

<div class="paragraph"> </div>
<ul class="doclist">
<li> Rule <span class="inlinecode"><span class="id" title="var">ev_0</span></span>: The number <span class="inlinecode">0</span> is even.

</li>
<li> Rule <span class="inlinecode"><span class="id" title="var">ev_SS</span></span>: If <span class="inlinecode"><span class="id" title="var">n</span></span> is even, then <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> is even. 
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
To illustrate how this new definition of evenness works,
    let's imagine using it to show that <span class="inlinecode">4</span> is even. By rule <span class="inlinecode"><span class="id" title="var">ev_SS</span></span>,
    it suffices to show that <span class="inlinecode">2</span> is even. This, in turn, is again
    guaranteed by rule <span class="inlinecode"><span class="id" title="var">ev_SS</span></span>, as long as we can show that <span class="inlinecode">0</span> is
    even. But this last fact follows directly from the <span class="inlinecode"><span class="id" title="var">ev_0</span></span> rule. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We will see many definitions like this one during the rest
    of the course.  For purposes of informal discussions, it is
    helpful to have a lightweight notation that makes them easy to
    read and write.  <i>Inference rules</i> are one such notation: 
<hr/>
             (ev_0)
                                 even 0

<div class="paragraph"> </div>

                                 even n
<hr/>
          (ev_SS)
                             even (S (S n))

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Each of the textual rules above is reformatted here as an
    inference rule; the intended reading is that, if the <i>premises</i>
    above the line all hold, then the <i>conclusion</i> below the line
    follows.  For example, the rule <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> says that, if <span class="inlinecode"><span class="id" title="var">n</span></span>
    satisfies <span class="inlinecode"><span class="id" title="var">even</span></span>, then <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> also does.  If a rule has no
    premises above the line, then its conclusion holds
    unconditionally.

<div class="paragraph"> </div>

    We can represent a proof using these rules by combining rule
    applications into a <i>proof tree</i>. Here's how we might transcribe
    the above proof that <span class="inlinecode">4</span> is even: 
<hr/>
  (ev_0)
                              even 0
<hr/>
 (ev_SS)
                              even 2
<hr/>
 (ev_SS)
                              even 4

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
(Why call this a "tree" (rather than a "stack", for example)?
    Because, in general, inference rules can have multiple premises.
    We will see examples of this shortly. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab3"></a><h2 class="section">Inductive Definition of Evenness</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Putting all of this together, we can translate the definition of
    evenness into a formal Coq definition using an <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>
    declaration, where each constructor corresponds to an inference
    rule: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">even</span> : nat -&gt; <span class="kt">Prop</span> :=
| ev_0 : even <span class="mi">0</span>
| ev_SS (n : nat) (H : even n) : even (S (S n)).</span></span></span></pre><div class="doc">
This definition is different in one crucial respect from previous
    uses of <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>: the thing we are defining is not a <span class="inlinecode"><span class="id" title="keyword">Type</span></span>,
    but rather a function from <span class="inlinecode"><span class="id" title="var">nat</span></span> to <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> -- that is, a property
    of numbers.  We've already seen other inductive definitions that
    result in functions -- for example, <span class="inlinecode"><span class="id" title="var">list</span></span>, whose type is <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">‚Üí</span>
<span class="inlinecode"><span class="id" title="keyword">Type</span></span>.  What is really new here is that, because the <span class="inlinecode"><span class="id" title="var">nat</span></span>
    argument of <span class="inlinecode"><span class="id" title="var">even</span></span> appears to the <i>right</i> of the colon, it is
    allowed to take different values in the types of different
    constructors: <span class="inlinecode">0</span> in the type of <span class="inlinecode"><span class="id" title="var">ev_0</span></span> and <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> in the type
    of <span class="inlinecode"><span class="id" title="var">ev_SS</span></span>.

<div class="paragraph"> </div>

    In contrast, the definition of <span class="inlinecode"><span class="id" title="var">list</span></span> names the <span class="inlinecode"><span class="id" title="var">X</span></span> parameter
    <i>globally</i>, to the <i>left</i> of the colon, forcing the result of
    <span class="inlinecode"><span class="id" title="var">nil</span></span> and <span class="inlinecode"><span class="id" title="var">cons</span></span> to be the same (<span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>).  Had we tried to bring
    <span class="inlinecode"><span class="id" title="var">nat</span></span> to the left in defining <span class="inlinecode"><span class="id" title="var">even</span></span>, we would have seen an
    error: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="IndProp-v-chk0" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="IndProp-v-chk0"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">wrong_ev</span> (<span class="nv">n</span> : nat) : <span class="kt">Prop</span> :=
| wrong_ev_0 : wrong_ev <span class="mi">0</span>
| wrong_ev_SS : wrong_ev n -&gt; wrong_ev (S (S n)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">Last occurrence of <span class="s2">&quot;wrong_ev&quot;</span> must <span class="nb">have</span> <span class="s2">&quot;n&quot;</span> <span class="kr">as</span> <span class="mi">1</span>st argument <span class="kr">in</span>
 <span class="s2">&quot;wrong_ev 0&quot;</span>.</span></blockquote></div></div></small></span></pre><div class="doc">
In an <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> definition, an argument to the type
    constructor on the left of the colon is called a "parameter",
    whereas an argument on the right is called an "index".

<div class="paragraph"> </div>

    For example, in <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">X</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>)</span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span>, <span class="inlinecode"><span class="id" title="var">X</span></span> is a
    parameter; in <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span>, the
    unnamed <span class="inlinecode"><span class="id" title="var">nat</span></span> argument is an index. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We can think of the definition of <span class="inlinecode"><span class="id" title="var">even</span></span> as defining a Coq
    property <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, together with primitive theorems
    <span class="inlinecode"><span class="id" title="var">ev_0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span> and <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">‚àÄ</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>))</span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
That definition can also be written as follows...

<div class="paragraph"> </div>

  Inductive even : nat -&gt; Prop :=
  | ev_0 : even 0
  | ev_SS : forall n, even n -&gt; even (S (S n)).

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
... making explicit the type of the rule <span class="inlinecode"><span class="id" title="var">ev_SS</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Such "constructor theorems" have the same status as proven
    theorems.  In particular, we can use Coq's <span class="inlinecode"><span class="id" title="tactic">apply</span></span> tactic with the
    rule names to prove <span class="inlinecode"><span class="id" title="var">even</span></span> for particular numbers... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">ev_4</span> : even <span class="mi">4</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk2" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk2"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk3" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk3"><span class="highlight"><span class="nb">apply</span> ev_SS.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even <span class="mi">2</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk4" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk4"><span class="highlight"><span class="nb">apply</span> ev_SS.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> ev_0.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
... or we can use function application syntax: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk5" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk5"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">ev_4&#39;</span> : even <span class="mi">4</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk6" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> (ev_SS <span class="mi">2</span> (ev_SS <span class="mi">0</span> ev_0)).</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
We can also prove theorems that have hypotheses involving <span class="inlinecode"><span class="id" title="var">even</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk7" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk7"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">ev_plus4</span> : <span class="kr">forall</span> <span class="nv">n</span>, even n -&gt; even (<span class="mi">4</span> + n).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even n -&gt; even (<span class="mi">4</span> + n)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk8" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk8"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even n -&gt; even (<span class="mi">4</span> + n)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk9" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk9"><span class="highlight"><span class="nb">intros</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n -&gt; even (<span class="mi">4</span> + n)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chka" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chka"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n -&gt; even (S (S (S (S n))))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkb" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkb"><span class="highlight"><span class="nb">intros</span> Hn.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even (S (S (S (S n))))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkc" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkc"><span class="highlight"><span class="nb">apply</span> ev_SS.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even (S (S n))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkd" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkd"><span class="highlight"><span class="nb">apply</span> ev_SS.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> Hn.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab4"></a><h4 class="section">Exercise: 1 star, standard (ev_double)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chke" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chke"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">ev_double</span> : <span class="kr">forall</span> <span class="nv">n</span>,
  even (double n).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even (double n)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkf" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkf"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even (double n)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab5"></a><h1 class="section">Using Evidence in Proofs</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Besides <i>constructing</i> evidence that numbers are even, we can also
    <i>reason about</i> such evidence.

<div class="paragraph"> </div>

    Introducing <span class="inlinecode"><span class="id" title="var">even</span></span> with an <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> declaration tells Coq not
    only that the constructors <span class="inlinecode"><span class="id" title="var">ev_0</span></span> and <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> are valid ways to
    build evidence that some number is even, but also that these two
    constructors are the <i>only</i> ways to build evidence that numbers
    are even (in the sense of <span class="inlinecode"><span class="id" title="var">even</span></span>). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
In other words, if someone gives us evidence <span class="inlinecode"><span class="id" title="var">E</span></span> for the assertion
    <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, then we know that <span class="inlinecode"><span class="id" title="var">E</span></span> must have one of two shapes:

<div class="paragraph"> </div>
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">E</span></span> is <span class="inlinecode"><span class="id" title="var">ev_0</span></span> (and <span class="inlinecode"><span class="id" title="var">n</span></span> is <span class="inlinecode"><span class="id" title="var">O</span></span>), or

</li>
<li> <span class="inlinecode"><span class="id" title="var">E</span></span> is <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode"><span class="id" title="var">E'</span></span> (and <span class="inlinecode"><span class="id" title="var">n</span></span> is <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>, where <span class="inlinecode"><span class="id" title="var">E'</span></span> is
        evidence for <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>). 
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
This suggests that it should be possible to analyze a
    hypothesis of the form <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> much as we do inductively defined
    data structures; in particular, it should be possible to argue by
    <i>induction</i> and <i>case analysis</i> on such evidence.  Let's look at a
    few examples to see what this means in practice. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab6"></a><h2 class="section">Inversion on Evidence</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Suppose we are proving some fact involving a number <span class="inlinecode"><span class="id" title="var">n</span></span>, and
    we are given <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> as a hypothesis.  We already know how to
    perform case analysis on <span class="inlinecode"><span class="id" title="var">n</span></span> using <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> or <span class="inlinecode"><span class="id" title="tactic">induction</span></span>,
    generating separate subgoals for the case where <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">O</span></span> and the
    case where <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> for some <span class="inlinecode"><span class="id" title="var">n'</span></span>.  But for some proofs we may
    instead want to analyze the evidence that <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <i>directly</i>. As
    a tool, we can prove our characterization of evidence for
    <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, using <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk10" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk10"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">ev_inversion</span> :
  <span class="kr">forall</span> (<span class="nv">n</span> : nat), even n -&gt;
    (n = <span class="mi">0</span>) \/ (<span class="kr">exists</span> <span class="nv">n&#39;</span>, n = S (S n&#39;) /\ even n&#39;).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
even n -&gt;
n = <span class="mi">0</span> \/ (<span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, n = S (S n&#39;) /\ even n&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk11" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk11"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
even n -&gt;
n = <span class="mi">0</span> \/ (<span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, n = S (S n&#39;) /\ even n&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk12" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk12"><span class="highlight"><span class="nb">intros</span> n E.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = <span class="mi">0</span> \/ (<span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, n = S (S n&#39;) /\ even n&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk13" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk13"><span class="highlight"><span class="nb">destruct</span> E <span class="kr">as</span> [ | n&#39; E&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span> \/ (<span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, <span class="mi">0</span> = S (S n&#39;) /\ even n&#39;)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk14" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk14"><hr></label><div class="goal-conclusion"><span class="highlight">S (S n&#39;) = <span class="mi">0</span> \/
(<span class="kr">exists</span> <span class="nv">n&#39;0</span> : nat, S (S n&#39;) = S (S n&#39;0) /\ even n&#39;0)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk15" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk15"><span class="highlight">- <span class="c">(* E = ev_0 : even 0 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span> \/ (<span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, <span class="mi">0</span> = S (S n&#39;) /\ even n&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk16" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk16"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk17" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk17"><span class="highlight">- <span class="c">(* E = ev_SS n&#39; E&#39; : even (S (S n&#39;)) *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">S (S n&#39;) = <span class="mi">0</span> \/
(<span class="kr">exists</span> <span class="nv">n&#39;0</span> : nat, S (S n&#39;) = S (S n&#39;0) /\ even n&#39;0)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk18" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk18"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">n&#39;0</span> : nat, S (S n&#39;) = S (S n&#39;0) /\ even n&#39;0</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk19" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk19"><span class="highlight"><span class="kr">exists</span> <span class="nv">n&#39;</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">S (S n&#39;) = S (S n&#39;) /\ even n&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1a"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">S (S n&#39;) = S (S n&#39;)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk1b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk1b"><hr></label><div class="goal-conclusion"><span class="highlight">even n&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1c"><span class="highlight"><span class="bp">reflexivity</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> E&#39;.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The following theorem can easily be proved using <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> on
    evidence. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1d"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">ev_minus2</span> : <span class="kr">forall</span> <span class="nv">n</span>,
  even n -&gt; even (pred (pred n)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even n -&gt; even (Nat.pred (Nat.pred n))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even n -&gt; even (Nat.pred (Nat.pred n))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1f"><span class="highlight"><span class="nb">intros</span> n E.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even (Nat.pred (Nat.pred n))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk20" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk20"><span class="highlight"><span class="nb">destruct</span> E <span class="kr">as</span> [| n&#39; E&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even (Nat.pred (Nat.pred <span class="mi">0</span>))</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk21" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk21"><hr></label><div class="goal-conclusion"><span class="highlight">even (Nat.pred (Nat.pred (S (S n&#39;))))</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk22" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk22"><span class="highlight">- <span class="c">(* E = ev_0 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even (Nat.pred (Nat.pred <span class="mi">0</span>))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk23" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk23"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> ev_0.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk24" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk24"><span class="highlight">- <span class="c">(* E = ev_SS n&#39; E&#39; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even (Nat.pred (Nat.pred (S (S n&#39;))))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk25" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk25"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> E&#39;.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
However, this variation cannot easily be handled with <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk26" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk26"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">evSS_ev</span> : <span class="kr">forall</span> <span class="nv">n</span>,
  even (S (S n)) -&gt; even n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even (S (S n)) -&gt; even n</span></div></blockquote></div></div></small></span></pre><div class="doc">
Intuitively, we know that evidence for the hypothesis cannot
    consist just of the <span class="inlinecode"><span class="id" title="var">ev_0</span></span> constructor, since <span class="inlinecode"><span class="id" title="var">O</span></span> and <span class="inlinecode"><span class="id" title="var">S</span></span> are
    different constructors of the type <span class="inlinecode"><span class="id" title="var">nat</span></span>; hence, <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> is the
    only case that applies.  Unfortunately, <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> is not smart
    enough to realize this, and it still generates two subgoals.  Even
    worse, in doing so, it keeps the final goal unchanged, failing to
    provide any useful information for completing the proof.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk27" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk27"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even (S (S n)) -&gt; even n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk28" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk28"><span class="highlight"><span class="nb">intros</span> n E.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even (S (S n))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk29" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk29"><span class="highlight"><span class="nb">destruct</span> E <span class="kr">as</span> [| n&#39; E&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk2a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk2a"><hr></label><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk2b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk2b"><span class="highlight">- <span class="c">(* E = ev_0. *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">    <span class="c">(* We must prove that [n] is even from no assumptions! *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><div class="doc">
What happened, exactly?  Calling <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> has the effect of
    replacing all occurrences of the property argument by the values
    that correspond to each constructor.  This is enough in the case
    of <span class="inlinecode"><span class="id" title="var">ev_minus2</span></span> because that argument <span class="inlinecode"><span class="id" title="var">n</span></span> is mentioned directly
    in the final goal. However, it doesn't help in the case of
    <span class="inlinecode"><span class="id" title="var">evSS_ev</span></span> since the term that gets replaced (<span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>) is not
    mentioned anywhere. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We could patch this proof by replacing the goal <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>,
    which does not mention the replaced term <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>, by the
    equivalent goal <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">pred</span></span> <span class="inlinecode">(<span class="id" title="var">pred</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>))))</span>, which does mention
    this term, after which <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> can make progress. But it is
    more straightforward to use our inversion lemma. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk2c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk2c"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">evSS_ev</span> : <span class="kr">forall</span> <span class="nv">n</span>, even (S (S n)) -&gt; even n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even (S (S n)) -&gt; even n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk2d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk2d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even (S (S n)) -&gt; even n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk2e"><span class="highlight"><span class="nb">intros</span> n H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even (S (S n))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk2f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk2f"><span class="highlight"><span class="nb">apply</span> ev_inversion <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n) = <span class="mi">0</span> \/
(<span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, S (S n) = S (S n&#39;) /\ even n&#39;)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk30" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk30"><span class="highlight"><span class="nb">destruct</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n) = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk31" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, S (S n) = S (S n&#39;) /\ even n&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk31"><hr></label><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"> </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk32" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk32"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n) = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"> </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk33" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk33"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, S (S n) = S (S n&#39;) /\ even n&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk34" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk34"><span class="highlight"><span class="nb">destruct</span> H <span class="kr">as</span> [n&#39; [Hnm Hev]].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n) = S (S n&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hev</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk35" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk35"><span class="highlight"><span class="nb">injection</span> Hnm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n) = S (S n&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hev</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = n&#39; -&gt; even n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk36" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk36"><span class="highlight"><span class="nb">intro</span> Heq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n) = S (S n&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hev</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = n&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk37" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk37"><span class="highlight"><span class="nb">rewrite</span> Heq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n) = S (S n&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hev</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = n&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> Hev.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Coq provides a tactic called <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, which does the work of
    our inversion lemma and more besides. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> tactic can detect (1) that the first case
    (<span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>) does not apply and (2) that the <span class="inlinecode"><span class="id" title="var">n'</span></span> that appears in the
    <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> case must be the same as <span class="inlinecode"><span class="id" title="var">n</span></span>.  It has an "<span class="inlinecode"><span class="id" title="keyword">as</span></span>" variant
    similar to <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, allowing us to assign names rather than
    have Coq choose them. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk38" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk38"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">evSS_ev&#39;</span> : <span class="kr">forall</span> <span class="nv">n</span>,
  even (S (S n)) -&gt; even n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even (S (S n)) -&gt; even n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk39" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk39"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even (S (S n)) -&gt; even n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk3a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk3a"><span class="highlight"><span class="nb">intros</span> n E.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even (S (S n))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk3b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk3b"><span class="highlight"><span class="nb">inversion</span> E <span class="kr">as</span> [| n&#39; E&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even (S (S n))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n&#39; = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* We are in the [E = ev_SS n&#39; E&#39;] case now. *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> E&#39;.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> tactic can apply the principle of explosion to
    "obviously contradictory" hypotheses involving inductive
    properties, something that takes a bit more work using our
    inversion lemma. For example: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk3c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk3c"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">one_not_even</span> : ~ even <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ even <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk3d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk3d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ even <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk3e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk3e"><span class="highlight"><span class="nb">intros</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even <span class="mi">1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk3f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk3f"><span class="highlight"><span class="nb">apply</span> ev_inversion <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">1</span> = <span class="mi">0</span> \/
(<span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, <span class="mi">1</span> = S (S n&#39;) /\ even n&#39;)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk40" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk40"><span class="highlight"><span class="nb">destruct</span> H <span class="kr">as</span> [ | [m [Hm _]]].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">1</span> = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk41" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">1</span> = S (S m)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk41"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk42" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk42"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">1</span> = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk43" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk43"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">1</span> = S (S m)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span> Hm.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk44" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk44"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">one_not_even&#39;</span> : ~ even <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ even <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk45" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk45"><span class="highlight"><span class="nb">intros</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even <span class="mi">1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab7"></a><h4 class="section">Exercise: 1 star, standard (inversion_practice)</h4>
<div class="paragraph"> </div>

    Prove the following result using <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>.  For extra practice,
    prove it using the inversion lemma. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk46" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk46"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">SSSSev__even</span> : <span class="kr">forall</span> <span class="nv">n</span>,
  even (S (S (S (S n)))) -&gt; even n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even (S (S (S (S n)))) -&gt; even n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk47" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk47"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even (S (S (S (S n)))) -&gt; even n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab8"></a><h4 class="section">Exercise: 1 star, standard (even5_nonsense)</h4>
<div class="paragraph"> </div>

    Prove the following result using <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk48" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk48"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">even5_nonsense</span> :
  even <span class="mi">5</span> -&gt; <span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">9</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even <span class="mi">5</span> -&gt; <span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">9</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk49" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk49"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even <span class="mi">5</span> -&gt; <span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">9</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> tactic does quite a bit of work. When
    applied to equalities, as a special case, it does the work of both
    <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span> and <span class="inlinecode"><span class="id" title="tactic">injection</span></span>. In addition, it carries out the
    <span class="inlinecode"><span class="id" title="tactic">intros</span></span> and <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>s that are typically necessary in the case
    of <span class="inlinecode"><span class="id" title="tactic">injection</span></span>. It can also be applied, more generally, to analyze
    evidence for inductively defined propositions.  As examples, we'll
    use it to reprove some theorems from <span class="inlinecode"><span class="id" title="var">Tactics.v</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk4a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk4a"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">inversion_ex1</span> : <span class="kr">forall</span> (<span class="nv">n</span> <span class="nv">m</span> <span class="nv">o</span> : nat),
  [n; m] = [o; o] -&gt;
  [n] = [m].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">o</span> : nat, [n; m] = [o; o] -&gt; [n] = [m]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk4b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk4b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">o</span> : nat, [n; m] = [o; o] -&gt; [n] = [m]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk4c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk4c"><span class="highlight"><span class="nb">intros</span> n m o H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, o</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">[n; m] = [o; o]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[n] = [m]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk4d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk4d"><span class="highlight"><span class="nb">inversion</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, o</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">[n; m] = [o; o]</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = o</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = o</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[o] = [o]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk4e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk4e"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">inversion_ex2</span> : <span class="kr">forall</span> (<span class="nv">n</span> : nat),
  S n = O -&gt;
  <span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">5</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, S n = <span class="mi">0</span> -&gt; <span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">5</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk4f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk4f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, S n = <span class="mi">0</span> -&gt; <span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">5</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk50" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk50"><span class="highlight"><span class="nb">intros</span> n contra.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">contra</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">5</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> contra.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Here's how <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> works in general.  Suppose the name
    <span class="inlinecode"><span class="id" title="var">H</span></span> refers to an assumption <span class="inlinecode"><span class="id" title="var">P</span></span> in the current context, where <span class="inlinecode"><span class="id" title="var">P</span></span>
    has been defined by an <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> declaration.  Then, for each of
    the constructors of <span class="inlinecode"><span class="id" title="var">P</span></span>, <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> generates a subgoal in which
    <span class="inlinecode"><span class="id" title="var">H</span></span> has been replaced by the exact, specific conditions under
    which this constructor could have been used to prove <span class="inlinecode"><span class="id" title="var">P</span></span>.  Some of
    these subgoals will be self-contradictory; <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> throws
    these away.  The ones that are left represent the cases that must
    be proved to establish the original goal.  For those, <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>
    adds all equations into the proof context that must hold of the
    arguments given to <span class="inlinecode"><span class="id" title="var">P</span></span> (e.g., <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> in the proof of
    <span class="inlinecode"><span class="id" title="var">evSS_ev</span></span>). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">ev_double</span></span> exercise above shows that our new notion of
    evenness is implied by the two earlier ones (since, by
    <span class="inlinecode"><span class="id" title="var">even_bool_prop</span></span> in chapter <span class="inlinecode"><span class="id" title="var">Logic</span></span>, we already know that
    those are equivalent to each other). To show that all three
    coincide, we just need the following lemma. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk51" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk51"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">ev_even_firsttry</span> : <span class="kr">forall</span> <span class="nv">n</span>,
  even n -&gt; <span class="kr">exists</span> <span class="nv">k</span>, n = double k.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even n -&gt; <span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk52" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk52"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even n -&gt; <span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* WORKED IN CLASS *)</span></span></span></pre><div class="doc">
We could try to proceed by case analysis or induction on <span class="inlinecode"><span class="id" title="var">n</span></span>.  But
    since <span class="inlinecode"><span class="id" title="var">even</span></span> is mentioned in a premise, this strategy would
    probably lead to a dead end, as in the previous section.  Thus, it
    seems better to first try <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> on the evidence for <span class="inlinecode"><span class="id" title="var">even</span></span>.
    Indeed, the first case can be solved trivially. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk53" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk53"><span class="highlight"><span class="nb">intros</span> n E.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk54" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk54"><span class="highlight"><span class="nb">inversion</span> E <span class="kr">as</span> [| n&#39; E&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, <span class="mi">0</span> = double k</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk55" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n&#39;) = n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk55"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, S (S n&#39;) = double k</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk56" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk56"><span class="highlight">- <span class="c">(* E = ev_0 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, <span class="mi">0</span> = double k</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk57" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk57"><span class="highlight"><span class="kr">exists</span> <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = double <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk58" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk58"><span class="highlight">- <span class="c">(* E = ev_SS n&#39; E&#39; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n&#39;) = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, S (S n&#39;) = double k</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk59" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk59"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n&#39;) = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, S (S n&#39;) = double k</span></div></blockquote></div></div></small></span></pre><div class="doc">
Unfortunately, the second case is harder.  We need to show <span class="inlinecode"><span class="id" title="tactic">‚àÉ</span></span>
<span class="inlinecode"><span class="id" title="var">k</span>,</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">double</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span>, but the only available assumption is
    <span class="inlinecode"><span class="id" title="var">E'</span></span>, which states that <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> holds.  Since this isn't
    directly useful, it seems that we are stuck and that performing
    case analysis on <span class="inlinecode"><span class="id" title="var">E</span></span> was a waste of time.

<div class="paragraph"> </div>

    If we look more closely at our second goal, however, we can see
    that something interesting happened: By performing case analysis
    on <span class="inlinecode"><span class="id" title="var">E</span></span>, we were able to reduce the original result to a similar
    one that involves a <i>different</i> piece of evidence for <span class="inlinecode"><span class="id" title="var">even</span></span>:
    namely <span class="inlinecode"><span class="id" title="var">E'</span></span>.  More formally, we can finish our proof by showing
    that

<div class="paragraph"> </div>

        exists k', n' = double k',

<div class="paragraph"> </div>

    which is the same as the original statement, but with <span class="inlinecode"><span class="id" title="var">n'</span></span> instead
    of <span class="inlinecode"><span class="id" title="var">n</span></span>.  Indeed, it is not difficult to convince Coq that this
    intermediate result suffices. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">    </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk5a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk5a"><span class="highlight"><span class="nb">assert</span> (I : (<span class="kr">exists</span> <span class="nv">k&#39;</span>, n&#39; = double k&#39;) -&gt;
                (<span class="kr">exists</span> <span class="nv">k</span>, S (S n&#39;) = double k)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n&#39;) = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">exists</span> <span class="nv">k&#39;</span> : nat, n&#39; = double k&#39;) -&gt;
<span class="kr">exists</span> <span class="nv">k</span> : nat, S (S n&#39;) = double k</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk5b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n&#39;) = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">I</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(<span class="kr">exists</span> <span class="nv">k&#39;</span> : nat, n&#39; = double k&#39;) -&gt;
<span class="kr">exists</span> <span class="nv">k</span> : nat, S (S n&#39;) = double k</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk5b"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, S (S n&#39;) = double k</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk5c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk5c"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n&#39;) = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">exists</span> <span class="nv">k&#39;</span> : nat, n&#39; = double k&#39;) -&gt;
<span class="kr">exists</span> <span class="nv">k</span> : nat, S (S n&#39;) = double k</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk5d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk5d"><span class="highlight"><span class="nb">intros</span> [k&#39; Hk&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n&#39;) = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">k'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hk'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n&#39; = double k&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, S (S n&#39;) = double k</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk5e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk5e"><span class="highlight"><span class="nb">rewrite</span> Hk&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n&#39;) = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">k'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hk'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n&#39; = double k&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, S (S (double k&#39;)) = double k</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk5f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk5f"><span class="highlight"><span class="kr">exists</span> (<span class="nv">S</span> <span class="nv">k&#39;</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n&#39;) = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">k'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hk'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n&#39; = double k&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">S (S (double k&#39;)) = double (S k&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk60" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk60"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n&#39;) = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">I</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(<span class="kr">exists</span> <span class="nv">k&#39;</span> : nat, n&#39; = double k&#39;) -&gt;
<span class="kr">exists</span> <span class="nv">k</span> : nat, S (S n&#39;) = double k</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, S (S n&#39;) = double k</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk61" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk61"><span class="highlight"><span class="nb">apply</span> I. <span class="c">(* reduce the original goal to the new one *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S (S n&#39;) = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">I</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(<span class="kr">exists</span> <span class="nv">k&#39;</span> : nat, n&#39; = double k&#39;) -&gt;
<span class="kr">exists</span> <span class="nv">k</span> : nat, S (S n&#39;) = double k</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k&#39;</span> : nat, n&#39; = double k&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab9"></a><h2 class="section">Induction on Evidence</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
If this looks familiar, it is no coincidence: We've
    encountered similar problems in the <span class="inlinecode"><span class="id" title="keyword">Induction</span></span> chapter, when
    trying to use case analysis to prove results that required
    induction.  And once again the solution is... induction!

<div class="paragraph"> </div>

    The behavior of <span class="inlinecode"><span class="id" title="tactic">induction</span></span> on evidence is the same as its
    behavior on data: It causes Coq to generate one subgoal for each
    constructor that could have used to build that evidence, while
    providing an induction hypotheses for each recursive occurrence of
    the property in question.

<div class="paragraph"> </div>

    To prove a property of <span class="inlinecode"><span class="id" title="var">n</span></span> holds for all numbers for which <span class="inlinecode"><span class="id" title="var">even</span></span>
<span class="inlinecode"><span class="id" title="var">n</span></span> holds, we can use induction on <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. This requires us to
    prove two things, corresponding to the two ways in which <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>
    could have been constructed. If it was constructed by <span class="inlinecode"><span class="id" title="var">ev_0</span></span>, then
    <span class="inlinecode"><span class="id" title="var">n</span>=0</span>, and the property must hold of <span class="inlinecode">0</span>. If it was constructed by
    <span class="inlinecode"><span class="id" title="var">ev_SS</span></span>, then the evidence of <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> is of the form <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>
<span class="inlinecode"><span class="id" title="var">E'</span></span>, where <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> and <span class="inlinecode"><span class="id" title="var">E'</span></span> is evidence for <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>. In
    this case, the inductive hypothesis says that the property we are
    trying to prove holds for <span class="inlinecode"><span class="id" title="var">n'</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Let's try our current lemma again: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk62" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk62"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">ev_even</span> : <span class="kr">forall</span> <span class="nv">n</span>,
  even n -&gt; <span class="kr">exists</span> <span class="nv">k</span>, n = double k.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even n -&gt; <span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk63" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk63"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even n -&gt; <span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk64" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk64"><span class="highlight"><span class="nb">intros</span> n E.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk65" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk65"><span class="highlight"><span class="nb">induction</span> E <span class="kr">as</span> [|n&#39; E&#39; IH].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, <span class="mi">0</span> = double k</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk66" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, n&#39; = double k</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk66"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, S (S n&#39;) = double k</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk67" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk67"><span class="highlight">- <span class="c">(* E = ev_0 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, <span class="mi">0</span> = double k</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk68" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk68"><span class="highlight"><span class="kr">exists</span> <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = double <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk69" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk69"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, n&#39; = double k</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, S (S n&#39;) = double k</span></div></blockquote></div></div></small></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* E = ev_SS n&#39; E&#39;</span>
<span class="c">       with IH : exists k&#39;, n&#39; = double k&#39; *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk6a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk6a"><span class="highlight"><span class="nb">destruct</span> IH <span class="kr">as</span> [k&#39; Hk&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">k'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hk'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n&#39; = double k&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, S (S n&#39;) = double k</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk6b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk6b"><span class="highlight"><span class="nb">rewrite</span> Hk&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">k'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hk'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n&#39; = double k&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">k</span> : nat, S (S (double k&#39;)) = double k</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk6c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk6c"><span class="highlight"><span class="kr">exists</span> (<span class="nv">S</span> <span class="nv">k&#39;</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">even n&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">k'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hk'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n&#39; = double k&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">S (S (double k&#39;)) = double (S k&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Here, we can see that Coq produced an <span class="inlinecode"><span class="id" title="var">IH</span></span> that corresponds
    to <span class="inlinecode"><span class="id" title="var">E'</span></span>, the single recursive occurrence of <span class="inlinecode"><span class="id" title="var">even</span></span> in its own
    definition.  Since <span class="inlinecode"><span class="id" title="var">E'</span></span> mentions <span class="inlinecode"><span class="id" title="var">n'</span></span>, the induction hypothesis
    talks about <span class="inlinecode"><span class="id" title="var">n'</span></span>, as opposed to <span class="inlinecode"><span class="id" title="var">n</span></span> or some other number. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The equivalence between the second and third definitions of
    evenness now follows. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk6d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk6d"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">ev_even_iff</span> : <span class="kr">forall</span> <span class="nv">n</span>,
  even n &lt;-&gt; <span class="kr">exists</span> <span class="nv">k</span>, n = double k.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
even n &lt;-&gt; (<span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk6e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk6e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
even n &lt;-&gt; (<span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk6f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk6f"><span class="highlight"><span class="nb">intros</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n &lt;-&gt; (<span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk70" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk70"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n -&gt; <span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk71" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk71"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k) -&gt; even n</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk72" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk72"><span class="highlight">- <span class="c">(* -&gt; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n -&gt; <span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> ev_even.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk73" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk73"><span class="highlight">- <span class="c">(* &lt;- *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">exists</span> <span class="nv">k</span> : nat, n = double k) -&gt; even n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk74" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk74"><span class="highlight"><span class="nb">intros</span> [k Hk].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, k</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hk</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = double k</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even n</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk75" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk75"><span class="highlight"><span class="nb">rewrite</span> Hk.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, k</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hk</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = double k</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">even (double k)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> ev_double.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
As we will see in later chapters, induction on evidence is a
    recurring technique across many areas, and in particular when
    formalizing the semantics of programming languages, where many
    properties of interest are defined inductively. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The following exercises provide simple examples of this
    technique, to help you familiarize yourself with it. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab10"></a><h4 class="section">Exercise: 2 stars, standard (ev_sum)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk76" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk76"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">ev_sum</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>, even n -&gt; even m -&gt; even (n + m).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, even n -&gt; even m -&gt; even (n + m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk77" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk77"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, even n -&gt; even m -&gt; even (n + m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab11"></a><h4 class="section">Exercise: 4 stars, advanced, optional (even'_ev)</h4>
<div class="paragraph"> </div>

    In general, there may be multiple ways of defining a
    property inductively.  For example, here's a (slightly contrived)
    alternative definition for <span class="inlinecode"><span class="id" title="var">even</span></span>: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">even&#39;</span> : nat -&gt; <span class="kt">Prop</span> :=
| even&#39;_0 : even&#39; <span class="mi">0</span>
| even&#39;_2 : even&#39; <span class="mi">2</span>
| even&#39;_sum n m (Hn : even&#39; n) (Hm : even&#39; m) : even&#39; (n + m).</span></span></span></pre><div class="doc">
Prove that this definition is logically equivalent to the old
    one.  (You may want to look at the previous theorem when you get
    to the induction step.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk78" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk78"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">even&#39;_ev</span> : <span class="kr">forall</span> <span class="nv">n</span>, even&#39; n &lt;-&gt; even n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even&#39; n &lt;-&gt; even n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk79" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk79"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, even&#39; n &lt;-&gt; even n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab12"></a><h4 class="section">Exercise: 3 stars, advanced, recommended (ev_ev__ev)</h4>
<div class="paragraph"> </div>

    Finding the appropriate thing to do induction on is a
    bit tricky here: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk7a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk7a"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">ev_ev__ev</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>,
  even (n+m) -&gt; even n -&gt; even m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, even (n + m) -&gt; even n -&gt; even m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk7b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk7b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, even (n + m) -&gt; even n -&gt; even m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab13"></a><h4 class="section">Exercise: 3 stars, standard, optional (ev_plus_plus)</h4>
<div class="paragraph"> </div>

    This exercise just requires applying existing lemmas.  No
    induction or even case analysis is needed, though some of the
    rewriting may be tedious. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk7c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk7c"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">ev_plus_plus</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span>,
  even (n+m) -&gt; even (n+p) -&gt; even (m+p).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span> : nat,
even (n + m) -&gt; even (n + p) -&gt; even (m + p)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk7d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk7d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span> : nat,
even (n + m) -&gt; even (n + p) -&gt; even (m + p)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab14"></a><h1 class="section">Inductive Relations</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
A proposition parameterized by a number (such as <span class="inlinecode"><span class="id" title="var">even</span></span>)
    can be thought of as a <i>property</i> -- i.e., it defines
    a subset of <span class="inlinecode"><span class="id" title="var">nat</span></span>, namely those numbers for which the proposition
    is provable.  In the same way, a two-argument proposition can be
    thought of as a <i>relation</i> -- i.e., it defines a set of pairs for
    which the proposition is provable. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">Playground</span>.</span></span></span></pre><div class="doc">
One useful example is the "less than or equal to" relation on
    numbers. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The following definition should be fairly intuitive.  It
    says that there are two ways to give evidence that one number is
    less than or equal to another: either observe that they are the
    same number, or give evidence that the first is less than or equal
    to the predecessor of the second. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">le</span> : nat -&gt; nat -&gt; <span class="kt">Prop</span> :=
  | le_n n : le n n
  | le_S n m (H : le n m) : le n (S m).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;m &lt;= n&quot;</span> := (le m n).</span></span></span></pre><div class="doc">
Proofs of facts about <span class="inlinecode">‚â§</span> using the constructors <span class="inlinecode"><span class="id" title="var">le_n</span></span> and
    <span class="inlinecode"><span class="id" title="var">le_S</span></span> follow the same patterns as proofs about properties, like
    <span class="inlinecode"><span class="id" title="var">even</span></span> above. We can <span class="inlinecode"><span class="id" title="tactic">apply</span></span> the constructors to prove <span class="inlinecode">‚â§</span>
    goals (e.g., to show that <span class="inlinecode">3&lt;=3</span> or <span class="inlinecode">3&lt;=6</span>), and we can use
    tactics like <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> to extract information from <span class="inlinecode">‚â§</span>
    hypotheses in the context (e.g., to prove that <span class="inlinecode">(2</span> <span class="inlinecode">‚â§</span> <span class="inlinecode">1)</span> <span class="inlinecode">‚Üí</span>
<span class="inlinecode">2+2=5</span>.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Here are some sanity checks on the definition.  (Notice that,
    although these are the same kind of simple "unit tests" as we gave
    for the testing functions we wrote in the first few lectures, we
    must construct their proofs explicitly -- <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> and
    <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> don't do the job, because the proofs aren't just a
    matter of simplifying computations.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk7e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk7e"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">test_le1</span> :
  <span class="mi">3</span> &lt;= <span class="mi">3</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> &lt;= <span class="mi">3</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk7f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk7f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> &lt;= <span class="mi">3</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> le_n.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk80" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk80"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">test_le2</span> :
  <span class="mi">3</span> &lt;= <span class="mi">6</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> &lt;= <span class="mi">6</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk81" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk81"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> &lt;= <span class="mi">6</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk82" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk82"><span class="highlight"><span class="nb">apply</span> le_S.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> &lt;= <span class="mi">5</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk83" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk83"><span class="highlight"><span class="nb">apply</span> le_S.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> &lt;= <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk84" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk84"><span class="highlight"><span class="nb">apply</span> le_S.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> &lt;= <span class="mi">3</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> le_n.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk85" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk85"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">test_le3</span> :
  (<span class="mi">2</span> &lt;= <span class="mi">1</span>) -&gt; <span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">5</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> &lt;= <span class="mi">1</span> -&gt; <span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">5</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk86" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk86"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> &lt;= <span class="mi">1</span> -&gt; <span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">5</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk87" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk87"><span class="highlight"><span class="nb">intros</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">2</span> &lt;= <span class="mi">1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">5</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk88" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk88"><span class="highlight"><span class="nb">inversion</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">2</span> &lt;= <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">2</span> &lt;= <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">5</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H2.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The "strictly less than" relation <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">m</span></span> can now be defined
    in terms of <span class="inlinecode"><span class="id" title="var">le</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Playground</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lt</span> (<span class="nv">n</span> <span class="nv">m</span>:nat) := le (S n) m.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;m &lt; n&quot;</span> := (lt m n).</span></span></span></pre><div class="doc">
Here are a few more simple relations on numbers: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">square_of</span> : nat -&gt; nat -&gt; <span class="kt">Prop</span> :=
  | sq n : square_of n (n * n).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">next_nat</span> : nat -&gt; nat -&gt; <span class="kt">Prop</span> :=
  | nn n : next_nat n (S n).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">next_even</span> : nat -&gt; nat -&gt; <span class="kt">Prop</span> :=
  | ne_1 n : even (S n) -&gt; next_even n (S n)
  | ne_2 n (H : even (S (S n))) : next_even n (S (S n)).</span></span></span></pre><div class="doc">
<a name="lab15"></a><h4 class="section">Exercise: 2 stars, standard, optional (total_relation)</h4>
<div class="paragraph"> </div>

    Define an inductive binary relation <span class="inlinecode"><span class="id" title="var">total_relation</span></span> that holds
    between every pair of natural numbers. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE </span>

<span class="c">    [] *)</span></span></span></pre><div class="doc">
<a name="lab16"></a><h4 class="section">Exercise: 2 stars, standard, optional (empty_relation)</h4>
<div class="paragraph"> </div>

    Define an inductive binary relation <span class="inlinecode"><span class="id" title="var">empty_relation</span></span> (on numbers)
    that never holds. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE </span>

<span class="c">    [] *)</span></span></span></pre><div class="doc">
From the definition of <span class="inlinecode"><span class="id" title="var">le</span></span>, we can sketch the behaviors of
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, and <span class="inlinecode"><span class="id" title="tactic">induction</span></span> on a hypothesis <span class="inlinecode"><span class="id" title="var">H</span></span>
    providing evidence of the form <span class="inlinecode"><span class="id" title="var">le</span></span> <span class="inlinecode"><span class="id" title="var">e1</span></span> <span class="inlinecode"><span class="id" title="var">e2</span></span>.  Doing <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>
    will generate two cases. In the first case, <span class="inlinecode"><span class="id" title="var">e1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">e2</span></span>, and it
    will replace instances of <span class="inlinecode"><span class="id" title="var">e2</span></span> with <span class="inlinecode"><span class="id" title="var">e1</span></span> in the goal and context.
    In the second case, <span class="inlinecode"><span class="id" title="var">e2</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> for some <span class="inlinecode"><span class="id" title="var">n'</span></span> for which <span class="inlinecode"><span class="id" title="var">le</span></span> <span class="inlinecode"><span class="id" title="var">e1</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>
    holds, and it will replace instances of <span class="inlinecode"><span class="id" title="var">e2</span></span> with <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>. 
    Doing <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> will remove impossible cases and add generated
    equalities to the context for further use. Doing <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>
    will, in the second case, add the induction hypothesis that the
    goal holds when <span class="inlinecode"><span class="id" title="var">e2</span></span> is replaced with <span class="inlinecode"><span class="id" title="var">n'</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab17"></a><h4 class="section">Exercise: 3 stars, standard, optional (le_exercises)</h4>
<div class="paragraph"> </div>

    Here are a number of facts about the <span class="inlinecode">‚â§</span> and <span class="inlinecode">&lt;</span> relations that
    we are going to need later in the course.  The proofs make good
    practice exercises. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk89" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk89"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">le_trans</span> : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">o</span>, m &lt;= n -&gt; n &lt;= o -&gt; m &lt;= o.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">o</span> : nat, m &lt;= n -&gt; n &lt;= o -&gt; m &lt;= o</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk8a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk8a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">o</span> : nat, m &lt;= n -&gt; n &lt;= o -&gt; m &lt;= o</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk8b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk8b"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">O_le_n</span> : <span class="kr">forall</span> <span class="nv">n</span>,
  <span class="mi">0</span> &lt;= n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="mi">0</span> &lt;= n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk8c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk8c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="mi">0</span> &lt;= n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk8d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk8d"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">n_le_m__Sn_le_Sm</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>,
  n &lt;= m -&gt; S n &lt;= S m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n &lt;= m -&gt; S n &lt;= S m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk8e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk8e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n &lt;= m -&gt; S n &lt;= S m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk8f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk8f"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">Sn_le_Sm__n_le_m</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>,
  S n &lt;= S m -&gt; n &lt;= m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, S n &lt;= S m -&gt; n &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk90" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk90"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, S n &lt;= S m -&gt; n &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk91" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk91"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">le_plus_l</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>,
  a &lt;= a + b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : nat, a &lt;= a + b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk92" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk92"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : nat, a &lt;= a + b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk93" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk93"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">plus_lt</span> : <span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">m</span>,
  n1 + n2 &lt; m -&gt;
  n1 &lt; m /\ n2 &lt; m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">m</span> : nat, n1 + n2 &lt; m -&gt; n1 &lt; m /\ n2 &lt; m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk94" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk94"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">m</span> : nat, n1 + n2 &lt; m -&gt; n1 &lt; m /\ n2 &lt; m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"> </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk95" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk95"><span class="highlight"><span class="nb">unfold</span> lt.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">m</span> : nat,
S (n1 + n2) &lt;= m -&gt; S n1 &lt;= m /\ S n2 &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk96" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk96"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">lt_S</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>,
  n &lt; m -&gt;
  n &lt; S m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n &lt; m -&gt; n &lt; S m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk97" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk97"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n &lt; m -&gt; n &lt; S m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk98" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk98"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">leb_complete</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>,
  n &lt;=? m = true -&gt; n &lt;= m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, (n &lt;=? m) = true -&gt; n &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk99" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk99"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, (n &lt;=? m) = true -&gt; n &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
Hint: The next one may be easiest to prove by induction on <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk9a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk9a"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">leb_correct</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>,
  n &lt;= m -&gt;
  n &lt;=? m = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n &lt;= m -&gt; (n &lt;=? m) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk9b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk9b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n &lt;= m -&gt; (n &lt;=? m) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
Hint: This one can easily be proved without using <span class="inlinecode"><span class="id" title="tactic">induction</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk9c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk9c"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">leb_true_trans</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">o</span>,
  n &lt;=? m = true -&gt; m &lt;=? o = true -&gt; n &lt;=? o = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">o</span> : nat,
(n &lt;=? m) = true -&gt;
(m &lt;=? o) = true -&gt; (n &lt;=? o) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk9d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk9d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">o</span> : nat,
(n &lt;=? m) = true -&gt;
(m &lt;=? o) = true -&gt; (n &lt;=? o) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab18"></a><h4 class="section">Exercise: 2 stars, standard, optional (leb_iff)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk9e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk9e"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">leb_iff</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>,
  n &lt;=? m = true &lt;-&gt; n &lt;= m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, (n &lt;=? m) = true &lt;-&gt; n &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk9f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk9f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, (n &lt;=? m) = true &lt;-&gt; n &lt;= m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">R</span>.</span></span></span></pre><div class="doc">
<a name="lab19"></a><h4 class="section">Exercise: 3 stars, standard, recommended (R_provability)</h4>
<div class="paragraph"> </div>

    We can define three-place relations, four-place relations,
    etc., in just the same way as binary relations.  For example,
    consider the following three-place relation on numbers: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">R</span> : nat -&gt; nat -&gt; nat -&gt; <span class="kt">Prop</span> :=
   | c1 : R <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
   | c2 m n o (H : R m n o) : R (S m) n (S o)
   | c3 m n o (H : R m n o) : R m (S n) (S o)
   | c4 m n o (H : R (S m) (S n) (S (S o))) : R m n o
   | c5 m n o (H : R m n o) : R n m o.</span></span></span></pre><div class="doc">
<ul class="doclist">
<li> Which of the following propositions are provable?
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">1</span> <span class="inlinecode">1</span> <span class="inlinecode">2</span>
</li>
<li> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">2</span> <span class="inlinecode">2</span> <span class="inlinecode">6</span>
<div class="paragraph"> </div>
</li>
</ul>
</li>
<li> If we dropped constructor <span class="inlinecode"><span class="id" title="var">c5</span></span> from the definition of <span class="inlinecode"><span class="id" title="var">R</span></span>,
      would the set of provable propositions change?  Briefly (1
      sentence) explain your answer.

<div class="paragraph"> </div>
</li>
<li> If we dropped constructor <span class="inlinecode"><span class="id" title="var">c4</span></span> from the definition of <span class="inlinecode"><span class="id" title="var">R</span></span>,
      would the set of provable propositions change?  Briefly (1
      sentence) explain your answer.

</li>
</ul>
<div class="paragraph"> </div>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_R_provability</span> : option (nat*string) := None.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab20"></a><h4 class="section">Exercise: 3 stars, standard, optional (R_fact)</h4>
<div class="paragraph"> </div>

    The relation <span class="inlinecode"><span class="id" title="var">R</span></span> above actually encodes a familiar function.
    Figure out which function; then state and prove this equivalence
    in Coq? 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chka0" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chka0"><span class="highlight"><span class="kn">Definition</span> <span class="nf">fR</span> : nat -&gt; nat -&gt; nat
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nat -&gt; nat -&gt; nat</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chka1" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chka1"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">R_equiv_fR</span> : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">o</span>, R m n o &lt;-&gt; fR m n = o.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">o</span> : nat, R m n o &lt;-&gt; fR m n = o</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chka2" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chka2"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">o</span> : nat, R m n o &lt;-&gt; fR m n = o</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">R</span>.</span></span></span></pre><div class="doc">
<a name="lab21"></a><h4 class="section">Exercise: 2 stars, advanced (subsequence)</h4>
<div class="paragraph"> </div>

    A list is a <i>subsequence</i> of another list if all of the elements
    in the first list occur in the same order in the second list,
    possibly with some extra elements in between. For example,

<div class="paragraph"> </div>
<span class="inlinecode">1;2;3</span>
<div class="paragraph"> </div>

    is a subsequence of each of the lists

<div class="paragraph"> </div>
<span class="inlinecode">1;2;3</span>
<span class="inlinecode">1;1;1;2;2;3</span>
<span class="inlinecode">1;2;7;3</span>
<span class="inlinecode">5;6;1;9;9;2;7;3;8</span>
<div class="paragraph"> </div>

    but it is <i>not</i> a subsequence of any of the lists

<div class="paragraph"> </div>
<span class="inlinecode">1;2</span>
<span class="inlinecode">1;3</span>
<span class="inlinecode">5;6;2;1;7;3;8</span>.

<div class="paragraph"> </div>
<ul class="doclist">
<li> Define an inductive proposition <span class="inlinecode"><span class="id" title="var">subseq</span></span> on <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> that
      captures what it means to be a subsequence. (Hint: You'll need
      three cases.)

<div class="paragraph"> </div>
</li>
<li> Prove <span class="inlinecode"><span class="id" title="var">subseq_refl</span></span> that subsequence is reflexive, that is,
      any list is a subsequence of itself.

<div class="paragraph"> </div>
</li>
<li> Prove <span class="inlinecode"><span class="id" title="var">subseq_app</span></span> that for any lists <span class="inlinecode"><span class="id" title="var">l1</span></span>, <span class="inlinecode"><span class="id" title="var">l2</span></span>, and <span class="inlinecode"><span class="id" title="var">l3</span></span>,
      if <span class="inlinecode"><span class="id" title="var">l1</span></span> is a subsequence of <span class="inlinecode"><span class="id" title="var">l2</span></span>, then <span class="inlinecode"><span class="id" title="var">l1</span></span> is also a subsequence
      of <span class="inlinecode"><span class="id" title="var">l2</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">l3</span></span>.

<div class="paragraph"> </div>
</li>
<li> (Optional, harder) Prove <span class="inlinecode"><span class="id" title="var">subseq_trans</span></span> that subsequence is
      transitive -- that is, if <span class="inlinecode"><span class="id" title="var">l1</span></span> is a subsequence of <span class="inlinecode"><span class="id" title="var">l2</span></span> and <span class="inlinecode"><span class="id" title="var">l2</span></span>
      is a subsequence of <span class="inlinecode"><span class="id" title="var">l3</span></span>, then <span class="inlinecode"><span class="id" title="var">l1</span></span> is a subsequence of <span class="inlinecode"><span class="id" title="var">l3</span></span>.
      Hint: choose your induction carefully! 
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">subseq</span> : list nat -&gt; list nat -&gt; <span class="kt">Prop</span> :=
<span class="c">(* FILL IN HERE *)</span>
.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chka3" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chka3"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">subseq_refl</span> : <span class="kr">forall</span> (<span class="nv">l</span> : list nat), subseq l l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list nat, subseq l l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chka4" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chka4"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list nat, subseq l l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chka5" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chka5"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">subseq_app</span> : <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list nat),
  subseq l1 l2 -&gt;
  subseq l1 (l2 ++ l3).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list nat,
subseq l1 l2 -&gt; subseq l1 (l2 ++ l3)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chka6" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chka6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list nat,
subseq l1 l2 -&gt; subseq l1 (l2 ++ l3)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chka7" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chka7"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">subseq_trans</span> : <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list nat),
  subseq l1 l2 -&gt;
  subseq l2 l3 -&gt;
  subseq l1 l3.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list nat,
subseq l1 l2 -&gt; subseq l2 l3 -&gt; subseq l1 l3</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chka8" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chka8"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list nat,
subseq l1 l2 -&gt; subseq l2 l3 -&gt; subseq l1 l3</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab22"></a><h4 class="section">Exercise: 2 stars, standard, optional (R_provability2)</h4>
<div class="paragraph"> </div>

    Suppose we give Coq the following definition:

<div class="paragraph"> </div>

    Inductive R : nat -&gt; list nat -&gt; Prop :=
      | c1 : R 0 <font size="-2">‚òê</font>
      | c2 : forall n l, R n l -&gt; R (S n) (n :: l)
      | c3 : forall n l, R (S n) l -&gt; R n l.

<div class="paragraph"> </div>

    Which of the following propositions are provable?

<div class="paragraph"> </div>
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">2</span> <span class="inlinecode">[1;0]</span>
</li>
<li> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">1</span> <span class="inlinecode">[1;2;1;0]</span>
</li>
<li> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">6</span> <span class="inlinecode">[3;2;1;0]</span>
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE </span>

<span class="c">    [] *)</span>

<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab23"></a><h1 class="section">Case Study: Regular Expressions</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">even</span></span> property provides a simple example for
    illustrating inductive definitions and the basic techniques for
    reasoning about them, but it is not terribly exciting -- after
    all, it is equivalent to the two non-inductive definitions of
    evenness that we had already seen, and does not seem to offer any
    concrete benefit over them.

<div class="paragraph"> </div>

    To give a better sense of the power of inductive definitions, we
    now show how to use them to model a classic concept in computer
    science: <i>regular expressions</i>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Regular expressions are a simple language for describing sets of
    strings.  Their syntax is defined as follows: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">reg_exp</span> {<span class="nv">T</span> : <span class="kt">Type</span>} : <span class="kt">Type</span> :=
  | EmptySet
  | EmptyStr
  | Char (t : T)
  | App (r1 r2 : reg_exp)
  | Union (r1 r2 : reg_exp)
  | Star (r : reg_exp).</span></span></span></pre><div class="doc">
Note that this definition is <i>polymorphic</i>: Regular
    expressions in <span class="inlinecode"><span class="id" title="var">reg_exp</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span> describe strings with characters drawn
    from <span class="inlinecode"><span class="id" title="var">T</span></span> -- that is, lists of elements of <span class="inlinecode"><span class="id" title="var">T</span></span>.

<div class="paragraph"> </div>

    (We depart slightly from standard practice in that we do not
    require the type <span class="inlinecode"><span class="id" title="var">T</span></span> to be finite.  This results in a somewhat
    different theory of regular expressions, but the difference is not
    significant for our purposes.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We connect regular expressions and strings via the following
    rules, which define when a regular expression <i>matches</i> some
    string:

<div class="paragraph"> </div>
<ul class="doclist">
<li> The expression <span class="inlinecode"><span class="id" title="var">EmptySet</span></span> does not match any string.

<div class="paragraph"> </div>
</li>
<li> The expression <span class="inlinecode"><span class="id" title="var">EmptyStr</span></span> matches the empty string <span class="inlinecode">[]</span>.

<div class="paragraph"> </div>
</li>
<li> The expression <span class="inlinecode"><span class="id" title="var">Char</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> matches the one-character string <span class="inlinecode">[<span class="id" title="var">x</span>]</span>.

<div class="paragraph"> </div>
</li>
<li> If <span class="inlinecode"><span class="id" title="var">re1</span></span> matches <span class="inlinecode"><span class="id" title="var">s1</span></span>, and <span class="inlinecode"><span class="id" title="var">re2</span></span> matches <span class="inlinecode"><span class="id" title="var">s2</span></span>,
        then <span class="inlinecode"><span class="id" title="var">App</span></span> <span class="inlinecode"><span class="id" title="var">re1</span></span> <span class="inlinecode"><span class="id" title="var">re2</span></span> matches <span class="inlinecode"><span class="id" title="var">s1</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">s2</span></span>.

<div class="paragraph"> </div>
</li>
<li> If at least one of <span class="inlinecode"><span class="id" title="var">re1</span></span> and <span class="inlinecode"><span class="id" title="var">re2</span></span> matches <span class="inlinecode"><span class="id" title="var">s</span></span>,
        then <span class="inlinecode"><span class="id" title="var">Union</span></span> <span class="inlinecode"><span class="id" title="var">re1</span></span> <span class="inlinecode"><span class="id" title="var">re2</span></span> matches <span class="inlinecode"><span class="id" title="var">s</span></span>.

<div class="paragraph"> </div>
</li>
<li> Finally, if we can write some string <span class="inlinecode"><span class="id" title="var">s</span></span> as the concatenation
        of a sequence of strings <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">s_1</span></span> <span class="inlinecode">++</span> <span class="inlinecode">...</span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">s_k</span></span>, and the
        expression <span class="inlinecode"><span class="id" title="var">re</span></span> matches each one of the strings <span class="inlinecode"><span class="id" title="var">s_i</span></span>,
        then <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span> matches <span class="inlinecode"><span class="id" title="var">s</span></span>.

<div class="paragraph"> </div>

        As a special case, the sequence of strings may be empty, so
        <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span> always matches the empty string <span class="inlinecode">[]</span> no matter what
        <span class="inlinecode"><span class="id" title="var">re</span></span> is. 
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We can easily translate this informal definition into an
    <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> one as follows: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">exp_match</span> {<span class="nv">T</span>} : list T -&gt; reg_exp -&gt; <span class="kt">Prop</span> :=
  | MEmpty : exp_match [] EmptyStr
  | MChar x : exp_match [x] (Char x)
  | MApp s1 re1 s2 re2
             (H1 : exp_match s1 re1)
             (H2 : exp_match s2 re2) :
             exp_match (s1 ++ s2) (App re1 re2)
  | MUnionL s1 re1 re2
                (H1 : exp_match s1 re1) :
                exp_match s1 (Union re1 re2)
  | MUnionR re1 s2 re2
                (H2 : exp_match s2 re2) :
                exp_match s2 (Union re1 re2)
  | MStar0 re : exp_match [] (Star re)
  | MStarApp s1 s2 re
                 (H1 : exp_match s1 re)
                 (H2 : exp_match s2 (Star re)) :
                 exp_match (s1 ++ s2) (Star re).</span></span></span></pre><div class="doc">
Again, for readability, we can also display this definition using
    inference-rule notation.  At the same time, let's introduce a more
    readable infix notation. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;s =~ re&quot;</span> := (exp_match s re) (<span class="kn">at level</span> <span class="mi">80</span>).</span></span></span></pre><div class="doc">
<hr/>
                    (MEmpty)
                           <font size="-2">‚òê</font> =~ EmptyStr
<hr/>
                      (MChar)
                           <span class="inlinecode"><span class="id" title="var">x</span></span> =~ Char x

<div class="paragraph"> </div>

                       s1 =~ re1    s2 =~ re2
<hr/>
                 (MApp)
                       s1 ++ s2 =~ App re1 re2

<div class="paragraph"> </div>

                              s1 =~ re1
<hr/>
                (MUnionL)
                         s1 =~ Union re1 re2

<div class="paragraph"> </div>

                              s2 =~ re2
<hr/>
                (MUnionR)
                         s2 =~ Union re1 re2
<hr/>
                     (MStar0)
                           <font size="-2">‚òê</font> =~ Star re

<div class="paragraph"> </div>

                      s1 =~ re    s2 =~ Star re
<hr/>
            (MStarApp)
                        s1 ++ s2 =~ Star re

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Notice that these rules are not <i>quite</i> the same as the
    informal ones that we gave at the beginning of the section.
    First, we don't need to include a rule explicitly stating that no
    string matches <span class="inlinecode"><span class="id" title="var">EmptySet</span></span>; we just don't happen to include any
    rule that would have the effect of some string matching
    <span class="inlinecode"><span class="id" title="var">EmptySet</span></span>.  (Indeed, the syntax of inductive definitions doesn't
    even <i>allow</i> us to give such a "negative rule.")

<div class="paragraph"> </div>

    Second, the informal rules for <span class="inlinecode"><span class="id" title="var">Union</span></span> and <span class="inlinecode"><span class="id" title="var">Star</span></span> correspond
    to two constructors each: <span class="inlinecode"><span class="id" title="var">MUnionL</span></span> / <span class="inlinecode"><span class="id" title="var">MUnionR</span></span>, and <span class="inlinecode"><span class="id" title="var">MStar0</span></span> /
    <span class="inlinecode"><span class="id" title="var">MStarApp</span></span>.  The result is logically equivalent to the original
    rules but more convenient to use in Coq, since the recursive
    occurrences of <span class="inlinecode"><span class="id" title="var">exp_match</span></span> are given as direct arguments to the
    constructors, making it easier to perform induction on evidence.
    (The <span class="inlinecode"><span class="id" title="var">exp_match_ex1</span></span> and <span class="inlinecode"><span class="id" title="var">exp_match_ex2</span></span> exercises below ask you
    to prove that the constructors given in the inductive declaration
    and the ones that would arise from a more literal transcription of
    the informal rules are indeed equivalent.)

<div class="paragraph"> </div>

    Let's illustrate these rules with a few examples. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chka9" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chka9"><span class="highlight"><span class="kn">Example</span> <span class="nf">reg_exp_ex1</span> : [<span class="mi">1</span>] =~ Char <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">1</span>] =~ Char <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkaa" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkaa"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">1</span>] =~ Char <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> MChar.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkab" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkab"><span class="highlight"><span class="kn">Example</span> <span class="nf">reg_exp_ex2</span> : [<span class="mi">1</span>; <span class="mi">2</span>] =~ App (Char <span class="mi">1</span>) (Char <span class="mi">2</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">1</span>; <span class="mi">2</span>] =~ App (Char <span class="mi">1</span>) (Char <span class="mi">2</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkac" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkac"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">1</span>; <span class="mi">2</span>] =~ App (Char <span class="mi">1</span>) (Char <span class="mi">2</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkad" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkad"><span class="highlight"><span class="nb">apply</span> (MApp [<span class="mi">1</span>] _ [<span class="mi">2</span>]).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">1</span>] =~ Char <span class="mi">1</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chkae" style="display: none" type="checkbox"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">2</span>] =~ Char <span class="mi">2</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkaf" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkaf"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">1</span>] =~ Char <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> MChar.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkb0" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkb0"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">2</span>] =~ Char <span class="mi">2</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> MChar.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
(Notice how the last example applies <span class="inlinecode"><span class="id" title="var">MApp</span></span> to the strings
    <span class="inlinecode">[1]</span> and <span class="inlinecode">[2]</span> directly.  Since the goal mentions <span class="inlinecode">[1;</span> <span class="inlinecode">2]</span>
    instead of <span class="inlinecode">[1]</span> <span class="inlinecode">++</span> <span class="inlinecode">[2]</span>, Coq wouldn't be able to figure out how to
    split the string on its own.)

<div class="paragraph"> </div>

    Using <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, we can also show that certain strings do <i>not</i>
    match a regular expression: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkb1" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkb1"><span class="highlight"><span class="kn">Example</span> <span class="nf">reg_exp_ex3</span> : ~ ([<span class="mi">1</span>; <span class="mi">2</span>] =~ Char <span class="mi">1</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ ([<span class="mi">1</span>; <span class="mi">2</span>] =~ Char <span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkb2" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkb2"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ ([<span class="mi">1</span>; <span class="mi">2</span>] =~ Char <span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkb3" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkb3"><span class="highlight"><span class="nb">intros</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">[<span class="mi">1</span>; <span class="mi">2</span>] =~ Char <span class="mi">1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
We can define helper functions for writing down regular
    expressions. The <span class="inlinecode"><span class="id" title="var">reg_exp_of_list</span></span> function constructs a regular
    expression that matches exactly the list that it receives as an
    argument: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">reg_exp_of_list</span> {<span class="nv">T</span>} (<span class="nv">l</span> : list T) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; EmptyStr
  | x :: l&#39; =&gt; App (Char x) (reg_exp_of_list l&#39;)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkb4" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkb4"><span class="highlight"><span class="kn">Example</span> <span class="nf">reg_exp_ex4</span> : [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] =~ reg_exp_of_list [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] =~ reg_exp_of_list [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkb5" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkb5"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] =~ reg_exp_of_list [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkb6" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkb6"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] =~
App (Char <span class="mi">1</span>) (App (Char <span class="mi">2</span>) (App (Char <span class="mi">3</span>) EmptyStr))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkb7" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkb7"><span class="highlight"><span class="nb">apply</span> (MApp [<span class="mi">1</span>]).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">1</span>] =~ Char <span class="mi">1</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chkb8" style="display: none" type="checkbox"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">2</span>; <span class="mi">3</span>] =~ App (Char <span class="mi">2</span>) (App (Char <span class="mi">3</span>) EmptyStr)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkb9" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkb9"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">1</span>] =~ Char <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> MChar.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkba" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkba"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">2</span>; <span class="mi">3</span>] =~ App (Char <span class="mi">2</span>) (App (Char <span class="mi">3</span>) EmptyStr)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkbb" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkbb"><span class="highlight"><span class="nb">apply</span> (MApp [<span class="mi">2</span>]).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">2</span>] =~ Char <span class="mi">2</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chkbc" style="display: none" type="checkbox"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">3</span>] =~ App (Char <span class="mi">3</span>) EmptyStr</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkbd" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkbd"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">2</span>] =~ Char <span class="mi">2</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> MChar.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkbe" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkbe"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">3</span>] =~ App (Char <span class="mi">3</span>) EmptyStr</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkbf" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkbf"><span class="highlight"><span class="nb">apply</span> (MApp [<span class="mi">3</span>]).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">3</span>] =~ Char <span class="mi">3</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chkc0" style="display: none" type="checkbox"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[ ] =~ EmptyStr</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkc1" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkc1"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">3</span>] =~ Char <span class="mi">3</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> MChar.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkc2" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkc2"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[ ] =~ EmptyStr</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> MEmpty.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
We can also prove general facts about <span class="inlinecode"><span class="id" title="var">exp_match</span></span>.  For instance,
    the following lemma shows that every string <span class="inlinecode"><span class="id" title="var">s</span></span> that matches <span class="inlinecode"><span class="id" title="var">re</span></span>
    also matches <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkc3" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkc3"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">MStar1</span> :
  <span class="kr">forall</span> <span class="nv">T</span> <span class="nv">s</span> (<span class="nv">re</span> : @reg_exp T) ,
    s =~ re -&gt;
    s =~ Star re.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s</span> : list T) (<span class="nv">re</span> : reg_exp),
s =~ re -&gt; s =~ Star re</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkc4" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkc4"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s</span> : list T) (<span class="nv">re</span> : reg_exp),
s =~ re -&gt; s =~ Star re</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkc5" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkc5"><span class="highlight"><span class="nb">intros</span> T s re H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ Star re</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkc6" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkc6"><span class="highlight"><span class="nb">rewrite</span> &lt;- (app_nil_r _ s).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s ++ [ ] =~ Star re</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkc7" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkc7"><span class="highlight"><span class="nb">apply</span> (MStarApp s [] re).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ re</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chkc8" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chkc8"><hr></label><div class="goal-conclusion"><span class="highlight">[ ] =~ Star re</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkc9" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkc9"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ re</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkca" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkca"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[ ] =~ Star re</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> MStar0.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
(Note the use of <span class="inlinecode"><span class="id" title="var">app_nil_r</span></span> to change the goal of the theorem to
    exactly the same shape expected by <span class="inlinecode"><span class="id" title="var">MStarApp</span></span>.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab24"></a><h4 class="section">Exercise: 3 stars, standard (exp_match_ex1)</h4>
<div class="paragraph"> </div>

    The following lemmas show that the informal matching rules given
    at the beginning of the chapter can be obtained from the formal
    inductive definition. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkcb" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkcb"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">empty_is_empty</span> : <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">s</span> : list T),
  ~ (s =~ EmptySet).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s</span> : list T), ~ (s =~ EmptySet)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkcc" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkcc"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s</span> : list T), ~ (s =~ EmptySet)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkcd" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkcd"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">MUnion&#39;</span> : <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">s</span> : list T) (<span class="nv">re1</span> <span class="nv">re2</span> : @reg_exp T),
  s =~ re1 \/ s =~ re2 -&gt;
  s =~ Union re1 re2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s</span> : list T) (<span class="nv">re1</span> <span class="nv">re2</span> : reg_exp),
s =~ re1 \/ s =~ re2 -&gt; s =~ Union re1 re2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkce" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkce"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s</span> : list T) (<span class="nv">re1</span> <span class="nv">re2</span> : reg_exp),
s =~ re1 \/ s =~ re2 -&gt; s =~ Union re1 re2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
The next lemma is stated in terms of the <span class="inlinecode"><span class="id" title="tactic">fold</span></span> function from the
    <span class="inlinecode"><span class="id" title="var">Poly</span></span> chapter: If <span class="inlinecode"><span class="id" title="var">ss</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">(<span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> represents a sequence of
    strings <span class="inlinecode"><span class="id" title="var">s1</span>,</span> <span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" title="var">sn</span></span>, then <span class="inlinecode"><span class="id" title="tactic">fold</span></span> <span class="inlinecode"><span class="id" title="var">app</span></span> <span class="inlinecode"><span class="id" title="var">ss</span></span> <span class="inlinecode">[]</span> is the result of
    concatenating them all together. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkcf" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkcf"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">MStar&#39;</span> : <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">ss</span> : list (list T)) (<span class="nv">re</span> : reg_exp),
  (<span class="kr">forall</span> <span class="nv">s</span>, In s ss -&gt; s =~ re) -&gt;
  <span class="nb">fold</span> app ss [] =~ Star re.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">ss</span> : list (list T)) (<span class="nv">re</span> : reg_exp),
(<span class="kr">forall</span> <span class="nv">s</span> : list T, In s ss -&gt; s =~ re) -&gt;
<span class="nb">fold</span> app ss [ ] =~ Star re</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkd0" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkd0"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">ss</span> : list (list T)) (<span class="nv">re</span> : reg_exp),
(<span class="kr">forall</span> <span class="nv">s</span> : list T, In s ss -&gt; s =~ re) -&gt;
<span class="nb">fold</span> app ss [ ] =~ Star re</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab25"></a><h4 class="section">Exercise: 4 stars, standard, optional (reg_exp_of_list_spec)</h4>
<div class="paragraph"> </div>

    Prove that <span class="inlinecode"><span class="id" title="var">reg_exp_of_list</span></span> satisfies the following
    specification: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkd1" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkd1"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">reg_exp_of_list_spec</span> : <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">s1</span> <span class="nv">s2</span> : list T),
  s1 =~ reg_exp_of_list s2 &lt;-&gt; s1 = s2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s1</span> <span class="nv">s2</span> : list T),
s1 =~ reg_exp_of_list s2 &lt;-&gt; s1 = s2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkd2" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkd2"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s1</span> <span class="nv">s2</span> : list T),
s1 =~ reg_exp_of_list s2 &lt;-&gt; s1 = s2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Since the definition of <span class="inlinecode"><span class="id" title="var">exp_match</span></span> has a recursive
    structure, we might expect that proofs involving regular
    expressions will often require induction on evidence. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
For example, suppose that we wanted to prove the following
    intuitive result: If a regular expression <span class="inlinecode"><span class="id" title="var">re</span></span> matches some string
    <span class="inlinecode"><span class="id" title="var">s</span></span>, then all elements of <span class="inlinecode"><span class="id" title="var">s</span></span> must occur as character literals
    somewhere in <span class="inlinecode"><span class="id" title="var">re</span></span>.

<div class="paragraph"> </div>

    To state this theorem, we first define a function <span class="inlinecode"><span class="id" title="var">re_chars</span></span> that
    lists all characters that occur in a regular expression: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">re_chars</span> {<span class="nv">T</span>} (<span class="nv">re</span> : reg_exp) : list T :=
  <span class="kr">match</span> re <span class="kr">with</span>
  | EmptySet =&gt; []
  | EmptyStr =&gt; []
  | Char x =&gt; [x]
  | App re1 re2 =&gt; re_chars re1 ++ re_chars re2
  | Union re1 re2 =&gt; re_chars re1 ++ re_chars re2
  | Star re =&gt; re_chars re
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
We can then phrase our theorem as follows: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkd3" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkd3"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">in_re_match</span> : <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">s</span> : list T) (<span class="nv">re</span> : reg_exp) (<span class="nv">x</span> : T),
  s =~ re -&gt;
  In x s -&gt;
  In x (re_chars re).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s</span> : list T) (<span class="nv">re</span> : reg_exp) (<span class="nv">x</span> : T),
s =~ re -&gt; In x s -&gt; In x (re_chars re)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkd4" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkd4"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s</span> : list T) (<span class="nv">re</span> : reg_exp) (<span class="nv">x</span> : T),
s =~ re -&gt; In x s -&gt; In x (re_chars re)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkd5" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkd5"><span class="highlight"><span class="nb">intros</span> T s re x Hmatch Hin.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkd6" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkd6"><span class="highlight"><span class="nb">induction</span> Hmatch
    <span class="kr">as</span> [| x&#39;
        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2
        | s1 re1 re2 Hmatch IH | re1 s2 re2 Hmatch IH
        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars EmptyStr)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chkd7" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x [x&#39;]</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chkd7"><hr></label><div class="goal-conclusion"><span class="highlight">In x (re_chars (Char x&#39;))</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chkd8" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x (s1 ++ s2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars re2)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chkd8"><hr></label><div class="goal-conclusion"><span class="highlight">In x (re_chars (App re1 re2))</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chkd9" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1, re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re1)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chkd9"><hr></label><div class="goal-conclusion"><span class="highlight">In x (re_chars (Union re1 re2))</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chkda" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars re2)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chkda"><hr></label><div class="goal-conclusion"><span class="highlight">In x (re_chars (Union re1 re2))</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chkdb" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x [ ]</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chkdb"><hr></label><div class="goal-conclusion"><span class="highlight">In x (re_chars (Star re))</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chkdc" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x (s1 ++ s2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars (Star re))</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chkdc"><hr></label><div class="goal-conclusion"><span class="highlight">In x (re_chars (Star re))</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkdd" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkdd"><span class="highlight">- <span class="c">(* MEmpty *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars EmptyStr)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> Hin.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkde" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkde"><span class="highlight">- <span class="c">(* MChar *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x [x&#39;]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars (Char x&#39;))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> Hin.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkdf" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkdf"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x (s1 ++ s2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars re2)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars (App re1 re2))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chke0" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chke0"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x (s1 ++ s2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars re2)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re1 ++ re_chars re2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chke1" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chke1"><span class="highlight"><span class="nb">rewrite</span> In_app_iff <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 \/ In x s2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars re2)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re1) \/ In x (re_chars re2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chke2" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chke2"><span class="highlight"><span class="nb">destruct</span> Hin <span class="kr">as</span> [Hin | Hin].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars re2)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re1) \/ In x (re_chars re2)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chke3" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars re2)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chke3"><hr></label><div class="goal-conclusion"><span class="highlight">In x (re_chars re1) \/ In x (re_chars re2)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chke4" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chke4"><span class="highlight">+ <span class="c">(* In x s1 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars re2)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re1) \/ In x (re_chars re2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chke5" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chke5"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars re2)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re1)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> (IH1 Hin).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chke6" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chke6"><span class="highlight">+ <span class="c">(* In x s2 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars re2)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re1) \/ In x (re_chars re2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chke7" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chke7"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars re2)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> (IH2 Hin).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chke8" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chke8"><span class="highlight">- <span class="c">(* MUnionL *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1, re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re1)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars (Union re1 re2))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chke9" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chke9"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1, re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re1)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re1 ++ re_chars re2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkea" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkea"><span class="highlight"><span class="nb">rewrite</span> In_app_iff.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1, re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re1)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re1) \/ In x (re_chars re2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkeb" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkeb"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1, re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re1)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re1)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> (IH Hin).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkec" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkec"><span class="highlight">- <span class="c">(* MUnionR *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars re2)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars (Union re1 re2))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chked" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chked"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars re2)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re1 ++ re_chars re2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkee" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkee"><span class="highlight"><span class="nb">rewrite</span> In_app_iff.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars re2)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re1) \/ In x (re_chars re2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkef" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkef"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars re2)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> (IH Hin).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkf0" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkf0"><span class="highlight">- <span class="c">(* MStar0 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars (Star re))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> Hin.</span></span></span></pre><div class="doc">
Something interesting happens in the <span class="inlinecode"><span class="id" title="var">MStarApp</span></span> case.  We obtain
    <i>two</i> induction hypotheses: One that applies when <span class="inlinecode"><span class="id" title="var">x</span></span> occurs in
    <span class="inlinecode"><span class="id" title="var">s1</span></span> (which matches <span class="inlinecode"><span class="id" title="var">re</span></span>), and a second one that applies when <span class="inlinecode"><span class="id" title="var">x</span></span>
    occurs in <span class="inlinecode"><span class="id" title="var">s2</span></span> (which matches <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>).  This is a good
    illustration of why we need induction on evidence for <span class="inlinecode"><span class="id" title="var">exp_match</span></span>,
    rather than induction on the regular expression <span class="inlinecode"><span class="id" title="var">re</span></span>: The latter
    would only provide an induction hypothesis for strings that match
    <span class="inlinecode"><span class="id" title="var">re</span></span>, which would not allow us to reason about the case <span class="inlinecode"><span class="id" title="var">In</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>
<span class="inlinecode"><span class="id" title="var">s2</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkf1" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkf1"><span class="highlight">- <span class="c">(* MStarApp *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x (s1 ++ s2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars (Star re))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars (Star re))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkf2" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkf2"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x (s1 ++ s2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars (Star re))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkf3" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkf3"><span class="highlight"><span class="nb">rewrite</span> In_app_iff <span class="kr">in</span> Hin.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 \/ In x s2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars (Star re))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkf4" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkf4"><span class="highlight"><span class="nb">destruct</span> Hin <span class="kr">as</span> [Hin | Hin].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars (Star re))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chkf5" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars (Star re))</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chkf5"><hr></label><div class="goal-conclusion"><span class="highlight">In x (re_chars re)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkf6" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkf6"><span class="highlight">+ <span class="c">(* In x s1 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars (Star re))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> (IH1 Hin).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkf7" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkf7"><span class="highlight">+ <span class="c">(* In x s2 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hin</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s1 -&gt; In x (re_chars re)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x s2 -&gt; In x (re_chars (Star re))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In x (re_chars re)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> (IH2 Hin).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab26"></a><h4 class="section">Exercise: 4 stars, standard (re_not_empty)</h4>
<div class="paragraph"> </div>

    Write a recursive function <span class="inlinecode"><span class="id" title="var">re_not_empty</span></span> that tests whether a
    regular expression matches some string. Prove that your function
    is correct. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkf8" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkf8"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">re_not_empty</span> {<span class="nv">T</span> : <span class="kt">Type</span>} (<span class="nv">re</span> : @reg_exp T) : bool
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">re_not_empty</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">T0</span> : <span class="kt">Type</span>, reg_exp -&gt; bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">bool</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkf9" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkf9"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">re_not_empty_correct</span> : <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">re</span> : @reg_exp T),
  (<span class="kr">exists</span> <span class="nv">s</span>, s =~ re) &lt;-&gt; re_not_empty re = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">re</span> : reg_exp),
(<span class="kr">exists</span> <span class="nv">s</span> : list T, s =~ re) &lt;-&gt;
re_not_empty re = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkfa" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkfa"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">re</span> : reg_exp),
(<span class="kr">exists</span> <span class="nv">s</span> : list T, s =~ re) &lt;-&gt;
re_not_empty re = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab27"></a><h2 class="section">The <span class="inlinecode"><span class="id" title="var">remember</span></span> Tactic</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
One potentially confusing feature of the <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic is
    that it will let you try to perform an induction over a term that
    isn't sufficiently general.  The effect of this is to lose
    information (much as <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> without an <span class="inlinecode"><span class="id" title="var">eqn</span>:</span> clause can do),
    and leave you unable to complete the proof.  Here's an example: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkfb" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkfb"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">star_app</span>: <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">s1</span> <span class="nv">s2</span> : list T) (<span class="nv">re</span> : @reg_exp T),
  s1 =~ Star re -&gt;
  s2 =~ Star re -&gt;
  s1 ++ s2 =~ Star re.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s1</span> <span class="nv">s2</span> : list T) (<span class="nv">re</span> : reg_exp),
s1 =~ Star re -&gt; s2 =~ Star re -&gt; s1 ++ s2 =~ Star re</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkfc" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkfc"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s1</span> <span class="nv">s2</span> : list T) (<span class="nv">re</span> : reg_exp),
s1 =~ Star re -&gt; s2 =~ Star re -&gt; s1 ++ s2 =~ Star re</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkfd" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkfd"><span class="highlight"><span class="nb">intros</span> T s1 s2 re H1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ Star re</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s2 =~ Star re -&gt; s1 ++ s2 =~ Star re</span></div></blockquote></div></div></small></span></pre><div class="doc">
Just doing an <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> on <span class="inlinecode"><span class="id" title="var">H1</span></span> won't get us very far in
    the recursive cases. (Try it!). So we need induction (on
    evidence!). Here is a naive first attempt: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chkfe" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chkfe"><span class="highlight"><span class="nb">induction</span> H1
    <span class="kr">as</span> [|x&#39;|s1 re1 s2&#39; re2 Hmatch1 IH1 Hmatch2 IH2
        |s1 re1 re2 Hmatch IH|re1 s2&#39; re2 Hmatch IH
        |re&#39;&#39;|s1 s2&#39; re&#39;&#39; Hmatch1 IH1 Hmatch2 IH2].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s2 =~ EmptyStr -&gt; [ ] ++ s2 =~ EmptyStr</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chkff" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chkff"><hr></label><div class="goal-conclusion"><span class="highlight">s2 =~ Char x&#39; -&gt; [x&#39;] ++ s2 =~ Char x&#39;</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chk100" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re1 -&gt; s1 ++ s2 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2 -&gt; s2&#39; ++ s2 =~ re2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk100"><hr></label><div class="goal-conclusion"><span class="highlight">s2 =~ App re1 re2 -&gt; (s1 ++ s2&#39;) ++ s2 =~ App re1 re2</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chk101" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1, re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re1 -&gt; s1 ++ s2 =~ re1</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk101"><hr></label><div class="goal-conclusion"><span class="highlight">s2 =~ Union re1 re2 -&gt; s1 ++ s2 =~ Union re1 re2</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chk102" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2 -&gt; s2&#39; ++ s2 =~ re2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk102"><hr></label><div class="goal-conclusion"><span class="highlight">s2 =~ Union re1 re2 -&gt; s2&#39; ++ s2 =~ Union re1 re2</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chk103" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk103"><hr></label><div class="goal-conclusion"><span class="highlight">s2 =~ Star re&#39;&#39; -&gt; [ ] ++ s2 =~ Star re&#39;&#39;</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chk104" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re&#39;&#39; -&gt; s1 ++ s2 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s2 =~ Star re&#39;&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk104"><hr></label><div class="goal-conclusion"><span class="highlight">s2 =~ Star re&#39;&#39; -&gt; (s1 ++ s2&#39;) ++ s2 =~ Star re&#39;&#39;</span></div></blockquote></div></div></div></small></span></pre><div class="doc">
But now, although we get seven cases (as we would expect from the
    definition of <span class="inlinecode"><span class="id" title="var">exp_match</span></span>), we have lost a very important bit of
    information from <span class="inlinecode"><span class="id" title="var">H1</span></span>: the fact that <span class="inlinecode"><span class="id" title="var">s1</span></span> matched something of the
    form <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>.  This means that we have to give proofs for <i>all</i>
    seven constructors of this definition, even though all but two of
    them (<span class="inlinecode"><span class="id" title="var">MStar0</span></span> and <span class="inlinecode"><span class="id" title="var">MStarApp</span></span>) are contradictory.  We can still
    get the proof to go through for a few constructors, such as
    <span class="inlinecode"><span class="id" title="var">MEmpty</span></span>... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk105" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk105"><span class="highlight">- <span class="c">(* MEmpty *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s2 =~ EmptyStr -&gt; [ ] ++ s2 =~ EmptyStr</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk106" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk106"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s2 =~ EmptyStr -&gt; s2 =~ EmptyStr</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk107" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk107"><span class="highlight"><span class="nb">intros</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ EmptyStr</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s2 =~ EmptyStr</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span></span></pre><div class="doc">
... but most cases get stuck.  For <span class="inlinecode"><span class="id" title="var">MChar</span></span>, for instance, we
    must show that

<div class="paragraph"> </div>

    s2 =~ Char x' -&gt; x' :: s2 =~ Char x',

<div class="paragraph"> </div>

    which is clearly impossible. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk108" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk108"><span class="highlight">- <span class="c">(* MChar. Stuck... *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s2 =~ Char x&#39; -&gt; [x&#39;] ++ s2 =~ Char x&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><div class="doc">
The problem is that <span class="inlinecode"><span class="id" title="tactic">induction</span></span> over a Prop hypothesis only works
    properly with hypotheses that are completely general, i.e., ones
    in which all the arguments are variables, as opposed to more
    complex expressions, such as <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>.

<div class="paragraph"> </div>

    (In this respect, <span class="inlinecode"><span class="id" title="tactic">induction</span></span> on evidence behaves more like
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>-without-<span class="inlinecode"><span class="id" title="var">eqn</span>:</span> than like <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>.)

<div class="paragraph"> </div>

    An awkward way to solve this problem is "manually generalizing" 
    over the problematic expressions by adding explicit equality 
    hypotheses to the lemma: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk109" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk109"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">star_app</span>: <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">s1</span> <span class="nv">s2</span> : list T) (<span class="nv">re</span> <span class="nv">re&#39;</span> : reg_exp),
  re&#39; = Star re -&gt;
  s1 =~ re&#39; -&gt;
  s2 =~ Star re -&gt;
  s1 ++ s2 =~ Star re.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s1</span> <span class="nv">s2</span> : list T) (<span class="nv">re</span> <span class="nv">re&#39;</span> : reg_exp),
re&#39; = Star re -&gt;
s1 =~ re&#39; -&gt; s2 =~ Star re -&gt; s1 ++ s2 =~ Star re</span></div></blockquote></div></div></small></span></pre><div class="doc">
We can now proceed by performing induction over evidence directly,
    because the argument to the first hypothesis is sufficiently
    general, which means that we can discharge most cases by inverting
    the <span class="inlinecode"><span class="id" title="var">re'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span> equality in the context.

<div class="paragraph"> </div>

    This idiom is so common that Coq provides a tactic to
    automatically generate such equations for us, avoiding thus the
    need for changing the statements of our theorems. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><div class="doc">
The tactic <span class="inlinecode"><span class="id" title="var">remember</span></span> <span class="inlinecode"><span class="id" title="var">e</span></span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> causes Coq to (1) replace all
    occurrences of the expression <span class="inlinecode"><span class="id" title="var">e</span></span> by the variable <span class="inlinecode"><span class="id" title="var">x</span></span>, and (2) add
    an equation <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">e</span></span> to the context.  Here's how we can use it to
    show the above result: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk10a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk10a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">star_app</span>: <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">s1</span> <span class="nv">s2</span> : list T) (<span class="nv">re</span> : reg_exp),
  s1 =~ Star re -&gt;
  s2 =~ Star re -&gt;
  s1 ++ s2 =~ Star re.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s1</span> <span class="nv">s2</span> : list T) (<span class="nv">re</span> : reg_exp),
s1 =~ Star re -&gt; s2 =~ Star re -&gt; s1 ++ s2 =~ Star re</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk10b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk10b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s1</span> <span class="nv">s2</span> : list T) (<span class="nv">re</span> : reg_exp),
s1 =~ Star re -&gt; s2 =~ Star re -&gt; s1 ++ s2 =~ Star re</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk10c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk10c"><span class="highlight"><span class="nb">intros</span> T s1 s2 re H1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ Star re</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s2 =~ Star re -&gt; s1 ++ s2 =~ Star re</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk10d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk10d"><span class="highlight"><span class="nb">remember</span> (Star re) <span class="kr">as</span> re&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s2 =~ re&#39; -&gt; s1 ++ s2 =~ re&#39;</span></div></blockquote></div></div></small></span></pre><div class="doc">
We now have <span class="inlinecode"><span class="id" title="var">Heqre'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">re'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk10e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk10e"><span class="highlight"><span class="nb">generalize dependent</span> s2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T, s2 =~ re&#39; -&gt; s1 ++ s2 =~ re&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk10f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk10f"><span class="highlight"><span class="nb">induction</span> H1
    <span class="kr">as</span> [|x&#39;|s1 re1 s2&#39; re2 Hmatch1 IH1 Hmatch2 IH2
        |s1 re1 re2 Hmatch IH|re1 s2&#39; re2 Hmatch IH
        |re&#39;&#39;|s1 s2&#39; re&#39;&#39; Hmatch1 IH1 Hmatch2 IH2].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">EmptyStr = Star re</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ EmptyStr -&gt; [ ] ++ s2 =~ EmptyStr</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk110" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Char x&#39; = Star re</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk110"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Char x&#39; -&gt; [x&#39;] ++ s2 =~ Char x&#39;</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chk111" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re1, re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">App re1 re2 = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re1 = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T, s2 =~ re1 -&gt; s1 ++ s2 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ re2 -&gt; s2&#39; ++ s2 =~ re2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk111"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ App re1 re2 -&gt; (s1 ++ s2&#39;) ++ s2 =~ App re1 re2</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chk112" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re1, re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Union re1 re2 = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re1 = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T, s2 =~ re1 -&gt; s1 ++ s2 =~ re1</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk112"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Union re1 re2 -&gt; s1 ++ s2 =~ Union re1 re2</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chk113" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re1, re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Union re1 re2 = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T, s2 =~ re2 -&gt; s2&#39; ++ s2 =~ re2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk113"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Union re1 re2 -&gt; s2&#39; ++ s2 =~ Union re1 re2</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chk114" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk114"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Star re&#39;&#39; -&gt; [ ] ++ s2 =~ Star re&#39;&#39;</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chk115" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ re&#39;&#39; -&gt; s1 ++ s2 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s2 =~ Star re&#39;&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk115"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Star re&#39;&#39; -&gt; (s1 ++ s2&#39;) ++ s2 =~ Star re&#39;&#39;</span></div></blockquote></div></div></div></small></span></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">Heqre'</span></span> is contradictory in most cases, allowing us to
    conclude immediately. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk116" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk116"><span class="highlight">- <span class="c">(* MEmpty *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">EmptyStr = Star re</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ EmptyStr -&gt; [ ] ++ s2 =~ EmptyStr</span></div></blockquote></div></div></small><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk117" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk117"><span class="highlight">- <span class="c">(* MChar *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Char x&#39; = Star re</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Char x&#39; -&gt; [x&#39;] ++ s2 =~ Char x&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">   </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk118" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk118"><span class="highlight">- <span class="c">(* MApp *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re1, re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">App re1 re2 = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re1 = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T, s2 =~ re1 -&gt; s1 ++ s2 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ re2 -&gt; s2&#39; ++ s2 =~ re2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ App re1 re2 -&gt; (s1 ++ s2&#39;) ++ s2 =~ App re1 re2</span></div></blockquote></div></div></small><span class="coq-wsp">    </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk119" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk119"><span class="highlight">- <span class="c">(* MUnionL *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re1, re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Union re1 re2 = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re1 = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T, s2 =~ re1 -&gt; s1 ++ s2 =~ re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Union re1 re2 -&gt; s1 ++ s2 =~ Union re1 re2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk11a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk11a"><span class="highlight">- <span class="c">(* MUnionR *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re1, re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Union re1 re2 = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T, s2 =~ re2 -&gt; s2&#39; ++ s2 =~ re2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Union re1 re2 -&gt; s2&#39; ++ s2 =~ Union re1 re2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span>.</span></span></span></pre><div class="doc">
The interesting cases are those that correspond to <span class="inlinecode"><span class="id" title="var">Star</span></span>.  Note
    that the induction hypothesis <span class="inlinecode"><span class="id" title="var">IH2</span></span> on the <span class="inlinecode"><span class="id" title="var">MStarApp</span></span> case
    mentions an additional premise <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re''</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re'</span></span>, which
    results from the equality generated by <span class="inlinecode"><span class="id" title="var">remember</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk11b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk11b"><span class="highlight">- <span class="c">(* MStar0 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Star re&#39;&#39; -&gt; [ ] ++ s2 =~ Star re&#39;&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk11c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk11c"><span class="highlight"><span class="nb">injection</span> Heqre&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">re&#39;&#39; = re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Star re&#39;&#39; -&gt; [ ] ++ s2 =~ Star re&#39;&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk11d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk11d"><span class="highlight"><span class="nb">intros</span> Heqre&#39;&#39; s H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ Star re&#39;&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[ ] ++ s =~ Star re&#39;&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk11e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk11e"><span class="highlight">- <span class="c">(* MStarApp *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ re&#39;&#39; -&gt; s1 ++ s2 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s2 =~ Star re&#39;&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Star re&#39;&#39; -&gt; (s1 ++ s2&#39;) ++ s2 =~ Star re&#39;&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk11f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk11f"><span class="highlight"><span class="nb">injection</span> Heqre&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ re&#39;&#39; -&gt; s1 ++ s2 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s2 =~ Star re&#39;&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">re&#39;&#39; = re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Star re&#39;&#39; -&gt; (s1 ++ s2&#39;) ++ s2 =~ Star re&#39;&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk120" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk120"><span class="highlight"><span class="nb">intros</span> H0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ re&#39;&#39; -&gt; s1 ++ s2 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s2 =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = re</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s2</span> : list T,
s2 =~ Star re&#39;&#39; -&gt; (s1 ++ s2&#39;) ++ s2 =~ Star re&#39;&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk121" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk121"><span class="highlight"><span class="nb">intros</span> s2 H1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ re&#39;&#39; -&gt; s1 ++ s0 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s0 =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re&#39;&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(s1 ++ s2&#39;) ++ s2 =~ Star re&#39;&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk122" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk122"><span class="highlight"><span class="nb">rewrite</span> &lt;- app_assoc.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ re&#39;&#39; -&gt; s1 ++ s0 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s0 =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re&#39;&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s1 ++ s2&#39; ++ s2 =~ Star re&#39;&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk123" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk123"><span class="highlight"><span class="nb">apply</span> MStarApp.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ re&#39;&#39; -&gt; s1 ++ s0 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s0 =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re&#39;&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s1 =~ re&#39;&#39;</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk124" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ re&#39;&#39; -&gt; s1 ++ s0 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s0 =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re&#39;&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk124"><hr></label><div class="goal-conclusion"><span class="highlight">s2&#39; ++ s2 =~ Star re&#39;&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk125" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk125"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ re&#39;&#39; -&gt; s1 ++ s0 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s0 =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re&#39;&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s1 =~ re&#39;&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> Hmatch1.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk126" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk126"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ re&#39;&#39; -&gt; s1 ++ s0 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s0 =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re&#39;&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s2&#39; ++ s2 =~ Star re&#39;&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk127" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk127"><span class="highlight"><span class="nb">apply</span> IH2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ re&#39;&#39; -&gt; s1 ++ s0 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s0 =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re&#39;&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Star re&#39;&#39; = Star re</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk128" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ re&#39;&#39; -&gt; s1 ++ s0 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s0 =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re&#39;&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk128"><hr></label><div class="goal-conclusion"><span class="highlight">s2 =~ Star re&#39;&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk129" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk129"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ re&#39;&#39; -&gt; s1 ++ s0 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s0 =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re&#39;&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Star re&#39;&#39; = Star re</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk12a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk12a"><span class="highlight"><span class="nb">rewrite</span> H0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ re&#39;&#39; -&gt; s1 ++ s0 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s0 =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re&#39;&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Star re = Star re</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk12b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk12b"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re, re''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqre'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2&#39; =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ re&#39;&#39; -&gt; s1 ++ s0 =~ re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Star re&#39;&#39; = Star re -&gt;
<span class="kr">forall</span> <span class="nv">s0</span> : list T,
s0 =~ Star re&#39;&#39; -&gt; s2&#39; ++ s0 =~ Star re&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re&#39;&#39; = re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re&#39;&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s2 =~ Star re&#39;&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H1.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab28"></a><h4 class="section">Exercise: 4 stars, standard, optional (exp_match_ex2)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">MStar''</span></span> lemma below (combined with its converse, the
    <span class="inlinecode"><span class="id" title="var">MStar'</span></span> exercise above), shows that our definition of <span class="inlinecode"><span class="id" title="var">exp_match</span></span>
    for <span class="inlinecode"><span class="id" title="var">Star</span></span> is equivalent to the informal one given previously. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk12c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk12c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">MStar&#39;&#39;</span> : <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">s</span> : list T) (<span class="nv">re</span> : reg_exp),
  s =~ Star re -&gt;
  <span class="kr">exists</span> <span class="nv">ss</span> : list (list T),
    s = <span class="nb">fold</span> app ss []
    /\ <span class="kr">forall</span> <span class="nv">s&#39;</span>, In s&#39; ss -&gt; s&#39; =~ re.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s</span> : list T) (<span class="nv">re</span> : reg_exp),
s =~ Star re -&gt;
<span class="kr">exists</span> <span class="nv">ss</span> : list (list T),
  s = <span class="nb">fold</span> app ss [ ] /\
  (<span class="kr">forall</span> <span class="nv">s&#39;</span> : list T, In s&#39; ss -&gt; s&#39; =~ re)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk12d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk12d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">s</span> : list T) (<span class="nv">re</span> : reg_exp),
s =~ Star re -&gt;
<span class="kr">exists</span> <span class="nv">ss</span> : list (list T),
  s = <span class="nb">fold</span> app ss [ ] /\
  (<span class="kr">forall</span> <span class="nv">s&#39;</span> : list T, In s&#39; ss -&gt; s&#39; =~ re)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab29"></a><h4 class="section">Exercise: 5 stars, advanced (pumping)</h4>
<div class="paragraph"> </div>

    One of the first really interesting theorems in the theory of
    regular expressions is the so-called <i>pumping lemma</i>, which
    states, informally, that any sufficiently long string <span class="inlinecode"><span class="id" title="var">s</span></span> matching
    a regular expression <span class="inlinecode"><span class="id" title="var">re</span></span> can be "pumped" by repeating some middle
    section of <span class="inlinecode"><span class="id" title="var">s</span></span> an arbitrary number of times to produce a new
    string also matching <span class="inlinecode"><span class="id" title="var">re</span></span>.

<div class="paragraph"> </div>

    To begin, we need to define "sufficiently long."  Since we are
    working in a constructive logic, we actually need to be able to
    calculate, for each regular expression <span class="inlinecode"><span class="id" title="var">re</span></span>, the minimum length
    for strings <span class="inlinecode"><span class="id" title="var">s</span></span> to guarantee "pumpability." 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">Pumping</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">pumping_constant</span> {<span class="nv">T</span>} (<span class="nv">re</span> : @reg_exp T) : nat :=
  <span class="kr">match</span> re <span class="kr">with</span>
  | EmptySet =&gt; <span class="mi">0</span>
  | EmptyStr =&gt; <span class="mi">1</span>
  | Char _ =&gt; <span class="mi">2</span>
  | App re1 re2 =&gt;
      pumping_constant re1 + pumping_constant re2
  | Union re1 re2 =&gt;
      pumping_constant re1 + pumping_constant re2
  | Star _ =&gt; <span class="mi">1</span>
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Next, it is useful to define an auxiliary function that repeats a
    string (appends it to itself) some number of times. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">napp</span> {<span class="nv">T</span>} (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list T) : list T :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; []
  | S n&#39; =&gt; l ++ napp n&#39; l
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk12e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk12e"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">napp_plus</span>: <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">n</span> <span class="nv">m</span> : nat) (<span class="nv">l</span> : list T),
  napp (n + m) l = napp n l ++ napp m l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">n</span> <span class="nv">m</span> : nat) (<span class="nv">l</span> : list T),
napp (n + m) l = napp n l ++ napp m l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk12f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk12f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">n</span> <span class="nv">m</span> : nat) (<span class="nv">l</span> : list T),
napp (n + m) l = napp n l ++ napp m l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk130" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk130"><span class="highlight"><span class="nb">intros</span> T n m l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">napp (n + m) l = napp n l ++ napp m l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk131" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk131"><span class="highlight"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">napp (<span class="mi">0</span> + m) l = napp <span class="mi">0</span> l ++ napp m l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk132" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">napp (n + m) l = napp n l ++ napp m l</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk132"><hr></label><div class="goal-conclusion"><span class="highlight">napp (S n + m) l = napp (S n) l ++ napp m l</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk133" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk133"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">napp (<span class="mi">0</span> + m) l = napp <span class="mi">0</span> l ++ napp m l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk134" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk134"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">napp (n + m) l = napp n l ++ napp m l</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">napp (S n + m) l = napp (S n) l ++ napp m l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk135" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk135"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">napp (n + m) l = napp n l ++ napp m l</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">l ++ napp (n + m) l = (l ++ napp n l) ++ napp m l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk136" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk136"><span class="highlight"><span class="nb">rewrite</span> IHn, app_assoc.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">napp (n + m) l = napp n l ++ napp m l</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(l ++ napp n l) ++ napp m l =
(l ++ napp n l) ++ napp m l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Now, the pumping lemma itself says that, if <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" title="var">re</span></span> and if the
    length of <span class="inlinecode"><span class="id" title="var">s</span></span> is at least the pumping constant of <span class="inlinecode"><span class="id" title="var">re</span></span>, then <span class="inlinecode"><span class="id" title="var">s</span></span>
    can be split into three substrings <span class="inlinecode"><span class="id" title="var">s1</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">s2</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">s3</span></span> in such a way
    that <span class="inlinecode"><span class="id" title="var">s2</span></span> can be repeated any number of times and the result, when
    combined with <span class="inlinecode"><span class="id" title="var">s1</span></span> and <span class="inlinecode"><span class="id" title="var">s3</span></span> will still match <span class="inlinecode"><span class="id" title="var">re</span></span>.  Since <span class="inlinecode"><span class="id" title="var">s2</span></span> is
    also guaranteed not to be the empty string, this gives us
    a (constructive!) way to generate strings matching <span class="inlinecode"><span class="id" title="var">re</span></span> that are
    as long as we like. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk137" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk137"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">pumping</span> : <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">re</span> : @reg_exp T) <span class="nv">s</span>,
  s =~ re -&gt;
  pumping_constant re &lt;= length s -&gt;
  <span class="kr">exists</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span>,
    s = s1 ++ s2 ++ s3 /\
    s2 &lt;&gt; [] /\
    <span class="kr">forall</span> <span class="nv">m</span>, s1 ++ napp m s2 ++ s3 =~ re.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">re</span> : reg_exp) (<span class="nv">s</span> : list T),
s =~ re -&gt;
pumping_constant re &lt;= length s -&gt;
<span class="kr">exists</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> : list T,
  s = s1 ++ s2 ++ s3 /\
  s2 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat, s1 ++ napp m s2 ++ s3 =~ re)</span></div></blockquote></div></div></small></span></pre><div class="doc">
To streamline the proof (which you are to fill in), the <span class="inlinecode"><span class="id" title="tactic">omega</span></span>
    tactic, which is enabled by the following <span class="inlinecode"><span class="id" title="keyword">Require</span></span>, is helpful in
    several places for automatically completing tedious low-level
    arguments involving equalities or inequalities over natural
    numbers.  We'll return to <span class="inlinecode"><span class="id" title="tactic">omega</span></span> in a later chapter, but feel
    free to experiment with it now if you like.  The first case of the
    induction gives an example of how it is used. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk138" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk138"><span class="highlight"><span class="kn">Import</span> Coq.<span class="bp">omega</span>.Omega.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">re</span> : reg_exp) (<span class="nv">s</span> : list T),
s =~ re -&gt;
pumping_constant re &lt;= length s -&gt;
<span class="kr">exists</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> : list T,
  s = s1 ++ s2 ++ s3 /\
  s2 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat, s1 ++ napp m s2 ++ s3 =~ re)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk139" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk139"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">re</span> : reg_exp) (<span class="nv">s</span> : list T),
s =~ re -&gt;
pumping_constant re &lt;= length s -&gt;
<span class="kr">exists</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> : list T,
  s = s1 ++ s2 ++ s3 /\
  s2 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat, s1 ++ napp m s2 ++ s3 =~ re)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk13a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk13a"><span class="highlight"><span class="nb">intros</span> T re s Hmatch.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pumping_constant re &lt;= length s -&gt;
<span class="kr">exists</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> : list T,
  s = s1 ++ s2 ++ s3 /\
  s2 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat, s1 ++ napp m s2 ++ s3 =~ re)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk13b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk13b"><span class="highlight"><span class="nb">induction</span> Hmatch
    <span class="kr">as</span> [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2
       | s1 re1 re2 Hmatch IH | re1 s2 re2 Hmatch IH
       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pumping_constant EmptyStr &lt;= length [ ] -&gt;
<span class="kr">exists</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> : list T,
  [ ] = s1 ++ s2 ++ s3 /\
  s2 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat, s1 ++ napp m s2 ++ s3 =~ EmptyStr)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk13c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">T</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk13c"><hr></label><div class="goal-conclusion"><span class="highlight">pumping_constant (Char x) &lt;= length [x] -&gt;
<span class="kr">exists</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> : list T,
  [x] = s1 ++ s2 ++ s3 /\
  s2 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat, s1 ++ napp m s2 ++ s3 =~ Char x)</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chk13d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">pumping_constant re1 &lt;= length s1 -&gt;
<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s3</span> <span class="nv">s4</span> : list T,
  s1 = s0 ++ s3 ++ s4 /\
  s3 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat, s0 ++ napp m s3 ++ s4 =~ re1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">pumping_constant re2 &lt;= length s2 -&gt;
<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s3</span> <span class="nv">s4</span> : list T,
  s2 = s0 ++ s3 ++ s4 /\
  s3 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat, s0 ++ napp m s3 ++ s4 =~ re2)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk13d"><hr></label><div class="goal-conclusion"><span class="highlight">pumping_constant (App re1 re2) &lt;= length (s1 ++ s2) -&gt;
<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s3</span> <span class="nv">s4</span> : list T,
  s1 ++ s2 = s0 ++ s3 ++ s4 /\
  s3 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat,
   s0 ++ napp m s3 ++ s4 =~ App re1 re2)</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chk13e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1, re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">pumping_constant re1 &lt;= length s1 -&gt;
<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s2</span> <span class="nv">s3</span> : list T,
  s1 = s0 ++ s2 ++ s3 /\
  s2 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat, s0 ++ napp m s2 ++ s3 =~ re1)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk13e"><hr></label><div class="goal-conclusion"><span class="highlight">pumping_constant (Union re1 re2) &lt;= length s1 -&gt;
<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s2</span> <span class="nv">s3</span> : list T,
  s1 = s0 ++ s2 ++ s3 /\
  s2 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat,
   s0 ++ napp m s2 ++ s3 =~ Union re1 re2)</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chk13f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">pumping_constant re2 &lt;= length s2 -&gt;
<span class="kr">exists</span> <span class="nv">s1</span> <span class="nv">s0</span> <span class="nv">s3</span> : list T,
  s2 = s1 ++ s0 ++ s3 /\
  s0 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat, s1 ++ napp m s0 ++ s3 =~ re2)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk13f"><hr></label><div class="goal-conclusion"><span class="highlight">pumping_constant (Union re1 re2) &lt;= length s2 -&gt;
<span class="kr">exists</span> <span class="nv">s1</span> <span class="nv">s0</span> <span class="nv">s3</span> : list T,
  s2 = s1 ++ s0 ++ s3 /\
  s0 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat,
   s1 ++ napp m s0 ++ s3 =~ Union re1 re2)</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chk140" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk140"><hr></label><div class="goal-conclusion"><span class="highlight">pumping_constant (Star re) &lt;= length [ ] -&gt;
<span class="kr">exists</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> : list T,
  [ ] = s1 ++ s2 ++ s3 /\
  s2 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat, s1 ++ napp m s2 ++ s3 =~ Star re)</span></div></blockquote><input class="coq-extra-goal-toggle" id="IndProp-v-chk141" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list T</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmatch2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ Star re</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">pumping_constant re &lt;= length s1 -&gt;
<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s3</span> <span class="nv">s4</span> : list T,
  s1 = s0 ++ s3 ++ s4 /\
  s3 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat, s0 ++ napp m s3 ++ s4 =~ re)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IH2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">pumping_constant (Star re) &lt;= length s2 -&gt;
<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s3</span> <span class="nv">s4</span> : list T,
  s2 = s0 ++ s3 ++ s4 /\
  s3 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat,
   s0 ++ napp m s3 ++ s4 =~ Star re)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk141"><hr></label><div class="goal-conclusion"><span class="highlight">pumping_constant (Star re) &lt;= length (s1 ++ s2) -&gt;
<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s3</span> <span class="nv">s4</span> : list T,
  s1 ++ s2 = s0 ++ s3 ++ s4 /\
  s3 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat, s0 ++ napp m s3 ++ s4 =~ Star re)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk142" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk142"><span class="highlight">- <span class="c">(* MEmpty *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pumping_constant EmptyStr &lt;= length [ ] -&gt;
<span class="kr">exists</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> : list T,
  [ ] = s1 ++ s2 ++ s3 /\
  s2 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat, s1 ++ napp m s2 ++ s3 =~ EmptyStr)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk143" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk143"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> &lt;= <span class="mi">0</span> -&gt;
<span class="kr">exists</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> : list T,
  [ ] = s1 ++ s2 ++ s3 /\
  s2 &lt;&gt; [ ] /\
  (<span class="kr">forall</span> <span class="nv">m</span> : nat, s1 ++ napp m s2 ++ s3 =~ EmptyStr)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">omega</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Pumping</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab30"></a><h1 class="section">Case Study: Improving Reflection</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We've seen in the <span class="inlinecode"><span class="id" title="var">Logic</span></span> chapter that we often need to
    relate boolean computations to statements in <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.  But
    performing this conversion as we did it there can result in
    tedious proof scripts.  Consider the proof of the following
    theorem: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk144" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk144"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">filter_not_empty_In</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">l</span>,
  filter (<span class="kr">fun</span> <span class="nv">x</span> =&gt; n =? x) l &lt;&gt; [] -&gt;
  In n l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list nat),
filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l &lt;&gt; [ ] -&gt; In n l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk145" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk145"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list nat),
filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l &lt;&gt; [ ] -&gt; In n l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk146" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk146"><span class="highlight"><span class="nb">intros</span> n l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l &lt;&gt; [ ] -&gt; In n l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk147" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk147"><span class="highlight"><span class="nb">induction</span> l <span class="kr">as</span> [|m l&#39; IHl&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) [ ] &lt;&gt; [ ] -&gt; In n [ ]</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk148" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk148"><hr></label><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) (m :: l&#39;) &lt;&gt; [ ] -&gt;
In n (m :: l&#39;)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk149" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk149"><span class="highlight">- <span class="c">(* l = [] *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) [ ] &lt;&gt; [ ] -&gt; In n [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk14a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk14a"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[ ] &lt;&gt; [ ] -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk14b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk14b"><span class="highlight"><span class="nb">intros</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">[ ] &lt;&gt; [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk14c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk14c"><span class="highlight"><span class="nb">apply</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">[ ] &lt;&gt; [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[ ] = [ ]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk14d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk14d"><span class="highlight">- <span class="c">(* l = m :: l&#39; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) (m :: l&#39;) &lt;&gt; [ ] -&gt;
In n (m :: l&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk14e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk14e"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">if</span> n =? m
 <span class="kr">then</span> m :: filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39;
 <span class="kr">else</span> filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39;) &lt;&gt; [ ] -&gt;
m = n \/ In n l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk14f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk14f"><span class="highlight"><span class="nb">destruct</span> (n =? m) <span class="nb">eqn</span>:H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(n =? m) = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m :: filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
m = n \/ In n l&#39;</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk150" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(n =? m) = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk150"><hr></label><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
m = n \/ In n l&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk151" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk151"><span class="highlight">+ <span class="c">(* n =? m = true *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(n =? m) = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m :: filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
m = n \/ In n l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk152" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk152"><span class="highlight"><span class="nb">intros</span> _.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(n =? m) = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m = n \/ In n l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk153" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk153"><span class="highlight"><span class="nb">rewrite</span> eqb_eq <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m = n \/ In n l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk154" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk154"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m = m \/ In m l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk155" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk155"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m = m</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk156" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk156"><span class="highlight">+ <span class="c">(* n =? m = false *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(n =? m) = false</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
m = n \/ In n l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk157" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk157"><span class="highlight"><span class="nb">intros</span> H&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(n =? m) = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m = n \/ In n l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk158" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk158"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(n =? m) = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In n l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk159" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk159"><span class="highlight"><span class="nb">apply</span> IHl&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(n =? m) = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H&#39;.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
In the first branch after <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, we explicitly apply
    the <span class="inlinecode"><span class="id" title="var">eqb_eq</span></span> lemma to the equation generated by
    destructing <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span></span>, to convert the assumption <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span></span>
<span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> into the assumption <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>; then we had to <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>
    using this assumption to complete the case. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We can streamline this by defining an inductive proposition that
    yields a better case-analysis principle for <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span></span>.
    Instead of generating an equation such as <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>,
    which is generally not directly useful, this principle gives us
    right away the assumption we really need: <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">reflect</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : bool -&gt; <span class="kt">Prop</span> :=
| ReflectT (H :   P) : reflect P true
| ReflectF (H : ~ P) : reflect P false.</span></span></span></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">reflect</span></span> property takes two arguments: a proposition
    <span class="inlinecode"><span class="id" title="var">P</span></span> and a boolean <span class="inlinecode"><span class="id" title="var">b</span></span>.  Intuitively, it states that the property
    <span class="inlinecode"><span class="id" title="var">P</span></span> is <i>reflected</i> in (i.e., equivalent to) the boolean <span class="inlinecode"><span class="id" title="var">b</span></span>: that
    is, <span class="inlinecode"><span class="id" title="var">P</span></span> holds if and only if <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>.  To see this, notice
    that, by definition, the only way we can produce evidence for
    <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> is by showing <span class="inlinecode"><span class="id" title="var">P</span></span> and then using the <span class="inlinecode"><span class="id" title="var">ReflectT</span></span>
    constructor.  If we invert this statement, this means that it
    should be possible to extract evidence for <span class="inlinecode"><span class="id" title="var">P</span></span> from a proof of
    <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>.  Similarly, the only way to show <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span>
<span class="inlinecode"><span class="id" title="var">false</span></span> is by combining evidence for <span class="inlinecode">¬¨</span> <span class="inlinecode"><span class="id" title="var">P</span></span> with the <span class="inlinecode"><span class="id" title="var">ReflectF</span></span>
    constructor.

<div class="paragraph"> </div>

    It is easy to formalize this intuition and show that the
    statements <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">‚Üî</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> and <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> are indeed
    equivalent.  First, the left-to-right implication: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk15a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk15a"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">iff_reflect</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">b</span>, (P &lt;-&gt; b = true) -&gt; reflect P b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">b</span> : bool),
P &lt;-&gt; b = true -&gt; reflect P b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk15b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk15b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">b</span> : bool),
P &lt;-&gt; b = true -&gt; reflect P b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk15c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk15c"><span class="highlight"><span class="nb">intros</span> P b H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; b = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect P b</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk15d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk15d"><span class="highlight"><span class="nb">destruct</span> b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; true = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect P true</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk15e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; false = true</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk15e"><hr></label><div class="goal-conclusion"><span class="highlight">reflect P false</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk15f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk15f"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; true = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect P true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk160" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk160"><span class="highlight"><span class="nb">apply</span> ReflectT.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; true = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk161" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk161"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; true = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk162" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk162"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; false = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect P false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk163" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk163"><span class="highlight"><span class="nb">apply</span> ReflectF.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; false = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk164" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk164"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; false = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">false &lt;&gt; true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk165" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk165"><span class="highlight"><span class="nb">intros</span> H&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P &lt;-&gt; false = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">false = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Now you prove the right-to-left implication: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab31"></a><h4 class="section">Exercise: 2 stars, standard, recommended (reflect_iff)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk166" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk166"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">reflect_iff</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">b</span>, reflect P b -&gt; (P &lt;-&gt; b = true).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">b</span> : bool),
reflect P b -&gt; P &lt;-&gt; b = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk167" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk167"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">b</span> : bool),
reflect P b -&gt; P &lt;-&gt; b = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The advantage of <span class="inlinecode"><span class="id" title="var">reflect</span></span> over the normal "if and only if"
    connective is that, by destructing a hypothesis or lemma of the
    form <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>, we can perform case analysis on <span class="inlinecode"><span class="id" title="var">b</span></span> while at
    the same time generating appropriate hypothesis in the two
    branches (<span class="inlinecode"><span class="id" title="var">P</span></span> in the first subgoal and <span class="inlinecode">¬¨</span> <span class="inlinecode"><span class="id" title="var">P</span></span> in the second). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk168" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk168"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">eqbP</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>, reflect (n = m) (n =? m).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, reflect (n = m) (n =? m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk169" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk169"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, reflect (n = m) (n =? m)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk16a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk16a"><span class="highlight"><span class="nb">intros</span> n m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (n = m) (n =? m)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk16b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk16b"><span class="highlight"><span class="nb">apply</span> iff_reflect.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = m &lt;-&gt; (n =? m) = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk16c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk16c"><span class="highlight"><span class="nb">rewrite</span> eqb_eq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = m &lt;-&gt; n = m</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
A smoother proof of <span class="inlinecode"><span class="id" title="var">filter_not_empty_In</span></span> now goes as follows.
    Notice how the calls to <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> and <span class="inlinecode"><span class="id" title="tactic">apply</span></span> are combined into a
    single call to <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
(To see this clearly, look at the two proofs of
    <span class="inlinecode"><span class="id" title="var">filter_not_empty_In</span></span> with Coq and observe the differences in
    proof state at the beginning of the first case of the
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk16d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk16d"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">filter_not_empty_In&#39;</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">l</span>,
  filter (<span class="kr">fun</span> <span class="nv">x</span> =&gt; n =? x) l &lt;&gt; [] -&gt;
  In n l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list nat),
filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l &lt;&gt; [ ] -&gt; In n l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk16e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk16e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list nat),
filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l &lt;&gt; [ ] -&gt; In n l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk16f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk16f"><span class="highlight"><span class="nb">intros</span> n l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l &lt;&gt; [ ] -&gt; In n l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk170" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk170"><span class="highlight"><span class="nb">induction</span> l <span class="kr">as</span> [|m l&#39; IHl&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) [ ] &lt;&gt; [ ] -&gt; In n [ ]</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk171" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk171"><hr></label><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) (m :: l&#39;) &lt;&gt; [ ] -&gt;
In n (m :: l&#39;)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk172" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk172"><span class="highlight">- <span class="c">(* l = [] *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) [ ] &lt;&gt; [ ] -&gt; In n [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk173" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk173"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[ ] &lt;&gt; [ ] -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk174" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk174"><span class="highlight"><span class="nb">intros</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">[ ] &lt;&gt; [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk175" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk175"><span class="highlight"><span class="nb">apply</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">[ ] &lt;&gt; [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[ ] = [ ]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk176" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk176"><span class="highlight">- <span class="c">(* l = m :: l&#39; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) (m :: l&#39;) &lt;&gt; [ ] -&gt;
In n (m :: l&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk177" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk177"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">if</span> n =? m
 <span class="kr">then</span> m :: filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39;
 <span class="kr">else</span> filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39;) &lt;&gt; [ ] -&gt;
m = n \/ In n l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk178" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk178"><span class="highlight"><span class="nb">destruct</span> (eqbP n m) <span class="kr">as</span> [H | H].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m :: filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
m = n \/ In n l&#39;</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk179" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;&gt; m</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk179"><hr></label><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
m = n \/ In n l&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk17a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk17a"><span class="highlight">+ <span class="c">(* n = m *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m :: filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
m = n \/ In n l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk17b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk17b"><span class="highlight"><span class="nb">intros</span> _.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m = n \/ In n l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk17c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk17c"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m = m \/ In m l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk17d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk17d"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m = m</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk17e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk17e"><span class="highlight">+ <span class="c">(* n &lt;&gt; m *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;&gt; m</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
m = n \/ In n l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk17f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk17f"><span class="highlight"><span class="nb">intros</span> H&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;&gt; m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m = n \/ In n l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk180" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk180"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;&gt; m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In n l&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk181" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk181"><span class="highlight"><span class="nb">apply</span> IHl&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ] -&gt;
In n l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;&gt; m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">filter (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; n =? x) l&#39; &lt;&gt; [ ]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H&#39;.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab32"></a><h4 class="section">Exercise: 3 stars, standard, recommended (eqbP_practice)</h4>
<div class="paragraph"> </div>

    Use <span class="inlinecode"><span class="id" title="var">eqbP</span></span> as above to prove the following: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">count</span> <span class="nv">n</span> <span class="nv">l</span> :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; <span class="mi">0</span>
  | m :: l&#39; =&gt; (<span class="kr">if</span> n =? m <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span>) + count n l&#39;
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk182" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk182"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">eqbP_practice</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">l</span>,
  count n l = <span class="mi">0</span> -&gt; ~(In n l).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list nat),
count n l = <span class="mi">0</span> -&gt; ~ In n l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk183" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk183"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list nat),
count n l = <span class="mi">0</span> -&gt; ~ In n l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
This small example shows how reflection gives us a small gain in
    convenience; in larger developments, using <span class="inlinecode"><span class="id" title="var">reflect</span></span> consistently
    can often lead to noticeably shorter and clearer proof scripts.
    We'll see many more examples in later chapters and in <i>Programming
    Language Foundations</i>.

<div class="paragraph"> </div>

    The use of the <span class="inlinecode"><span class="id" title="var">reflect</span></span> property has been popularized by
    <i>SSReflect</i>, a Coq library that has been used to formalize
    important results in mathematics, including as the 4-color theorem
    and the Feit-Thompson theorem.  The name SSReflect stands for
    <i>small-scale reflection</i>, i.e., the pervasive use of reflection to
    simplify small proof steps with boolean computations. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab33"></a><h1 class="section">Additional Exercises</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab34"></a><h4 class="section">Exercise: 3 stars, standard, recommended (nostutter_defn)</h4>
<div class="paragraph"> </div>

    Formulating inductive definitions of properties is an important
    skill you'll need in this course.  Try to solve this exercise
    without any help at all.

<div class="paragraph"> </div>

    We say that a list "stutters" if it repeats the same element
    consecutively.  (This is different from not containing duplicates:
    the sequence <span class="inlinecode">[1;4;1]</span> repeats the element <span class="inlinecode">1</span> but does not
    stutter.)  The property "<span class="inlinecode"><span class="id" title="var">nostutter</span></span> <span class="inlinecode"><span class="id" title="var">mylist</span></span>" means that <span class="inlinecode"><span class="id" title="var">mylist</span></span>
    does not stutter.  Formulate an inductive definition for
    <span class="inlinecode"><span class="id" title="var">nostutter</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">nostutter</span> {<span class="nv">X</span>:<span class="kt">Type</span>} : list X -&gt; <span class="kt">Prop</span> :=
 <span class="c">(* FILL IN HERE *)</span>
.</span></span></span></pre><div class="doc">
Make sure each of these tests succeeds, but feel free to change
    the suggested proof (in comments) if the given one doesn't work
    for you.  Your definition might be different from ours and still
    be correct, in which case the examples might need a different
    proof.  (You'll notice that the suggested proofs use a number of
    tactics we haven't talked about, to make them more robust to
    different possible ways of defining <span class="inlinecode"><span class="id" title="var">nostutter</span></span>.  You can probably
    just uncomment and use them as-is, but you can also prove each
    example with more basic tactics.)  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk184" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk184"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_nostutter_1</span>: nostutter [<span class="mi">3</span>;<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">1</span>;<span class="mi">5</span>;<span class="mi">6</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nostutter [<span class="mi">3</span>; <span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">1</span>; <span class="mi">5</span>; <span class="mi">6</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* </span>
<span class="c">  Proof. repeat constructor; apply eqb_neq; auto.</span>
<span class="c">  Qed.</span>
<span class="c">*)</span>

</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk185" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk185"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_nostutter_2</span>:  nostutter (@nil nat).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nostutter [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* </span>
<span class="c">  Proof. repeat constructor; apply eqb_neq; auto.</span>
<span class="c">  Qed.</span>
<span class="c">*)</span>

</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk186" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk186"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_nostutter_3</span>:  nostutter [<span class="mi">5</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nostutter [<span class="mi">5</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* </span>
<span class="c">  Proof. repeat constructor; apply eqb_false; auto. Qed.</span>
<span class="c">*)</span>

</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk187" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk187"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_nostutter_4</span>:      not (nostutter [<span class="mi">3</span>;<span class="mi">1</span>;<span class="mi">1</span>;<span class="mi">4</span>]).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ nostutter [<span class="mi">3</span>; <span class="mi">1</span>; <span class="mi">1</span>; <span class="mi">4</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* </span>
<span class="c">  Proof. intro.</span>
<span class="c">  repeat match goal with</span>
<span class="c">    h: nostutter _ |- _ =&gt; inversion h; clear h; subst</span>
<span class="c">  end.</span>
<span class="c">  contradiction Hneq0; auto. Qed.</span>
<span class="c">*)</span>

<span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_nostutter</span> : option (nat*string) := None.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab35"></a><h4 class="section">Exercise: 4 stars, advanced (filter_challenge)</h4>
<div class="paragraph"> </div>

    Let's prove that our definition of <span class="inlinecode"><span class="id" title="var">filter</span></span> from the <span class="inlinecode"><span class="id" title="var">Poly</span></span>
    chapter matches an abstract specification.  Here is the
    specification, written out informally in English:

<div class="paragraph"> </div>

    A list <span class="inlinecode"><span class="id" title="var">l</span></span> is an "in-order merge" of <span class="inlinecode"><span class="id" title="var">l1</span></span> and <span class="inlinecode"><span class="id" title="var">l2</span></span> if it contains
    all the same elements as <span class="inlinecode"><span class="id" title="var">l1</span></span> and <span class="inlinecode"><span class="id" title="var">l2</span></span>, in the same order as <span class="inlinecode"><span class="id" title="var">l1</span></span>
    and <span class="inlinecode"><span class="id" title="var">l2</span></span>, but possibly interleaved.  For example,

<div class="paragraph"> </div>
<span class="inlinecode">1;4;6;2;3</span>
<div class="paragraph"> </div>

    is an in-order merge of

<div class="paragraph"> </div>
<span class="inlinecode">1;6;2</span>
<div class="paragraph"> </div>

    and

<div class="paragraph"> </div>
<span class="inlinecode">4;3</span>.

<div class="paragraph"> </div>

    Now, suppose we have a set <span class="inlinecode"><span class="id" title="var">X</span></span>, a function <span class="inlinecode"><span class="id" title="var">test</span>:</span> <span class="inlinecode"><span class="id" title="var">X</span>‚Üí<span class="id" title="var">bool</span></span>, and a
    list <span class="inlinecode"><span class="id" title="var">l</span></span> of type <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>.  Suppose further that <span class="inlinecode"><span class="id" title="var">l</span></span> is an
    in-order merge of two lists, <span class="inlinecode"><span class="id" title="var">l1</span></span> and <span class="inlinecode"><span class="id" title="var">l2</span></span>, such that every item
    in <span class="inlinecode"><span class="id" title="var">l1</span></span> satisfies <span class="inlinecode"><span class="id" title="var">test</span></span> and no item in <span class="inlinecode"><span class="id" title="var">l2</span></span> satisfies test.  Then
    <span class="inlinecode"><span class="id" title="var">filter</span></span> <span class="inlinecode"><span class="id" title="var">test</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">l1</span></span>.

<div class="paragraph"> </div>

    Translate this specification into a Coq theorem and prove
    it.  (You'll need to begin by defining what it means for one list
    to be a merge of two others.  Do this with an inductive relation,
    not a <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>.)  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span>

<span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_filter_challenge</span> : option (nat*string) := None.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab36"></a><h4 class="section">Exercise: 5 stars, advanced, optional (filter_challenge_2)</h4>
<div class="paragraph"> </div>

    A different way to characterize the behavior of <span class="inlinecode"><span class="id" title="var">filter</span></span> goes like
    this: Among all subsequences of <span class="inlinecode"><span class="id" title="var">l</span></span> with the property that <span class="inlinecode"><span class="id" title="var">test</span></span>
    evaluates to <span class="inlinecode"><span class="id" title="var">true</span></span> on all their members, <span class="inlinecode"><span class="id" title="var">filter</span></span> <span class="inlinecode"><span class="id" title="var">test</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> is the
    longest.  Formalize this claim and prove it. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE </span>

<span class="c">    [] *)</span></span></span></pre><div class="doc">
<a name="lab37"></a><h4 class="section">Exercise: 4 stars, standard, optional (palindromes)</h4>
<div class="paragraph"> </div>

    A palindrome is a sequence that reads the same backwards as
    forwards.

<div class="paragraph"> </div>
<ul class="doclist">
<li> Define an inductive proposition <span class="inlinecode"><span class="id" title="var">pal</span></span> on <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> that
      captures what it means to be a palindrome. (Hint: You'll need
      three cases.  Your definition should be based on the structure
      of the list; just having a single constructor like

<div class="paragraph"> </div>

        c : forall l, l = rev l -&gt; pal l

<div class="paragraph"> </div>

      may seem obvious, but will not work very well.)

<div class="paragraph"> </div>
</li>
<li> Prove (<span class="inlinecode"><span class="id" title="var">pal_app_rev</span></span>) that

<div class="paragraph"> </div>

       forall l, pal (l ++ rev l).

<div class="paragraph"> </div>
</li>
<li> Prove (<span class="inlinecode"><span class="id" title="var">pal_rev</span></span> that)

<div class="paragraph"> </div>

       forall l, pal l -&gt; l = rev l.

</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span>

<span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_pal_pal_app_rev_pal_rev</span> : option (nat*string) := None.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab38"></a><h4 class="section">Exercise: 5 stars, standard, optional (palindrome_converse)</h4>
<div class="paragraph"> </div>

    Again, the converse direction is significantly more difficult, due
    to the lack of evidence.  Using your definition of <span class="inlinecode"><span class="id" title="var">pal</span></span> from the
    previous exercise, prove that

<div class="paragraph"> </div>

     forall l, l = rev l -&gt; pal l.

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE </span>

<span class="c">    [] *)</span></span></span></pre><div class="doc">
<a name="lab39"></a><h4 class="section">Exercise: 4 stars, advanced, optional (NoDup)</h4>
<div class="paragraph"> </div>

    Recall the definition of the <span class="inlinecode"><span class="id" title="var">In</span></span> property from the <span class="inlinecode"><span class="id" title="var">Logic</span></span>
    chapter, which asserts that a value <span class="inlinecode"><span class="id" title="var">x</span></span> appears at least once in a
    list <span class="inlinecode"><span class="id" title="var">l</span></span>: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* Fixpoint In (A : Type) (x : A) (l : list A) : Prop :=</span>
<span class="c">   match l with</span>
<span class="c">   | [] =&gt; False</span>
<span class="c">   | x&#39; :: l&#39; =&gt; x&#39; = x \/ In A x l&#39;</span>
<span class="c">   end *)</span></span></span></pre><div class="doc">
Your first task is to use <span class="inlinecode"><span class="id" title="var">In</span></span> to define a proposition <span class="inlinecode"><span class="id" title="var">disjoint</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>
<span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode"><span class="id" title="var">l2</span></span>, which should be provable exactly when <span class="inlinecode"><span class="id" title="var">l1</span></span> and <span class="inlinecode"><span class="id" title="var">l2</span></span> are
    lists (with elements of type X) that have no elements in
    common. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span></pre><div class="doc">
Next, use <span class="inlinecode"><span class="id" title="var">In</span></span> to define an inductive proposition <span class="inlinecode"><span class="id" title="var">NoDup</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>
<span class="inlinecode"><span class="id" title="var">l</span></span>, which should be provable exactly when <span class="inlinecode"><span class="id" title="var">l</span></span> is a list (with
    elements of type <span class="inlinecode"><span class="id" title="var">X</span></span>) where every member is different from every
    other.  For example, <span class="inlinecode"><span class="id" title="var">NoDup</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">[1;2;3;4]</span> and <span class="inlinecode"><span class="id" title="var">NoDup</span></span>
<span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">[]</span> should be provable, while <span class="inlinecode"><span class="id" title="var">NoDup</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">[1;2;1]</span> and
    <span class="inlinecode"><span class="id" title="var">NoDup</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">[<span class="id" title="var">true</span>;<span class="id" title="var">true</span>]</span> should not be.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span></pre><div class="doc">
Finally, state and prove one or more interesting theorems relating
    <span class="inlinecode"><span class="id" title="var">disjoint</span></span>, <span class="inlinecode"><span class="id" title="var">NoDup</span></span> and <span class="inlinecode">++</span> (list append).  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span>

<span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_NoDup_disjoint_etc</span> : option (nat*string) := None.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab40"></a><h4 class="section">Exercise: 4 stars, advanced, optional (pigeonhole_principle)</h4>
<div class="paragraph"> </div>

    The <i>pigeonhole principle</i> states a basic fact about counting: if
    we distribute more than <span class="inlinecode"><span class="id" title="var">n</span></span> items into <span class="inlinecode"><span class="id" title="var">n</span></span> pigeonholes, some
    pigeonhole must contain at least two items.  As often happens, this
    apparently trivial fact about numbers requires non-trivial
    machinery to prove, but we now have enough... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
First prove an easy useful lemma. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk188" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk188"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">in_split</span> : <span class="kr">forall</span> (<span class="nv">X</span>:<span class="kt">Type</span>) (<span class="nv">x</span>:X) (<span class="nv">l</span>:list X),
  In x l -&gt;
  <span class="kr">exists</span> <span class="nv">l1</span> <span class="nv">l2</span>, l = l1 ++ x :: l2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X),
In x l -&gt; <span class="kr">exists</span> <span class="nv">l1</span> <span class="nv">l2</span> : list X, l = l1 ++ x :: l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk189" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk189"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : X) (<span class="nv">l</span> : list X),
In x l -&gt; <span class="kr">exists</span> <span class="nv">l1</span> <span class="nv">l2</span> : list X, l = l1 ++ x :: l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
Now define a property <span class="inlinecode"><span class="id" title="var">repeats</span></span> such that <span class="inlinecode"><span class="id" title="var">repeats</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> asserts
    that <span class="inlinecode"><span class="id" title="var">l</span></span> contains at least one repeated element (of type <span class="inlinecode"><span class="id" title="var">X</span></span>).  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">repeats</span> {<span class="nv">X</span>:<span class="kt">Type</span>} : list X -&gt; <span class="kt">Prop</span> :=
  <span class="c">(* FILL IN HERE *)</span>
.</span></span></span></pre><div class="doc">
Now, here's a way to formalize the pigeonhole principle.  Suppose
    list <span class="inlinecode"><span class="id" title="var">l2</span></span> represents a list of pigeonhole labels, and list <span class="inlinecode"><span class="id" title="var">l1</span></span>
    represents the labels assigned to a list of items.  If there are
    more items than labels, at least two items must have the same
    label -- i.e., list <span class="inlinecode"><span class="id" title="var">l1</span></span> must contain repeats.

<div class="paragraph"> </div>

    This proof is much easier if you use the <span class="inlinecode"><span class="id" title="var">excluded_middle</span></span>
    hypothesis to show that <span class="inlinecode"><span class="id" title="var">In</span></span> is decidable, i.e., <span class="inlinecode"><span class="id" title="keyword">‚àÄ</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">l</span>,</span> <span class="inlinecode">(<span class="id" title="var">In</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>
<span class="inlinecode"><span class="id" title="var">l</span>)</span> <span class="inlinecode">‚à®</span> <span class="inlinecode">¬¨</span> <span class="inlinecode">(<span class="id" title="var">In</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">l</span>)</span>.  However, it is also possible to make the proof
    go through <i>without</i> assuming that <span class="inlinecode"><span class="id" title="var">In</span></span> is decidable; if you
    manage to do this, you will not need the <span class="inlinecode"><span class="id" title="var">excluded_middle</span></span>
    hypothesis. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk18a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk18a"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">pigeonhole_principle</span>: <span class="kr">forall</span> (<span class="nv">X</span>:<span class="kt">Type</span>) (<span class="nv">l1</span>  <span class="nv">l2</span>:list X),
   excluded_middle -&gt;
   (<span class="kr">forall</span> <span class="nv">x</span>, In x l1 -&gt; In x l2) -&gt;
   length l2 &lt; length l1 -&gt;
   repeats l1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list X),
excluded_middle -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : X, In x l1 -&gt; In x l2) -&gt;
length l2 &lt; length l1 -&gt; repeats l1</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk18b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk18b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list X),
excluded_middle -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : X, In x l1 -&gt; In x l2) -&gt;
length l2 &lt; length l1 -&gt; repeats l1</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk18c" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk18c"><span class="highlight"><span class="nb">intros</span> X l1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list X</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l2</span> : list X,
excluded_middle -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : X, In x l1 -&gt; In x l2) -&gt;
length l2 &lt; length l1 -&gt; repeats l1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk18d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk18d"><span class="highlight"><span class="nb">induction</span> l1 <span class="kr">as</span> [|x l1&#39; IHl1&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l2</span> : list X,
excluded_middle -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : X, In x [ ] -&gt; In x l2) -&gt;
length l2 &lt; length [ ] -&gt; repeats [ ]</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk18e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">X</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list X</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l2</span> : list X,
excluded_middle -&gt;
(<span class="kr">forall</span> <span class="nv">x0</span> : X, In x0 l1&#39; -&gt; In x0 l2) -&gt;
length l2 &lt; length l1&#39; -&gt; repeats l1&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk18e"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l2</span> : list X,
excluded_middle -&gt;
(<span class="kr">forall</span> <span class="nv">x0</span> : X, In x0 (x :: l1&#39;) -&gt; In x0 l2) -&gt;
length l2 &lt; length (x :: l1&#39;) -&gt; repeats (x :: l1&#39;)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_check_repeats</span> : option (nat*string) := None.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab41"></a><h2 class="section">Extended Exercise: A Verified Regular-Expression Matcher</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We have now defined a match relation over regular expressions and
    polymorphic lists. We can use such a definition to manually prove that
    a given regex matches a given string, but it does not give us a
    program that we can run to determine a match autmatically.

<div class="paragraph"> </div>

    It would be reasonable to hope that we can translate the definitions
    of the inductive rules for constructing evidence of the match relation
    into cases of a recursive function reflects the relation by recursing
    on a given regex. However, it does not seem straightforward to define
    such a function in which the given regex is a recursion variable
    recognized by Coq. As a result, Coq will not accept that the function
    always terminates.

<div class="paragraph"> </div>

    Heavily-optimized regex matchers match a regex by translating a given
    regex into a state machine and determining if the state machine
    accepts a given string. However, regex matching can also be
    implemented using an algorithm that operates purely on strings and
    regexes without defining and maintaining additional datatypes, such as
    state machines. We'll implemement such an algorithm, and verify that
    its value reflects the match relation. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We will implement a regex matcher that matches strings represented
    as lists of ASCII characters: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Export</span> Coq.Strings.Ascii.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">string</span> := list ascii.</span></span></span></pre><div class="doc">
The Coq standard library contains a distinct inductive definition
    of strings of ASCII characters. However, we will use the above
    definition of strings as lists as ASCII characters in order to apply
    the existing definition of the match relation.

<div class="paragraph"> </div>

    We could also define a regex matcher over polymorphic lists, not lists
    of ASCII characters specifically. The matching algorithm that we will
    implement needs to be able to test equality of elements in a given
    list, and thus needs to be given an equality-testing
    function. Generalizing the definitions, theorems, and proofs that we
    define for such a setting is a bit tedious, but workable. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The proof of correctness of the regex matcher will combine
    properties of the regex-matching function with properties of the
    <span class="inlinecode"><span class="id" title="keyword">match</span></span> relation that do not depend on the matching function. We'll go
    ahead and prove the latter class of properties now. Most of them have
    straightforward proofs, which have been given to you, although there
    are a few key lemmas that are left for you to prove. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Each provable <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> is equivalent to <span class="inlinecode"><span class="id" title="var">True</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk18f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk18f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">provable_equiv_true</span> : <span class="kr">forall</span> (<span class="nv">P</span> : <span class="kt">Prop</span>), P -&gt; (P &lt;-&gt; <span class="kt">True</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, P -&gt; P &lt;-&gt; <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk190" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk190"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, P -&gt; P &lt;-&gt; <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk191" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk191"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P &lt;-&gt; <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk192" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk192"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P -&gt; <span class="kt">True</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk193" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk193"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span> -&gt; P</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk194" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk194"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P -&gt; <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk195" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk195"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H, H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">constructor</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk196" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk196"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span> -&gt; P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk197" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk197"><span class="highlight"><span class="nb">intros</span> _.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Each <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> whose negation is provable is equivalent to <span class="inlinecode"><span class="id" title="var">False</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk198" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk198"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">not_equiv_false</span> : <span class="kr">forall</span> (<span class="nv">P</span> : <span class="kt">Prop</span>), ~P -&gt; (P &lt;-&gt; <span class="kt">False</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, ~ P -&gt; P &lt;-&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk199" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk199"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, ~ P -&gt; P &lt;-&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk19a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk19a"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P &lt;-&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk19b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk19b"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P -&gt; <span class="kt">False</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk19c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk19c"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span> -&gt; P</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk19d" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk19d"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk19e" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk19e"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span> -&gt; P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk19f" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk19f"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">False</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> H0.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">EmptySet</span></span> matches no string. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1a0" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1a0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">null_matches_none</span> : <span class="kr">forall</span> (<span class="nv">s</span> : string), (s =~ EmptySet) &lt;-&gt; <span class="kt">False</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s</span> : string, s =~ EmptySet &lt;-&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1a1" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1a1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s</span> : string, s =~ EmptySet &lt;-&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1a2" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1a2"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ EmptySet &lt;-&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1a3" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1a3"><span class="highlight"><span class="nb">apply</span> not_equiv_false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (s =~ EmptySet)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1a4" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1a4"><span class="highlight"><span class="nb">unfold</span> not.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ EmptySet -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1a5" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1a5"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ EmptySet</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">EmptyStr</span></span> only matches the empty string. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1a6" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1a6"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">empty_matches_eps</span> : <span class="kr">forall</span> (<span class="nv">s</span> : string), s =~ EmptyStr &lt;-&gt; s = [ ].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s</span> : string, s =~ EmptyStr &lt;-&gt; s = [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1a7" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1a7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s</span> : string, s =~ EmptyStr &lt;-&gt; s = [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1a8" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1a8"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ EmptyStr -&gt; s = [ ]</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk1a9" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk1a9"><hr></label><div class="goal-conclusion"><span class="highlight">s = [ ] -&gt; s =~ EmptyStr</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1aa" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1aa"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ EmptyStr -&gt; s = [ ]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1ab" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1ab"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ EmptyStr</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s = [ ]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1ac" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1ac"><span class="highlight"><span class="nb">inversion</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ EmptyStr</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">[ ] = s</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[ ] = [ ]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1ad" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1ad"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s = [ ] -&gt; s =~ EmptyStr</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1ae" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1ae"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s = [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ EmptyStr</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1af" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1af"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s = [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[ ] =~ EmptyStr</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> MEmpty.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">EmptyStr</span></span> matches no non-empty string. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1b0" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1b0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">empty_nomatch_ne</span> : <span class="kr">forall</span> (<span class="nv">a</span> : ascii) <span class="nv">s</span>, (a :: s =~ EmptyStr) &lt;-&gt; <span class="kt">False</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : ascii) (<span class="nv">s</span> : list ascii),
a :: s =~ EmptyStr &lt;-&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1b1" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1b1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : ascii) (<span class="nv">s</span> : list ascii),
a :: s =~ EmptyStr &lt;-&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1b2" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1b2"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a :: s =~ EmptyStr &lt;-&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1b3" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1b3"><span class="highlight"><span class="nb">apply</span> not_equiv_false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (a :: s =~ EmptyStr)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1b4" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1b4"><span class="highlight"><span class="nb">unfold</span> not.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a :: s =~ EmptyStr -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1b5" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1b5"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a :: s =~ EmptyStr</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">Char</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> matches no string that starts with a non-<span class="inlinecode"><span class="id" title="var">a</span></span> character. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1b6" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1b6"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">char_nomatch_char</span> :
  <span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : ascii) <span class="nv">s</span>, b &lt;&gt; a -&gt; (b :: s =~ Char a &lt;-&gt; <span class="kt">False</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : ascii) (<span class="nv">s</span> : list ascii),
b &lt;&gt; a -&gt; b :: s =~ Char a &lt;-&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1b7" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1b7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : ascii) (<span class="nv">s</span> : list ascii),
b &lt;&gt; a -&gt; b :: s =~ Char a &lt;-&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1b8" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1b8"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b &lt;&gt; a</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b :: s =~ Char a &lt;-&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1b9" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1b9"><span class="highlight"><span class="nb">apply</span> not_equiv_false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b &lt;&gt; a</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (b :: s =~ Char a)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1ba" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1ba"><span class="highlight"><span class="nb">unfold</span> not.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b &lt;&gt; a</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b :: s =~ Char a -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1bb" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1bb"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b &lt;&gt; a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b :: s =~ Char a</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1bc" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1bc"><span class="highlight"><span class="nb">apply</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b &lt;&gt; a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b :: s =~ Char a</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b = a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1bd" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1bd"><span class="highlight"><span class="nb">inversion</span> H0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b &lt;&gt; a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b :: s =~ Char a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = b</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">[ ] = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = a</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a = a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
If <span class="inlinecode"><span class="id" title="var">Char</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> matches a non-empty string, then the string's tail is empty. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1be" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1be"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">char_eps_suffix</span> : <span class="kr">forall</span> (<span class="nv">a</span> : ascii) <span class="nv">s</span>, a :: s =~ Char a &lt;-&gt; s = [ ].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : ascii) (<span class="nv">s</span> : list ascii),
a :: s =~ Char a &lt;-&gt; s = [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1bf" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1bf"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : ascii) (<span class="nv">s</span> : list ascii),
a :: s =~ Char a &lt;-&gt; s = [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1c0" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1c0"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a :: s =~ Char a -&gt; s = [ ]</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk1c1" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk1c1"><hr></label><div class="goal-conclusion"><span class="highlight">s = [ ] -&gt; a :: s =~ Char a</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1c2" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1c2"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a :: s =~ Char a -&gt; s = [ ]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1c3" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1c3"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a :: s =~ Char a</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s = [ ]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1c4" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1c4"><span class="highlight"><span class="nb">inversion</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a :: s =~ Char a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">[ ] = s</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[ ] = [ ]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1c5" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1c5"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s = [ ] -&gt; a :: s =~ Char a</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1c6" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1c6"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s = [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a :: s =~ Char a</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1c7" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1c7"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s = [ ]</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[a] =~ Char a</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> MChar.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">App</span></span> <span class="inlinecode"><span class="id" title="var">re0</span></span> <span class="inlinecode"><span class="id" title="var">re1</span></span> matches string <span class="inlinecode"><span class="id" title="var">s</span></span> iff <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">s0</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">s1</span></span>, where <span class="inlinecode"><span class="id" title="var">s0</span></span>
    matches <span class="inlinecode"><span class="id" title="var">re0</span></span> and <span class="inlinecode"><span class="id" title="var">s1</span></span> matches <span class="inlinecode"><span class="id" title="var">re1</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1c8" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1c8"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">app_exists</span> : <span class="kr">forall</span> (<span class="nv">s</span> : string) <span class="nv">re0</span> <span class="nv">re1</span>,
    s =~ App re0 re1 &lt;-&gt;
    <span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s1</span>, s = s0 ++ s1 /\ s0 =~ re0 /\ s1 =~ re1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : string) (<span class="nv">re0</span> <span class="nv">re1</span> : reg_exp),
s =~ App re0 re1 &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s1</span> : list ascii,
   s = s0 ++ s1 /\ (s0 =~ re0) /\ s1 =~ re1)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1c9" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1c9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : string) (<span class="nv">re0</span> <span class="nv">re1</span> : reg_exp),
s =~ App re0 re1 &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s1</span> : list ascii,
   s = s0 ++ s1 /\ (s0 =~ re0) /\ s1 =~ re1)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1ca" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1ca"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ App re0 re1 &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s1</span> : list ascii,
   s = s0 ++ s1 /\ (s0 =~ re0) /\ s1 =~ re1)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1cb" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1cb"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ App re0 re1 -&gt;
<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s1</span> : list ascii,
  s = s0 ++ s1 /\ (s0 =~ re0) /\ s1 =~ re1</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk1cc" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk1cc"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s1</span> : list ascii,
   s = s0 ++ s1 /\ (s0 =~ re0) /\ s1 =~ re1) -&gt;
s =~ App re0 re1</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1cd" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1cd"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ App re0 re1 -&gt;
<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s1</span> : list ascii,
  s = s0 ++ s1 /\ (s0 =~ re0) /\ s1 =~ re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1ce" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1ce"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ App re0 re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s1</span> : list ascii,
  s = s0 ++ s1 /\ (s0 =~ re0) /\ s1 =~ re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1cf" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1cf"><span class="highlight"><span class="nb">inversion</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ App re0 re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 ++ s2 = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re3 = re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s3</span> : list ascii,
  s1 ++ s2 = s0 ++ s3 /\ (s0 =~ re0) /\ s3 =~ re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1d0" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1d0"><span class="highlight"><span class="kr">exists</span> <span class="nv">s1</span>, s2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ App re0 re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 ++ s2 = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re3 = re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s1 ++ s2 = s1 ++ s2 /\ (s1 =~ re0) /\ s2 =~ re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1d1" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1d1"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ App re0 re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 ++ s2 = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re3 = re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s1 ++ s2 = s1 ++ s2</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk1d2" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ App re0 re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 ++ s2 = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re3 = re1</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk1d2"><hr></label><div class="goal-conclusion"><span class="highlight">(s1 =~ re0) /\ s2 =~ re1</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1d3" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1d3"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ App re0 re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 ++ s2 = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re3 = re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s1 ++ s2 = s1 ++ s2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1d4" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1d4"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ App re0 re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 ++ s2 = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re3 = re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(s1 =~ re0) /\ s2 =~ re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1d5" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1d5"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ App re0 re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 ++ s2 = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re3 = re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s1 =~ re0</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk1d6" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ App re0 re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 ++ s2 = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re3 = re1</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk1d6"><hr></label><div class="goal-conclusion"><span class="highlight">s2 =~ re1</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1d7" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1d7"><span class="highlight"><span class="nb">apply</span> H3.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ App re0 re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 ++ s2 = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re3 = re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s2 =~ re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H4.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1d8" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1d8"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s1</span> : list ascii,
   s = s0 ++ s1 /\ (s0 =~ re0) /\ s1 =~ re1) -&gt;
s =~ App re0 re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1d9" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1d9"><span class="highlight"><span class="nb">intros</span> [ s0 [ s1 [ Happ [ Hmat0 Hmat1 ] ] ] ].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0, s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Happ</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s = s0 ++ s1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmat0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s0 =~ re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmat1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ App re0 re1</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1da" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1da"><span class="highlight"><span class="nb">rewrite</span> Happ.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0, s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Happ</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s = s0 ++ s1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmat0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s0 =~ re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hmat1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 =~ re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s0 ++ s1 =~ App re0 re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> (MApp s0 _ s1 _ Hmat0 Hmat1).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab42"></a><h4 class="section">Exercise: 3 stars, standard, optional (app_ne)</h4>
<div class="paragraph"> </div>
<span class="inlinecode"><span class="id" title="var">App</span></span> <span class="inlinecode"><span class="id" title="var">re0</span></span> <span class="inlinecode"><span class="id" title="var">re1</span></span> matches <span class="inlinecode"><span class="id" title="var">a</span>::<span class="id" title="var">s</span></span> iff <span class="inlinecode"><span class="id" title="var">re0</span></span> matches the empty string
    and <span class="inlinecode"><span class="id" title="var">a</span>::<span class="id" title="var">s</span></span> matches <span class="inlinecode"><span class="id" title="var">re1</span></span> or <span class="inlinecode"><span class="id" title="var">s</span>=<span class="id" title="var">s0</span>++<span class="id" title="var">s1</span></span>, where <span class="inlinecode"><span class="id" title="var">a</span>::<span class="id" title="var">s0</span></span> matches <span class="inlinecode"><span class="id" title="var">re0</span></span>
    and <span class="inlinecode"><span class="id" title="var">s1</span></span> matches <span class="inlinecode"><span class="id" title="var">re1</span></span>.

<div class="paragraph"> </div>

    Even though this is a property of purely the match relation, it is a
    critical observation behind the design of our regex matcher. So (1)
    take time to understand it, (2) prove it, and (3) look for how you'll
    use it later. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1db" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1db"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">app_ne</span> : <span class="kr">forall</span> (<span class="nv">a</span> : ascii) <span class="nv">s</span> <span class="nv">re0</span> <span class="nv">re1</span>,
    a :: s =~ (App re0 re1) &lt;-&gt;
    ([ ] =~ re0 /\ a :: s =~ re1) \/
    <span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s1</span>, s = s0 ++ s1 /\ a :: s0 =~ re0 /\ s1 =~ re1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : ascii) (<span class="nv">s</span> : list ascii)
  (<span class="nv">re0</span> <span class="nv">re1</span> : reg_exp),
a :: s =~ App re0 re1 &lt;-&gt;
([ ] =~ re0) /\ a :: s =~ re1 \/
(<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s1</span> : list ascii,
   s = s0 ++ s1 /\ (a :: s0 =~ re0) /\ s1 =~ re1)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1dc" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1dc"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : ascii) (<span class="nv">s</span> : list ascii)
  (<span class="nv">re0</span> <span class="nv">re1</span> : reg_exp),
a :: s =~ App re0 re1 &lt;-&gt;
([ ] =~ re0) /\ a :: s =~ re1 \/
(<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s1</span> : list ascii,
   s = s0 ++ s1 /\ (a :: s0 =~ re0) /\ s1 =~ re1)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">s</span></span> matches <span class="inlinecode"><span class="id" title="var">Union</span></span> <span class="inlinecode"><span class="id" title="var">re0</span></span> <span class="inlinecode"><span class="id" title="var">re1</span></span> iff <span class="inlinecode"><span class="id" title="var">s</span></span> matches <span class="inlinecode"><span class="id" title="var">re0</span></span> or <span class="inlinecode"><span class="id" title="var">s</span></span> matches <span class="inlinecode"><span class="id" title="var">re1</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1dd" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1dd"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">union_disj</span> : <span class="kr">forall</span> (<span class="nv">s</span> : string) <span class="nv">re0</span> <span class="nv">re1</span>,
    s =~ Union re0 re1 &lt;-&gt; s =~ re0 \/ s =~ re1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : string) (<span class="nv">re0</span> <span class="nv">re1</span> : reg_exp),
s =~ Union re0 re1 &lt;-&gt; s =~ re0 \/ s =~ re1</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1de" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1de"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : string) (<span class="nv">re0</span> <span class="nv">re1</span> : reg_exp),
s =~ Union re0 re1 &lt;-&gt; s =~ re0 \/ s =~ re1</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1df" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1df"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ Union re0 re1 &lt;-&gt; s =~ re0 \/ s =~ re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1e0" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1e0"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ Union re0 re1 -&gt; s =~ re0 \/ s =~ re1</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk1e1" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk1e1"><hr></label><div class="goal-conclusion"><span class="highlight">s =~ re0 \/ s =~ re1 -&gt; s =~ Union re0 re1</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1e2" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1e2"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ Union re0 re1 -&gt; s =~ re0 \/ s =~ re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1e3" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1e3"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ Union re0 re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ re0 \/ s =~ re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1e4" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1e4"><span class="highlight"><span class="nb">inversion</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ Union re0 re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2, re3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re3 = re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ re0 \/ s =~ re1</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk1e5" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ Union re0 re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re3 = re1</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk1e5"><hr></label><div class="goal-conclusion"><span class="highlight">s =~ re0 \/ s =~ re1</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1e6" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1e6"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ Union re0 re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2, re3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re3 = re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ re0 \/ s =~ re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1e7" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1e7"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ Union re0 re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2, re3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re3 = re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ re0</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H2.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1e8" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1e8"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ Union re0 re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re3 = re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ re0 \/ s =~ re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1e9" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1e9"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ Union re0 re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s2 = s</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re2 = re0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">re3 = re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H1.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1ea" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1ea"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ re0 \/ s =~ re1 -&gt; s =~ Union re0 re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1eb" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1eb"><span class="highlight"><span class="nb">intros</span> [ H | H ].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re0</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ Union re0 re1</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="IndProp-v-chk1ec" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re1</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="IndProp-v-chk1ec"><hr></label><div class="goal-conclusion"><span class="highlight">s =~ Union re0 re1</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1ed" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1ed"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re0</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ Union re0 re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1ee" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1ee"><span class="highlight"><span class="nb">apply</span> MUnionL.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re0</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ re0</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1ef" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1ef"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ Union re0 re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1f0" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1f0"><span class="highlight"><span class="nb">apply</span> MUnionR.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re0, re1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s =~ re1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s =~ re1</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab43"></a><h4 class="section">Exercise: 3 stars, standard, optional (star_ne)</h4>
<div class="paragraph"> </div>
<span class="inlinecode"><span class="id" title="var">a</span>::<span class="id" title="var">s</span></span> matches <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span> iff <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">s0</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">s1</span></span>, where <span class="inlinecode"><span class="id" title="var">a</span>::<span class="id" title="var">s0</span></span> matches
    <span class="inlinecode"><span class="id" title="var">re</span></span> and <span class="inlinecode"><span class="id" title="var">s1</span></span> matches <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>. Like <span class="inlinecode"><span class="id" title="var">app_ne</span></span>, this observation is
    critical, so understand it, prove it, and keep it in mind.

<div class="paragraph"> </div>

    Hint: you'll need to perform induction. There are quite a few
    reasonable candidates for <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>'s to prove by induction. The only one
    that will work is splitting the <span class="inlinecode"><span class="id" title="var">iff</span></span> into two implications and
    proving one by induction on the evidence for <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>. The
    other implication can be proved without induction.

<div class="paragraph"> </div>

    In order to prove the right property by induction, you'll need to
    rephrase <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span> to be a <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> over general variables,
    using the <span class="inlinecode"><span class="id" title="var">remember</span></span> tactic.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1f1" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1f1"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">star_ne</span> : <span class="kr">forall</span> (<span class="nv">a</span> : ascii) <span class="nv">s</span> <span class="nv">re</span>,
    a :: s =~ Star re &lt;-&gt;
    <span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s1</span>, s = s0 ++ s1 /\ a :: s0 =~ re /\ s1 =~ Star re.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : ascii) (<span class="nv">s</span> : list ascii) (<span class="nv">re</span> : reg_exp),
a :: s =~ Star re &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s1</span> : list ascii,
   s = s0 ++ s1 /\ (a :: s0 =~ re) /\ s1 =~ Star re)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1f2" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1f2"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : ascii) (<span class="nv">s</span> : list ascii) (<span class="nv">re</span> : reg_exp),
a :: s =~ Star re &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">s0</span> <span class="nv">s1</span> : list ascii,
   s = s0 ++ s1 /\ (a :: s0 =~ re) /\ s1 =~ Star re)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The definition of our regex matcher will include two fixpoint
    functions. The first function, given regex <span class="inlinecode"><span class="id" title="var">re</span></span>, will evaluate to a
    value that reflects whether <span class="inlinecode"><span class="id" title="var">re</span></span> matches the empty string. The
    function will satisfy the following property: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">refl_matches_eps</span> <span class="nv">m</span> :=
  <span class="kr">forall</span> <span class="nv">re</span> : @reg_exp ascii, reflect ([ ] =~ re) (m re).</span></span></span></pre><div class="doc">
<a name="lab44"></a><h4 class="section">Exercise: 2 stars, standard, optional (match_eps)</h4>
<div class="paragraph"> </div>

    Complete the definition of <span class="inlinecode"><span class="id" title="var">match_eps</span></span> so that it tests if a given
    regex matches the empty string: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1f3" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1f3"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">match_eps</span> (<span class="nv">re</span>: @reg_exp ascii) : bool
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">match_eps</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp -&gt; bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">bool</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab45"></a><h4 class="section">Exercise: 3 stars, standard, optional (match_eps_refl)</h4>
<div class="paragraph"> </div>

    Now, prove that <span class="inlinecode"><span class="id" title="var">match_eps</span></span> indeed tests if a given regex matches
    the empty string.  (Hint: You'll want to use the reflection lemmas
    <span class="inlinecode"><span class="id" title="var">ReflectT</span></span> and <span class="inlinecode"><span class="id" title="var">ReflectF</span></span>.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1f4" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1f4"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">match_eps_refl</span> : refl_matches_eps match_eps.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">refl_matches_eps match_eps</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1f5" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1f5"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">refl_matches_eps match_eps</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We'll define other functions that use <span class="inlinecode"><span class="id" title="var">match_eps</span></span>. However, the
    only property of <span class="inlinecode"><span class="id" title="var">match_eps</span></span> that you'll need to use in all proofs
    over these functions is <span class="inlinecode"><span class="id" title="var">match_eps_refl</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The key operation that will be performed by our regex matcher will
    be to iteratively construct a sequence of regex derivatives. For each
    character <span class="inlinecode"><span class="id" title="var">a</span></span> and regex <span class="inlinecode"><span class="id" title="var">re</span></span>, the derivative of <span class="inlinecode"><span class="id" title="var">re</span></span> on <span class="inlinecode"><span class="id" title="var">a</span></span> is a regex
    that matches all suffixes of strings matched by <span class="inlinecode"><span class="id" title="var">re</span></span> that start with
    <span class="inlinecode"><span class="id" title="var">a</span></span>. I.e., <span class="inlinecode"><span class="id" title="var">re'</span></span> is a derivative of <span class="inlinecode"><span class="id" title="var">re</span></span> on <span class="inlinecode"><span class="id" title="var">a</span></span> if they satisfy the
    following relation: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">is_der</span> <span class="nv">re</span> (<span class="nv">a</span> : ascii) <span class="nv">re&#39;</span> :=
  <span class="kr">forall</span> <span class="nv">s</span>, a :: s =~ re &lt;-&gt; s =~ re&#39;.</span></span></span></pre><div class="doc">
A function <span class="inlinecode"><span class="id" title="var">d</span></span> derives strings if, given character <span class="inlinecode"><span class="id" title="var">a</span></span> and regex
    <span class="inlinecode"><span class="id" title="var">re</span></span>, it evaluates to the derivative of <span class="inlinecode"><span class="id" title="var">re</span></span> on <span class="inlinecode"><span class="id" title="var">a</span></span>. I.e., <span class="inlinecode"><span class="id" title="var">d</span></span>
    satisfies the following property: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">derives</span> <span class="nv">d</span> := <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">re</span>, is_der re a (d a re).</span></span></span></pre><div class="doc">
<a name="lab46"></a><h4 class="section">Exercise: 3 stars, standard, optional (derive)</h4>
<div class="paragraph"> </div>

    Define <span class="inlinecode"><span class="id" title="var">derive</span></span> so that it derives strings. One natural
    implementation uses <span class="inlinecode"><span class="id" title="var">match_eps</span></span> in some cases to determine if key
    regex's match the empty string. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1f6" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1f6"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">derive</span> (<span class="nv">a</span> : ascii) (<span class="nv">re</span> : @reg_exp ascii) : @reg_exp ascii
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">derive</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii -&gt; reg_exp -&gt; reg_exp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ascii</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reg_exp</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">derive</span></span> function should pass the following tests. Each test
    establishes an equality between an expression that will be
    evaluated by our regex matcher and the final value that must be
    returned by the regex matcher. Each test is annotated with the
    match fact that it reflects. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Example</span> <span class="nf">c</span> := ascii_of_nat <span class="mi">99</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Example</span> <span class="nf">d</span> := ascii_of_nat <span class="mi">100</span>.</span></span></span></pre><div class="doc">
"c" =~ EmptySet: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1f7" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1f7"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_der0</span> : match_eps (derive c (EmptySet)) = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps (derive c EmptySet) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1f8" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1f8"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps (derive c EmptySet) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
"c" =~ Char c: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1f9" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1f9"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_der1</span> : match_eps (derive c (Char c)) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps (derive c (Char c)) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1fa" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1fa"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps (derive c (Char c)) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
"c" =~ Char d: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1fb" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1fb"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_der2</span> : match_eps (derive c (Char d)) = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps (derive c (Char d)) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1fc" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1fc"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps (derive c (Char d)) = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
"c" =~ App (Char c) EmptyStr: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1fd" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1fd"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_der3</span> : match_eps (derive c (App (Char c) EmptyStr)) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps (derive c (App (Char c) EmptyStr)) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1fe" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1fe"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps (derive c (App (Char c) EmptyStr)) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
"c" =~ App EmptyStr (Char c): 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk1ff" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk1ff"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_der4</span> : match_eps (derive c (App EmptyStr (Char c))) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps (derive c (App EmptyStr (Char c))) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk200" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk200"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps (derive c (App EmptyStr (Char c))) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
"c" =~ Star c: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk201" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk201"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_der5</span> : match_eps (derive c (Star (Char c))) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps (derive c (Star (Char c))) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk202" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk202"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps (derive c (Star (Char c))) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
"cd" =~ App (Char c) (Char d): 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk203" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk203"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_der6</span> :
  match_eps (derive d (derive c (App (Char c) (Char d)))) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps
  (derive d (derive c (App (Char c) (Char d)))) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk204" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk204"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps
  (derive d (derive c (App (Char c) (Char d)))) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
"cd" =~ App (Char d) (Char c): 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk205" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk205"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_der7</span> :
  match_eps (derive d (derive c (App (Char d) (Char c)))) = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps
  (derive d (derive c (App (Char d) (Char c)))) =
false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk206" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk206"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">match_eps
  (derive d (derive c (App (Char d) (Char c)))) =
false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<a name="lab47"></a><h4 class="section">Exercise: 4 stars, standard, optional (derive_corr)</h4>
<div class="paragraph"> </div>

    Prove that <span class="inlinecode"><span class="id" title="var">derive</span></span> in fact always derives strings.

<div class="paragraph"> </div>

    Hint: one proof performs induction on <span class="inlinecode"><span class="id" title="var">re</span></span>, although you'll need
    to carefully choose the property that you prove by induction by
    generalizing the appropriate terms.

<div class="paragraph"> </div>

    Hint: if your definition of <span class="inlinecode"><span class="id" title="var">derive</span></span> applies <span class="inlinecode"><span class="id" title="var">match_eps</span></span> to a
    particular regex <span class="inlinecode"><span class="id" title="var">re</span></span>, then a natural proof will apply
    <span class="inlinecode"><span class="id" title="var">match_eps_refl</span></span> to <span class="inlinecode"><span class="id" title="var">re</span></span> and destruct the result to generate cases
    with assumptions that the <span class="inlinecode"><span class="id" title="var">re</span></span> does or does not match the empty
    string.

<div class="paragraph"> </div>

    Hint: You can save quite a bit of work by using lemmas proved
    above. In particular, to prove many cases of the induction, you
    can rewrite a <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> over a complicated regex (e.g., <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" title="var">Union</span></span>
<span class="inlinecode"><span class="id" title="var">re0</span></span> <span class="inlinecode"><span class="id" title="var">re1</span></span>) to a Boolean combination of <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>'s over simple
    regex's (e.g., <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" title="var">re0</span></span> <span class="inlinecode">‚à®</span> <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" title="var">re1</span></span>) using lemmas given above
    that are logical equivalences. You can then reason about these
    <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>'s naturally using <span class="inlinecode"><span class="id" title="tactic">intro</span></span> and <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk207" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk207"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">derive_corr</span> : derives derive.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">derives derive</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk208" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk208"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">derives derive</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We'll define the regex matcher using <span class="inlinecode"><span class="id" title="var">derive</span></span>. However, the only
    property of <span class="inlinecode"><span class="id" title="var">derive</span></span> that you'll need to use in all proofs of
    properties of the matcher is <span class="inlinecode"><span class="id" title="var">derive_corr</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
A function <span class="inlinecode"><span class="id" title="var">m</span></span> matches regexes if, given string <span class="inlinecode"><span class="id" title="var">s</span></span> and regex <span class="inlinecode"><span class="id" title="var">re</span></span>,
    it evaluates to a value that reflects whether <span class="inlinecode"><span class="id" title="var">s</span></span> is matched by
    <span class="inlinecode"><span class="id" title="var">re</span></span>. I.e., <span class="inlinecode"><span class="id" title="var">m</span></span> holds the following property: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">matches_regex</span> <span class="nv">m</span> : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> (<span class="nv">s</span> : string) <span class="nv">re</span>, reflect (s =~ re) (m s re).</span></span></span></pre><div class="doc">
<a name="lab48"></a><h4 class="section">Exercise: 2 stars, standard, optional (regex_match)</h4>
<div class="paragraph"> </div>

    Complete the definition of <span class="inlinecode"><span class="id" title="var">regex_match</span></span> so that it matches
    regexes. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk209" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk209"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">regex_match</span> (<span class="nv">s</span> : string) (<span class="nv">re</span> : @reg_exp ascii) : bool
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">regex_match</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string -&gt; reg_exp -&gt; bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">re</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">reg_exp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">bool</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab49"></a><h4 class="section">Exercise: 3 stars, standard, optional (regex_refl)</h4>
<div class="paragraph"> </div>

    Finally, prove that <span class="inlinecode"><span class="id" title="var">regex_match</span></span> in fact matches regexes.

<div class="paragraph"> </div>

    Hint: if your definition of <span class="inlinecode"><span class="id" title="var">regex_match</span></span> applies <span class="inlinecode"><span class="id" title="var">match_eps</span></span> to
    regex <span class="inlinecode"><span class="id" title="var">re</span></span>, then a natural proof applies <span class="inlinecode"><span class="id" title="var">match_eps_refl</span></span> to <span class="inlinecode"><span class="id" title="var">re</span></span>
    and destructs the result to generate cases in which you may assume
    that <span class="inlinecode"><span class="id" title="var">re</span></span> does or does not match the empty string.

<div class="paragraph"> </div>

    Hint: if your definition of <span class="inlinecode"><span class="id" title="var">regex_match</span></span> applies <span class="inlinecode"><span class="id" title="var">derive</span></span> to
    character <span class="inlinecode"><span class="id" title="var">x</span></span> and regex <span class="inlinecode"><span class="id" title="var">re</span></span>, then a natural proof applies
    <span class="inlinecode"><span class="id" title="var">derive_corr</span></span> to <span class="inlinecode"><span class="id" title="var">x</span></span> and <span class="inlinecode"><span class="id" title="var">re</span></span> to prove that <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" title="var">re</span></span> given
    <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" title="var">derive</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>, and vice versa. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk20a" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk20a"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">regex_refl</span> : matches_regex regex_match.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">matches_regex regex_match</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="IndProp-v-chk20b" style="display: none" type="checkbox"><label class="coq-input" for="IndProp-v-chk20b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">matches_regex regex_match</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* Wed Jan 9 12:02:45 EST 2019 *)</span></span></span></pre></article></body></html>