<!DOCTYPE html>
<html><head><title>Imp.v</title><meta charset="utf-8"><meta content="Alectryon v0.2" name="generator"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet"><link href="https://unpkg.com/firacode/distr/fira_code.css" rel="stylesheet"><link href="alectryon.css" rel="stylesheet"><script src="alectryon.js"></script><style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-standalone alectryon-centered alectryon-coqdoc"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><div class="doc">
<a name="lab1"></a><h1 class="section">Imp: Simple Imperative Programs</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
In this chapter, we take a more serious look at how to use Coq to
    study other things.  Our case study is a <i>simple imperative
    programming language</i> called Imp, embodying a tiny core fragment
    of conventional mainstream languages such as C and Java.  Here is
    a familiar mathematical function written in Imp.

<div class="paragraph"> </div>

       Z ::= X;;
       Y ::= 1;;
       WHILE ~(Z = 0) DO
         Y ::= Y * Z;;
         Z ::= Z - 1
       END

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We concentrate here on defining the <i>syntax</i> and <i>semantics</i> of
    Imp; later chapters in <i>Programming Language Foundations</i> 
    (<i>Software Foundations</i>, volume 2) develop a theory of 
    <i>program equivalence</i> and introduce <i>Hoare Logic</i>, a widely
    used logic for reasoning about imperative programs. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Set Warnings</span> <span class="s2">&quot;-notation-overridden,-parsing&quot;</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Bool.Bool.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Init.Nat.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Arith.Arith.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Arith.EqNat.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> <span class="bp">omega</span>.Omega.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Lists.List.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Strings.String.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Import</span> ListNotations.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> LF <span class="kn">Require Import</span> Maps.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab2"></a><h1 class="section">Arithmetic and Boolean Expressions</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We'll present Imp in three parts: first a core language of
    <i>arithmetic and boolean expressions</i>, then an extension of these
    expressions with <i>variables</i>, and finally a language of <i>commands</i>
    including assignment, conditions, sequencing, and loops. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab3"></a><h2 class="section">Syntax</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">AExp</span>.</span></span></span></pre><div class="doc">
These two definitions specify the <i>abstract syntax</i> of
    arithmetic and boolean expressions. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">aexp</span> : <span class="kt">Type</span> :=
  | ANum (n : nat)
  | APlus (a1 a2 : aexp)
  | AMinus (a1 a2 : aexp)
  | AMult (a1 a2 : aexp).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">bexp</span> : <span class="kt">Type</span> :=
  | BTrue
  | BFalse
  | BEq (a1 a2 : aexp)
  | BLe (a1 a2 : aexp)
  | BNot (b : bexp)
  | BAnd (b1 b2 : bexp).</span></span></span></pre><div class="doc">
In this chapter, we'll mostly elide the translation from the
    concrete syntax that a programmer would actually write to these
    abstract syntax trees -- the process that, for example, would
    translate the string <span class="inlinecode">"1</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">√ó</span> <span class="inlinecode">3"</span> to the AST

<div class="paragraph"> </div>

      APlus (ANum 1) (AMult (ANum 2) (ANum 3)).

<div class="paragraph"> </div>

    The optional chapter <span class="inlinecode"><span class="id" title="var">ImpParser</span></span> develops a simple lexical
    analyzer and parser that can perform this translation.  You do
    <i>not</i> need to understand that chapter to understand this one, but
    if you haven't already taken a course where these techniques are
    covered (e.g., a compilers course) you may want to skim it. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
For comparison, here's a conventional BNF (Backus-Naur Form)
    grammar defining the same abstract syntax:

<div class="paragraph"> </div>

    a ::= nat
        | a + a
        | a - a
        | a * a

<div class="paragraph"> </div>

    b ::= true
        | false
        | a = a
        | a &lt;= a
        | ~ b
        | b &amp;&amp; b

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Compared to the Coq version above...

<div class="paragraph"> </div>
<ul class="doclist">
<li> The BNF is more informal -- for example, it gives some
         suggestions about the surface syntax of expressions (like the
         fact that the addition operation is written with an infix
         <span class="inlinecode">+</span>) while leaving other aspects of lexical analysis and
         parsing (like the relative precedence of <span class="inlinecode">+</span>, <span class="inlinecode">-</span>, and
         <span class="inlinecode">√ó</span>, the use of parens to group subexpressions, etc.)
         unspecified.  Some additional information -- and human
         intelligence -- would be required to turn this description
         into a formal definition, e.g., for implementing a compiler.

<div class="paragraph"> </div>

         The Coq version consistently omits all this information and
         concentrates on the abstract syntax only.

<div class="paragraph"> </div>
</li>
<li> Conversely, the BNF version is lighter and easier to read.
         Its informality makes it flexible, a big advantage in
         situations like discussions at the blackboard, where
         conveying general ideas is more important than getting every
         detail nailed down precisely.

<div class="paragraph"> </div>

         Indeed, there are dozens of BNF-like notations and people
         switch freely among them, usually without bothering to say
         which kind of BNF they're using because there is no need to:
         a rough-and-ready informal understanding is all that's
         important.

</li>
</ul>
<div class="paragraph"> </div>

    It's good to be comfortable with both sorts of notations: informal
    ones for communicating between humans and formal ones for carrying
    out implementations and proofs. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab4"></a><h2 class="section">Evaluation</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<i>Evaluating</i> an arithmetic expression produces a number. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">aeval</span> (<span class="nv">a</span> : aexp) : nat :=
  <span class="kr">match</span> a <span class="kr">with</span>
  | ANum n =&gt; n
  | APlus  a1 a2 =&gt; (aeval a1) + (aeval a2)
  | AMinus a1 a2 =&gt; (aeval a1) - (aeval a2)
  | AMult  a1 a2 =&gt; (aeval a1) * (aeval a2)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk0" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk0"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_aeval1</span>:
  aeval (APlus (ANum <span class="mi">2</span>) (ANum <span class="mi">2</span>)) = <span class="mi">4</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (APlus (ANum <span class="mi">2</span>) (ANum <span class="mi">2</span>)) = <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk1" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (APlus (ANum <span class="mi">2</span>) (ANum <span class="mi">2</span>)) = <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Similarly, evaluating a boolean expression yields a boolean. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">beval</span> (<span class="nv">b</span> : bexp) : bool :=
  <span class="kr">match</span> b <span class="kr">with</span>
  | BTrue       =&gt; true
  | BFalse      =&gt; false
  | BEq a1 a2   =&gt; (aeval a1) =? (aeval a2)
  | BLe a1 a2   =&gt; (aeval a1) &lt;=? (aeval a2)
  | BNot b1     =&gt; negb (beval b1)
  | BAnd b1 b2  =&gt; andb (beval b1) (beval b2)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab5"></a><h2 class="section">Optimization</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We haven't defined very much yet, but we can already get
    some mileage out of the definitions.  Suppose we define a function
    that takes an arithmetic expression and slightly simplifies it,
    changing every occurrence of <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">e</span></span> (i.e., <span class="inlinecode">(<span class="id" title="var">APlus</span></span> <span class="inlinecode">(<span class="id" title="var">ANum</span></span> <span class="inlinecode">0)</span> <span class="inlinecode"><span class="id" title="var">e</span></span>)
    into just <span class="inlinecode"><span class="id" title="var">e</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">optimize_0plus</span> (<span class="nv">a</span>:aexp) : aexp :=
  <span class="kr">match</span> a <span class="kr">with</span>
  | ANum n =&gt; ANum n
  | APlus (ANum <span class="mi">0</span>) e2 =&gt; optimize_0plus e2
  | APlus  e1 e2 =&gt; APlus  (optimize_0plus e1) (optimize_0plus e2)
  | AMinus e1 e2 =&gt; AMinus (optimize_0plus e1) (optimize_0plus e2)
  | AMult  e1 e2 =&gt; AMult  (optimize_0plus e1) (optimize_0plus e2)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
To make sure our optimization is doing the right thing we
    can test it on some examples and see if the output looks OK. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk2" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk2"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_optimize_0plus</span>:
  optimize_0plus (APlus (ANum <span class="mi">2</span>)
                        (APlus (ANum <span class="mi">0</span>)
                               (APlus (ANum <span class="mi">0</span>) (ANum <span class="mi">1</span>))))
  = APlus (ANum <span class="mi">2</span>) (ANum <span class="mi">1</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">optimize_0plus
  (APlus (ANum <span class="mi">2</span>)
     (APlus (ANum <span class="mi">0</span>) (APlus (ANum <span class="mi">0</span>) (ANum <span class="mi">1</span>)))) =
APlus (ANum <span class="mi">2</span>) (ANum <span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk3" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">optimize_0plus
  (APlus (ANum <span class="mi">2</span>)
     (APlus (ANum <span class="mi">0</span>) (APlus (ANum <span class="mi">0</span>) (ANum <span class="mi">1</span>)))) =
APlus (ANum <span class="mi">2</span>) (ANum <span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
But if we want to be sure the optimization is correct --
    i.e., that evaluating an optimized expression gives the same
    result as the original -- we should prove it. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk4" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk4"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">optimize_0plus_sound</span>: <span class="kr">forall</span> <span class="nv">a</span>,
  aeval (optimize_0plus a) = aeval a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : aexp, aeval (optimize_0plus a) = aeval a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk5" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk5"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : aexp, aeval (optimize_0plus a) = aeval a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk6" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk6"><span class="highlight"><span class="nb">intros</span> a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus a) = aeval a</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk7" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk7"><span class="highlight"><span class="nb">induction</span> a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (ANum n)) = aeval (ANum n)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chk8" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk8"><hr></label><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus a1 a2)) =
aeval (APlus a1 a2)</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chk9" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk9"><hr></label><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (AMinus a1 a2)) =
aeval (AMinus a1 a2)</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chka" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chka"><hr></label><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (AMult a1 a2)) =
aeval (AMult a1 a2)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkb" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkb"><span class="highlight">- <span class="c">(* ANum *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (ANum n)) = aeval (ANum n)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkc" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkc"><span class="highlight">- <span class="c">(* APlus *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus a1 a2)) =
aeval (APlus a1 a2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkd" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkd"><span class="highlight"><span class="nb">destruct</span> a1 <span class="nb">eqn</span>:Ea1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = ANum n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (ANum n)) =
aeval (ANum n)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (ANum n) a2)) =
aeval (APlus (ANum n) a2)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chke" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = APlus a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (APlus a3 a4)) =
aeval (APlus a3 a4)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chke"><hr></label><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (APlus a3 a4) a2)) =
aeval (APlus (APlus a3 a4) a2)</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chkf" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = AMinus a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (AMinus a3 a4)) =
aeval (AMinus a3 a4)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chkf"><hr></label><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (AMinus a3 a4) a2)) =
aeval (APlus (AMinus a3 a4) a2)</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chk10" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = AMult a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (AMult a3 a4)) =
aeval (AMult a3 a4)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk10"><hr></label><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (AMult a3 a4) a2)) =
aeval (APlus (AMult a3 a4) a2)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk11" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk11"><span class="highlight">+ <span class="c">(* a1 = ANum n *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = ANum n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (ANum n)) =
aeval (ANum n)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (ANum n) a2)) =
aeval (APlus (ANum n) a2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk12" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk12"><span class="highlight"><span class="nb">destruct</span> n <span class="nb">eqn</span>:En.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">En</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = ANum <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (ANum <span class="mi">0</span>)) =
aeval (ANum <span class="mi">0</span>)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (ANum <span class="mi">0</span>) a2)) =
aeval (APlus (ANum <span class="mi">0</span>) a2)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chk13" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">En</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = ANum (S n0)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (ANum (S n0))) =
aeval (ANum (S n0))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk13"><hr></label><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (ANum (S n0)) a2)) =
aeval (APlus (ANum (S n0)) a2)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk14" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk14"><span class="highlight">* <span class="c">(* n = 0 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">En</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = ANum <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (ANum <span class="mi">0</span>)) =
aeval (ANum <span class="mi">0</span>)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (ANum <span class="mi">0</span>) a2)) =
aeval (APlus (ANum <span class="mi">0</span>) a2)</span></div></blockquote></div></div></small><span class="coq-wsp">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk15" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk15"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">En</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = ANum <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (ANum <span class="mi">0</span>)) =
aeval (ANum <span class="mi">0</span>)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> IHa2.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk16" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk16"><span class="highlight">* <span class="c">(* n &lt;&gt; 0 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">En</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = ANum (S n0)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (ANum (S n0))) =
aeval (ANum (S n0))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (ANum (S n0)) a2)) =
aeval (APlus (ANum (S n0)) a2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk17" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk17"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">En</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = ANum (S n0)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (ANum (S n0))) =
aeval (ANum (S n0))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">S (n0 + aeval (optimize_0plus a2)) = S (n0 + aeval a2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk18" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk18"><span class="highlight"><span class="nb">rewrite</span> IHa2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">En</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = ANum (S n0)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (ANum (S n0))) =
aeval (ANum (S n0))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">S (n0 + aeval a2) = S (n0 + aeval a2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk19" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk19"><span class="highlight">+ <span class="c">(* a1 = APlus a1_1 a1_2 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = APlus a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (APlus a3 a4)) =
aeval (APlus a3 a4)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (APlus a3 a4) a2)) =
aeval (APlus (APlus a3 a4) a2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk1a" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk1a"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = APlus a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (APlus a3 a4)) =
aeval (APlus a3 a4)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval
  <span class="kr">match</span> a3 <span class="kr">with</span>
  | ANum <span class="mi">0</span> =&gt; optimize_0plus a4
  | _ =&gt; APlus (optimize_0plus a3) (optimize_0plus a4)
  <span class="kr">end</span> + aeval (optimize_0plus a2) =
aeval a3 + aeval a4 + aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk1b"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> IHa1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = APlus a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval
  <span class="kr">match</span> a3 <span class="kr">with</span>
  | ANum <span class="mi">0</span> =&gt; optimize_0plus a4
  | _ =&gt;
      APlus (optimize_0plus a3)
        (optimize_0plus a4)
  <span class="kr">end</span> = aeval a3 + aeval a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval
  <span class="kr">match</span> a3 <span class="kr">with</span>
  | ANum <span class="mi">0</span> =&gt; optimize_0plus a4
  | _ =&gt; APlus (optimize_0plus a3) (optimize_0plus a4)
  <span class="kr">end</span> + aeval (optimize_0plus a2) =
aeval a3 + aeval a4 + aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk1c"><span class="highlight"><span class="nb">rewrite</span> IHa1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = APlus a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval
  <span class="kr">match</span> a3 <span class="kr">with</span>
  | ANum <span class="mi">0</span> =&gt; optimize_0plus a4
  | _ =&gt;
      APlus (optimize_0plus a3)
        (optimize_0plus a4)
  <span class="kr">end</span> = aeval a3 + aeval a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a3 + aeval a4 + aeval (optimize_0plus a2) =
aeval a3 + aeval a4 + aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk1d" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk1d"><span class="highlight"><span class="nb">rewrite</span> IHa2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = APlus a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval
  <span class="kr">match</span> a3 <span class="kr">with</span>
  | ANum <span class="mi">0</span> =&gt; optimize_0plus a4
  | _ =&gt;
      APlus (optimize_0plus a3)
        (optimize_0plus a4)
  <span class="kr">end</span> = aeval a3 + aeval a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a3 + aeval a4 + aeval a2 =
aeval a3 + aeval a4 + aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk1e"><span class="highlight">+ <span class="c">(* a1 = AMinus a1_1 a1_2 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = AMinus a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (AMinus a3 a4)) =
aeval (AMinus a3 a4)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (AMinus a3 a4) a2)) =
aeval (APlus (AMinus a3 a4) a2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk1f"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = AMinus a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (AMinus a3 a4)) =
aeval (AMinus a3 a4)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus a3) - aeval (optimize_0plus a4) +
aeval (optimize_0plus a2) =
aeval a3 - aeval a4 + aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk20" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk20"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> IHa1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = AMinus a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a3) -
aeval (optimize_0plus a4) = 
aeval a3 - aeval a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus a3) - aeval (optimize_0plus a4) +
aeval (optimize_0plus a2) =
aeval a3 - aeval a4 + aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk21" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk21"><span class="highlight"><span class="nb">rewrite</span> IHa1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = AMinus a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a3) -
aeval (optimize_0plus a4) = 
aeval a3 - aeval a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a3 - aeval a4 + aeval (optimize_0plus a2) =
aeval a3 - aeval a4 + aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk22" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk22"><span class="highlight"><span class="nb">rewrite</span> IHa2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = AMinus a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a3) -
aeval (optimize_0plus a4) = 
aeval a3 - aeval a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a3 - aeval a4 + aeval a2 =
aeval a3 - aeval a4 + aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk23" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk23"><span class="highlight">+ <span class="c">(* a1 = AMult a1_1 a1_2 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = AMult a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (AMult a3 a4)) =
aeval (AMult a3 a4)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (AMult a3 a4) a2)) =
aeval (APlus (AMult a3 a4) a2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk24" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk24"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = AMult a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (AMult a3 a4)) =
aeval (AMult a3 a4)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus a3) * aeval (optimize_0plus a4) +
aeval (optimize_0plus a2) =
aeval a3 * aeval a4 + aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk25" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk25"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> IHa1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = AMult a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a3) *
aeval (optimize_0plus a4) = 
aeval a3 * aeval a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus a3) * aeval (optimize_0plus a4) +
aeval (optimize_0plus a2) =
aeval a3 * aeval a4 + aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk26" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk26"><span class="highlight"><span class="nb">rewrite</span> IHa1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = AMult a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a3) *
aeval (optimize_0plus a4) = 
aeval a3 * aeval a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a3 * aeval a4 + aeval (optimize_0plus a2) =
aeval a3 * aeval a4 + aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk27" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk27"><span class="highlight"><span class="nb">rewrite</span> IHa2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2, a3, a4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = AMult a3 a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a3) *
aeval (optimize_0plus a4) = 
aeval a3 * aeval a4</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a3 * aeval a4 + aeval a2 =
aeval a3 * aeval a4 + aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk28" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk28"><span class="highlight">- <span class="c">(* AMinus *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (AMinus a1 a2)) =
aeval (AMinus a1 a2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk29" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk29"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus a1) - aeval (optimize_0plus a2) =
aeval a1 - aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk2a" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk2a"><span class="highlight"><span class="nb">rewrite</span> IHa1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a1 - aeval (optimize_0plus a2) =
aeval a1 - aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk2b" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk2b"><span class="highlight"><span class="nb">rewrite</span> IHa2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a1 - aeval a2 = aeval a1 - aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk2c" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk2c"><span class="highlight">- <span class="c">(* AMult *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (AMult a1 a2)) =
aeval (AMult a1 a2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk2d" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk2d"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus a1) * aeval (optimize_0plus a2) =
aeval a1 * aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk2e"><span class="highlight"><span class="nb">rewrite</span> IHa1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a1 * aeval (optimize_0plus a2) =
aeval a1 * aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk2f" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk2f"><span class="highlight"><span class="nb">rewrite</span> IHa2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a1 * aeval a2 = aeval a1 * aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab6"></a><h1 class="section">Coq Automation</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The amount of repetition in this last proof is a little
    annoying.  And if either the language of arithmetic expressions or
    the optimization being proved sound were significantly more
    complex, it would start to be a real problem.

<div class="paragraph"> </div>

    So far, we've been doing all our proofs using just a small handful
    of Coq's tactics and completely ignoring its powerful facilities
    for constructing parts of proofs automatically.  This section
    introduces some of these facilities, and we will see more over the
    next several chapters.  Getting used to them will take some
    energy -- Coq's automation is a power tool -- but it will allow us
    to scale up our efforts to more complex definitions and more
    interesting properties without becoming overwhelmed by boring,
    repetitive, low-level details. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab7"></a><h2 class="section">Tacticals</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<i>Tacticals</i> is Coq's term for tactics that take other tactics as
    arguments -- "higher-order tactics," if you will.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab8"></a><h3 class="section">The <span class="inlinecode"><span class="id" title="tactic">try</span></span> Tactical</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
If <span class="inlinecode"><span class="id" title="var">T</span></span> is a tactic, then <span class="inlinecode"><span class="id" title="tactic">try</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span> is a tactic that is just like <span class="inlinecode"><span class="id" title="var">T</span></span>
    except that, if <span class="inlinecode"><span class="id" title="var">T</span></span> fails, <span class="inlinecode"><span class="id" title="tactic">try</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span> <i>successfully</i> does nothing at
    all (rather than failing). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk30" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk30"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">silly1</span> : <span class="kr">forall</span> <span class="nv">ae</span>, aeval ae = aeval ae.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">ae</span> : aexp, aeval ae = aeval ae</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk31" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk31"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">ae</span> : aexp, aeval ae = aeval ae</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kp">try</span> <span class="bp">reflexivity</span>. <span class="c">(* This just does [reflexivity]. *)</span></span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk32" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk32"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">silly2</span> : <span class="kr">forall</span> (<span class="nv">P</span> : <span class="kt">Prop</span>), P -&gt; P.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, P -&gt; P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk33" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk33"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, P -&gt; P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk34" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk34"><span class="highlight"><span class="nb">intros</span> P HP.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk35" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk35"><span class="highlight"><span class="kp">try</span> <span class="bp">reflexivity</span>. <span class="c">(* Just [reflexivity] would have failed. *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> HP. <span class="c">(* We can still finish the proof in some other way. *)</span></span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
There is no real reason to use <span class="inlinecode"><span class="id" title="tactic">try</span></span> in completely manual
    proofs like these, but it is very useful for doing automated
    proofs in conjunction with the <span class="inlinecode">;</span> tactical, which we show
    next. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab9"></a><h3 class="section">The <span class="inlinecode">;</span> Tactical (Simple Form)</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
In its most common form, the <span class="inlinecode">;</span> tactical takes two tactics as
    arguments.  The compound tactic <span class="inlinecode"><span class="id" title="var">T</span>;<span class="id" title="var">T'</span></span> first performs <span class="inlinecode"><span class="id" title="var">T</span></span> and then
    performs <span class="inlinecode"><span class="id" title="var">T'</span></span> on <i>each subgoal</i> generated by <span class="inlinecode"><span class="id" title="var">T</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
For example, consider the following trivial lemma: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk36" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk36"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">foo</span> : <span class="kr">forall</span> <span class="nv">n</span>, <span class="mi">0</span> &lt;=? n = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, (<span class="mi">0</span> &lt;=? n) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk37" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk37"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, (<span class="mi">0</span> &lt;=? n) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk38" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk38"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="mi">0</span> &lt;=? n) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk39" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk39"><span class="highlight"><span class="nb">destruct</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="mi">0</span> &lt;=? <span class="mi">0</span>) = true</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chk3a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk3a"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="mi">0</span> &lt;=? S n) = true</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">    <span class="c">(* Leaves two subgoals, which are discharged identically...  *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk3b" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk3b"><span class="highlight">- <span class="c">(* n=0 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="mi">0</span> &lt;=? <span class="mi">0</span>) = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk3c" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk3c"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk3d" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk3d"><span class="highlight">- <span class="c">(* n=Sn&#39; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="mi">0</span> &lt;=? S n) = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk3e" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk3e"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
We can simplify this proof using the <span class="inlinecode">;</span> tactical: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk3f" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk3f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">foo&#39;</span> : <span class="kr">forall</span> <span class="nv">n</span>, <span class="mi">0</span> &lt;=? n = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, (<span class="mi">0</span> &lt;=? n) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk40" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk40"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, (<span class="mi">0</span> &lt;=? n) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk41" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk41"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="mi">0</span> &lt;=? n) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* [destruct] the current goal *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> n;
  <span class="c">(* then [simpl] each resulting subgoal *)</span>
  <span class="nb">simpl</span>;
  <span class="c">(* and do [reflexivity] on each resulting subgoal *)</span>
  <span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Using <span class="inlinecode"><span class="id" title="tactic">try</span></span> and <span class="inlinecode">;</span> together, we can get rid of the repetition in
    the proof that was bothering us a little while ago. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk42" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk42"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">optimize_0plus_sound&#39;</span>: <span class="kr">forall</span> <span class="nv">a</span>,
  aeval (optimize_0plus a) = aeval a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : aexp, aeval (optimize_0plus a) = aeval a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk43" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk43"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : aexp, aeval (optimize_0plus a) = aeval a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk44" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk44"><span class="highlight"><span class="nb">intros</span> a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus a) = aeval a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk45" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk45"><span class="highlight"><span class="nb">induction</span> a;
    <span class="c">(* Most cases follow directly by the IH... *)</span>
    <span class="kp">try</span> (<span class="nb">simpl</span>; <span class="nb">rewrite</span> IHa1; <span class="nb">rewrite</span> IHa2; <span class="bp">reflexivity</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (ANum n)) = aeval (ANum n)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chk46" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk46"><hr></label><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus a1 a2)) =
aeval (APlus a1 a2)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">    <span class="c">(* ... but the remaining cases -- ANum and APlus --</span>
<span class="c">       are different: *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk47" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk47"><span class="highlight">- <span class="c">(* ANum *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (ANum n)) = aeval (ANum n)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk48" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk48"><span class="highlight">- <span class="c">(* APlus *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus a1 a2)) =
aeval (APlus a1 a2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk49" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk49"><span class="highlight"><span class="nb">destruct</span> a1 <span class="nb">eqn</span>:Ea1;
      <span class="c">(* Again, most cases follow directly by the IH: *)</span>
      <span class="kp">try</span> (<span class="nb">simpl</span>; <span class="nb">simpl</span> <span class="kr">in</span> IHa1; <span class="nb">rewrite</span> IHa1;
           <span class="nb">rewrite</span> IHa2; <span class="bp">reflexivity</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = ANum n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (ANum n)) =
aeval (ANum n)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (ANum n) a2)) =
aeval (APlus (ANum n) a2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">    <span class="c">(* The interesting case, on which the [try...]</span>
<span class="c">       does nothing, is when [e1 = ANum n]. In this</span>
<span class="c">       case, we have to destruct [n] (to see whether</span>
<span class="c">       the optimization applies) and rewrite with the</span>
<span class="c">       induction hypothesis. *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk4a" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk4a"><span class="highlight">+ <span class="c">(* a1 = ANum n *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ea1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = ANum n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (ANum n)) =
aeval (ANum n)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (ANum n) a2)) =
aeval (APlus (ANum n) a2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> n <span class="nb">eqn</span>:En;
      <span class="nb">simpl</span>; <span class="nb">rewrite</span> IHa2; <span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">   </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Coq experts often use this "<span class="inlinecode">...;</span> <span class="inlinecode"><span class="id" title="tactic">try</span>...</span> <span class="inlinecode"></span>" idiom after a tactic
    like <span class="inlinecode"><span class="id" title="tactic">induction</span></span> to take care of many similar cases all at once.
    Naturally, this practice has an analog in informal proofs.  For
    example, here is an informal proof of the optimization theorem
    that matches the structure of the formal one:

<div class="paragraph"> </div>
<i>Theorem</i>: For all arithmetic expressions <span class="inlinecode"><span class="id" title="var">a</span></span>,

<div class="paragraph"> </div>

       aeval (optimize_0plus a) = aeval a.

<div class="paragraph"> </div>
<i>Proof</i>: By induction on <span class="inlinecode"><span class="id" title="var">a</span></span>.  Most cases follow directly from the
    IH.  The remaining cases are as follows:

<div class="paragraph"> </div>
<ul class="doclist">
<li> Suppose <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">ANum</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> for some <span class="inlinecode"><span class="id" title="var">n</span></span>.  We must show

<div class="paragraph"> </div>

          aeval (optimize_0plus (ANum n)) = aeval (ANum n).

<div class="paragraph"> </div>

        This is immediate from the definition of <span class="inlinecode"><span class="id" title="var">optimize_0plus</span></span>.

<div class="paragraph"> </div>
</li>
<li> Suppose <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">APlus</span></span> <span class="inlinecode"><span class="id" title="var">a1</span></span> <span class="inlinecode"><span class="id" title="var">a2</span></span> for some <span class="inlinecode"><span class="id" title="var">a1</span></span> and <span class="inlinecode"><span class="id" title="var">a2</span></span>.  We must
        show

<div class="paragraph"> </div>

          aeval (optimize_0plus (APlus a1 a2)) = aeval (APlus a1 a2).

<div class="paragraph"> </div>

        Consider the possible forms of <span class="inlinecode"><span class="id" title="var">a1</span></span>.  For most of them,
        <span class="inlinecode"><span class="id" title="var">optimize_0plus</span></span> simply calls itself recursively for the
        subexpressions and rebuilds a new expression of the same form
        as <span class="inlinecode"><span class="id" title="var">a1</span></span>; in these cases, the result follows directly from the
        IH.

<div class="paragraph"> </div>

        The interesting case is when <span class="inlinecode"><span class="id" title="var">a1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">ANum</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> for some <span class="inlinecode"><span class="id" title="var">n</span></span>.  If
        <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>, then

<div class="paragraph"> </div>

          optimize_0plus (APlus a1 a2) = optimize_0plus a2

<div class="paragraph"> </div>

        and the IH for <span class="inlinecode"><span class="id" title="var">a2</span></span> is exactly what we need.  On the other
        hand, if <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> for some <span class="inlinecode"><span class="id" title="var">n'</span></span>, then again <span class="inlinecode"><span class="id" title="var">optimize_0plus</span></span>
        simply calls itself recursively, and the result follows from
        the IH.  <font size="-2">‚òê</font>
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
However, this proof can still be improved: the first case (for
    <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">ANum</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>) is very trivial -- even more trivial than the cases
    that we said simply followed from the IH -- yet we have chosen to
    write it out in full.  It would be better and clearer to drop it
    and just say, at the top, "Most cases are either immediate or
    direct from the IH.  The only interesting case is the one for
    <span class="inlinecode"><span class="id" title="var">APlus</span></span>..."  We can make the same improvement in our formal proof
    too.  Here's how it looks: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk4b" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk4b"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">optimize_0plus_sound&#39;&#39;</span>: <span class="kr">forall</span> <span class="nv">a</span>,
  aeval (optimize_0plus a) = aeval a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : aexp, aeval (optimize_0plus a) = aeval a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk4c" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk4c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : aexp, aeval (optimize_0plus a) = aeval a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk4d" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk4d"><span class="highlight"><span class="nb">intros</span> a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus a) = aeval a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk4e" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk4e"><span class="highlight"><span class="nb">induction</span> a;
    <span class="c">(* Most cases follow directly by the IH *)</span>
    <span class="kp">try</span> (<span class="nb">simpl</span>; <span class="nb">rewrite</span> IHa1; <span class="nb">rewrite</span> IHa2; <span class="bp">reflexivity</span>);
    <span class="c">(* ... or are immediate by definition *)</span>
    <span class="kp">try</span> <span class="bp">reflexivity</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus a1 a2)) =
aeval (APlus a1 a2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* The interesting case is when a = APlus a1 a2. *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk4f" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk4f"><span class="highlight">- <span class="c">(* APlus *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a1) = aeval a1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus a1 a2)) =
aeval (APlus a1 a2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk50" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk50"><span class="highlight"><span class="nb">destruct</span> a1; <span class="kp">try</span> (<span class="nb">simpl</span>; <span class="nb">simpl</span> <span class="kr">in</span> IHa1; <span class="nb">rewrite</span> IHa1;
                      <span class="nb">rewrite</span> IHa2; <span class="bp">reflexivity</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (ANum n)) =
aeval (ANum n)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (ANum n) a2)) =
aeval (APlus (ANum n) a2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk51" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk51"><span class="highlight">+ <span class="c">(* a1 = ANum n *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus (ANum n)) =
aeval (ANum n)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval (optimize_0plus a2) = aeval a2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (optimize_0plus (APlus (ANum n) a2)) =
aeval (APlus (ANum n) a2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> n;
      <span class="nb">simpl</span>; <span class="nb">rewrite</span> IHa2; <span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab10"></a><h3 class="section">The <span class="inlinecode">;</span> Tactical (General Form)</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <span class="inlinecode">;</span> tactical also has a more general form than the simple
    <span class="inlinecode"><span class="id" title="var">T</span>;<span class="id" title="var">T'</span></span> we've seen above.  If <span class="inlinecode"><span class="id" title="var">T</span></span>, <span class="inlinecode"><span class="id" title="var">T1</span></span>, ..., <span class="inlinecode"><span class="id" title="var">Tn</span></span> are tactics,
    then

<div class="paragraph"> </div>

      T; <span class="inlinecode"><span class="id" title="var">T1</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">T2</span></span> <span class="inlinecode">|</span> <span class="inlinecode">...</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">Tn</span></span>
<div class="paragraph"> </div>

    is a tactic that first performs <span class="inlinecode"><span class="id" title="var">T</span></span> and then performs <span class="inlinecode"><span class="id" title="var">T1</span></span> on the
    first subgoal generated by <span class="inlinecode"><span class="id" title="var">T</span></span>, performs <span class="inlinecode"><span class="id" title="var">T2</span></span> on the second
    subgoal, etc.

<div class="paragraph"> </div>

    So <span class="inlinecode"><span class="id" title="var">T</span>;<span class="id" title="var">T'</span></span> is just special notation for the case when all of the
    <span class="inlinecode"><span class="id" title="var">Ti</span></span>'s are the same tactic; i.e., <span class="inlinecode"><span class="id" title="var">T</span>;<span class="id" title="var">T'</span></span> is shorthand for:

<div class="paragraph"> </div>

      T; <span class="inlinecode"><span class="id" title="var">T'</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">T'</span></span> <span class="inlinecode">|</span> <span class="inlinecode">...</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">T'</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab11"></a><h3 class="section">The <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> Tactical</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> tactical takes another tactic and keeps applying this
    tactic until it fails. Here is an example showing that <span class="inlinecode">10</span> is in
    a long list using repeat. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk52" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk52"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">In10</span> : In <span class="mi">10</span> [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>;<span class="mi">4</span>;<span class="mi">5</span>;<span class="mi">6</span>;<span class="mi">7</span>;<span class="mi">8</span>;<span class="mi">9</span>;<span class="mi">10</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In <span class="mi">10</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>; <span class="mi">7</span>; <span class="mi">8</span>; <span class="mi">9</span>; <span class="mi">10</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk53" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk53"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In <span class="mi">10</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>; <span class="mi">7</span>; <span class="mi">8</span>; <span class="mi">9</span>; <span class="mi">10</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kp">repeat</span> (<span class="kp">try</span> (<span class="nb">left</span>; <span class="bp">reflexivity</span>); <span class="nb">right</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The tactic <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span> never fails: if the tactic <span class="inlinecode"><span class="id" title="var">T</span></span> doesn't apply
    to the original goal, then repeat still succeeds without changing
    the original goal (i.e., it repeats zero times). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk54" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk54"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">In10&#39;</span> : In <span class="mi">10</span> [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>;<span class="mi">4</span>;<span class="mi">5</span>;<span class="mi">6</span>;<span class="mi">7</span>;<span class="mi">8</span>;<span class="mi">9</span>;<span class="mi">10</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In <span class="mi">10</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>; <span class="mi">7</span>; <span class="mi">8</span>; <span class="mi">9</span>; <span class="mi">10</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk55" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk55"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In <span class="mi">10</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>; <span class="mi">7</span>; <span class="mi">8</span>; <span class="mi">9</span>; <span class="mi">10</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk56" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk56"><span class="highlight"><span class="kp">repeat</span> (<span class="nb">left</span>; <span class="bp">reflexivity</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In <span class="mi">10</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>; <span class="mi">7</span>; <span class="mi">8</span>; <span class="mi">9</span>; <span class="mi">10</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kp">repeat</span> (<span class="nb">right</span>; <span class="kp">try</span> (<span class="nb">left</span>; <span class="bp">reflexivity</span>)).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The tactic <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span> also does not have any upper bound on the
    number of times it applies <span class="inlinecode"><span class="id" title="var">T</span></span>.  If <span class="inlinecode"><span class="id" title="var">T</span></span> is a tactic that always
    succeeds, then repeat <span class="inlinecode"><span class="id" title="var">T</span></span> will loop forever (e.g., <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>
    loops, since <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> always succeeds).  While evaluation in Coq's
    term language, Gallina, is guaranteed to terminate, tactic
    evaluation is not!  This does not affect Coq's logical
    consistency, however, since the job of <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> and other tactics
    is to guide Coq in constructing proofs; if the construction
    process diverges (i.e., it does not terminate), this simply means
    that we have failed to construct a proof, not that we have
    constructed a wrong one. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab12"></a><h4 class="section">Exercise: 3 stars, standard (optimize_0plus_b_sound)</h4>
<div class="paragraph"> </div>

    Since the <span class="inlinecode"><span class="id" title="var">optimize_0plus</span></span> transformation doesn't change the value
    of <span class="inlinecode"><span class="id" title="var">aexp</span></span>s, we should be able to apply it to all the <span class="inlinecode"><span class="id" title="var">aexp</span></span>s that
    appear in a <span class="inlinecode"><span class="id" title="var">bexp</span></span> without changing the <span class="inlinecode"><span class="id" title="var">bexp</span></span>'s value.  Write a
    function that performs this transformation on <span class="inlinecode"><span class="id" title="var">bexp</span></span>s and prove
    it is sound.  Use the tacticals we've just seen to make the proof
    as elegant as possible. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk57" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk57"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">optimize_0plus_b</span> (<span class="nv">b</span> : bexp) : bexp
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">optimize_0plus_b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp -&gt; bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">bexp</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk58" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk58"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">optimize_0plus_b_sound</span> : <span class="kr">forall</span> <span class="nv">b</span>,
  beval (optimize_0plus_b b) = beval b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : bexp, beval (optimize_0plus_b b) = beval b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk59" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk59"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : bexp, beval (optimize_0plus_b b) = beval b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab13"></a><h4 class="section">Exercise: 4 stars, standard, optional (optimize)</h4>
<div class="paragraph"> </div>
<i>Design exercise</i>: The optimization implemented by our
    <span class="inlinecode"><span class="id" title="var">optimize_0plus</span></span> function is only one of many possible
    optimizations on arithmetic and boolean expressions.  Write a more
    sophisticated optimizer and prove it correct.  (You will probably
    find it easiest to start small -- add just a single, simple
    optimization and its correctness proof -- and build up to
    something more interesting incrementially.)  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE </span>

<span class="c">    [] *)</span>

<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab14"></a><h2 class="section">Defining New Tactic Notations</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Coq also provides several ways of "programming" tactic
    scripts.

<div class="paragraph"> </div>
<ul class="doclist">
<li> The <span class="inlinecode"><span class="id" title="keyword">Tactic</span></span> <span class="inlinecode"><span class="id" title="keyword">Notation</span></span> idiom illustrated below gives a handy way
      to define "shorthand tactics" that bundle several tactics into a
      single command.

<div class="paragraph"> </div>
</li>
<li> For more sophisticated programming, Coq offers a built-in
      language called <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span> with primitives that can examine and
      modify the proof state.  The details are a bit too complicated
      to get into here (and it is generally agreed that <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span> is not
      the most beautiful part of Coq's design!), but they can be found
      in the reference manual and other books on Coq, and there are
      many examples of <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span> definitions in the Coq standard library
      that you can use as examples.

<div class="paragraph"> </div>
</li>
<li> There is also an OCaml API, which can be used to build tactics
      that access Coq's internal structures at a lower level, but this
      is seldom worth the trouble for ordinary Coq users.

</li>
</ul>
<div class="paragraph"> </div>

    The <span class="inlinecode"><span class="id" title="keyword">Tactic</span></span> <span class="inlinecode"><span class="id" title="keyword">Notation</span></span> mechanism is the easiest to come to grips
    with, and it offers plenty of power for many purposes.  Here's an
    example. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;simpl_and_try&quot;</span> tactic(c) :=
  <span class="nb">simpl</span>;
  <span class="kp">try</span> c.</span></span></span></pre><div class="doc">
This defines a new tactical called <span class="inlinecode"><span class="id" title="var">simpl_and_try</span></span> that takes one
    tactic <span class="inlinecode"><span class="id" title="var">c</span></span> as an argument and is defined to be equivalent to the
    tactic <span class="inlinecode"><span class="id" title="tactic">simpl</span>;</span> <span class="inlinecode"><span class="id" title="tactic">try</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span>.  Now writing "<span class="inlinecode"><span class="id" title="var">simpl_and_try</span></span> <span class="inlinecode"><span class="id" title="tactic">reflexivity</span>.</span>"
    in a proof will be the same as writing "<span class="inlinecode"><span class="id" title="tactic">simpl</span>;</span> <span class="inlinecode"><span class="id" title="tactic">try</span></span> <span class="inlinecode"><span class="id" title="tactic">reflexivity</span>.</span>" 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab15"></a><h2 class="section">The <span class="inlinecode"><span class="id" title="tactic">omega</span></span> Tactic</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="tactic">omega</span></span> tactic implements a decision procedure for a subset of
    first-order logic called <i>Presburger arithmetic</i>.  It is based on
    the Omega algorithm invented by William Pugh <span class="inlinecode"><span class="id" title="var">Pugh</span></span> <span class="inlinecode">1991</span> (in Bib.v).

<div class="paragraph"> </div>

    If the goal is a universally quantified formula made out of

<div class="paragraph"> </div>
<ul class="doclist">
<li> numeric constants, addition (<span class="inlinecode">+</span> and <span class="inlinecode"><span class="id" title="var">S</span></span>), subtraction (<span class="inlinecode">-</span>
        and <span class="inlinecode"><span class="id" title="var">pred</span></span>), and multiplication by constants (this is what
        makes it Presburger arithmetic),

<div class="paragraph"> </div>
</li>
<li> equality (<span class="inlinecode">=</span> and <span class="inlinecode">‚â†</span>) and ordering (<span class="inlinecode">‚â§</span>), and

<div class="paragraph"> </div>
</li>
<li> the logical connectives <span class="inlinecode">‚àß</span>, <span class="inlinecode">‚à®</span>, <span class="inlinecode">¬¨</span>, and <span class="inlinecode">‚Üí</span>,

</li>
</ul>
<div class="paragraph"> </div>

    then invoking <span class="inlinecode"><span class="id" title="tactic">omega</span></span> will either solve the goal or fail, meaning
    that the goal is actually false.  (If the goal is <i>not</i> of this
    form, <span class="inlinecode"><span class="id" title="tactic">omega</span></span> will also fail.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk5a" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk5a"><span class="highlight"><span class="kn">Example</span> <span class="nf">silly_presburger_example</span> : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">o</span> <span class="nv">p</span>,
  m + n &lt;= n + o /\ o + <span class="mi">3</span> = p + <span class="mi">3</span> -&gt;
  m &lt;= p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">o</span> <span class="nv">p</span> : nat,
m + n &lt;= n + o /\ o + <span class="mi">3</span> = p + <span class="mi">3</span> -&gt; m &lt;= p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk5b" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk5b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">o</span> <span class="nv">p</span> : nat,
m + n &lt;= n + o /\ o + <span class="mi">3</span> = p + <span class="mi">3</span> -&gt; m &lt;= p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk5c" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk5c"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n, o, p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m + n &lt;= n + o /\ o + <span class="mi">3</span> = p + <span class="mi">3</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m &lt;= p</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">omega</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
(Note the <span class="inlinecode"><span class="id" title="keyword">From</span></span> <span class="inlinecode"><span class="id" title="var">Coq</span></span> <span class="inlinecode"><span class="id" title="keyword">Require</span></span> <span class="inlinecode"><span class="id" title="keyword">Import</span></span> <span class="inlinecode"><span class="id" title="var">omega.Omega</span>.</span> at the top of
    the file.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab16"></a><h2 class="section">A Few More Handy Tactics</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Finally, here are some miscellaneous tactics that you may find
    convenient.

<div class="paragraph"> </div>
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="tactic">clear</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>: Delete hypothesis <span class="inlinecode"><span class="id" title="var">H</span></span> from the context.

<div class="paragraph"> </div>
</li>
<li> <span class="inlinecode"><span class="id" title="tactic">subst</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>: For a variable <span class="inlinecode"><span class="id" title="var">x</span></span>, find an assumption <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">e</span></span> or
       <span class="inlinecode"><span class="id" title="var">e</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span> in the context, replace <span class="inlinecode"><span class="id" title="var">x</span></span> with <span class="inlinecode"><span class="id" title="var">e</span></span> throughout the
       context and current goal, and clear the assumption.

<div class="paragraph"> </div>
</li>
<li> <span class="inlinecode"><span class="id" title="tactic">subst</span></span>: Substitute away <i>all</i> assumptions of the form <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">e</span></span>
       or <span class="inlinecode"><span class="id" title="var">e</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span> (where <span class="inlinecode"><span class="id" title="var">x</span></span> is a variable).

<div class="paragraph"> </div>
</li>
<li> <span class="inlinecode"><span class="id" title="tactic">rename</span>...</span> <span class="inlinecode"><span class="id" title="var">into</span>...</span>: Change the name of a hypothesis in the
       proof context.  For example, if the context includes a variable
       named <span class="inlinecode"><span class="id" title="var">x</span></span>, then <span class="inlinecode"><span class="id" title="tactic">rename</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">into</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> will change all occurrences
       of <span class="inlinecode"><span class="id" title="var">x</span></span> to <span class="inlinecode"><span class="id" title="var">y</span></span>.

<div class="paragraph"> </div>
</li>
<li> <span class="inlinecode"><span class="id" title="tactic">assumption</span></span>: Try to find a hypothesis <span class="inlinecode"><span class="id" title="var">H</span></span> in the context that
       exactly matches the goal; if one is found, behave like <span class="inlinecode"><span class="id" title="tactic">apply</span></span>
<span class="inlinecode"><span class="id" title="var">H</span></span>.

<div class="paragraph"> </div>
</li>
<li> <span class="inlinecode"><span class="id" title="var">contradiction</span></span>: Try to find a hypothesis <span class="inlinecode"><span class="id" title="var">H</span></span> in the current
       context that is logically equivalent to <span class="inlinecode"><span class="id" title="var">False</span></span>.  If one is
       found, solve the goal.

<div class="paragraph"> </div>
</li>
<li> <span class="inlinecode"><span class="id" title="tactic">constructor</span></span>: Try to find a constructor <span class="inlinecode"><span class="id" title="var">c</span></span> (from some
       <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> definition in the current environment) that can be
       applied to solve the current goal.  If one is found, behave
       like <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span>.

</li>
</ul>
<div class="paragraph"> </div>

    We'll see examples of all of these as we go along. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab17"></a><h1 class="section">Evaluation as a Relation</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We have presented <span class="inlinecode"><span class="id" title="var">aeval</span></span> and <span class="inlinecode"><span class="id" title="var">beval</span></span> as functions defined by
    <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>s.  Another way to think about evaluation -- one that we
    will see is often more flexible -- is as a <i>relation</i> between
    expressions and their values.  This leads naturally to <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>
    definitions like the following one for arithmetic expressions... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">aevalR_first_try</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">aevalR</span> : aexp -&gt; nat -&gt; <span class="kt">Prop</span> :=
  | E_ANum n :
      aevalR (ANum n) n
  | E_APlus (e1 e2: aexp) (n1 n2: nat) :
      aevalR e1 n1 -&gt;
      aevalR e2 n2 -&gt;
      aevalR (APlus e1 e2) (n1 + n2)
  | E_AMinus (e1 e2: aexp) (n1 n2: nat) :
      aevalR e1 n1 -&gt;
      aevalR e2 n2 -&gt;
      aevalR (AMinus e1 e2) (n1 - n2)
  | E_AMult (e1 e2: aexp) (n1 n2: nat) :
      aevalR e1 n1 -&gt;
      aevalR e2 n2 -&gt;
      aevalR (AMult e1 e2) (n1 * n2).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">TooHardToRead</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* A small notational aside. We would previously have written the</span>
<span class="c">   definition of [aevalR] like this, with explicit names for the</span>
<span class="c">   hypotheses in each case: *)</span>

</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">aevalR</span> : aexp -&gt; nat -&gt; <span class="kt">Prop</span> :=
  | E_ANum n :
      aevalR (ANum n) n
  | E_APlus (e1 e2: aexp) (n1 n2: nat)
      (H1 : aevalR e1 n1)
      (H2 : aevalR e2 n2) :
      aevalR (APlus e1 e2) (n1 + n2)
  | E_AMinus (e1 e2: aexp) (n1 n2: nat)
      (H1 : aevalR e1 n1)
      (H2 : aevalR e2 n2) :
      aevalR (AMinus e1 e2) (n1 - n2)
  | E_AMult (e1 e2: aexp) (n1 n2: nat)
      (H1 : aevalR e1 n1)
      (H2 : aevalR e2 n2) :
      aevalR (AMult e1 e2) (n1 * n2).</span></span></span></pre><div class="doc">
Instead, we've chosen to leave the hypotheses anonymous, just
    giving their types.  This style gives us less control over the
    names that Coq chooses during proofs involving <span class="inlinecode"><span class="id" title="var">aevalR</span></span>, but it
    makes the definition itself quite a bit lighter. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">TooHardToRead</span>.</span></span></span></pre><div class="doc">
It will be convenient to have an infix notation for
    <span class="inlinecode"><span class="id" title="var">aevalR</span></span>.  We'll write <span class="inlinecode"><span class="id" title="var">e</span></span> <span class="inlinecode">\\</span> <span class="inlinecode"><span class="id" title="var">n</span></span> to mean that arithmetic expression
    <span class="inlinecode"><span class="id" title="var">e</span></span> evaluates to value <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;e &#39;\\&#39; n&quot;</span>
         := (aevalR e n)
            (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">left associativity</span>)
         : type_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">aevalR_first_try</span>.</span></span></span></pre><div class="doc">
In fact, Coq provides a way to use this notation in the
    definition of <span class="inlinecode"><span class="id" title="var">aevalR</span></span> itself.  This reduces confusion by avoiding
    situations where we're working on a proof involving statements in
    the form <span class="inlinecode"><span class="id" title="var">e</span></span> <span class="inlinecode">\\</span> <span class="inlinecode"><span class="id" title="var">n</span></span> but we have to refer back to a definition
    written using the form <span class="inlinecode"><span class="id" title="var">aevalR</span></span> <span class="inlinecode"><span class="id" title="var">e</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    We do this by first "reserving" the notation, then giving the
    definition together with a declaration of what the notation
    means. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Reserved Notation</span> <span class="s2">&quot;e &#39;\\&#39; n&quot;</span> (<span class="kn">at level</span> <span class="mi">90</span>, <span class="kn">left associativity</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">aevalR</span> : aexp -&gt; nat -&gt; <span class="kt">Prop</span> :=
  | E_ANum (n : nat) :
      (ANum n) \\ n
  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :
      (e1 \\ n1) -&gt; (e2 \\ n2) -&gt; (APlus e1 e2) \\ (n1 + n2)
  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :
      (e1 \\ n1) -&gt; (e2 \\ n2) -&gt; (AMinus e1 e2) \\ (n1 - n2)
  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :
      (e1 \\ n1) -&gt; (e2 \\ n2) -&gt; (AMult e1 e2) \\ (n1 * n2)

  <span class="kn">where</span> <span class="s2">&quot;e &#39;\\&#39; n&quot;</span> := (aevalR e n) : type_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab18"></a><h2 class="section">Inference Rule Notation</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
In informal discussions, it is convenient to write the rules
    for <span class="inlinecode"><span class="id" title="var">aevalR</span></span> and similar relations in the more readable graphical
    form of <i>inference rules</i>, where the premises above the line
    justify the conclusion below the line (we have already seen them
    in the <span class="inlinecode"><span class="id" title="var">IndProp</span></span> chapter). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
For example, the constructor <span class="inlinecode"><span class="id" title="var">E_APlus</span></span>...

<div class="paragraph"> </div>

      | E_APlus : forall (e1 e2: aexp) (n1 n2: nat),
          aevalR e1 n1 -&gt;
          aevalR e2 n2 -&gt;
          aevalR (APlus e1 e2) (n1 + n2)

<div class="paragraph"> </div>

    ...would be written like this as an inference rule:

<div class="paragraph"> </div>

                               e1 \\ n1
                               e2 \\ n2
<hr/>
                (E_APlus)
                         APlus e1 e2 \\ n1+n2

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Formally, there is nothing deep about inference rules: they
    are just implications.  You can read the rule name on the right as
    the name of the constructor and read each of the linebreaks
    between the premises above the line (as well as the line itself)
    as <span class="inlinecode">‚Üí</span>.  All the variables mentioned in the rule (<span class="inlinecode"><span class="id" title="var">e1</span></span>, <span class="inlinecode"><span class="id" title="var">n1</span></span>,
    etc.) are implicitly bound by universal quantifiers at the
    beginning. (Such variables are often called <i>metavariables</i> to
    distinguish them from the variables of the language we are
    defining.  At the moment, our arithmetic expressions don't include
    variables, but we'll soon be adding them.)  The whole collection
    of rules is understood as being wrapped in an <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>
    declaration.  In informal prose, this is either elided or else
    indicated by saying something like "Let <span class="inlinecode"><span class="id" title="var">aevalR</span></span> be the smallest
    relation closed under the following rules...". 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
For example, <span class="inlinecode">\\</span> is the smallest relation closed under these
    rules:
<hr/>
                               (E_ANum)
                             ANum n \\ n

<div class="paragraph"> </div>

                               e1 \\ n1
                               e2 \\ n2
<hr/>
                         (E_APlus)
                         APlus e1 e2 \\ n1+n2

<div class="paragraph"> </div>

                               e1 \\ n1
                               e2 \\ n2
<hr/>
                        (E_AMinus)
                        AMinus e1 e2 \\ n1-n2

<div class="paragraph"> </div>

                               e1 \\ n1
                               e2 \\ n2
<hr/>
                         (E_AMult)
                         AMult e1 e2 \\ n1*n2

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab19"></a><h4 class="section">Exercise: 1 star, standard, optional (beval_rules)</h4>
<div class="paragraph"> </div>

    Here, again, is the Coq definition of the <span class="inlinecode"><span class="id" title="var">beval</span></span> function:

<div class="paragraph"> </div>

  Fixpoint beval (e : bexp) : bool :=
    match e with
    | BTrue       =&gt; true
    | BFalse      =&gt; false
    | BEq a1 a2   =&gt; (aeval a1) =? (aeval a2)
    | BLe a1 a2   =&gt; (aeval a1) &lt;=? (aeval a2)
    | BNot b1     =&gt; negb (beval b1)
    | BAnd b1 b2  =&gt; andb (beval b1) (beval b2)
    end.

<div class="paragraph"> </div>

    Write out a corresponding definition of boolean evaluation as a
    relation (in inference rule notation). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span>

<span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_beval_rules</span> : option (nat*string) := None.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab20"></a><h2 class="section">Equivalence of the Definitions</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
It is straightforward to prove that the relational and functional
    definitions of evaluation agree: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk5d" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk5d"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">aeval_iff_aevalR</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">n</span>,
  (a \\ n) &lt;-&gt; aeval a = n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : aexp) (<span class="nv">n</span> : nat), a \\ n &lt;-&gt; aeval a = n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk5e" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk5e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : aexp) (<span class="nv">n</span> : nat), a \\ n &lt;-&gt; aeval a = n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"> </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk5f" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk5f"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a \\ n -&gt; aeval a = n</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chk60" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk60"><hr></label><div class="goal-conclusion"><span class="highlight">aeval a = n -&gt; a \\ n</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"> </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk61" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk61"><span class="highlight">- <span class="c">(* -&gt; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a \\ n -&gt; aeval a = n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk62" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk62"><span class="highlight"><span class="nb">intros</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a = n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk63" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk63"><span class="highlight"><span class="nb">induction</span> H; <span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = n</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chk64" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e1 \\ n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e2 \\ n2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e1 = n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e2 = n2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk64"><hr></label><div class="goal-conclusion"><span class="highlight">aeval e1 + aeval e2 = n1 + n2</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chk65" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e1 \\ n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e2 \\ n2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e1 = n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e2 = n2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk65"><hr></label><div class="goal-conclusion"><span class="highlight">aeval e1 - aeval e2 = n1 - n2</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chk66" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e1 \\ n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e2 \\ n2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e1 = n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e2 = n2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk66"><hr></label><div class="goal-conclusion"><span class="highlight">aeval e1 * aeval e2 = n1 * n2</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk67" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk67"><span class="highlight">+ <span class="c">(* E_ANum *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk68" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk68"><span class="highlight">+ <span class="c">(* E_APlus *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e1 \\ n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e2 \\ n2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e1 = n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e2 = n2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval e1 + aeval e2 = n1 + n2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk69" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk69"><span class="highlight"><span class="nb">rewrite</span> IHaevalR1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e1 \\ n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e2 \\ n2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e1 = n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e2 = n2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n1 + aeval e2 = n1 + n2</span></div></blockquote></div></div></small><span class="coq-wsp">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk6a" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk6a"><span class="highlight"><span class="nb">rewrite</span> IHaevalR2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e1 \\ n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e2 \\ n2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e1 = n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e2 = n2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n1 + n2 = n1 + n2</span></div></blockquote></div></div></small><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk6b" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk6b"><span class="highlight">+ <span class="c">(* E_AMinus *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e1 \\ n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e2 \\ n2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e1 = n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e2 = n2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval e1 - aeval e2 = n1 - n2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk6c" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk6c"><span class="highlight"><span class="nb">rewrite</span> IHaevalR1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e1 \\ n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e2 \\ n2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e1 = n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e2 = n2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n1 - aeval e2 = n1 - n2</span></div></blockquote></div></div></small><span class="coq-wsp">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk6d" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk6d"><span class="highlight"><span class="nb">rewrite</span> IHaevalR2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e1 \\ n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e2 \\ n2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e1 = n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e2 = n2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n1 - n2 = n1 - n2</span></div></blockquote></div></div></small><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk6e" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk6e"><span class="highlight">+ <span class="c">(* E_AMult *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e1 \\ n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e2 \\ n2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e1 = n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e2 = n2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval e1 * aeval e2 = n1 * n2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk6f" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk6f"><span class="highlight"><span class="nb">rewrite</span> IHaevalR1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e1 \\ n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e2 \\ n2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e1 = n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e2 = n2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n1 * aeval e2 = n1 * n2</span></div></blockquote></div></div></small><span class="coq-wsp">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk70" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk70"><span class="highlight"><span class="nb">rewrite</span> IHaevalR2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">e1, e2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n1, n2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e1 \\ n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">e2 \\ n2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e1 = n1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHaevalR2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval e2 = n2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n1 * n2 = n1 * n2</span></div></blockquote></div></div></small><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"> </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk71" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk71"><span class="highlight">- <span class="c">(* &lt;- *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a = n -&gt; a \\ n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk72" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk72"><span class="highlight"><span class="nb">generalize dependent</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a = n -&gt; a \\ n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk73" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk73"><span class="highlight"><span class="nb">induction</span> a;
      <span class="nb">simpl</span>; <span class="nb">intros</span>; <span class="nb">subst</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ANum n0 \\ n0</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chk74" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk74"><hr></label><div class="goal-conclusion"><span class="highlight">APlus a1 a2 \\ aeval a1 + aeval a2</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chk75" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk75"><hr></label><div class="goal-conclusion"><span class="highlight">AMinus a1 a2 \\ aeval a1 - aeval a2</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chk76" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk76"><hr></label><div class="goal-conclusion"><span class="highlight">AMult a1 a2 \\ aeval a1 * aeval a2</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk77" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk77"><span class="highlight">+ <span class="c">(* ANum *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ANum n0 \\ n0</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> E_ANum.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk78" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk78"><span class="highlight">+ <span class="c">(* APlus *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">APlus a1 a2 \\ aeval a1 + aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk79" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk79"><span class="highlight"><span class="nb">apply</span> E_APlus.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a1 \\ aeval a1</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chk7a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk7a"><hr></label><div class="goal-conclusion"><span class="highlight">a2 \\ aeval a2</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk7b" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk7b"><span class="highlight"><span class="nb">apply</span> IHa1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a1 = aeval a1</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chk7c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk7c"><hr></label><div class="goal-conclusion"><span class="highlight">a2 \\ aeval a2</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk7d" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk7d"><span class="highlight"><span class="bp">reflexivity</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a2 \\ aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk7e" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk7e"><span class="highlight"><span class="nb">apply</span> IHa2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a2 = aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk7f" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk7f"><span class="highlight">+ <span class="c">(* AMinus *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">AMinus a1 a2 \\ aeval a1 - aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk80" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk80"><span class="highlight"><span class="nb">apply</span> E_AMinus.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a1 \\ aeval a1</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chk81" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk81"><hr></label><div class="goal-conclusion"><span class="highlight">a2 \\ aeval a2</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk82" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk82"><span class="highlight"><span class="nb">apply</span> IHa1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a1 = aeval a1</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chk83" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk83"><hr></label><div class="goal-conclusion"><span class="highlight">a2 \\ aeval a2</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk84" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk84"><span class="highlight"><span class="bp">reflexivity</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a2 \\ aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk85" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk85"><span class="highlight"><span class="nb">apply</span> IHa2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a2 = aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk86" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk86"><span class="highlight">+ <span class="c">(* AMult *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">AMult a1 a2 \\ aeval a1 * aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk87" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk87"><span class="highlight"><span class="nb">apply</span> E_AMult.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a1 \\ aeval a1</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chk88" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk88"><hr></label><div class="goal-conclusion"><span class="highlight">a2 \\ aeval a2</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk89" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk89"><span class="highlight"><span class="nb">apply</span> IHa1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a1 = aeval a1</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chk8a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk8a"><hr></label><div class="goal-conclusion"><span class="highlight">a2 \\ aeval a2</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk8b" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk8b"><span class="highlight"><span class="bp">reflexivity</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a2 \\ aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk8c" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk8c"><span class="highlight"><span class="nb">apply</span> IHa2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a1 = n -&gt; a1 \\ n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHa2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a2 = n -&gt; a2 \\ n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a2 = aeval a2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
We can make the proof quite a bit shorter by making more
    use of tacticals. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk8d" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk8d"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">aeval_iff_aevalR&#39;</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">n</span>,
  (a \\ n) &lt;-&gt; aeval a = n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : aexp) (<span class="nv">n</span> : nat), a \\ n &lt;-&gt; aeval a = n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk8e" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk8e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : aexp) (<span class="nv">n</span> : nat), a \\ n &lt;-&gt; aeval a = n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk8f" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk8f"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a \\ n -&gt; aeval a = n</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chk90" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chk90"><hr></label><div class="goal-conclusion"><span class="highlight">aeval a = n -&gt; a \\ n</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk91" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk91"><span class="highlight">- <span class="c">(* -&gt; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a \\ n -&gt; aeval a = n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span> H; <span class="nb">induction</span> H; <span class="nb">subst</span>; <span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk92" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk92"><span class="highlight">- <span class="c">(* &lt;- *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval a = n -&gt; a \\ n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk93" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk93"><span class="highlight"><span class="nb">generalize dependent</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, aeval a = n -&gt; a \\ n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">induction</span> a; <span class="nb">simpl</span>; <span class="nb">intros</span>; <span class="nb">subst</span>; <span class="nb">constructor</span>;
       <span class="kp">try</span> <span class="nb">apply</span> IHa1; <span class="kp">try</span> <span class="nb">apply</span> IHa2; <span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab21"></a><h4 class="section">Exercise: 3 stars, standard (bevalR)</h4>
<div class="paragraph"> </div>

    Write a relation <span class="inlinecode"><span class="id" title="var">bevalR</span></span> in the same style as
    <span class="inlinecode"><span class="id" title="var">aevalR</span></span>, and prove that it is equivalent to <span class="inlinecode"><span class="id" title="var">beval</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">bevalR</span>: bexp -&gt; bool -&gt; <span class="kt">Prop</span> :=
<span class="c">(* FILL IN HERE *)</span>
.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk94" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk94"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">beval_iff_bevalR</span> : <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">bv</span>,
  bevalR b bv &lt;-&gt; beval b = bv.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">b</span> : bexp) (<span class="nv">bv</span> : bool),
bevalR b bv &lt;-&gt; beval b = bv</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk95" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk95"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">b</span> : bexp) (<span class="nv">bv</span> : bool),
bevalR b bv &lt;-&gt; beval b = bv</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">AExp</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab22"></a><h2 class="section">Computational vs. Relational Definitions</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
For the definitions of evaluation for arithmetic and boolean
    expressions, the choice of whether to use functional or relational
    definitions is mainly a matter of taste: either way works.

<div class="paragraph"> </div>

    However, there are circumstances where relational definitions of
    evaluation work much better than functional ones.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">aevalR_division</span>.</span></span></span></pre><div class="doc">
For example, suppose that we wanted to extend the arithmetic
    operations with division: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">aexp</span> : <span class="kt">Type</span> :=
  | ANum (n : nat)
  | APlus (a1 a2 : aexp)
  | AMinus (a1 a2 : aexp)
  | AMult (a1 a2 : aexp)
  | ADiv (a1 a2 : aexp).         <span class="c">(* &lt;--- NEW *)</span></span></span></span></pre><div class="doc">
Extending the definition of <span class="inlinecode"><span class="id" title="var">aeval</span></span> to handle this new operation
    would not be straightforward (what should we return as the result
    of <span class="inlinecode"><span class="id" title="var">ADiv</span></span> <span class="inlinecode">(<span class="id" title="var">ANum</span></span> <span class="inlinecode">5)</span> <span class="inlinecode">(<span class="id" title="var">ANum</span></span> <span class="inlinecode">0)</span>?).  But extending <span class="inlinecode"><span class="id" title="var">aevalR</span></span> is
    straightforward. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Reserved Notation</span> <span class="s2">&quot;e &#39;\\&#39; n&quot;</span>
                  (<span class="kn">at level</span> <span class="mi">90</span>, <span class="kn">left associativity</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">aevalR</span> : aexp -&gt; nat -&gt; <span class="kt">Prop</span> :=
  | E_ANum (n : nat) :
      (ANum n) \\ n
  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :
      (a1 \\ n1) -&gt; (a2 \\ n2) -&gt; (APlus a1 a2) \\ (n1 + n2)
  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :
      (a1 \\ n1) -&gt; (a2 \\ n2) -&gt; (AMinus a1 a2) \\ (n1 - n2)
  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :
      (a1 \\ n1) -&gt; (a2 \\ n2) -&gt; (AMult a1 a2) \\ (n1 * n2)
  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :
      (a1 \\ n1) -&gt; (a2 \\ n2) -&gt; (n2 &gt; <span class="mi">0</span>) -&gt;
      (mult n2 n3 = n1) -&gt; (ADiv a1 a2) \\ n3

<span class="kn">where</span> <span class="s2">&quot;a &#39;\\&#39; n&quot;</span> := (aevalR a n) : type_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">aevalR_division</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">aevalR_extended</span>.</span></span></span></pre><div class="doc">
Or suppose that we want to extend the arithmetic operations by a
    nondeterministic number generator <span class="inlinecode"><span class="id" title="var">any</span></span> that, when evaluated, may
    yield any number.  (Note that this is not the same as making a
    <i>probabilistic</i> choice among all possible numbers -- we're not
    specifying any particular probability distribution for the
    results, just saying what results are <i>possible</i>.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Reserved Notation</span> <span class="s2">&quot;e &#39;\\&#39; n&quot;</span> (<span class="kn">at level</span> <span class="mi">90</span>, <span class="kn">left associativity</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">aexp</span> : <span class="kt">Type</span> :=
  | AAny                           <span class="c">(* &lt;--- NEW *)</span>
  | ANum (n : nat)
  | APlus (a1 a2 : aexp)
  | AMinus (a1 a2 : aexp)
  | AMult (a1 a2 : aexp).</span></span></span></pre><div class="doc">
Again, extending <span class="inlinecode"><span class="id" title="var">aeval</span></span> would be tricky, since now evaluation is
    <i>not</i> a deterministic function from expressions to numbers, but
    extending <span class="inlinecode"><span class="id" title="var">aevalR</span></span> is no problem... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">aevalR</span> : aexp -&gt; nat -&gt; <span class="kt">Prop</span> :=
  | E_Any (n : nat) :
      AAny \\ n                        <span class="c">(* &lt;--- NEW *)</span>
  | E_ANum (n : nat) :
      (ANum n) \\ n
  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :
      (a1 \\ n1) -&gt; (a2 \\ n2) -&gt; (APlus a1 a2) \\ (n1 + n2)
  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :
      (a1 \\ n1) -&gt; (a2 \\ n2) -&gt; (AMinus a1 a2) \\ (n1 - n2)
  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :
      (a1 \\ n1) -&gt; (a2 \\ n2) -&gt; (AMult a1 a2) \\ (n1 * n2)

<span class="kn">where</span> <span class="s2">&quot;a &#39;\\&#39; n&quot;</span> := (aevalR a n) : type_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">aevalR_extended</span>.</span></span></span></pre><div class="doc">
At this point you maybe wondering: which style should I use by
    default?  In the examples we've just seen, relational definitions
    turned out to be more useful than functional ones.  For situations
    like these, where the thing being defined is not easy to express
    as a function, or indeed where it is <i>not</i> a function, there is no
    real choice.  But what about when both styles are workable?

<div class="paragraph"> </div>

    One point in favor of relational definitions is that they can be
    more elegant and easier to understand.

<div class="paragraph"> </div>

    Another is that Coq automatically generates nice inversion and
    induction principles from <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> definitions. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
On the other hand, functional definitions can often be more
    convenient:
<ul class="doclist">
<li> Functions are by definition deterministic and defined on all
       arguments; for a relation we have to show these properties
       explicitly if we need them.

</li>
<li> With functions we can also take advantage of Coq's computation
       mechanism to simplify expressions during proofs.

</li>
</ul>
<div class="paragraph"> </div>

    Furthermore, functions can be directly "extracted" from Gallina to
    executable code in OCaml or Haskell. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Ultimately, the choice often comes down to either the specifics of
    a particular situation or simply a question of taste.  Indeed, in
    large Coq developments it is common to see a definition given in
    <i>both</i> functional and relational styles, plus a lemma stating that
    the two coincide, allowing further proofs to switch from one point
    of view to the other at will. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab23"></a><h1 class="section">Expressions With Variables</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Back to defining Imp.  The next thing we need to do is to enrich
    our arithmetic and boolean expressions with variables.  To keep
    things simple, we'll assume that all variables are global and that
    they only hold numbers. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab24"></a><h2 class="section">States</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Since we'll want to look variables up to find out their current
    values, we'll reuse maps from the <span class="inlinecode"><span class="id" title="var">Maps</span></span> chapter, and 
    <span class="inlinecode"><span class="id" title="var">string</span></span>s will be used to represent variables in Imp.

<div class="paragraph"> </div>

    A <i>machine state</i> (or just <i>state</i>) represents the current values
    of <i>all</i> variables at some point in the execution of a program. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
For simplicity, we assume that the state is defined for
    <i>all</i> variables, even though any given program is only going to
    mention a finite number of them.  The state captures all of the
    information stored in memory.  For Imp programs, because each
    variable stores a natural number, we can represent the state as a
    mapping from strings to <span class="inlinecode"><span class="id" title="var">nat</span></span>, and will use <span class="inlinecode">0</span> as default value
    in the store. For more complex programming languages, the state
    might have more structure. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">state</span> := total_map nat.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab25"></a><h2 class="section">Syntax</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We can add variables to the arithmetic expressions we had before by
    simply adding one more constructor: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">aexp</span> : <span class="kt">Type</span> :=
  | ANum (n : nat)
  | AId (x : string)              <span class="c">(* &lt;--- NEW *)</span>
  | APlus (a1 a2 : aexp)
  | AMinus (a1 a2 : aexp)
  | AMult (a1 a2 : aexp).</span></span></span></pre><div class="doc">
Defining a few variable names as notational shorthands will make
    examples easier to read: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">W</span> : string := <span class="s2">&quot;W&quot;</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">X</span> : string := <span class="s2">&quot;X&quot;</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Y</span> : string := <span class="s2">&quot;Y&quot;</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Z</span> : string := <span class="s2">&quot;Z&quot;</span>.</span></span></span></pre><div class="doc">
(This convention for naming program variables (<span class="inlinecode"><span class="id" title="var">X</span></span>, <span class="inlinecode"><span class="id" title="var">Y</span></span>,
    <span class="inlinecode"><span class="id" title="var">Z</span></span>) clashes a bit with our earlier use of uppercase letters for
    types.  Since we're not using polymorphism heavily in the chapters
    developed to Imp, this overloading should not cause confusion.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The definition of <span class="inlinecode"><span class="id" title="var">bexp</span></span>s is unchanged (except that it now refers
    to the new <span class="inlinecode"><span class="id" title="var">aexp</span></span>s): 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">bexp</span> : <span class="kt">Type</span> :=
  | BTrue
  | BFalse
  | BEq (a1 a2 : aexp)
  | BLe (a1 a2 : aexp)
  | BNot (b : bexp)
  | BAnd (b1 b2 : bexp).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab26"></a><h2 class="section">Notations</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
To make Imp programs easier to read and write, we introduce some
    notations and implicit coercions.

<div class="paragraph"> </div>

    You do not need to understand exactly what these declarations do.
    Briefly, though, the <span class="inlinecode"><span class="id" title="keyword">Coercion</span></span> declaration in Coq stipulates that
    a function (or constructor) can be implicitly used by the type
    system to coerce a value of the input type to a value of the
    output type.  For instance, the coercion declaration for <span class="inlinecode"><span class="id" title="var">AId</span></span>
    allows us to use plain strings when an <span class="inlinecode"><span class="id" title="var">aexp</span></span> is expected; the
    string will implicitly be wrapped with <span class="inlinecode"><span class="id" title="var">AId</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The notations below are declared in specific <i>notation scopes</i>, in
    order to avoid conflicts with other interpretations of the same
    symbols.  Again, it is not necessary to understand the details,
    but it is important to recognize that we are defining <i>new</i>
    intepretations for some familiar operators like <span class="inlinecode">+</span>, <span class="inlinecode">-</span>, <span class="inlinecode">√ó</span>,
    <span class="inlinecode">=.,</span> <span class="inlinecode">[&lt;=],</span> <span class="inlinecode"><span class="id" title="var">etc</span>.</span> <span class="inlinecode"></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Coercion</span> <span class="nf">AId</span> : string &gt;-&gt; aexp.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Coercion</span> <span class="nf">ANum</span> : nat &gt;-&gt; aexp.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">bool_to_bexp</span> (<span class="nv">b</span> : bool) : bexp :=
  <span class="kr">if</span> b <span class="kr">then</span> BTrue <span class="kr">else</span> BFalse.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Coercion</span> <span class="nf">bool_to_bexp</span> : bool &gt;-&gt; bexp.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk96" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk96"><span class="highlight"><span class="kn">Bind Scope</span> imp_scope <span class="kr">with</span> aexp.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">Declaring a scope implicitly <span class="kr">is</span> deprecated; use <span class="kr">in</span>
advance an explicit <span class="s2">&quot;Declare Scope imp_scope.&quot;</span>.
[undeclared-scope,deprecated]</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Bind Scope</span> imp_scope <span class="kr">with</span> bexp.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Delimit Scope</span> imp_scope <span class="kr">with</span> imp.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x + y&quot;</span> := (APlus x y) (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">left associativity</span>) : imp_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x - y&quot;</span> := (AMinus x y) (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">left associativity</span>) : imp_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x * y&quot;</span> := (AMult x y) (<span class="kn">at level</span> <span class="mi">40</span>, <span class="kn">left associativity</span>) : imp_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &lt;= y&quot;</span> := (BLe x y) (<span class="kn">at level</span> <span class="mi">70</span>, <span class="kn">no associativity</span>) : imp_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x = y&quot;</span> := (BEq x y) (<span class="kn">at level</span> <span class="mi">70</span>, <span class="kn">no associativity</span>) : imp_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &amp;&amp; y&quot;</span> := (BAnd x y) (<span class="kn">at level</span> <span class="mi">40</span>, <span class="kn">left associativity</span>) : imp_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&#39;~&#39; b&quot;</span> := (BNot b) (<span class="kn">at level</span> <span class="mi">75</span>, <span class="kn">right associativity</span>) : imp_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">example_aexp</span> := (<span class="mi">3</span> + (X * <span class="mi">2</span>))%imp : aexp.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">example_bexp</span> := (true &amp;&amp; ~(X &lt;= <span class="mi">4</span>))%imp : bexp.</span></span></span></pre><div class="doc">
One downside of these coercions is that they can make it a little
    harder for humans to calculate the types of expressions.  If you
    get confused, try doing <span class="inlinecode"><span class="id" title="keyword">Set</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="var">Coercions</span></span> to see exactly
    what is going on. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Set Printing Coercions</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Imp-v-chk97" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk97"><span class="highlight"><span class="kn">Print</span> example_bexp.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">example_bexp = 
(bool_to_bexp true &amp;&amp; (~ AId X &lt;= ANum <span class="mi">4</span>))%imp
     : bexp</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Unset Printing Coercions</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab27"></a><h2 class="section">Evaluation</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The arith and boolean evaluators are extended to handle
    variables in the obvious way, taking a state as an extra
    argument: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">aeval</span> (<span class="nv">st</span> : state) (<span class="nv">a</span> : aexp) : nat :=
  <span class="kr">match</span> a <span class="kr">with</span>
  | ANum n =&gt; n
  | AId x =&gt; st x                                <span class="c">(* &lt;--- NEW *)</span>
  | APlus a1 a2 =&gt; (aeval st a1) + (aeval st a2)
  | AMinus a1 a2  =&gt; (aeval st a1) - (aeval st a2)
  | AMult a1 a2 =&gt; (aeval st a1) * (aeval st a2)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">beval</span> (<span class="nv">st</span> : state) (<span class="nv">b</span> : bexp) : bool :=
  <span class="kr">match</span> b <span class="kr">with</span>
  | BTrue       =&gt; true
  | BFalse      =&gt; false
  | BEq a1 a2   =&gt; (aeval st a1) =? (aeval st a2)
  | BLe a1 a2   =&gt; (aeval st a1) &lt;=? (aeval st a2)
  | BNot b1     =&gt; negb (beval st b1)
  | BAnd b1 b2  =&gt; andb (beval st b1) (beval st b2)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
We specialize our notation for total maps to the specific case of
    states, i.e. using <span class="inlinecode">(<span class="id" title="var">_</span></span> <span class="inlinecode">!-&gt;</span> <span class="inlinecode">0)</span> as empty state. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">empty_st</span> := (_ !-&gt; <span class="mi">0</span>).</span></span></span></pre><div class="doc">
Now we can add a notation for a "singleton state" with just one
    variable bound to a value. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;a &#39;!-&gt;&#39; x&quot;</span> := (t_update empty_st a x) (<span class="kn">at level</span> <span class="mi">100</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk98" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk98"><span class="highlight"><span class="kn">Example</span> <span class="nf">aexp1</span> :
    aeval (X !-&gt; <span class="mi">5</span>) (<span class="mi">3</span> + (X * <span class="mi">2</span>))%imp
  = <span class="mi">13</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (X !-&gt; <span class="mi">5</span>) (<span class="mi">3</span> + X * <span class="mi">2</span>) = <span class="mi">13</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk99" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk99"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (X !-&gt; <span class="mi">5</span>) (<span class="mi">3</span> + X * <span class="mi">2</span>) = <span class="mi">13</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk9a" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk9a"><span class="highlight"><span class="kn">Example</span> <span class="nf">bexp1</span> :
    beval (X !-&gt; <span class="mi">5</span>) (true &amp;&amp; ~(X &lt;= <span class="mi">4</span>))%imp
  = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">beval (X !-&gt; <span class="mi">5</span>) (true &amp;&amp; (~ X &lt;= <span class="mi">4</span>)) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chk9b" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk9b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">beval (X !-&gt; <span class="mi">5</span>) (true &amp;&amp; (~ X &lt;= <span class="mi">4</span>)) = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab28"></a><h1 class="section">Commands</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Now we are ready define the syntax and behavior of Imp
    <i>commands</i> (sometimes called <i>statements</i>). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab29"></a><h2 class="section">Syntax</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Informally, commands <span class="inlinecode"><span class="id" title="var">c</span></span> are described by the following BNF
    grammar.

<div class="paragraph"> </div>

     c ::= SKIP | x ::= a | c ;; c | TEST b THEN c ELSE c FI
         | WHILE b DO c END

<div class="paragraph"> </div>

    (We choose this slightly awkward concrete syntax for the
    sake of being able to define Imp syntax using Coq's notation
    mechanism.  In particular, we use <span class="inlinecode"><span class="id" title="var">TEST</span></span> to avoid conflicting with
    the <span class="inlinecode"><span class="id" title="keyword">if</span></span> and <span class="inlinecode"><span class="id" title="var">IF</span></span> notations from the standard library.) 
    For example, here's factorial in Imp:

<div class="paragraph"> </div>

     Z ::= X;;
     Y ::= 1;;
     WHILE ~(Z = 0) DO
       Y ::= Y * Z;;
       Z ::= Z - 1
     END

<div class="paragraph"> </div>

   When this command terminates, the variable <span class="inlinecode"><span class="id" title="var">Y</span></span> will contain the
   factorial of the initial value of <span class="inlinecode"><span class="id" title="var">X</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Here is the formal definition of the abstract syntax of
    commands: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">com</span> : <span class="kt">Type</span> :=
  | CSkip
  | CAss (x : string) (a : aexp)
  | CSeq (c1 c2 : com)
  | CIf (b : bexp) (c1 c2 : com)
  | CWhile (b : bexp) (c : com).</span></span></span></pre><div class="doc">
As for expressions, we can use a few <span class="inlinecode"><span class="id" title="keyword">Notation</span></span> declarations to
    make reading and writing Imp programs more convenient. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Bind Scope</span> imp_scope <span class="kr">with</span> com.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&#39;SKIP&#39;&quot;</span> :=
   CSkip : imp_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &#39;::=&#39; a&quot;</span> :=
  (CAss x a) (<span class="kn">at level</span> <span class="mi">60</span>) : imp_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;c1 ;; c2&quot;</span> :=
  (CSeq c1 c2) (<span class="kn">at level</span> <span class="mi">80</span>, <span class="kn">right associativity</span>) : imp_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&#39;WHILE&#39; b &#39;DO&#39; c &#39;END&#39;&quot;</span> :=
  (CWhile b c) (<span class="kn">at level</span> <span class="mi">80</span>, <span class="kn">right associativity</span>) : imp_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&#39;TEST&#39; c1 &#39;THEN&#39; c2 &#39;ELSE&#39; c3 &#39;FI&#39;&quot;</span> :=
  (CIf c1 c2 c3) (<span class="kn">at level</span> <span class="mi">80</span>, <span class="kn">right associativity</span>) : imp_scope.</span></span></span></pre><div class="doc">
For example, here is the factorial function again, written as a
    formal definition to Coq: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">fact_in_coq</span> : com :=
  (Z ::= X;;
  Y ::= <span class="mi">1</span>;;
  WHILE ~(Z = <span class="mi">0</span>) DO
    Y ::= Y * Z;;
    Z ::= Z - <span class="mi">1</span>
  END)%imp.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab30"></a><h2 class="section">Desugaring notations</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Coq offers a rich set of features to manage the increasing
    complexity of the objects we work with, such as coercions
    and notations. However, their heavy usage can make for quite
    overwhelming syntax. It is often instructive to "turn off"
    those features to get a more elementary picture of things,
    using the following commands:

<div class="paragraph"> </div>
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="keyword">Unset</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="var">Notations</span></span> (undo with <span class="inlinecode"><span class="id" title="keyword">Set</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="var">Notations</span></span>)

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">Set</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="var">Coercions</span></span> (undo with <span class="inlinecode"><span class="id" title="keyword">Unset</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="var">Coercions</span></span>)

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">Set</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="keyword">All</span></span> (undo with <span class="inlinecode"><span class="id" title="keyword">Unset</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="keyword">All</span></span>)

</li>
</ul>
<div class="paragraph"> </div>

    These commands can also be used in the middle of a proof,
    to elaborate the current goal and context.
 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Unset Printing Notations</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Imp-v-chk9c" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk9c"><span class="highlight"><span class="kn">Print</span> fact_in_coq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">fact_in_coq = 
CSeq (CAss Z X)
  (CSeq (CAss Y (S O))
     (CWhile (BNot (BEq Z O))
        (CSeq (CAss Y (AMult Y Z))
           (CAss Z (AMinus Z (S O))))))
     : com</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Set Printing Notations</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Set Printing Coercions</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Imp-v-chk9d" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk9d"><span class="highlight"><span class="kn">Print</span> fact_in_coq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">fact_in_coq = 
(Z ::= AId X;;
 Y ::= ANum <span class="mi">1</span>;;
 WHILE ~ AId Z = ANum <span class="mi">0</span>
 DO Y ::= AId Y * AId Z;; Z ::= AId Z - ANum <span class="mi">1</span> END)%imp
     : com</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Unset Printing Coercions</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab31"></a><h2 class="section">The <span class="inlinecode"><span class="id" title="keyword">Locate</span></span> command</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab32"></a><h3 class="section">Finding notations</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
When faced with unknown notation, use <span class="inlinecode"><span class="id" title="keyword">Locate</span></span> with a <i>string</i>
    containing one of its symbols to see its possible
    interpretations. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Imp-v-chk9e" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk9e"><span class="highlight"><span class="kn">Locate</span> <span class="s2">&quot;&amp;&amp;&quot;</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight"><span class="kn">Notation</span>
<span class="s2">&quot;x &amp;&amp; y&quot;</span> := andb x y : bool_scope
(default interpretation)
<span class="s2">&quot;x &amp;&amp; y&quot;</span> := BAnd x y : imp_scope</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Imp-v-chk9f" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chk9f"><span class="highlight"><span class="kn">Locate</span> <span class="s2">&quot;;;&quot;</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight"><span class="kn">Notation</span>
<span class="s2">&quot;c1 ;; c2&quot;</span> := CSeq c1 c2 : imp_scope</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Imp-v-chka0" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chka0"><span class="highlight"><span class="kn">Locate</span> <span class="s2">&quot;WHILE&quot;</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight"><span class="kn">Notation</span>
<span class="s2">&quot;&#39;WHILE&#39; b &#39;DO&#39; c &#39;END&#39;&quot;</span> := CWhile b c : imp_scope
<span class="s2">&quot;&#39;_&#39; &#39;!-&gt;&#39; v&quot;</span> := t_empty v (default interpretation)</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab33"></a><h3 class="section">Finding identifiers</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
When used with an identifier, the command <span class="inlinecode"><span class="id" title="keyword">Locate</span></span> prints
    the full path to every value in scope with the same name.
    This is useful to troubleshoot problems due to variable
    shadowing. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Imp-v-chka1" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chka1"><span class="highlight"><span class="kn">Locate</span> aexp.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">SerTop</span>.aexp
<span class="kn">Inductive</span> <span class="nf">SerTop</span>.AExp.aexp
  (shorter name to refer to it <span class="kr">in</span> current <span class="kp">context</span> <span class="kr">is</span> AExp.aexp)
<span class="kn">Inductive</span> <span class="nf">SerTop</span>.aevalR_division.aexp
  (shorter name to refer to it <span class="kr">in</span> current <span class="kp">context</span> <span class="kr">is</span> aevalR_division.aexp)
<span class="kn">Inductive</span> <span class="nf">SerTop</span>.aevalR_extended.aexp
  (shorter name to refer to it <span class="kr">in</span> current <span class="kp">context</span> <span class="kr">is</span> aevalR_extended.aexp)</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab34"></a><h2 class="section">More Examples</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Assignment: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">plus2</span> : com :=
  X ::= X + <span class="mi">2</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">XtimesYinZ</span> : com :=
  Z ::= X * Y.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">subtract_slowly_body</span> : com :=
  Z ::= Z - <span class="mi">1</span> ;;
  X ::= X - <span class="mi">1</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab35"></a><h3 class="section">Loops</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">subtract_slowly</span> : com :=
  (WHILE ~(X = <span class="mi">0</span>) DO
    subtract_slowly_body
  END)%imp.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">subtract_3_from_5_slowly</span> : com :=
  X ::= <span class="mi">3</span> ;;
  Z ::= <span class="mi">5</span> ;;
  subtract_slowly.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab36"></a><h3 class="section">An infinite loop:</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">loop</span> : com :=
  WHILE true DO
    SKIP
  END.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab37"></a><h1 class="section">Evaluating Commands</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Next we need to define what it means to evaluate an Imp command.
    The fact that <span class="inlinecode"><span class="id" title="var">WHILE</span></span> loops don't necessarily terminate makes
    defining an evaluation function tricky... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab38"></a><h2 class="section">Evaluation as a Function (Failed Attempt)</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Here's an attempt at defining an evaluation function for commands,
    omitting the <span class="inlinecode"><span class="id" title="var">WHILE</span></span> case. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The following declaration is needed to be able to use the
    notations in match patterns. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Open Scope</span> imp_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">ceval_fun_no_while</span> (<span class="nv">st</span> : state) (<span class="nv">c</span> : com)
                          : state :=
  <span class="kr">match</span> c <span class="kr">with</span>
    | SKIP =&gt;
        st
    | x ::= a1 =&gt;
        (x !-&gt; (aeval st a1) ; st)
    | c1 ;; c2 =&gt;
        <span class="kr">let</span> <span class="nv">st&#39;</span> := ceval_fun_no_while st c1 <span class="kr">in</span>
        ceval_fun_no_while st&#39; c2
    | TEST b THEN c1 ELSE c2 FI =&gt;
        <span class="kr">if</span> (beval st b)
          <span class="kr">then</span> ceval_fun_no_while st c1
          <span class="kr">else</span> ceval_fun_no_while st c2
    | WHILE b DO c END =&gt;
        st  <span class="c">(* bogus *)</span>
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Close Scope</span> imp_scope.</span></span></span></pre><div class="doc">
In a traditional functional programming language like OCaml or
    Haskell we could add the <span class="inlinecode"><span class="id" title="var">WHILE</span></span> case as follows:

<div class="paragraph"> </div>

        Fixpoint ceval_fun (st : state) (c : com) : state :=
          match c with
            ...
            | WHILE b DO c END =&gt;
                if (beval st b)
                  then ceval_fun st (c ;; WHILE b DO c END)
                  else st
          end.

<div class="paragraph"> </div>

    Coq doesn't accept such a definition ("Error: Cannot guess
    decreasing argument of fix") because the function we want to
    define is not guaranteed to terminate. Indeed, it <i>doesn't</i> always
    terminate: for example, the full version of the <span class="inlinecode"><span class="id" title="var">ceval_fun</span></span>
    function applied to the <span class="inlinecode"><span class="id" title="var">loop</span></span> program above would never
    terminate. Since Coq is not just a functional programming
    language but also a consistent logic, any potentially
    non-terminating function needs to be rejected. Here is
    an (invalid!) program showing what would go wrong if Coq
    allowed non-terminating recursive functions:

<div class="paragraph"> </div>

         Fixpoint loop_false (n : nat) : False := loop_false n.

<div class="paragraph"> </div>

    That is, propositions like <span class="inlinecode"><span class="id" title="var">False</span></span> would become provable
    (<span class="inlinecode"><span class="id" title="var">loop_false</span></span> <span class="inlinecode">0</span> would be a proof of <span class="inlinecode"><span class="id" title="var">False</span></span>), which
    would be a disaster for Coq's logical consistency.

<div class="paragraph"> </div>

    Thus, because it doesn't terminate on all inputs,
    of <span class="inlinecode"><span class="id" title="var">ceval_fun</span></span> cannot be written in Coq -- at least not without
    additional tricks and workarounds (see chapter <span class="inlinecode"><span class="id" title="var">ImpCEvalFun</span></span>
    if you're curious about what those might be). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab39"></a><h2 class="section">Evaluation as a Relation</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Here's a better way: define <span class="inlinecode"><span class="id" title="var">ceval</span></span> as a <i>relation</i> rather than a
    <i>function</i> -- i.e., define it in <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> instead of <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, as we
    did for <span class="inlinecode"><span class="id" title="var">aevalR</span></span> above. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
This is an important change.  Besides freeing us from awkward
    workarounds, it gives us a lot more flexibility in the definition.
    For example, if we add nondeterministic features like <span class="inlinecode"><span class="id" title="var">any</span></span> to the
    language, we want the definition of evaluation to be
    nondeterministic -- i.e., not only will it not be total, it will
    not even be a function! 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We'll use the notation <span class="inlinecode"><span class="id" title="var">st</span></span> <span class="inlinecode">=[</span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">]=&gt;</span> <span class="inlinecode"><span class="id" title="var">st'</span></span> for the <span class="inlinecode"><span class="id" title="var">ceval</span></span> relation:
    <span class="inlinecode"><span class="id" title="var">st</span></span> <span class="inlinecode">=[</span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">]=&gt;</span> <span class="inlinecode"><span class="id" title="var">st'</span></span> means that executing program <span class="inlinecode"><span class="id" title="var">c</span></span> in a starting
    state <span class="inlinecode"><span class="id" title="var">st</span></span> results in an ending state <span class="inlinecode"><span class="id" title="var">st'</span></span>.  This can be
    pronounced "<span class="inlinecode"><span class="id" title="var">c</span></span> takes state <span class="inlinecode"><span class="id" title="var">st</span></span> to <span class="inlinecode"><span class="id" title="var">st'</span></span>". 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab40"></a><h3 class="section">Operational Semantics</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Here is an informal definition of evaluation, presented as inference
    rules for readability:
<hr/>
                            (E_Skip)
                           st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">SKIP</span></span> <span class="inlinecode"></span>=&gt; st

<div class="paragraph"> </div>

                           aeval st a1 = n
<hr/>
                     (E_Ass)
                   st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">a1</span></span> <span class="inlinecode"></span>=&gt; (x !-&gt; n ; st)

<div class="paragraph"> </div>

                           st  =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">c1</span></span> <span class="inlinecode"></span>=&gt; st'
                           st' =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">c2</span></span> <span class="inlinecode"></span>=&gt; st''
<hr/>
                            (E_Seq)
                         st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">c1</span>;;<span class="id" title="var">c2</span></span> <span class="inlinecode"></span>=&gt; st''

<div class="paragraph"> </div>

                          beval st b1 = true
                           st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">c1</span></span> <span class="inlinecode"></span>=&gt; st'
<hr/>
                (E_IfTrue)
                st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">TEST</span></span> <span class="inlinecode"><span class="id" title="var">b1</span></span> <span class="inlinecode"><span class="id" title="var">THEN</span></span> <span class="inlinecode"><span class="id" title="var">c1</span></span> <span class="inlinecode"><span class="id" title="var">ELSE</span></span> <span class="inlinecode"><span class="id" title="var">c2</span></span> <span class="inlinecode"><span class="id" title="var">FI</span></span> <span class="inlinecode"></span>=&gt; st'

<div class="paragraph"> </div>

                         beval st b1 = false
                           st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">c2</span></span> <span class="inlinecode"></span>=&gt; st'
<hr/>
               (E_IfFalse)
                st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">TEST</span></span> <span class="inlinecode"><span class="id" title="var">b1</span></span> <span class="inlinecode"><span class="id" title="var">THEN</span></span> <span class="inlinecode"><span class="id" title="var">c1</span></span> <span class="inlinecode"><span class="id" title="var">ELSE</span></span> <span class="inlinecode"><span class="id" title="var">c2</span></span> <span class="inlinecode"><span class="id" title="var">FI</span></span> <span class="inlinecode"></span>=&gt; st'

<div class="paragraph"> </div>

                         beval st b = false
<hr/>
                  (E_WhileFalse)
                    st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">WHILE</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">DO</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">END</span></span> <span class="inlinecode"></span>=&gt; st

<div class="paragraph"> </div>

                          beval st b = true
                           st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"></span>=&gt; st'
                  st' =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">WHILE</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">DO</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">END</span></span> <span class="inlinecode"></span>=&gt; st''
<hr/>
                  (E_WhileTrue)
                  st  =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">WHILE</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">DO</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">END</span></span> <span class="inlinecode"></span>=&gt; st''

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Here is the formal definition.  Make sure you understand
    how it corresponds to the inference rules. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Reserved Notation</span> <span class="s2">&quot;st &#39;=[&#39; c &#39;]=&gt;&#39; st&#39;&quot;</span>
                  (<span class="kn">at level</span> <span class="mi">40</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">ceval</span> : com -&gt; state -&gt; state -&gt; <span class="kt">Prop</span> :=
  | E_Skip : <span class="kr">forall</span> <span class="nv">st</span>,
      st =[ SKIP ]=&gt; st
  | E_Ass  : <span class="kr">forall</span> <span class="nv">st</span> <span class="nv">a1</span> <span class="nv">n</span> <span class="nv">x</span>,
      aeval st a1 = n -&gt;
      st =[ x ::= a1 ]=&gt; (x !-&gt; n ; st)
  | E_Seq : <span class="kr">forall</span> <span class="nv">c1</span> <span class="nv">c2</span> <span class="nv">st</span> <span class="nv">st&#39;</span> <span class="nv">st&#39;&#39;</span>,
      st  =[ c1 ]=&gt; st&#39;  -&gt;
      st&#39; =[ c2 ]=&gt; st&#39;&#39; -&gt;
      st  =[ c1 ;; c2 ]=&gt; st&#39;&#39;
  | E_IfTrue : <span class="kr">forall</span> <span class="nv">st</span> <span class="nv">st&#39;</span> <span class="nv">b</span> <span class="nv">c1</span> <span class="nv">c2</span>,
      beval st b = true -&gt;
      st =[ c1 ]=&gt; st&#39; -&gt;
      st =[ TEST b THEN c1 ELSE c2 FI ]=&gt; st&#39;
  | E_IfFalse : <span class="kr">forall</span> <span class="nv">st</span> <span class="nv">st&#39;</span> <span class="nv">b</span> <span class="nv">c1</span> <span class="nv">c2</span>,
      beval st b = false -&gt;
      st =[ c2 ]=&gt; st&#39; -&gt;
      st =[ TEST b THEN c1 ELSE c2 FI ]=&gt; st&#39;
  | E_WhileFalse : <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">st</span> <span class="nv">c</span>,
      beval st b = false -&gt;
      st =[ WHILE b DO c END ]=&gt; st
  | E_WhileTrue : <span class="kr">forall</span> <span class="nv">st</span> <span class="nv">st&#39;</span> <span class="nv">st&#39;&#39;</span> <span class="nv">b</span> <span class="nv">c</span>,
      beval st b = true -&gt;
      st  =[ c ]=&gt; st&#39; -&gt;
      st&#39; =[ WHILE b DO c END ]=&gt; st&#39;&#39; -&gt;
      st  =[ WHILE b DO c END ]=&gt; st&#39;&#39;

  <span class="kn">where</span> <span class="s2">&quot;st =[ c ]=&gt; st&#39;&quot;</span> := (ceval c st st&#39;).</span></span></span></pre><div class="doc">
The cost of defining evaluation as a relation instead of a
    function is that we now need to construct <i>proofs</i> that some
    program evaluates to some result state, rather than just letting
    Coq's computation mechanism do it for us. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chka2" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chka2"><span class="highlight"><span class="kn">Example</span> <span class="nf">ceval_example1</span>:
  empty_st =[
     X ::= <span class="mi">2</span>;;
     TEST X &lt;= <span class="mi">1</span>
       THEN Y ::= <span class="mi">3</span>
       ELSE Z ::= <span class="mi">4</span>
     FI
  ]=&gt; (Z !-&gt; <span class="mi">4</span> ; X !-&gt; <span class="mi">2</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">empty_st =[
X ::= <span class="mi">2</span>;; TEST X &lt;= <span class="mi">1</span> THEN Y ::= <span class="mi">3</span> ELSE Z ::= <span class="mi">4</span> FI
]=&gt; (Z !-&gt; <span class="mi">4</span>; X !-&gt; <span class="mi">2</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chka3" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chka3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">empty_st =[
X ::= <span class="mi">2</span>;; TEST X &lt;= <span class="mi">1</span> THEN Y ::= <span class="mi">3</span> ELSE Z ::= <span class="mi">4</span> FI
]=&gt; (Z !-&gt; <span class="mi">4</span>; X !-&gt; <span class="mi">2</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* We must supply the intermediate state *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chka4" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chka4"><span class="highlight"><span class="nb">apply</span> E_Seq <span class="kr">with</span> (X !-&gt; <span class="mi">2</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">empty_st =[ X ::= <span class="mi">2</span> ]=&gt; (X !-&gt; <span class="mi">2</span>)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chka5" style="display: none" type="checkbox"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(X !-&gt; <span class="mi">2</span>) =[ TEST X &lt;= <span class="mi">1</span> THEN Y ::= <span class="mi">3</span> ELSE Z ::= <span class="mi">4</span> FI
]=&gt; (Z !-&gt; <span class="mi">4</span>; X !-&gt; <span class="mi">2</span>)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chka6" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chka6"><span class="highlight">- <span class="c">(* assignment command *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">empty_st =[ X ::= <span class="mi">2</span> ]=&gt; (X !-&gt; <span class="mi">2</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chka7" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chka7"><span class="highlight"><span class="nb">apply</span> E_Ass.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval empty_st <span class="mi">2</span> = <span class="mi">2</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chka8" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chka8"><span class="highlight">- <span class="c">(* if command *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(X !-&gt; <span class="mi">2</span>) =[ TEST X &lt;= <span class="mi">1</span> THEN Y ::= <span class="mi">3</span> ELSE Z ::= <span class="mi">4</span> FI
]=&gt; (Z !-&gt; <span class="mi">4</span>; X !-&gt; <span class="mi">2</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chka9" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chka9"><span class="highlight"><span class="nb">apply</span> E_IfFalse.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">beval (X !-&gt; <span class="mi">2</span>) (X &lt;= <span class="mi">1</span>) = false</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chkaa" style="display: none" type="checkbox"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(X !-&gt; <span class="mi">2</span>) =[ Z ::= <span class="mi">4</span> ]=&gt; (Z !-&gt; <span class="mi">4</span>; X !-&gt; <span class="mi">2</span>)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkab" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkab"><span class="highlight"><span class="bp">reflexivity</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(X !-&gt; <span class="mi">2</span>) =[ Z ::= <span class="mi">4</span> ]=&gt; (Z !-&gt; <span class="mi">4</span>; X !-&gt; <span class="mi">2</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkac" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkac"><span class="highlight"><span class="nb">apply</span> E_Ass.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">aeval (X !-&gt; <span class="mi">2</span>) <span class="mi">4</span> = <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab41"></a><h4 class="section">Exercise: 2 stars, standard (ceval_example2)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkad" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkad"><span class="highlight"><span class="kn">Example</span> <span class="nf">ceval_example2</span>:
  empty_st =[
    X ::= <span class="mi">0</span>;; Y ::= <span class="mi">1</span>;; Z ::= <span class="mi">2</span>
  ]=&gt; (Z !-&gt; <span class="mi">2</span> ; Y !-&gt; <span class="mi">1</span> ; X !-&gt; <span class="mi">0</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">empty_st =[ X ::= <span class="mi">0</span>;; Y ::= <span class="mi">1</span>;; Z ::= <span class="mi">2</span>
]=&gt; (Z !-&gt; <span class="mi">2</span>; Y !-&gt; <span class="mi">1</span>; X !-&gt; <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkae" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkae"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">empty_st =[ X ::= <span class="mi">0</span>;; Y ::= <span class="mi">1</span>;; Z ::= <span class="mi">2</span>
]=&gt; (Z !-&gt; <span class="mi">2</span>; Y !-&gt; <span class="mi">1</span>; X !-&gt; <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab42"></a><h4 class="section">Exercise: 3 stars, standard, optional (pup_to_n)</h4>
<div class="paragraph"> </div>

    Write an Imp program that sums the numbers from <span class="inlinecode">1</span> to
   <span class="inlinecode"><span class="id" title="var">X</span></span> (inclusive: <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">...</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">X</span></span>) in the variable <span class="inlinecode"><span class="id" title="var">Y</span></span>.
   Prove that this program executes as intended for <span class="inlinecode"><span class="id" title="var">X</span></span> = <span class="inlinecode">2</span>
   (this is trickier than you might expect). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkaf" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkaf"><span class="highlight"><span class="kn">Definition</span> <span class="nf">pup_to_n</span> : com
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">com</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkb0" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkb0"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">pup_to_2_ceval</span> :
  (X !-&gt; <span class="mi">2</span>) =[
    pup_to_n
  ]=&gt; (X !-&gt; <span class="mi">0</span> ; Y !-&gt; <span class="mi">3</span> ; X !-&gt; <span class="mi">1</span> ; Y !-&gt; <span class="mi">2</span> ; Y !-&gt; <span class="mi">0</span> ; X !-&gt; <span class="mi">2</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(X !-&gt; <span class="mi">2</span>) =[ pup_to_n
]=&gt; (X !-&gt; <span class="mi">0</span>;
     Y !-&gt; <span class="mi">3</span>; X !-&gt; <span class="mi">1</span>; Y !-&gt; <span class="mi">2</span>; Y !-&gt; <span class="mi">0</span>; X !-&gt; <span class="mi">2</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkb1" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkb1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(X !-&gt; <span class="mi">2</span>) =[ pup_to_n
]=&gt; (X !-&gt; <span class="mi">0</span>;
     Y !-&gt; <span class="mi">3</span>; X !-&gt; <span class="mi">1</span>; Y !-&gt; <span class="mi">2</span>; Y !-&gt; <span class="mi">0</span>; X !-&gt; <span class="mi">2</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab43"></a><h2 class="section">Determinism of Evaluation</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Changing from a computational to a relational definition of
    evaluation is a good move because it frees us from the artificial
    requirement that evaluation should be a total function.  But it
    also raises a question: Is the second definition of evaluation
    really a partial function?  Or is it possible that, beginning from
    the same state <span class="inlinecode"><span class="id" title="var">st</span></span>, we could evaluate some command <span class="inlinecode"><span class="id" title="var">c</span></span> in
    different ways to reach two different output states <span class="inlinecode"><span class="id" title="var">st'</span></span> and
    <span class="inlinecode"><span class="id" title="var">st''</span></span>?

<div class="paragraph"> </div>

    In fact, this cannot happen: <span class="inlinecode"><span class="id" title="var">ceval</span></span> <i>is</i> a partial function: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkb2" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkb2"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">ceval_deterministic</span>: <span class="kr">forall</span> <span class="nv">c</span> <span class="nv">st</span> <span class="nv">st1</span> <span class="nv">st2</span>,
     st =[ c ]=&gt; st1  -&gt;
     st =[ c ]=&gt; st2 -&gt;
     st1 = st2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">c</span> : com) (<span class="nv">st</span> <span class="nv">st1</span> <span class="nv">st2</span> : state),
st =[ c ]=&gt; st1 -&gt; st =[ c ]=&gt; st2 -&gt; st1 = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkb3" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkb3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">c</span> : com) (<span class="nv">st</span> <span class="nv">st1</span> <span class="nv">st2</span> : state),
st =[ c ]=&gt; st1 -&gt; st =[ c ]=&gt; st2 -&gt; st1 = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkb4" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkb4"><span class="highlight"><span class="nb">intros</span> c st st1 st2 E1 E2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st, st1, st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st1 = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkb5" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkb5"><span class="highlight"><span class="nb">generalize dependent</span> st2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st, st1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">st2</span> : state, st =[ c ]=&gt; st2 -&gt; st1 = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkb6" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkb6"><span class="highlight"><span class="nb">induction</span> E1;
           <span class="nb">intros</span> st2 E2; <span class="nb">inversion</span> E2; <span class="nb">subst</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st2 =[ SKIP ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st2 = st2</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chkb7" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ x ::= a1 ]=&gt; (x !-&gt; aeval st a1; st)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chkb7"><hr></label><div class="goal-conclusion"><span class="highlight">(x !-&gt; aeval st a1; st) = (x !-&gt; aeval st a1; st)</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chkb8" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ c2 ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c1 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ c2 ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1;; c2 ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39;0 =[ c2 ]=&gt; st2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chkb8"><hr></label><div class="goal-conclusion"><span class="highlight">st&#39;&#39; = st2</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chkb9" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c1 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ TEST b THEN c1 ELSE c2 FI ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chkb9"><hr></label><div class="goal-conclusion"><span class="highlight">st&#39; = st2</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chkba" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c1 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ TEST b THEN c1 ELSE c2 FI ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c2 ]=&gt; st2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chkba"><hr></label><div class="goal-conclusion"><span class="highlight">st&#39; = st2</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chkbb" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c2 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c2 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ TEST b THEN c1 ELSE c2 FI ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chkbb"><hr></label><div class="goal-conclusion"><span class="highlight">st&#39; = st2</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chkbc" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c2 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c2 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ TEST b THEN c1 ELSE c2 FI ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c2 ]=&gt; st2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chkbc"><hr></label><div class="goal-conclusion"><span class="highlight">st&#39; = st2</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chkbd" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st2 =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H, H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st2 b = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chkbd"><hr></label><div class="goal-conclusion"><span class="highlight">st2 = st2</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chkbe" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chkbe"><hr></label><div class="goal-conclusion"><span class="highlight">st = st2</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chkbf" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st2 =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st2 =[ c ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st2 b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st2 =[ c ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ WHILE b DO c END ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st2 b = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chkbf"><hr></label><div class="goal-conclusion"><span class="highlight">st&#39;&#39; = st2</span></div></blockquote><input class="coq-extra-goal-toggle" id="Imp-v-chkc0" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ WHILE b DO c END ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39;0 =[ WHILE b DO c END ]=&gt; st2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chkc0"><hr></label><div class="goal-conclusion"><span class="highlight">st&#39;&#39; = st2</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkc1" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkc1"><span class="highlight">- <span class="c">(* E_Skip *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st2 =[ SKIP ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st2 = st2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkc2" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkc2"><span class="highlight">- <span class="c">(* E_Ass *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ x ::= a1 ]=&gt; (x !-&gt; aeval st a1; st)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(x !-&gt; aeval st a1; st) = (x !-&gt; aeval st a1; st)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkc3" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkc3"><span class="highlight">- <span class="c">(* E_Seq *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ c2 ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c1 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ c2 ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1;; c2 ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39;0 =[ c2 ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39;&#39; = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkc4" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkc4"><span class="highlight"><span class="nb">assert</span> (st&#39; = st&#39;0) <span class="kr">as</span> EQ1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ c2 ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c1 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ c2 ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1;; c2 ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39;0 =[ c2 ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39; = st&#39;0</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chkc5" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ c2 ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c1 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ c2 ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1;; c2 ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39;0 =[ c2 ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; = st&#39;0</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chkc5"><hr></label><div class="goal-conclusion"><span class="highlight">st&#39;&#39; = st2</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkc6" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkc6"><span class="highlight">{ <span class="c">(* Proof of assertion *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ c2 ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c1 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ c2 ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1;; c2 ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39;0 =[ c2 ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39; = st&#39;0</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> IHE1_1; <span class="bp">assumption</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkc7" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkc7"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ c2 ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c1 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ c2 ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1;; c2 ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39;0 =[ c2 ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; = st&#39;0</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39;&#39; = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkc8" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkc8"><span class="highlight"><span class="nb">subst</span> st&#39;0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ c2 ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c1 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ c2 ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1;; c2 ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ c2 ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39;&#39; = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkc9" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkc9"><span class="highlight"><span class="nb">apply</span> IHE1_2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ c2 ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c1 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ c2 ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1;; c2 ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ c2 ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39; =[ c2 ]=&gt; st2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkca" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkca"><span class="highlight">- <span class="c">(* E_IfTrue, b1 evaluates to true *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c1 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ TEST b THEN c1 ELSE c2 FI ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39; = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkcb" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkcb"><span class="highlight"><span class="nb">apply</span> IHE1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c1 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ TEST b THEN c1 ELSE c2 FI ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st =[ c1 ]=&gt; st2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkcc" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkcc"><span class="highlight">- <span class="c">(* E_IfTrue,  b1 evaluates to false (contradiction) *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c1 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ TEST b THEN c1 ELSE c2 FI ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c2 ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39; = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkcd" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkcd"><span class="highlight"><span class="nb">rewrite</span> H <span class="kr">in</span> H5.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c1 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ TEST b THEN c1 ELSE c2 FI ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">true = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c2 ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39; = st2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span> H5.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkce" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkce"><span class="highlight">- <span class="c">(* E_IfFalse, b1 evaluates to true (contradiction) *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c2 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c2 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ TEST b THEN c1 ELSE c2 FI ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39; = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkcf" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkcf"><span class="highlight"><span class="nb">rewrite</span> H <span class="kr">in</span> H5.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c2 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c2 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ TEST b THEN c1 ELSE c2 FI ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">false = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c1 ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39; = st2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span> H5.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkd0" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkd0"><span class="highlight">- <span class="c">(* E_IfFalse, b1 evaluates to false *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c2 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c2 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ TEST b THEN c1 ELSE c2 FI ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c2 ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39; = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkd1" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkd1"><span class="highlight"><span class="nb">apply</span> IHE1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c1, c2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c2 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c2 ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ TEST b THEN c1 ELSE c2 FI ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c2 ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st =[ c2 ]=&gt; st2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkd2" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkd2"><span class="highlight">- <span class="c">(* E_WhileFalse, b1 evaluates to false *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st2 =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H, H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st2 b = false</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st2 = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkd3" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkd3"><span class="highlight">- <span class="c">(* E_WhileFalse, b1 evaluates to true (contradiction) *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkd4" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkd4"><span class="highlight"><span class="nb">rewrite</span> H <span class="kr">in</span> H2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = false</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">false = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st = st2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span> H2.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkd5" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkd5"><span class="highlight">- <span class="c">(* E_WhileTrue, b1 evaluates to false (contradiction) *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st2 =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st2 =[ c ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st2 b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st2 =[ c ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ WHILE b DO c END ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st2 b = false</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39;&#39; = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkd6" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkd6"><span class="highlight"><span class="nb">rewrite</span> H <span class="kr">in</span> H4.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st2 =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st2 =[ c ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st2 b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st2 =[ c ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ WHILE b DO c END ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">true = false</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39;&#39; = st2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span> H4.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkd7" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkd7"><span class="highlight">- <span class="c">(* E_WhileTrue, b1 evaluates to true *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ WHILE b DO c END ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39;0 =[ WHILE b DO c END ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39;&#39; = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkd8" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkd8"><span class="highlight"><span class="nb">assert</span> (st&#39; = st&#39;0) <span class="kr">as</span> EQ1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ WHILE b DO c END ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39;0 =[ WHILE b DO c END ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39; = st&#39;0</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Imp-v-chkd9" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ WHILE b DO c END ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39;0 =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; = st&#39;0</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Imp-v-chkd9"><hr></label><div class="goal-conclusion"><span class="highlight">st&#39;&#39; = st2</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkda" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkda"><span class="highlight">{ <span class="c">(* Proof of assertion *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ WHILE b DO c END ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39;0 =[ WHILE b DO c END ]=&gt; st2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39; = st&#39;0</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> IHE1_1; <span class="bp">assumption</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkdb" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkdb"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ WHILE b DO c END ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39;0 =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; = st&#39;0</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39;&#39; = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkdc" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkdc"><span class="highlight"><span class="nb">subst</span> st&#39;0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ WHILE b DO c END ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39;&#39; = st2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkdd" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkdd"><span class="highlight"><span class="nb">apply</span> IHE1_2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st', st''</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st&#39;&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st =[ c ]=&gt; st0 -&gt; st&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHE1_2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">st0</span> : state,
st&#39; =[ WHILE b DO c END ]=&gt; st0 -&gt; st&#39;&#39; = st0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">beval st b = true</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ c ]=&gt; st&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39; =[ WHILE b DO c END ]=&gt; st2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab44"></a><h1 class="section">Reasoning About Imp Programs</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We'll get deeper into more systematic and powerful techniques for
    reasoning about Imp programs in <i>Programming Language
    Foundations</i>, but we can get some distance just working with the
    bare definitions.  This section explores some examples. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkde" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkde"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">plus2_spec</span> : <span class="kr">forall</span> <span class="nv">st</span> <span class="nv">n</span> <span class="nv">st&#39;</span>,
  st X = n -&gt;
  st =[ plus2 ]=&gt; st&#39; -&gt;
  st&#39; X = n + <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : string -&gt; nat) (<span class="nv">n</span> : nat) (<span class="nv">st&#39;</span> : state),
st X = n -&gt; st =[ plus2 ]=&gt; st&#39; -&gt; st&#39; X = n + <span class="mi">2</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkdf" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkdf"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : string -&gt; nat) (<span class="nv">n</span> : nat) (<span class="nv">st&#39;</span> : state),
st X = n -&gt; st =[ plus2 ]=&gt; st&#39; -&gt; st&#39; X = n + <span class="mi">2</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chke0" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chke0"><span class="highlight"><span class="nb">intros</span> st n st&#39; HX Heval.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string -&gt; nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HX</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st X = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heval</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ plus2 ]=&gt; st&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st&#39; X = n + <span class="mi">2</span></span></div></blockquote></div></div></small></span></pre><div class="doc">
Inverting <span class="inlinecode"><span class="id" title="var">Heval</span></span> essentially forces Coq to expand one step of
      the <span class="inlinecode"><span class="id" title="var">ceval</span></span> computation -- in this case revealing that <span class="inlinecode"><span class="id" title="var">st'</span></span>
      must be <span class="inlinecode"><span class="id" title="var">st</span></span> extended with the new value of <span class="inlinecode"><span class="id" title="var">X</span></span>, since <span class="inlinecode"><span class="id" title="var">plus2</span></span>
      is an assignment. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chke1" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chke1"><span class="highlight"><span class="nb">inversion</span> Heval.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string -&gt; nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HX</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st X = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heval</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ plus2 ]=&gt; st&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aeval st (X + <span class="mi">2</span>) = n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = X</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a1 = (X + <span class="mi">2</span>)%imp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st0 = st</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(X !-&gt; n0; st) = st&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(X !-&gt; n0; st) X = n + <span class="mi">2</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chke2" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chke2"><span class="highlight"><span class="nb">subst</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string -&gt; nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heval</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ plus2 ]=&gt; (X !-&gt; aeval st (X + <span class="mi">2</span>); st)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(X !-&gt; aeval st (X + <span class="mi">2</span>); st) X = st X + <span class="mi">2</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chke3" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chke3"><span class="highlight"><span class="nb">clear</span> Heval.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string -&gt; nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(X !-&gt; aeval st (X + <span class="mi">2</span>); st) X = st X + <span class="mi">2</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chke4" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chke4"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">string -&gt; nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(X !-&gt; st X + <span class="mi">2</span>; st) X = st X + <span class="mi">2</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> t_update_eq.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<a name="lab45"></a><h4 class="section">Exercise: 3 stars, standard, recommended (XtimesYinZ_spec)</h4>
<div class="paragraph"> </div>

    State and prove a specification of <span class="inlinecode"><span class="id" title="var">XtimesYinZ</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span>

<span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_XtimesYinZ_spec</span> : option (nat*string) := None.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab46"></a><h4 class="section">Exercise: 3 stars, standard, recommended (loop_never_stops)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chke5" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chke5"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">loop_never_stops</span> : <span class="kr">forall</span> <span class="nv">st</span> <span class="nv">st&#39;</span>,
  ~(st =[ loop ]=&gt; st&#39;).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">st</span> <span class="nv">st&#39;</span> : state, ~ st =[ loop ]=&gt; st&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chke6" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chke6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">st</span> <span class="nv">st&#39;</span> : state, ~ st =[ loop ]=&gt; st&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chke7" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chke7"><span class="highlight"><span class="nb">intros</span> st st&#39; contra.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">contra</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ loop ]=&gt; st&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chke8" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chke8"><span class="highlight"><span class="nb">unfold</span> loop <span class="kr">in</span> contra.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">contra</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ WHILE true DO SKIP END ]=&gt; st&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chke9" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chke9"><span class="highlight"><span class="nb">remember</span> (WHILE true DO SKIP END)%imp <span class="kr">as</span> loopdef
           <span class="nb">eqn</span>:Heqloopdef.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">st, st'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">loopdef</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">com</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqloopdef</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">loopdef = (WHILE true DO SKIP END)%imp</span></span></span></div><div class="goal-hyp"><span class="hyp-names">contra</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">st =[ loopdef ]=&gt; st&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small></span></pre><div class="doc">
Proceed by induction on the assumed derivation showing that
      <span class="inlinecode"><span class="id" title="var">loopdef</span></span> terminates.  Most of the cases are immediately
      contradictory (and so can be solved in one step with
      <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span>). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab47"></a><h4 class="section">Exercise: 3 stars, standard (no_whiles_eqv)</h4>
<div class="paragraph"> </div>

    Consider the following function: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Open Scope</span> imp_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">no_whiles</span> (<span class="nv">c</span> : com) : bool :=
  <span class="kr">match</span> c <span class="kr">with</span>
  | SKIP =&gt;
      true
  | _ ::= _ =&gt;
      true
  | c1 ;; c2 =&gt;
      andb (no_whiles c1) (no_whiles c2)
  | TEST _ THEN ct ELSE cf FI =&gt;
      andb (no_whiles ct) (no_whiles cf)
  | WHILE _ DO _ END  =&gt;
      false
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Close Scope</span> imp_scope.</span></span></span></pre><div class="doc">
This predicate yields <span class="inlinecode"><span class="id" title="var">true</span></span> just on programs that have no while
    loops.  Using <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>, write a property <span class="inlinecode"><span class="id" title="var">no_whilesR</span></span> such that
    <span class="inlinecode"><span class="id" title="var">no_whilesR</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> is provable exactly when <span class="inlinecode"><span class="id" title="var">c</span></span> is a program with no
    while loops.  Then prove its equivalence with <span class="inlinecode"><span class="id" title="var">no_whiles</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">no_whilesR</span>: com -&gt; <span class="kt">Prop</span> :=
 <span class="c">(* FILL IN HERE *)</span>
.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkea" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkea"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">no_whiles_eqv</span>:
   <span class="kr">forall</span> <span class="nv">c</span>, no_whiles c = true &lt;-&gt; no_whilesR c.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">c</span> : com, no_whiles c = true &lt;-&gt; no_whilesR c</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkeb" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkeb"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">c</span> : com, no_whiles c = true &lt;-&gt; no_whilesR c</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab48"></a><h4 class="section">Exercise: 4 stars, standard (no_whiles_terminating)</h4>
<div class="paragraph"> </div>

    Imp programs that don't involve while loops always terminate.
    State and prove a theorem <span class="inlinecode"><span class="id" title="var">no_whiles_terminating</span></span> that says this. 

<div class="paragraph"> </div>

    Use either <span class="inlinecode"><span class="id" title="var">no_whiles</span></span> or <span class="inlinecode"><span class="id" title="var">no_whilesR</span></span>, as you prefer. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span>

<span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_no_whiles_terminating</span> : option (nat*string) := None.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab49"></a><h1 class="section">Additional Exercises</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab50"></a><h4 class="section">Exercise: 3 stars, standard (stack_compiler)</h4>
<div class="paragraph"> </div>

    Old HP Calculators, programming languages like Forth and Postscript,
    and abstract machines like the Java Virtual Machine all evaluate
    arithmetic expressions using a <i>stack</i>. For instance, the expression

<div class="paragraph"> </div>

      (2*3)+(3*(4-2))

<div class="paragraph"> </div>

   would be written as

<div class="paragraph"> </div>

      2 3 * 3 4 2 - * +

<div class="paragraph"> </div>

   and evaluated like this (where we show the program being evaluated
   on the right and the contents of the stack on the left):

<div class="paragraph"> </div>
<span class="inlinecode"></span> <span class="inlinecode"></span>           |    2 3 * 3 4 2 - * +
      <span class="inlinecode">2</span>           |    3 * 3 4 2 - * +
      <span class="inlinecode">3,</span> <span class="inlinecode">2</span>        |    * 3 4 2 - * +
      <span class="inlinecode">6</span>           |    3 4 2 - * +
      <span class="inlinecode">3,</span> <span class="inlinecode">6</span>        |    4 2 - * +
      <span class="inlinecode">4,</span> <span class="inlinecode">3,</span> <span class="inlinecode">6</span>     |    2 - * +
      <span class="inlinecode">2,</span> <span class="inlinecode">4,</span> <span class="inlinecode">3,</span> <span class="inlinecode">6</span>  |    - * +
      <span class="inlinecode">2,</span> <span class="inlinecode">3,</span> <span class="inlinecode">6</span>     |    * +
      <span class="inlinecode">6,</span> <span class="inlinecode">6</span>        |    +
      <span class="inlinecode">12</span>          |

<div class="paragraph"> </div>

  The goal of this exercise is to write a small compiler that
  translates <span class="inlinecode"><span class="id" title="var">aexp</span></span>s into stack machine instructions.

<div class="paragraph"> </div>

  The instruction set for our stack language will consist of the
  following instructions:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">SPush</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>: Push the number <span class="inlinecode"><span class="id" title="var">n</span></span> on the stack.

</li>
<li> <span class="inlinecode"><span class="id" title="var">SLoad</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>: Load the identifier <span class="inlinecode"><span class="id" title="var">x</span></span> from the store and push it
                  on the stack

</li>
<li> <span class="inlinecode"><span class="id" title="var">SPlus</span></span>:   Pop the two top numbers from the stack, add them, and
                  push the result onto the stack.

</li>
<li> <span class="inlinecode"><span class="id" title="var">SMinus</span></span>:  Similar, but subtract.

</li>
<li> <span class="inlinecode"><span class="id" title="var">SMult</span></span>:   Similar, but multiply. 
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">sinstr</span> : <span class="kt">Type</span> :=
| SPush (n : nat)
| SLoad (x : string)
| SPlus
| SMinus
| SMult.</span></span></span></pre><div class="doc">
Write a function to evaluate programs in the stack language. It
    should take as input a state, a stack represented as a list of
    numbers (top stack item is the head of the list), and a program
    represented as a list of instructions, and it should return the
    stack after executing the program.  Test your function on the
    examples below.

<div class="paragraph"> </div>

    Note that the specification leaves unspecified what to do when
    encountering an <span class="inlinecode"><span class="id" title="var">SPlus</span></span>, <span class="inlinecode"><span class="id" title="var">SMinus</span></span>, or <span class="inlinecode"><span class="id" title="var">SMult</span></span> instruction if the
    stack contains less than two elements.  In a sense, it is
    immaterial what we do, since our compiler will never emit such a
    malformed program. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkec" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkec"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">s_execute</span> (<span class="nv">st</span> : state) (<span class="nv">stack</span> : list nat)
                   (<span class="nv">prog</span> : list sinstr)
                 : list nat
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s_execute</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state -&gt;
list nat -&gt; list sinstr -&gt; list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">state</span></span></span></div><div class="goal-hyp"><span class="hyp-names">stack</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">prog</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list sinstr</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">list nat</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chked" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chked"><span class="highlight"><span class="kn">Example</span> <span class="nf">s_execute1</span> :
     s_execute empty_st []
       [SPush <span class="mi">5</span>; SPush <span class="mi">3</span>; SPush <span class="mi">1</span>; SMinus]
   = [<span class="mi">2</span>; <span class="mi">5</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s_execute empty_st []
  [SPush <span class="mi">5</span>; SPush <span class="mi">3</span>; SPush <span class="mi">1</span>; SMinus] = [<span class="mi">2</span>; <span class="mi">5</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkee" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkee"><span class="highlight"><span class="kn">Example</span> <span class="nf">s_execute2</span> :
     s_execute (X !-&gt; <span class="mi">3</span>) [<span class="mi">3</span>;<span class="mi">4</span>]
       [SPush <span class="mi">4</span>; SLoad X; SMult; SPlus]
   = [<span class="mi">15</span>; <span class="mi">4</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s_execute (X !-&gt; <span class="mi">3</span>) [<span class="mi">3</span>; <span class="mi">4</span>]
  [SPush <span class="mi">4</span>; SLoad X; SMult; SPlus] = [<span class="mi">15</span>; <span class="mi">4</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
Next, write a function that compiles an <span class="inlinecode"><span class="id" title="var">aexp</span></span> into a stack
    machine program. The effect of running the program should be the
    same as pushing the value of the expression on the stack. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkef" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkef"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">s_compile</span> (<span class="nv">e</span> : aexp) : list sinstr
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s_compile</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp -&gt; list sinstr</span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">aexp</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">list sinstr</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
After you've defined <span class="inlinecode"><span class="id" title="var">s_compile</span></span>, prove the following to test
    that it works. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkf0" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkf0"><span class="highlight"><span class="kn">Example</span> <span class="nf">s_compile1</span> :
  s_compile (X - (<span class="mi">2</span> * Y))%imp
  = [SLoad X; SPush <span class="mi">2</span>; SLoad Y; SMult; SMinus].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s_compile (X - <span class="mi">2</span> * Y) =
[SLoad X; SPush <span class="mi">2</span>; SLoad Y; SMult; SMinus]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab51"></a><h4 class="section">Exercise: 4 stars, advanced (stack_compiler_correct)</h4>
<div class="paragraph"> </div>

    Now we'll prove the correctness of the compiler implemented in the
    previous exercise.  Remember that the specification left
    unspecified what to do when encountering an <span class="inlinecode"><span class="id" title="var">SPlus</span></span>, <span class="inlinecode"><span class="id" title="var">SMinus</span></span>, or
    <span class="inlinecode"><span class="id" title="var">SMult</span></span> instruction if the stack contains less than two
    elements.  (In order to make your correctness proof easier you
    might find it helpful to go back and change your implementation!)

<div class="paragraph"> </div>

    Prove the following theorem.  You will need to start by stating a
    more general lemma to get a usable induction hypothesis; the main
    theorem will then be a simple corollary of this lemma. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkf1" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkf1"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">s_compile_correct</span> : <span class="kr">forall</span> (<span class="nv">st</span> : state) (<span class="nv">e</span> : aexp),
  s_execute st [] (s_compile e) = [ aeval st e ].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : state) (<span class="nv">e</span> : aexp),
s_execute st [] (s_compile e) = [aeval st e]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkf2" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkf2"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : state) (<span class="nv">e</span> : aexp),
s_execute st [] (s_compile e) = [aeval st e]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab52"></a><h4 class="section">Exercise: 3 stars, standard, optional (short_circuit)</h4>
<div class="paragraph"> </div>

    Most modern programming languages use a "short-circuit" evaluation
    rule for boolean <span class="inlinecode"><span class="id" title="var">and</span></span>: to evaluate <span class="inlinecode"><span class="id" title="var">BAnd</span></span> <span class="inlinecode"><span class="id" title="var">b1</span></span> <span class="inlinecode"><span class="id" title="var">b2</span></span>, first evaluate
    <span class="inlinecode"><span class="id" title="var">b1</span></span>.  If it evaluates to <span class="inlinecode"><span class="id" title="var">false</span></span>, then the entire <span class="inlinecode"><span class="id" title="var">BAnd</span></span>
    expression evaluates to <span class="inlinecode"><span class="id" title="var">false</span></span> immediately, without evaluating
    <span class="inlinecode"><span class="id" title="var">b2</span></span>.  Otherwise, <span class="inlinecode"><span class="id" title="var">b2</span></span> is evaluated to determine the result of the
    <span class="inlinecode"><span class="id" title="var">BAnd</span></span> expression.

<div class="paragraph"> </div>

    Write an alternate version of <span class="inlinecode"><span class="id" title="var">beval</span></span> that performs short-circuit
    evaluation of <span class="inlinecode"><span class="id" title="var">BAnd</span></span> in this manner, and prove that it is
    equivalent to <span class="inlinecode"><span class="id" title="var">beval</span></span>.  (N.b. This is only true because expression
    evaluation in Imp is rather simple.  In a bigger language where
    evaluating an expression might diverge, the short-circuiting <span class="inlinecode"><span class="id" title="var">BAnd</span></span>
    would <i>not</i> be equivalent to the original, since it would make more
    programs terminate.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE </span>

<span class="c">    [] *)</span>

</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">BreakImp</span>.</span></span></span></pre><div class="doc">
<a name="lab53"></a><h4 class="section">Exercise: 4 stars, advanced (break_imp)</h4>
<div class="paragraph"> </div>

    Imperative languages like C and Java often include a <span class="inlinecode"><span class="id" title="var">break</span></span> or
    similar statement for interrupting the execution of loops. In this
    exercise we consider how to add <span class="inlinecode"><span class="id" title="var">break</span></span> to Imp.  First, we need to
    enrich the language of commands with an additional case. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">com</span> : <span class="kt">Type</span> :=
  | CSkip
  | CBreak                        <span class="c">(* &lt;--- NEW *)</span>
  | CAss (x : string) (a : aexp)
  | CSeq (c1 c2 : com)
  | CIf (b : bexp) (c1 c2 : com)
  | CWhile (b : bexp) (c : com).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&#39;SKIP&#39;&quot;</span> :=
  CSkip.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&#39;BREAK&#39;&quot;</span> :=
  CBreak.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &#39;::=&#39; a&quot;</span> :=
  (CAss x a) (<span class="kn">at level</span> <span class="mi">60</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;c1 ;; c2&quot;</span> :=
  (CSeq c1 c2) (<span class="kn">at level</span> <span class="mi">80</span>, <span class="kn">right associativity</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&#39;WHILE&#39; b &#39;DO&#39; c &#39;END&#39;&quot;</span> :=
  (CWhile b c) (<span class="kn">at level</span> <span class="mi">80</span>, <span class="kn">right associativity</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&#39;TEST&#39; c1 &#39;THEN&#39; c2 &#39;ELSE&#39; c3 &#39;FI&#39;&quot;</span> :=
  (CIf c1 c2 c3) (<span class="kn">at level</span> <span class="mi">80</span>, <span class="kn">right associativity</span>).</span></span></span></pre><div class="doc">
Next, we need to define the behavior of <span class="inlinecode"><span class="id" title="var">BREAK</span></span>.  Informally,
    whenever <span class="inlinecode"><span class="id" title="var">BREAK</span></span> is executed in a sequence of commands, it stops
    the execution of that sequence and signals that the innermost
    enclosing loop should terminate.  (If there aren't any
    enclosing loops, then the whole program simply terminates.)  The
    final state should be the same as the one in which the <span class="inlinecode"><span class="id" title="var">BREAK</span></span>
    statement was executed.

<div class="paragraph"> </div>

    One important point is what to do when there are multiple loops
    enclosing a given <span class="inlinecode"><span class="id" title="var">BREAK</span></span>. In those cases, <span class="inlinecode"><span class="id" title="var">BREAK</span></span> should only
    terminate the <i>innermost</i> loop. Thus, after executing the
    following...

<div class="paragraph"> </div>

       X ::= 0;;
       Y ::= 1;;
       WHILE ~(0 = Y) DO
         WHILE true DO
           BREAK
         END;;
         X ::= 1;;
         Y ::= Y - 1
       END

<div class="paragraph"> </div>

    ... the value of <span class="inlinecode"><span class="id" title="var">X</span></span> should be <span class="inlinecode">1</span>, and not <span class="inlinecode">0</span>.

<div class="paragraph"> </div>

    One way of expressing this behavior is to add another parameter to
    the evaluation relation that specifies whether evaluation of a
    command executes a <span class="inlinecode"><span class="id" title="var">BREAK</span></span> statement: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">result</span> : <span class="kt">Type</span> :=
  | SContinue
  | SBreak.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Reserved Notation</span> <span class="s2">&quot;st &#39;=[&#39; c &#39;]=&gt;&#39; st&#39; &#39;/&#39; s&quot;</span>
         (<span class="kn">at level</span> <span class="mi">40</span>, st&#39; <span class="kn">at next level</span>).</span></span></span></pre><div class="doc">
Intuitively, <span class="inlinecode"><span class="id" title="var">st</span></span> <span class="inlinecode">=[</span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">]=&gt;</span> <span class="inlinecode"><span class="id" title="var">st'</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><span class="id" title="var">s</span></span> means that, if <span class="inlinecode"><span class="id" title="var">c</span></span> is started in
    state <span class="inlinecode"><span class="id" title="var">st</span></span>, then it terminates in state <span class="inlinecode"><span class="id" title="var">st'</span></span> and either signals
    that the innermost surrounding loop (or the whole program) should
    exit immediately (<span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">SBreak</span></span>) or that execution should continue
    normally (<span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">SContinue</span></span>).

<div class="paragraph"> </div>

    The definition of the "<span class="inlinecode"><span class="id" title="var">st</span></span> <span class="inlinecode">=[</span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">]=&gt;</span> <span class="inlinecode"><span class="id" title="var">st'</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><span class="id" title="var">s</span></span>" relation is very
    similar to the one we gave above for the regular evaluation
    relation (<span class="inlinecode"><span class="id" title="var">st</span></span> <span class="inlinecode">=[</span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">]=&gt;</span> <span class="inlinecode"><span class="id" title="var">st'</span></span>) -- we just need to handle the
    termination signals appropriately:

<div class="paragraph"> </div>
<ul class="doclist">
<li> If the command is <span class="inlinecode"><span class="id" title="var">SKIP</span></span>, then the state doesn't change and
      execution of any enclosing loop can continue normally.

<div class="paragraph"> </div>
</li>
<li> If the command is <span class="inlinecode"><span class="id" title="var">BREAK</span></span>, the state stays unchanged but we
      signal a <span class="inlinecode"><span class="id" title="var">SBreak</span></span>.

<div class="paragraph"> </div>
</li>
<li> If the command is an assignment, then we update the binding for
      that variable in the state accordingly and signal that execution
      can continue normally.

<div class="paragraph"> </div>
</li>
<li> If the command is of the form <span class="inlinecode"><span class="id" title="var">TEST</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">THEN</span></span> <span class="inlinecode"><span class="id" title="var">c1</span></span> <span class="inlinecode"><span class="id" title="var">ELSE</span></span> <span class="inlinecode"><span class="id" title="var">c2</span></span> <span class="inlinecode"><span class="id" title="var">FI</span></span>, then
      the state is updated as in the original semantics of Imp, except
      that we also propagate the signal from the execution of
      whichever branch was taken.

<div class="paragraph"> </div>
</li>
<li> If the command is a sequence <span class="inlinecode"><span class="id" title="var">c1</span></span> <span class="inlinecode">;;</span> <span class="inlinecode"><span class="id" title="var">c2</span></span>, we first execute
      <span class="inlinecode"><span class="id" title="var">c1</span></span>.  If this yields a <span class="inlinecode"><span class="id" title="var">SBreak</span></span>, we skip the execution of <span class="inlinecode"><span class="id" title="var">c2</span></span>
      and propagate the <span class="inlinecode"><span class="id" title="var">SBreak</span></span> signal to the surrounding context;
      the resulting state is the same as the one obtained by
      executing <span class="inlinecode"><span class="id" title="var">c1</span></span> alone. Otherwise, we execute <span class="inlinecode"><span class="id" title="var">c2</span></span> on the state
      obtained after executing <span class="inlinecode"><span class="id" title="var">c1</span></span>, and propagate the signal
      generated there.

<div class="paragraph"> </div>
</li>
<li> Finally, for a loop of the form <span class="inlinecode"><span class="id" title="var">WHILE</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">DO</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">END</span></span>, the
      semantics is almost the same as before. The only difference is
      that, when <span class="inlinecode"><span class="id" title="var">b</span></span> evaluates to true, we execute <span class="inlinecode"><span class="id" title="var">c</span></span> and check the
      signal that it raises.  If that signal is <span class="inlinecode"><span class="id" title="var">SContinue</span></span>, then the
      execution proceeds as in the original semantics. Otherwise, we
      stop the execution of the loop, and the resulting state is the
      same as the one resulting from the execution of the current
      iteration.  In either case, since <span class="inlinecode"><span class="id" title="var">BREAK</span></span> only terminates the
      innermost loop, <span class="inlinecode"><span class="id" title="var">WHILE</span></span> signals <span class="inlinecode"><span class="id" title="var">SContinue</span></span>. 
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Based on the above description, complete the definition of the
    <span class="inlinecode"><span class="id" title="var">ceval</span></span> relation. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">ceval</span> : com -&gt; state -&gt; result -&gt; state -&gt; <span class="kt">Prop</span> :=
  | E_Skip : <span class="kr">forall</span> <span class="nv">st</span>,
      st =[ CSkip ]=&gt; st / SContinue
  <span class="c">(* FILL IN HERE *)</span>

  <span class="kn">where</span> <span class="s2">&quot;st &#39;=[&#39; c &#39;]=&gt;&#39; st&#39; &#39;/&#39; s&quot;</span> := (ceval c st s st&#39;).</span></span></span></pre><div class="doc">
Now prove the following properties of your definition of <span class="inlinecode"><span class="id" title="var">ceval</span></span>: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkf3" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkf3"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">break_ignore</span> : <span class="kr">forall</span> <span class="nv">c</span> <span class="nv">st</span> <span class="nv">st&#39;</span> <span class="nv">s</span>,
     st =[ BREAK;; c ]=&gt; st&#39; / s -&gt;
     st = st&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">c</span> : com) (<span class="nv">st</span> <span class="nv">st&#39;</span> : state) (<span class="nv">s</span> : result),
st =[ BREAK;; c ]=&gt; st&#39; / s -&gt; st = st&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkf4" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkf4"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">c</span> : com) (<span class="nv">st</span> <span class="nv">st&#39;</span> : state) (<span class="nv">s</span> : result),
st =[ BREAK;; c ]=&gt; st&#39; / s -&gt; st = st&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkf5" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkf5"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">while_continue</span> : <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">st</span> <span class="nv">st&#39;</span> <span class="nv">s</span>,
  st =[ WHILE b DO c END ]=&gt; st&#39; / s -&gt;
  s = SContinue.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">b</span> : bexp) (<span class="nv">c</span> : com) (<span class="nv">st</span> <span class="nv">st&#39;</span> : state)
  (<span class="nv">s</span> : result),
st =[ WHILE b DO c END ]=&gt; st&#39; / s -&gt; s = SContinue</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkf6" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkf6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">b</span> : bexp) (<span class="nv">c</span> : com) (<span class="nv">st</span> <span class="nv">st&#39;</span> : state)
  (<span class="nv">s</span> : result),
st =[ WHILE b DO c END ]=&gt; st&#39; / s -&gt; s = SContinue</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkf7" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkf7"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">while_stops_on_break</span> : <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">st</span> <span class="nv">st&#39;</span>,
  beval st b = true -&gt;
  st =[ c ]=&gt; st&#39; / SBreak -&gt;
  st =[ WHILE b DO c END ]=&gt; st&#39; / SContinue.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">b</span> : bexp) (<span class="nv">c</span> : com) (<span class="nv">st</span> <span class="nv">st&#39;</span> : state),
beval st b = true -&gt;
st =[ c ]=&gt; st&#39; / SBreak -&gt;
st =[ WHILE b DO c END ]=&gt; st&#39; / SContinue</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkf8" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkf8"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">b</span> : bexp) (<span class="nv">c</span> : com) (<span class="nv">st</span> <span class="nv">st&#39;</span> : state),
beval st b = true -&gt;
st =[ c ]=&gt; st&#39; / SBreak -&gt;
st =[ WHILE b DO c END ]=&gt; st&#39; / SContinue</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab54"></a><h4 class="section">Exercise: 3 stars, advanced, optional (while_break_true)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkf9" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkf9"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">while_break_true</span> : <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">st</span> <span class="nv">st&#39;</span>,
  st =[ WHILE b DO c END ]=&gt; st&#39; / SContinue -&gt;
  beval st&#39; b = true -&gt;
  <span class="kr">exists</span> <span class="nv">st&#39;&#39;</span>, st&#39;&#39; =[ c ]=&gt; st&#39; / SBreak.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">b</span> : bexp) (<span class="nv">c</span> : com) (<span class="nv">st</span> <span class="nv">st&#39;</span> : state),
st =[ WHILE b DO c END ]=&gt; st&#39; / SContinue -&gt;
beval st&#39; b = true -&gt;
<span class="kr">exists</span> <span class="nv">st&#39;&#39;</span> : state, st&#39;&#39; =[ c ]=&gt; st&#39; / SBreak</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkfa" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkfa"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">b</span> : bexp) (<span class="nv">c</span> : com) (<span class="nv">st</span> <span class="nv">st&#39;</span> : state),
st =[ WHILE b DO c END ]=&gt; st&#39; / SContinue -&gt;
beval st&#39; b = true -&gt;
<span class="kr">exists</span> <span class="nv">st&#39;&#39;</span> : state, st&#39;&#39; =[ c ]=&gt; st&#39; / SBreak</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab55"></a><h4 class="section">Exercise: 4 stars, advanced, optional (ceval_deterministic)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkfb" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkfb"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">ceval_deterministic</span>: <span class="kr">forall</span> (<span class="nv">c</span>:com) <span class="nv">st</span> <span class="nv">st1</span> <span class="nv">st2</span> <span class="nv">s1</span> <span class="nv">s2</span>,
     st =[ c ]=&gt; st1 / s1 -&gt;
     st =[ c ]=&gt; st2 / s2 -&gt;
     st1 = st2 /\ s1 = s2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">c</span> : com) (<span class="nv">st</span> <span class="nv">st1</span> <span class="nv">st2</span> : state) (<span class="nv">s1</span> <span class="nv">s2</span> : result),
st =[ c ]=&gt; st1 / s1 -&gt;
st =[ c ]=&gt; st2 / s2 -&gt; st1 = st2 /\ s1 = s2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Imp-v-chkfc" style="display: none" type="checkbox"><label class="coq-input" for="Imp-v-chkfc"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">c</span> : com) (<span class="nv">st</span> <span class="nv">st1</span> <span class="nv">st2</span> : state) (<span class="nv">s1</span> <span class="nv">s2</span> : result),
st =[ c ]=&gt; st1 / s1 -&gt;
st =[ c ]=&gt; st2 / s2 -&gt; st1 = st2 /\ s1 = s2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">BreakImp</span>.</span></span></span></pre><div class="doc">
<a name="lab56"></a><h4 class="section">Exercise: 4 stars, standard, optional (add_for_loop)</h4>
<div class="paragraph"> </div>

    Add C-style <span class="inlinecode"><span class="id" title="keyword">for</span></span> loops to the language of commands, update the
    <span class="inlinecode"><span class="id" title="var">ceval</span></span> definition to define the semantics of <span class="inlinecode"><span class="id" title="keyword">for</span></span> loops, and add
    cases for <span class="inlinecode"><span class="id" title="keyword">for</span></span> loops as needed so that all the proofs in this
    file are accepted by Coq.

<div class="paragraph"> </div>

    A <span class="inlinecode"><span class="id" title="keyword">for</span></span> loop should be parameterized by (a) a statement executed
    initially, (b) a test that is run on each iteration of the loop to
    determine whether the loop should continue, (c) a statement
    executed at the end of each loop iteration, and (d) a statement
    that makes up the body of the loop.  (You don't need to worry
    about making up a concrete Notation for <span class="inlinecode"><span class="id" title="keyword">for</span></span> loops, but feel free
    to play with this too if you like.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE </span>

<span class="c">    [] *)</span>


<span class="c">(* Wed Jan 9 12:02:46 EST 2019 *)</span></span></span></pre></article></body></html>