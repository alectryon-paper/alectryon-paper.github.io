<!DOCTYPE html>
<html><head><title>Lists.v</title><meta charset="utf-8"><meta content="Alectryon v0.2" name="generator"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet"><link href="https://unpkg.com/firacode/distr/fira_code.css" rel="stylesheet"><link href="alectryon.css" rel="stylesheet"><script src="alectryon.js"></script><style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-standalone alectryon-centered alectryon-coqdoc"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><div class="doc">
<a name="lab1"></a><h1 class="section">Lists: Working with Structured Data</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> LF <span class="kn">Require Export</span> Induction.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">NatList</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab2"></a><h1 class="section">Pairs of Numbers</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
In an <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> type definition, each constructor can take
    any number of arguments -- none (as with <span class="inlinecode"><span class="id" title="var">true</span></span> and <span class="inlinecode"><span class="id" title="var">O</span></span>), one (as
    with <span class="inlinecode"><span class="id" title="var">S</span></span>), or more than one (as with <span class="inlinecode"><span class="id" title="var">nybble</span></span>, and here): 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">natprod</span> : <span class="kt">Type</span> :=
| pair (n1 n2 : nat).</span></span></span></pre><div class="doc">
This declaration can be read: "There is just one way to
    construct a pair of numbers: by applying the constructor <span class="inlinecode"><span class="id" title="var">pair</span></span> to
    two arguments of type <span class="inlinecode"><span class="id" title="var">nat</span></span>." 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Lists-v-chk0" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk0"><span class="highlight"><span class="kn">Check</span> (pair <span class="mi">3</span> <span class="mi">5</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">pair <span class="mi">3</span> <span class="mi">5</span>
     : natprod</span></blockquote></div></div></small></span></pre><div class="doc">
Here are simple functions for extracting the first and
    second components of a pair. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">fst</span> (<span class="nv">p</span> : natprod) : nat :=
  <span class="kr">match</span> p <span class="kr">with</span>
  | pair x y =&gt; x
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">snd</span> (<span class="nv">p</span> : natprod) : nat :=
  <span class="kr">match</span> p <span class="kr">with</span>
  | pair x y =&gt; y
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Lists-v-chk1" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk1"><span class="highlight"><span class="kn">Compute</span> (fst (pair <span class="mi">3</span> <span class="mi">5</span>)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">= <span class="mi">3</span>
: nat</span></blockquote></div></div></small></span></pre><div class="doc">
Since pairs will be used heavily, it is nice to be able to
    write them with the standard mathematical notation <span class="inlinecode">(<span class="id" title="var">x</span>,<span class="id" title="var">y</span>)</span> instead
    of <span class="inlinecode"><span class="id" title="var">pair</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>.  We can tell Coq to allow this with a <span class="inlinecode"><span class="id" title="keyword">Notation</span></span>
    declaration. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x , y )&quot;</span> := (pair x y).</span></span></span></pre><div class="doc">
The new pair notation can be used both in expressions and in
    pattern matches. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="Lists-v-chk2" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk2"><span class="highlight"><span class="kn">Compute</span> (fst (<span class="mi">3</span>,<span class="mi">5</span>)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">= <span class="mi">3</span>
: nat</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">fst&#39;</span> (<span class="nv">p</span> : natprod) : nat :=
  <span class="kr">match</span> p <span class="kr">with</span>
  | (x,y) =&gt; x
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">snd&#39;</span> (<span class="nv">p</span> : natprod) : nat :=
  <span class="kr">match</span> p <span class="kr">with</span>
  | (x,y) =&gt; y
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">swap_pair</span> (<span class="nv">p</span> : natprod) : natprod :=
  <span class="kr">match</span> p <span class="kr">with</span>
  | (x,y) =&gt; (y,x)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Note that pattern-matching on a pair (with parentheses: <span class="inlinecode">(<span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">y</span>)</span>)
    is not to be confused with the "multiple pattern" syntax
    (with no parentheses: <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">y</span></span>) that we have seen previously.

<div class="paragraph"> </div>

    The above examples illustrate pattern matching on a pair with
    elements <span class="inlinecode"><span class="id" title="var">x</span></span> and <span class="inlinecode"><span class="id" title="var">y</span></span>, whereas <span class="inlinecode"><span class="id" title="var">minus</span></span> below (taken from
    <span class="inlinecode"><span class="id" title="var">Basics</span></span>) performs pattern matching on the values <span class="inlinecode"><span class="id" title="var">n</span></span>
    and <span class="inlinecode"><span class="id" title="var">m</span></span>.

<div class="paragraph"> </div>

       Fixpoint minus (n m : nat) : nat :=
         match n, m with
         | O   , _    =&gt; O
         | S _ , O    =&gt; n
         | S n', S m' =&gt; minus n' m'
         end.

<div class="paragraph"> </div>

    The distinction is minor, but it is worth knowing that they
    are not the same. For instance, the following definitions are
    ill-formed:

<div class="paragraph"> </div>

                Definition bad_fst (p : natprod) : nat :=
          match p with
          | x, y =&gt; x
          end.

<div class="paragraph"> </div>

                Definition bad_minus (n m : nat) : nat :=
          match n, m with
          | (O   , _   ) =&gt; O
          | (S _ , O   ) =&gt; n
          | (S n', S m') =&gt; bad_minus n' m'
          end.

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Let's try to prove a few simple facts about pairs.

<div class="paragraph"> </div>

    If we state things in a slightly peculiar way, we can complete
    proofs with just reflexivity (and its built-in simplification): 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk3" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk3"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">surjective_pairing&#39;</span> : <span class="kr">forall</span> (<span class="nv">n</span> <span class="nv">m</span> : nat),
  (n,m) = (fst (n,m), snd (n,m)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, (n, m) = (fst (n, m), snd (n, m))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk4" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk4"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, (n, m) = (fst (n, m), snd (n, m))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
But <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> is not enough if we state the lemma in a more
    natural way: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk5" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk5"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">surjective_pairing_stuck</span> : <span class="kr">forall</span> (<span class="nv">p</span> : natprod),
  p = (fst p, snd p).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">p</span> : natprod, p = (fst p, snd p)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk6" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">p</span> : natprod, p = (fst p, snd p)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk7" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk7"><span class="highlight"><span class="nb">simpl</span>. <span class="c">(* Doesn&#39;t reduce anything! *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">p</span> : natprod, p = (fst p, snd p)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><div class="doc">
We have to expose the structure of <span class="inlinecode"><span class="id" title="var">p</span></span> so that <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> can
    perform the pattern match in <span class="inlinecode"><span class="id" title="var">fst</span></span> and <span class="inlinecode"><span class="id" title="var">snd</span></span>.  We can do this with
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk8" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk8"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">surjective_pairing</span> : <span class="kr">forall</span> (<span class="nv">p</span> : natprod),
  p = (fst p, snd p).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">p</span> : natprod, p = (fst p, snd p)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk9" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">p</span> : natprod, p = (fst p, snd p)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chka" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chka"><span class="highlight"><span class="nb">intros</span> p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natprod</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">p = (fst p, snd p)</span></div></blockquote></div></div></small><span class="coq-wsp">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chkb" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chkb"><span class="highlight"><span class="nb">destruct</span> p <span class="kr">as</span> [n m].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(n, m) = (fst (n, m), snd (n, m))</span></div></blockquote></div></div></small><span class="coq-wsp">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chkc" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chkc"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(n, m) = (n, m)</span></div></blockquote></div></div></small><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Notice that, unlike its behavior with <span class="inlinecode"><span class="id" title="var">nat</span></span>s, where it
    generates two subgoals, <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> generates just one subgoal
    here.  That's because <span class="inlinecode"><span class="id" title="var">natprod</span></span>s can only be constructed in one
    way. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab3"></a><h4 class="section">Exercise: 1 star, standard (snd_fst_is_swap)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chkd" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chkd"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">snd_fst_is_swap</span> : <span class="kr">forall</span> (<span class="nv">p</span> : natprod),
  (snd p, fst p) = swap_pair p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">p</span> : natprod, (snd p, fst p) = swap_pair p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chke" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chke"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">p</span> : natprod, (snd p, fst p) = swap_pair p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab4"></a><h4 class="section">Exercise: 1 star, standard, optional (fst_swap_is_snd)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chkf" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chkf"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">fst_swap_is_snd</span> : <span class="kr">forall</span> (<span class="nv">p</span> : natprod),
  fst (swap_pair p) = snd p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">p</span> : natprod, fst (swap_pair p) = snd p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk10" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk10"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">p</span> : natprod, fst (swap_pair p) = snd p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab5"></a><h1 class="section">Lists of Numbers</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Generalizing the definition of pairs, we can describe the
    type of <i>lists</i> of numbers like this: "A list is either the empty
    list or else a pair of a number and another list." 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">natlist</span> : <span class="kt">Type</span> :=
  | nil
  | cons (n : nat) (l : natlist).</span></span></span></pre><div class="doc">
For example, here is a three-element list: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">mylist</span> := cons <span class="mi">1</span> (cons <span class="mi">2</span> (cons <span class="mi">3</span> nil)).</span></span></span></pre><div class="doc">
As with pairs, it is more convenient to write lists in
    familiar programming notation.  The following declarations
    allow us to use <span class="inlinecode">::</span> as an infix <span class="inlinecode"><span class="id" title="var">cons</span></span> operator and square
    brackets as an "outfix" notation for constructing lists. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x :: l&quot;</span> := (cons x l)
                     (<span class="kn">at level</span> <span class="mi">60</span>, <span class="kn">right associativity</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;[ ]&quot;</span> := nil.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;[ x ; .. ; y ]&quot;</span> := (cons x .. (cons y nil) ..).</span></span></span></pre><div class="doc">
It is not necessary to understand the details of these
    declarations, but here is roughly what's going on in case you are
    interested.  The <span class="inlinecode"><span class="id" title="tactic">right</span></span> <span class="inlinecode"><span class="id" title="keyword">associativity</span></span> annotation tells Coq how to
    parenthesize expressions involving multiple uses of <span class="inlinecode">::</span> so that,
    for example, the next three declarations mean exactly the same
    thing: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">mylist1</span> := <span class="mi">1</span> :: (<span class="mi">2</span> :: (<span class="mi">3</span> :: nil)).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">mylist2</span> := <span class="mi">1</span> :: <span class="mi">2</span> :: <span class="mi">3</span> :: nil.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">mylist3</span> := [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>].</span></span></span></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="tactic">at</span></span> <span class="inlinecode"><span class="id" title="keyword">level</span></span> <span class="inlinecode">60</span> part tells Coq how to parenthesize
    expressions that involve both <span class="inlinecode">::</span> and some other infix operator.
    For example, since we defined <span class="inlinecode">+</span> as infix notation for the <span class="inlinecode"><span class="id" title="var">plus</span></span>
    function at level 50,

<div class="paragraph"> </div>

  Notation "x + y" := (plus x y)
                      (at level 50, left associativity).

<div class="paragraph"> </div>

    the <span class="inlinecode">+</span> operator will bind tighter than <span class="inlinecode">::</span>, so <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">::</span> <span class="inlinecode">[3]</span>
    will be parsed, as we'd expect, as <span class="inlinecode">(1</span> <span class="inlinecode">+</span> <span class="inlinecode">2)</span> <span class="inlinecode">::</span> <span class="inlinecode">[3]</span> rather than
    <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">(2</span> <span class="inlinecode">::</span> <span class="inlinecode">[3])</span>.

<div class="paragraph"> </div>

    (Expressions like "<span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">::</span> <span class="inlinecode">[3]</span>" can be a little confusing when
    you read them in a <span class="inlinecode">.<span class="id" title="var">v</span></span> file.  The inner brackets, around 3, indicate
    a list, but the outer brackets, which are invisible in the HTML
    rendering, are there to instruct the "coqdoc" tool that the bracketed
    part should be displayed as Coq code rather than running text.)

<div class="paragraph"> </div>

    The second and third <span class="inlinecode"><span class="id" title="keyword">Notation</span></span> declarations above introduce the
    standard square-bracket notation for lists; the right-hand side of
    the third one illustrates Coq's syntax for declaring n-ary
    notations and translating them to nested sequences of binary
    constructors. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab6"></a><h3 class="section">Repeat</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
A number of functions are useful for manipulating lists.
    For example, the <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> function takes a number <span class="inlinecode"><span class="id" title="var">n</span></span> and a
    <span class="inlinecode"><span class="id" title="var">count</span></span> and returns a list of length <span class="inlinecode"><span class="id" title="var">count</span></span> where every element
    is <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">repeat</span> (<span class="nv">n</span> <span class="nv">count</span> : nat) : natlist :=
  <span class="kr">match</span> count <span class="kr">with</span>
  | O =&gt; nil
  | S count&#39; =&gt; n :: (<span class="kp">repeat</span> n count&#39;)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab7"></a><h3 class="section">Length</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">length</span></span> function calculates the length of a list. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">length</span> (<span class="nv">l</span>:natlist) : nat :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | nil =&gt; O
  | h :: t =&gt; S (length t)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab8"></a><h3 class="section">Append</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">app</span></span> function concatenates (appends) two lists. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">app</span> (<span class="nv">l1</span> <span class="nv">l2</span> : natlist) : natlist :=
  <span class="kr">match</span> l1 <span class="kr">with</span>
  | nil    =&gt; l2
  | h :: t =&gt; h :: (app t l2)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Since <span class="inlinecode"><span class="id" title="var">app</span></span> will be used extensively in what follows, it is
    again convenient to have an infix operator for it. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x ++ y&quot;</span> := (app x y)
                     (<span class="kn">right associativity</span>, <span class="kn">at level</span> <span class="mi">60</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk11" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk11"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_app1</span>:             [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>] ++ [<span class="mi">4</span>;<span class="mi">5</span>] = [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>;<span class="mi">4</span>;<span class="mi">5</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] ++ [<span class="mi">4</span>; <span class="mi">5</span>] = [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>; <span class="mi">5</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk12" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk12"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] ++ [<span class="mi">4</span>; <span class="mi">5</span>] = [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>; <span class="mi">5</span>]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk13" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk13"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_app2</span>:             nil ++ [<span class="mi">4</span>;<span class="mi">5</span>] = [<span class="mi">4</span>;<span class="mi">5</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[ ] ++ [<span class="mi">4</span>; <span class="mi">5</span>] = [<span class="mi">4</span>; <span class="mi">5</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk14" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk14"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[ ] ++ [<span class="mi">4</span>; <span class="mi">5</span>] = [<span class="mi">4</span>; <span class="mi">5</span>]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk15" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk15"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_app3</span>:             [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>] ++ nil = [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] ++ [ ] = [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk16" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk16"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] ++ [ ] = [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab9"></a><h3 class="section">Head (With Default) and Tail</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Here are two smaller examples of programming with lists.
    The <span class="inlinecode"><span class="id" title="var">hd</span></span> function returns the first element (the "head") of the
    list, while <span class="inlinecode"><span class="id" title="var">tl</span></span> returns everything but the first element (the
    "tail").  Since the empty list has no first element, we must pass
    a default value to be returned in that case.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">hd</span> (<span class="nv">default</span>:nat) (<span class="nv">l</span>:natlist) : nat :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | nil =&gt; default
  | h :: t =&gt; h
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">tl</span> (<span class="nv">l</span>:natlist) : natlist :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | nil =&gt; nil
  | h :: t =&gt; t
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk17" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk17"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_hd1</span>:             hd <span class="mi">0</span> [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>] = <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hd <span class="mi">0</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk18" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk18"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hd <span class="mi">0</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk19" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk19"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_hd2</span>:             hd <span class="mi">0</span> [] = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hd <span class="mi">0</span> [ ] = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk1a" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk1a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hd <span class="mi">0</span> [ ] = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk1b"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_tl</span>:              tl [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>] = [<span class="mi">2</span>;<span class="mi">3</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tl [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] = [<span class="mi">2</span>; <span class="mi">3</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk1c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tl [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] = [<span class="mi">2</span>; <span class="mi">3</span>]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab10"></a><h3 class="section">Exercises</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab11"></a><h4 class="section">Exercise: 2 stars, standard, recommended (list_funs)</h4>
<div class="paragraph"> </div>

    Complete the definitions of <span class="inlinecode"><span class="id" title="var">nonzeros</span></span>, <span class="inlinecode"><span class="id" title="var">oddmembers</span></span>, and
    <span class="inlinecode"><span class="id" title="var">countoddmembers</span></span> below. Have a look at the tests to understand
    what these functions should do. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk1d" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk1d"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">nonzeros</span> (<span class="nv">l</span>:natlist) : natlist
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">nonzeros</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist -&gt; natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">natlist</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk1e"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_nonzeros</span>:
  nonzeros [<span class="mi">0</span>;<span class="mi">1</span>;<span class="mi">0</span>;<span class="mi">2</span>;<span class="mi">3</span>;<span class="mi">0</span>;<span class="mi">0</span>] = [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nonzeros [<span class="mi">0</span>; <span class="mi">1</span>; <span class="mi">0</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">0</span>; <span class="mi">0</span>] = [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk1f"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">oddmembers</span> (<span class="nv">l</span>:natlist) : natlist
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">oddmembers</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist -&gt; natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">natlist</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk20" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk20"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_oddmembers</span>:
  oddmembers [<span class="mi">0</span>;<span class="mi">1</span>;<span class="mi">0</span>;<span class="mi">2</span>;<span class="mi">3</span>;<span class="mi">0</span>;<span class="mi">0</span>] = [<span class="mi">1</span>;<span class="mi">3</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">oddmembers [<span class="mi">0</span>; <span class="mi">1</span>; <span class="mi">0</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">0</span>; <span class="mi">0</span>] = [<span class="mi">1</span>; <span class="mi">3</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk21" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk21"><span class="highlight"><span class="kn">Definition</span> <span class="nf">countoddmembers</span> (<span class="nv">l</span>:natlist) : nat
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nat</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk22" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk22"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_countoddmembers1</span>:
  countoddmembers [<span class="mi">1</span>;<span class="mi">0</span>;<span class="mi">3</span>;<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">5</span>] = <span class="mi">4</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">countoddmembers [<span class="mi">1</span>; <span class="mi">0</span>; <span class="mi">3</span>; <span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">5</span>] = <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk23" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk23"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_countoddmembers2</span>:
  countoddmembers [<span class="mi">0</span>;<span class="mi">2</span>;<span class="mi">4</span>] = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">countoddmembers [<span class="mi">0</span>; <span class="mi">2</span>; <span class="mi">4</span>] = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk24" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk24"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_countoddmembers3</span>:
  countoddmembers nil = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">countoddmembers [ ] = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab12"></a><h4 class="section">Exercise: 3 stars, advanced (alternate)</h4>
<div class="paragraph"> </div>

    Complete the definition of <span class="inlinecode"><span class="id" title="var">alternate</span></span>, which interleaves two
    lists into one, alternating between elements taken from the first
    list and elements from the second.  See the tests below for more
    specific examples.

<div class="paragraph"> </div>

    (Note: one natural and elegant way of writing <span class="inlinecode"><span class="id" title="var">alternate</span></span> will
    fail to satisfy Coq's requirement that all <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> definitions
    be "obviously terminating."  If you find yourself in this rut,
    look for a slightly more verbose solution that considers elements
    of both lists at the same time.  One possible solution involves
    defining a new kind of pairs, but this is not the only way.)  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk25" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk25"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">alternate</span> (<span class="nv">l1</span> <span class="nv">l2</span> : natlist) : natlist
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">alternate</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist -&gt; natlist -&gt; natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1, l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">natlist</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk26" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk26"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_alternate1</span>:
  alternate [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>] [<span class="mi">4</span>;<span class="mi">5</span>;<span class="mi">6</span>] = [<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">2</span>;<span class="mi">5</span>;<span class="mi">3</span>;<span class="mi">6</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">alternate [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>] = [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">5</span>; <span class="mi">3</span>; <span class="mi">6</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk27" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk27"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_alternate2</span>:
  alternate [<span class="mi">1</span>] [<span class="mi">4</span>;<span class="mi">5</span>;<span class="mi">6</span>] = [<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">5</span>;<span class="mi">6</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">alternate [<span class="mi">1</span>] [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>] = [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk28" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk28"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_alternate3</span>:
  alternate [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>] [<span class="mi">4</span>] = [<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">2</span>;<span class="mi">3</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">alternate [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">4</span>] = [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">3</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk29" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk29"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_alternate4</span>:
  alternate [] [<span class="mi">20</span>;<span class="mi">30</span>] = [<span class="mi">20</span>;<span class="mi">30</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">alternate [ ] [<span class="mi">20</span>; <span class="mi">30</span>] = [<span class="mi">20</span>; <span class="mi">30</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab13"></a><h3 class="section">Bags via Lists</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
A <span class="inlinecode"><span class="id" title="var">bag</span></span> (or <span class="inlinecode"><span class="id" title="var">multiset</span></span>) is like a set, except that each element
    can appear multiple times rather than just once.  One possible
    representation for a bag of numbers is as a list. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">bag</span> := natlist.</span></span></span></pre><div class="doc">
<a name="lab14"></a><h4 class="section">Exercise: 3 stars, standard, recommended (bag_functions)</h4>
<div class="paragraph"> </div>

    Complete the following definitions for the functions
    <span class="inlinecode"><span class="id" title="var">count</span></span>, <span class="inlinecode"><span class="id" title="var">sum</span></span>, <span class="inlinecode"><span class="id" title="var">add</span></span>, and <span class="inlinecode"><span class="id" title="var">member</span></span> for bags. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk2a" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk2a"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">count</span> (<span class="nv">v</span>:nat) (<span class="nv">s</span>:bag) : nat
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">count</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; bag -&gt; nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bag</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nat</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
All these proofs can be done just by <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk2b" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk2b"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_count1</span>:              count <span class="mi">1</span> [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>;<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">1</span>] = <span class="mi">3</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">count <span class="mi">1</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">1</span>] = <span class="mi">3</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk2c" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk2c"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_count2</span>:              count <span class="mi">6</span> [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>;<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">1</span>] = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">count <span class="mi">6</span> [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">1</span>] = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
Multiset <span class="inlinecode"><span class="id" title="var">sum</span></span> is similar to set <span class="inlinecode"><span class="id" title="var">union</span></span>: <span class="inlinecode"><span class="id" title="var">sum</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> contains all
    the elements of <span class="inlinecode"><span class="id" title="var">a</span></span> and of <span class="inlinecode"><span class="id" title="var">b</span></span>.  (Mathematicians usually define
    <span class="inlinecode"><span class="id" title="var">union</span></span> on multisets a little bit differently -- using max instead
    of sum -- which is why we don't use that name for this operation.)
    For <span class="inlinecode"><span class="id" title="var">sum</span></span> we're giving you a header that does not give explicit
    names to the arguments.  Moreover, it uses the keyword
    <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> instead of <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>, so even if you had names for
    the arguments, you wouldn't be able to process them recursively.
    The point of stating the question this way is to encourage you to
    think about whether <span class="inlinecode"><span class="id" title="var">sum</span></span> can be implemented in another way --
    perhaps by using functions that have already been defined.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk2d" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk2d"><span class="highlight"><span class="kn">Definition</span> <span class="nf">sum</span> : bag -&gt; bag -&gt; bag
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">bag -&gt; bag -&gt; bag</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk2e"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_sum1</span>:              count <span class="mi">1</span> (sum [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>] [<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">1</span>]) = <span class="mi">3</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">count <span class="mi">1</span> (sum [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">1</span>]) = <span class="mi">3</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk2f" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk2f"><span class="highlight"><span class="kn">Definition</span> <span class="nf">add</span> (<span class="nv">v</span>:nat) (<span class="nv">s</span>:bag) : bag
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bag</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">bag</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk30" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk30"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_add1</span>:                count <span class="mi">1</span> (add <span class="mi">1</span> [<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">1</span>]) = <span class="mi">3</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">count <span class="mi">1</span> (add <span class="mi">1</span> [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">1</span>]) = <span class="mi">3</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk31" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk31"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_add2</span>:                count <span class="mi">5</span> (add <span class="mi">1</span> [<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">1</span>]) = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">count <span class="mi">5</span> (add <span class="mi">1</span> [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">1</span>]) = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk32" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk32"><span class="highlight"><span class="kn">Definition</span> <span class="nf">member</span> (<span class="nv">v</span>:nat) (<span class="nv">s</span>:bag) : bool
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bag</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">bool</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk33" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk33"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_member1</span>:             member <span class="mi">1</span> [<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">1</span>] = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">member <span class="mi">1</span> [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">1</span>] = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk34" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk34"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_member2</span>:             member <span class="mi">2</span> [<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">1</span>] = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">member <span class="mi">2</span> [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">1</span>] = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab15"></a><h4 class="section">Exercise: 3 stars, standard, optional (bag_more_functions)</h4>
<div class="paragraph"> </div>

    Here are some more <span class="inlinecode"><span class="id" title="var">bag</span></span> functions for you to practice with. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
When <span class="inlinecode"><span class="id" title="var">remove_one</span></span> is applied to a bag without the number to
    remove, it should return the same bag unchanged.  (This exercise
    is optional, but students following the advanced track will need
    to fill in the definition of <span class="inlinecode"><span class="id" title="var">remove_one</span></span> for a later
    exercise.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk35" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk35"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">remove_one</span> (<span class="nv">v</span>:nat) (<span class="nv">s</span>:bag) : bag
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">remove_one</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; bag -&gt; bag</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bag</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">bag</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk36" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk36"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_remove_one1</span>:
  count <span class="mi">5</span> (remove_one <span class="mi">5</span> [<span class="mi">2</span>;<span class="mi">1</span>;<span class="mi">5</span>;<span class="mi">4</span>;<span class="mi">1</span>]) = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">count <span class="mi">5</span> (remove_one <span class="mi">5</span> [<span class="mi">2</span>; <span class="mi">1</span>; <span class="mi">5</span>; <span class="mi">4</span>; <span class="mi">1</span>]) = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk37" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk37"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_remove_one2</span>:
  count <span class="mi">5</span> (remove_one <span class="mi">5</span> [<span class="mi">2</span>;<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">1</span>]) = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">count <span class="mi">5</span> (remove_one <span class="mi">5</span> [<span class="mi">2</span>; <span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">1</span>]) = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk38" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk38"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_remove_one3</span>:
  count <span class="mi">4</span> (remove_one <span class="mi">5</span> [<span class="mi">2</span>;<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">5</span>;<span class="mi">1</span>;<span class="mi">4</span>]) = <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">count <span class="mi">4</span> (remove_one <span class="mi">5</span> [<span class="mi">2</span>; <span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">1</span>; <span class="mi">4</span>]) = <span class="mi">2</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk39" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk39"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_remove_one4</span>:
  count <span class="mi">5</span> (remove_one <span class="mi">5</span> [<span class="mi">2</span>;<span class="mi">1</span>;<span class="mi">5</span>;<span class="mi">4</span>;<span class="mi">5</span>;<span class="mi">1</span>;<span class="mi">4</span>]) = <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">count <span class="mi">5</span> (remove_one <span class="mi">5</span> [<span class="mi">2</span>; <span class="mi">1</span>; <span class="mi">5</span>; <span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">1</span>; <span class="mi">4</span>]) = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk3a" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk3a"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">remove_all</span> (<span class="nv">v</span>:nat) (<span class="nv">s</span>:bag) : bag
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">remove_all</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; bag -&gt; bag</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bag</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">bag</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk3b" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk3b"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_remove_all1</span>:  count <span class="mi">5</span> (remove_all <span class="mi">5</span> [<span class="mi">2</span>;<span class="mi">1</span>;<span class="mi">5</span>;<span class="mi">4</span>;<span class="mi">1</span>]) = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">count <span class="mi">5</span> (remove_all <span class="mi">5</span> [<span class="mi">2</span>; <span class="mi">1</span>; <span class="mi">5</span>; <span class="mi">4</span>; <span class="mi">1</span>]) = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk3c" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk3c"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_remove_all2</span>:  count <span class="mi">5</span> (remove_all <span class="mi">5</span> [<span class="mi">2</span>;<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">1</span>]) = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">count <span class="mi">5</span> (remove_all <span class="mi">5</span> [<span class="mi">2</span>; <span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">1</span>]) = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk3d" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk3d"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_remove_all3</span>:  count <span class="mi">4</span> (remove_all <span class="mi">5</span> [<span class="mi">2</span>;<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">5</span>;<span class="mi">1</span>;<span class="mi">4</span>]) = <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">count <span class="mi">4</span> (remove_all <span class="mi">5</span> [<span class="mi">2</span>; <span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">1</span>; <span class="mi">4</span>]) = <span class="mi">2</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk3e" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk3e"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_remove_all4</span>:  count <span class="mi">5</span> (remove_all <span class="mi">5</span> [<span class="mi">2</span>;<span class="mi">1</span>;<span class="mi">5</span>;<span class="mi">4</span>;<span class="mi">5</span>;<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">5</span>;<span class="mi">1</span>;<span class="mi">4</span>]) = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">count <span class="mi">5</span> (remove_all <span class="mi">5</span> [<span class="mi">2</span>; <span class="mi">1</span>; <span class="mi">5</span>; <span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">1</span>; <span class="mi">4</span>]) =
<span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk3f" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk3f"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">subset</span> (<span class="nv">s1</span>:bag) (<span class="nv">s2</span>:bag) : bool
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">subset</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bag -&gt; bag -&gt; bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bag</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">bool</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk40" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk40"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_subset1</span>:              subset [<span class="mi">1</span>;<span class="mi">2</span>] [<span class="mi">2</span>;<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">1</span>] = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">subset [<span class="mi">1</span>; <span class="mi">2</span>] [<span class="mi">2</span>; <span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">1</span>] = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk41" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk41"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_subset2</span>:              subset [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">2</span>] [<span class="mi">2</span>;<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">1</span>] = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">subset [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">2</span>] [<span class="mi">2</span>; <span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">1</span>] = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab16"></a><h4 class="section">Exercise: 2 stars, standard, recommended (bag_theorem)</h4>
<div class="paragraph"> </div>

    Write down an interesting theorem <span class="inlinecode"><span class="id" title="var">bag_theorem</span></span> about bags
    involving the functions <span class="inlinecode"><span class="id" title="var">count</span></span> and <span class="inlinecode"><span class="id" title="var">add</span></span>, and prove it.  Note
    that, since this problem is somewhat open-ended, it's possible
    that you may come up with a theorem which is true, but whose proof
    requires techniques you haven't learned yet.  Feel free to ask for
    help if you get stuck! 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(*</span>
<span class="c">Theorem bag_theorem : ...</span>
<span class="c">Proof.</span>
<span class="c">  ...</span>
<span class="c">Qed.</span>
<span class="c">*)</span>

<span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_bag_theorem</span> : option (nat*string) := None.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* Note to instructors: For silly technical reasons, in this</span>
<span class="c">   file (only) you will need to write [Some (Datatypes.pair 3 &quot;&quot;%string)]</span>
<span class="c">   rather than [Some (3,&quot;&quot;%string)] to enter your grade and comments. </span>

<span class="c">    [] *)</span>

<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab17"></a><h1 class="section">Reasoning About Lists</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
As for numbers, simple facts about list-processing functions
    can sometimes be proved entirely by simplification.  For example,
    the simplification performed by <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> is enough for this
    theorem... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk42" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk42"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">nil_app</span> : <span class="kr">forall</span> <span class="nv">l</span>:natlist,
  [] ++ l = l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : natlist, [ ] ++ l = l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk43" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk43"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : natlist, [ ] ++ l = l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
...because the <span class="inlinecode">[]</span> is substituted into the
    "scrutinee" (the expression whose value is being "scrutinized" by
    the match) in the definition of <span class="inlinecode"><span class="id" title="var">app</span></span>, allowing the match itself
    to be simplified. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Also, as with numbers, it is sometimes helpful to perform case
    analysis on the possible shapes (empty or non-empty) of an unknown
    list. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk44" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk44"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">tl_length_pred</span> : <span class="kr">forall</span> <span class="nv">l</span>:natlist,
  pred (length l) = length (tl l).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : natlist,
Nat.pred (length l) = length (tl l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk45" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk45"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : natlist,
Nat.pred (length l) = length (tl l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk46" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk46"><span class="highlight"><span class="nb">intros</span> l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Nat.pred (length l) = length (tl l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk47" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk47"><span class="highlight"><span class="nb">destruct</span> l <span class="kr">as</span> [| n l&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Nat.pred (length [ ]) = length (tl [ ])</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Lists-v-chk48" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Lists-v-chk48"><hr></label><div class="goal-conclusion"><span class="highlight">Nat.pred (length (n :: l&#39;)) = length (tl (n :: l&#39;))</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk49" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk49"><span class="highlight">- <span class="c">(* l = nil *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Nat.pred (length [ ]) = length (tl [ ])</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk4a" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk4a"><span class="highlight">- <span class="c">(* l = cons n l&#39; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Nat.pred (length (n :: l&#39;)) = length (tl (n :: l&#39;))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Here, the <span class="inlinecode"><span class="id" title="var">nil</span></span> case works because we've chosen to define
    <span class="inlinecode"><span class="id" title="var">tl</span></span> <span class="inlinecode"><span class="id" title="var">nil</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">nil</span></span>. Notice that the <span class="inlinecode"><span class="id" title="keyword">as</span></span> annotation on the <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>
    tactic here introduces two names, <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">l'</span></span>, corresponding to
    the fact that the <span class="inlinecode"><span class="id" title="var">cons</span></span> constructor for lists takes two
    arguments (the head and tail of the list it is constructing). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Usually, though, interesting theorems about lists require
    induction for their proofs. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab18"></a><h3 class="section">Micro-Sermon</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Simply <i>reading</i> proof scripts will not get you very far!  It is
    important to step through the details of each one using Coq and
    think about what each step achieves.  Otherwise it is more or less
    guaranteed that the exercises will make no sense when you get to
    them.  'Nuff said. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab19"></a><h2 class="section">Induction on Lists</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Proofs by induction over datatypes like <span class="inlinecode"><span class="id" title="var">natlist</span></span> are a
    little less familiar than standard natural number induction, but
    the idea is equally simple.  Each <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> declaration defines
    a set of data values that can be built up using the declared
    constructors: a boolean can be either <span class="inlinecode"><span class="id" title="var">true</span></span> or <span class="inlinecode"><span class="id" title="var">false</span></span>; a number
    can be either <span class="inlinecode"><span class="id" title="var">O</span></span> or <span class="inlinecode"><span class="id" title="var">S</span></span> applied to another number; a list can be
    either <span class="inlinecode"><span class="id" title="var">nil</span></span> or <span class="inlinecode"><span class="id" title="var">cons</span></span> applied to a number and a list.

<div class="paragraph"> </div>

    Moreover, applications of the declared constructors to one another
    are the <i>only</i> possible shapes that elements of an inductively
    defined set can have, and this fact directly gives rise to a way
    of reasoning about inductively defined sets: a number is either
    <span class="inlinecode"><span class="id" title="var">O</span></span> or else it is <span class="inlinecode"><span class="id" title="var">S</span></span> applied to some <i>smaller</i> number; a list is
    either <span class="inlinecode"><span class="id" title="var">nil</span></span> or else it is <span class="inlinecode"><span class="id" title="var">cons</span></span> applied to some number and some
    <i>smaller</i> list; etc. So, if we have in mind some proposition <span class="inlinecode"><span class="id" title="var">P</span></span>
    that mentions a list <span class="inlinecode"><span class="id" title="var">l</span></span> and we want to argue that <span class="inlinecode"><span class="id" title="var">P</span></span> holds for
    <i>all</i> lists, we can reason as follows:

<div class="paragraph"> </div>
<ul class="doclist">
<li> First, show that <span class="inlinecode"><span class="id" title="var">P</span></span> is true of <span class="inlinecode"><span class="id" title="var">l</span></span> when <span class="inlinecode"><span class="id" title="var">l</span></span> is <span class="inlinecode"><span class="id" title="var">nil</span></span>.

<div class="paragraph"> </div>
</li>
<li> Then show that <span class="inlinecode"><span class="id" title="var">P</span></span> is true of <span class="inlinecode"><span class="id" title="var">l</span></span> when <span class="inlinecode"><span class="id" title="var">l</span></span> is <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">l'</span></span> for
        some number <span class="inlinecode"><span class="id" title="var">n</span></span> and some smaller list <span class="inlinecode"><span class="id" title="var">l'</span></span>, assuming that <span class="inlinecode"><span class="id" title="var">P</span></span>
        is true for <span class="inlinecode"><span class="id" title="var">l'</span></span>.

</li>
</ul>
<div class="paragraph"> </div>

    Since larger lists can only be built up from smaller ones,
    eventually reaching <span class="inlinecode"><span class="id" title="var">nil</span></span>, these two arguments together establish
    the truth of <span class="inlinecode"><span class="id" title="var">P</span></span> for all lists <span class="inlinecode"><span class="id" title="var">l</span></span>.  Here's a concrete example: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk4b" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk4b"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">app_assoc</span> : <span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : natlist,
  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : natlist,
(l1 ++ l2) ++ l3 = l1 ++ l2 ++ l3</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk4c" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk4c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : natlist,
(l1 ++ l2) ++ l3 = l1 ++ l2 ++ l3</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk4d" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk4d"><span class="highlight"><span class="nb">intros</span> l1 l2 l3.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l1, l2, l3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(l1 ++ l2) ++ l3 = l1 ++ l2 ++ l3</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk4e" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk4e"><span class="highlight"><span class="nb">induction</span> l1 <span class="kr">as</span> [| n l1&#39; IHl1&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l2, l3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">([ ] ++ l2) ++ l3 = [ ] ++ l2 ++ l3</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Lists-v-chk4f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1', l2, l3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(l1&#39; ++ l2) ++ l3 = l1&#39; ++ l2 ++ l3</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Lists-v-chk4f"><hr></label><div class="goal-conclusion"><span class="highlight">((n :: l1&#39;) ++ l2) ++ l3 = (n :: l1&#39;) ++ l2 ++ l3</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk50" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk50"><span class="highlight">- <span class="c">(* l1 = nil *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l2, l3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">([ ] ++ l2) ++ l3 = [ ] ++ l2 ++ l3</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk51" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk51"><span class="highlight">- <span class="c">(* l1 = cons n l1&#39; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1', l2, l3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(l1&#39; ++ l2) ++ l3 = l1&#39; ++ l2 ++ l3</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((n :: l1&#39;) ++ l2) ++ l3 = (n :: l1&#39;) ++ l2 ++ l3</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk52" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk52"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1', l2, l3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(l1&#39; ++ l2) ++ l3 = l1&#39; ++ l2 ++ l3</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n :: (l1&#39; ++ l2) ++ l3 = n :: l1&#39; ++ l2 ++ l3</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk53" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk53"><span class="highlight"><span class="nb">rewrite</span> -&gt; IHl1&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1', l2, l3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(l1&#39; ++ l2) ++ l3 = l1&#39; ++ l2 ++ l3</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n :: l1&#39; ++ l2 ++ l3 = n :: l1&#39; ++ l2 ++ l3</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Notice that, as when doing induction on natural numbers, the
    <span class="inlinecode"><span class="id" title="keyword">as</span>...</span> clause provided to the <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic gives a name to
    the induction hypothesis corresponding to the smaller list <span class="inlinecode"><span class="id" title="var">l1'</span></span>
    in the <span class="inlinecode"><span class="id" title="var">cons</span></span> case. Once again, this Coq proof is not especially
    illuminating as a static document -- it is easy to see what's
    going on if you are reading the proof in an interactive Coq
    session and you can see the current goal and context at each
    point, but this state is not visible in the written-down parts of
    the Coq proof.  So a natural-language proof -- one written for
    human readers -- will need to include more explicit signposts; in
    particular, it will help the reader stay oriented if we remind
    them exactly what the induction hypothesis is in the second
    case. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
For comparison, here is an informal proof of the same theorem. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<i>Theorem</i>: For all lists <span class="inlinecode"><span class="id" title="var">l1</span></span>, <span class="inlinecode"><span class="id" title="var">l2</span></span>, and <span class="inlinecode"><span class="id" title="var">l3</span></span>,
   <span class="inlinecode">(<span class="id" title="var">l1</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">l2</span>)</span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">l3</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">++</span> <span class="inlinecode">(<span class="id" title="var">l2</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">l3</span>)</span>.

<div class="paragraph"> </div>
<i>Proof</i>: By induction on <span class="inlinecode"><span class="id" title="var">l1</span></span>.

<div class="paragraph"> </div>
<ul class="doclist">
<li> First, suppose <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>.  We must show

<div class="paragraph"> </div>

       (<font size="-2">‚òê</font> ++ l2) ++ l3 = <font size="-2">‚òê</font> ++ (l2 ++ l3),

<div class="paragraph"> </div>

     which follows directly from the definition of <span class="inlinecode">++</span>.

<div class="paragraph"> </div>
</li>
<li> Next, suppose <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>::<span class="id" title="var">l1'</span></span>, with

<div class="paragraph"> </div>

       (l1' ++ l2) ++ l3 = l1' ++ (l2 ++ l3)

<div class="paragraph"> </div>

     (the induction hypothesis). We must show

<div class="paragraph"> </div>

       ((n :: l1') ++ l2) ++ l3 = (n :: l1') ++ (l2 ++ l3).

<div class="paragraph"> </div>

     By the definition of <span class="inlinecode">++</span>, this follows from

<div class="paragraph"> </div>

       n :: ((l1' ++ l2) ++ l3) = n :: (l1' ++ (l2 ++ l3)),

<div class="paragraph"> </div>

     which is immediate from the induction hypothesis.  <font size="-2">‚òê</font>
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab20"></a><h3 class="section">Reversing a List</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
For a slightly more involved example of inductive proof over
    lists, suppose we use <span class="inlinecode"><span class="id" title="var">app</span></span> to define a list-reversing function
    <span class="inlinecode"><span class="id" title="var">rev</span></span>: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">rev</span> (<span class="nv">l</span>:natlist) : natlist :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | nil    =&gt; nil
  | h :: t =&gt; rev t ++ [h]
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk54" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk54"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_rev1</span>:            rev [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>] = [<span class="mi">3</span>;<span class="mi">2</span>;<span class="mi">1</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">rev [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] = [<span class="mi">3</span>; <span class="mi">2</span>; <span class="mi">1</span>]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk55" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk55"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">rev [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] = [<span class="mi">3</span>; <span class="mi">2</span>; <span class="mi">1</span>]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk56" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk56"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_rev2</span>:            rev nil = nil.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">rev [ ] = [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk57" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk57"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">rev [ ] = [ ]</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ----------------------------------------------------------------- *)</span></span></span></pre><div class="doc">
<a name="lab21"></a><h3 class="section">Properties of <span class="inlinecode"><span class="id" title="var">rev</span></span></h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Now, for something a bit more challenging than the proofs
    we've seen so far, let's prove that reversing a list does not
    change its length.  Our first attempt gets stuck in the successor
    case... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk58" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk58"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">rev_length_firsttry</span> : <span class="kr">forall</span> <span class="nv">l</span> : natlist,
  length (rev l) = length l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : natlist, length (rev l) = length l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk59" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk59"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : natlist, length (rev l) = length l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk5a" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk5a"><span class="highlight"><span class="nb">intros</span> l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length (rev l) = length l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk5b" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk5b"><span class="highlight"><span class="nb">induction</span> l <span class="kr">as</span> [| n l&#39; IHl&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length (rev [ ]) = length [ ]</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Lists-v-chk5c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length (rev l&#39;) = length l&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Lists-v-chk5c"><hr></label><div class="goal-conclusion"><span class="highlight">length (rev (n :: l&#39;)) = length (n :: l&#39;)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk5d" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk5d"><span class="highlight">- <span class="c">(* l = [] *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length (rev [ ]) = length [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk5e" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk5e"><span class="highlight">- <span class="c">(* l = n :: l&#39; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length (rev l&#39;) = length l&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length (rev (n :: l&#39;)) = length (n :: l&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">    <span class="c">(* This is the tricky case.  Let&#39;s begin as usual</span>
<span class="c">       by simplifying. *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk5f" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk5f"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length (rev l&#39;) = length l&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length (rev l&#39; ++ [n]) = S (length l&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">    <span class="c">(* Now we seem to be stuck: the goal is an equality</span>
<span class="c">       involving [++], but we don&#39;t have any useful equations</span>
<span class="c">       in either the immediate context or in the global</span>
<span class="c">       environment!  We can make a little progress by using</span>
<span class="c">       the IH to rewrite the goal... *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk60" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk60"><span class="highlight"><span class="nb">rewrite</span> &lt;- IHl&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length (rev l&#39;) = length l&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length (rev l&#39; ++ [n]) = S (length (rev l&#39;))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">    <span class="c">(* ... but now we can&#39;t go any further. *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><div class="doc">
So let's take the equation relating <span class="inlinecode">++</span> and <span class="inlinecode"><span class="id" title="var">length</span></span> that
    would have enabled us to make progress and state it as a separate
    lemma. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk61" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk61"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">app_length</span> : <span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : natlist,
  length (l1 ++ l2) = (length l1) + (length l2).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : natlist,
length (l1 ++ l2) = length l1 + length l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk62" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk62"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : natlist,
length (l1 ++ l2) = length l1 + length l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* WORKED IN CLASS *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk63" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk63"><span class="highlight"><span class="nb">intros</span> l1 l2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l1, l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length (l1 ++ l2) = length l1 + length l2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk64" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk64"><span class="highlight"><span class="nb">induction</span> l1 <span class="kr">as</span> [| n l1&#39; IHl1&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length ([ ] ++ l2) = length [ ] + length l2</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Lists-v-chk65" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1', l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length (l1&#39; ++ l2) = length l1&#39; + length l2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Lists-v-chk65"><hr></label><div class="goal-conclusion"><span class="highlight">length ((n :: l1&#39;) ++ l2) =
length (n :: l1&#39;) + length l2</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk66" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk66"><span class="highlight">- <span class="c">(* l1 = nil *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length ([ ] ++ l2) = length [ ] + length l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk67" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk67"><span class="highlight">- <span class="c">(* l1 = cons *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1', l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length (l1&#39; ++ l2) = length l1&#39; + length l2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length ((n :: l1&#39;) ++ l2) =
length (n :: l1&#39;) + length l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk68" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk68"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1', l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length (l1&#39; ++ l2) = length l1&#39; + length l2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">S (length (l1&#39; ++ l2)) = S (length l1&#39; + length l2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk69" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk69"><span class="highlight"><span class="nb">rewrite</span> -&gt; IHl1&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1', l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length (l1&#39; ++ l2) = length l1&#39; + length l2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">S (length l1&#39; + length l2) =
S (length l1&#39; + length l2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Note that, to make the lemma as general as possible, we
    quantify over <i>all</i> <span class="inlinecode"><span class="id" title="var">natlist</span></span>s, not just those that result from an
    application of <span class="inlinecode"><span class="id" title="var">rev</span></span>.  This should seem natural, because the truth
    of the goal clearly doesn't depend on the list having been
    reversed.  Moreover, it is easier to prove the more general
    property. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Now we can complete the original proof. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk6a" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk6a"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">rev_length</span> : <span class="kr">forall</span> <span class="nv">l</span> : natlist,
  length (rev l) = length l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : natlist, length (rev l) = length l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk6b" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk6b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : natlist, length (rev l) = length l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk6c" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk6c"><span class="highlight"><span class="nb">intros</span> l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length (rev l) = length l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk6d" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk6d"><span class="highlight"><span class="nb">induction</span> l <span class="kr">as</span> [| n l&#39; IHl&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length (rev [ ]) = length [ ]</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Lists-v-chk6e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length (rev l&#39;) = length l&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Lists-v-chk6e"><hr></label><div class="goal-conclusion"><span class="highlight">length (rev (n :: l&#39;)) = length (n :: l&#39;)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk6f" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk6f"><span class="highlight">- <span class="c">(* l = nil *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length (rev [ ]) = length [ ]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk70" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk70"><span class="highlight">- <span class="c">(* l = cons *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length (rev l&#39;) = length l&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length (rev (n :: l&#39;)) = length (n :: l&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk71" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk71"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length (rev l&#39;) = length l&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length (rev l&#39; ++ [n]) = S (length l&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk72" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk72"><span class="highlight"><span class="nb">rewrite</span> -&gt; app_length, plus_comm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length (rev l&#39;) = length l&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">length [n] + length (rev l&#39;) = S (length l&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk73" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk73"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length (rev l&#39;) = length l&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">S (length (rev l&#39;)) = S (length l&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk74" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk74"><span class="highlight"><span class="nb">rewrite</span> -&gt; IHl&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length (rev l&#39;) = length l&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">S (length l&#39;) = S (length l&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
For comparison, here are informal proofs of these two theorems:

<div class="paragraph"> </div>
<i>Theorem</i>: For all lists <span class="inlinecode"><span class="id" title="var">l1</span></span> and <span class="inlinecode"><span class="id" title="var">l2</span></span>,
       <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">l1</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">l2</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l2</span></span>.

<div class="paragraph"> </div>
<i>Proof</i>: By induction on <span class="inlinecode"><span class="id" title="var">l1</span></span>.

<div class="paragraph"> </div>
<ul class="doclist">
<li> First, suppose <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>.  We must show

<div class="paragraph"> </div>

        length (<font size="-2">‚òê</font> ++ l2) = length <font size="-2">‚òê</font> + length l2,

<div class="paragraph"> </div>

      which follows directly from the definitions of
      <span class="inlinecode"><span class="id" title="var">length</span></span> and <span class="inlinecode">++</span>.

<div class="paragraph"> </div>
</li>
<li> Next, suppose <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>::<span class="id" title="var">l1'</span></span>, with

<div class="paragraph"> </div>

        length (l1' ++ l2) = length l1' + length l2.

<div class="paragraph"> </div>

      We must show

<div class="paragraph"> </div>

        length ((n::l1') ++ l2) = length (n::l1') + length l2).

<div class="paragraph"> </div>

      This follows directly from the definitions of <span class="inlinecode"><span class="id" title="var">length</span></span> and <span class="inlinecode">++</span>
      together with the induction hypothesis. <font size="-2">‚òê</font>
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<i>Theorem</i>: For all lists <span class="inlinecode"><span class="id" title="var">l</span></span>, <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">rev</span></span> <span class="inlinecode"><span class="id" title="var">l</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span>.

<div class="paragraph"> </div>
<i>Proof</i>: By induction on <span class="inlinecode"><span class="id" title="var">l</span></span>.

<div class="paragraph"> </div>
<ul class="doclist">
<li> First, suppose <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>.  We must show

<div class="paragraph"> </div>

          length (rev <font size="-2">‚òê</font>) = length <font size="-2">‚òê</font>,

<div class="paragraph"> </div>

        which follows directly from the definitions of <span class="inlinecode"><span class="id" title="var">length</span></span>
        and <span class="inlinecode"><span class="id" title="var">rev</span></span>.

<div class="paragraph"> </div>
</li>
<li> Next, suppose <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>::<span class="id" title="var">l'</span></span>, with

<div class="paragraph"> </div>

          length (rev l') = length l'.

<div class="paragraph"> </div>

        We must show

<div class="paragraph"> </div>

          length (rev (n :: l')) = length (n :: l').

<div class="paragraph"> </div>

        By the definition of <span class="inlinecode"><span class="id" title="var">rev</span></span>, this follows from

<div class="paragraph"> </div>

          length ((rev l') ++ <span class="inlinecode"><span class="id" title="var">n</span></span>) = S (length l')

<div class="paragraph"> </div>

        which, by the previous lemma, is the same as

<div class="paragraph"> </div>

          length (rev l') + length <span class="inlinecode"><span class="id" title="var">n</span></span> = S (length l').

<div class="paragraph"> </div>

        This follows directly from the induction hypothesis and the
        definition of <span class="inlinecode"><span class="id" title="var">length</span></span>. <font size="-2">‚òê</font>
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The style of these proofs is rather longwinded and pedantic.
    After the first few, we might find it easier to follow proofs that
    give fewer details (which we can easily work out in our own minds or
    on scratch paper if necessary) and just highlight the non-obvious
    steps.  In this more compressed style, the above proof might look
    like this: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<i>Theorem</i>:
     For all lists <span class="inlinecode"><span class="id" title="var">l</span></span>, <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">rev</span></span> <span class="inlinecode"><span class="id" title="var">l</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span>.

<div class="paragraph"> </div>
<i>Proof</i>: First, observe that <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">l</span></span> <span class="inlinecode">++</span> <span class="inlinecode">[<span class="id" title="var">n</span>])</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span>)</span>
     for any <span class="inlinecode"><span class="id" title="var">l</span></span> (this follows by a straightforward induction on <span class="inlinecode"><span class="id" title="var">l</span></span>).
     The main property again follows by induction on <span class="inlinecode"><span class="id" title="var">l</span></span>, using the
     observation together with the induction hypothesis in the case
     where <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n'</span>::<span class="id" title="var">l'</span></span>. <font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Which style is preferable in a given situation depends on
    the sophistication of the expected audience and how similar the
    proof at hand is to ones that the audience will already be
    familiar with.  The more pedantic style is a good default for our
    present purposes. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab22"></a><h2 class="section"><span class="inlinecode"><span class="id" title="keyword">Search</span></span></h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We've seen that proofs can make use of other theorems we've
    already proved, e.g., using <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>.  But in order to refer to a
    theorem, we need to know its name!  Indeed, it is often hard even
    to remember what theorems have been proven, much less what they
    are called.

<div class="paragraph"> </div>

    Coq's <span class="inlinecode"><span class="id" title="keyword">Search</span></span> command is quite helpful with this.  Typing <span class="inlinecode"><span class="id" title="keyword">Search</span></span>
<span class="inlinecode"><span class="id" title="var">foo</span></span> into your .v file and evaluating this line will cause Coq to
    display a list of all theorems involving <span class="inlinecode"><span class="id" title="var">foo</span></span>.  For example, try
    uncommenting the following line to see a list of theorems that we
    have proved about <span class="inlinecode"><span class="id" title="var">rev</span></span>: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(*  Search rev. *)</span></span></span></pre><div class="doc">
Keep <span class="inlinecode"><span class="id" title="keyword">Search</span></span> in mind as you do the following exercises and
    throughout the rest of the book; it can save you a lot of time!

<div class="paragraph"> </div>

    If you are using ProofGeneral, you can run <span class="inlinecode"><span class="id" title="keyword">Search</span></span> with
    <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">a</span></span>. Pasting its response into your buffer can be
    accomplished with <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">C</span>-;</span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab23"></a><h2 class="section">List Exercises, Part 1</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab24"></a><h4 class="section">Exercise: 3 stars, standard (list_exercises)</h4>
<div class="paragraph"> </div>

    More practice with lists: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk75" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk75"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">app_nil_r</span> : <span class="kr">forall</span> <span class="nv">l</span> : natlist,
  l ++ [] = l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : natlist, l ++ [ ] = l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk76" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk76"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : natlist, l ++ [ ] = l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk77" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk77"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">rev_app_distr</span>: <span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : natlist,
  rev (l1 ++ l2) = rev l2 ++ rev l1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : natlist,
rev (l1 ++ l2) = rev l2 ++ rev l1</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk78" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk78"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : natlist,
rev (l1 ++ l2) = rev l2 ++ rev l1</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk79" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk79"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">rev_involutive</span> : <span class="kr">forall</span> <span class="nv">l</span> : natlist,
  rev (rev l) = l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : natlist, rev (rev l) = l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk7a" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk7a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : natlist, rev (rev l) = l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
There is a short solution to the next one.  If you find yourself
    getting tangled up, step back and try to look for a simpler
    way. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk7b" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk7b"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">app_assoc4</span> : <span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> <span class="nv">l4</span> : natlist,
  l1 ++ (l2 ++ (l3 ++ l4)) = ((l1 ++ l2) ++ l3) ++ l4.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> <span class="nv">l4</span> : natlist,
l1 ++ l2 ++ l3 ++ l4 = ((l1 ++ l2) ++ l3) ++ l4</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk7c" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk7c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> <span class="nv">l4</span> : natlist,
l1 ++ l2 ++ l3 ++ l4 = ((l1 ++ l2) ++ l3) ++ l4</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
An exercise about your implementation of <span class="inlinecode"><span class="id" title="var">nonzeros</span></span>: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk7d" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk7d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">nonzeros_app</span> : <span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : natlist,
  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : natlist,
nonzeros (l1 ++ l2) = nonzeros l1 ++ nonzeros l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk7e" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk7e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : natlist,
nonzeros (l1 ++ l2) = nonzeros l1 ++ nonzeros l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab25"></a><h4 class="section">Exercise: 2 stars, standard (eqblist)</h4>
<div class="paragraph"> </div>

    Fill in the definition of <span class="inlinecode"><span class="id" title="var">eqblist</span></span>, which compares
    lists of numbers for equality.  Prove that <span class="inlinecode"><span class="id" title="var">eqblist</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span>
    yields <span class="inlinecode"><span class="id" title="var">true</span></span> for every list <span class="inlinecode"><span class="id" title="var">l</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk7f" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk7f"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">eqblist</span> (<span class="nv">l1</span> <span class="nv">l2</span> : natlist) : bool
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">eqblist</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist -&gt; natlist -&gt; bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1, l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">bool</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk80" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk80"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_eqblist1</span> :
  (eqblist nil nil = true).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eqblist [ ] [ ] = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk81" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk81"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_eqblist2</span> :
  eqblist [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>] [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>] = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eqblist [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk82" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk82"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_eqblist3</span> :
  eqblist [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>] [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">4</span>] = false.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eqblist [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">4</span>] = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk83" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk83"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">eqblist_refl</span> : <span class="kr">forall</span> <span class="nv">l</span>:natlist,
  true = eqblist l l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : natlist, true = eqblist l l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk84" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk84"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : natlist, true = eqblist l l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ================================================================= *)</span></span></span></pre><div class="doc">
<a name="lab26"></a><h2 class="section">List Exercises, Part 2</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Here are a couple of little theorems to prove about your
    definitions about bags above. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab27"></a><h4 class="section">Exercise: 1 star, standard (count_member_nonzero)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk85" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk85"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">count_member_nonzero</span> : <span class="kr">forall</span> (<span class="nv">s</span> : bag),
  <span class="mi">1</span> &lt;=? (count <span class="mi">1</span> (<span class="mi">1</span> :: s)) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s</span> : bag, (<span class="mi">1</span> &lt;=? count <span class="mi">1</span> (<span class="mi">1</span> :: s)) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk86" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk86"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s</span> : bag, (<span class="mi">1</span> &lt;=? count <span class="mi">1</span> (<span class="mi">1</span> :: s)) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The following lemma about <span class="inlinecode"><span class="id" title="var">leb</span></span> might help you in the next exercise. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk87" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk87"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">leb_n_Sn</span> : <span class="kr">forall</span> <span class="nv">n</span>,
  n &lt;=? (S n) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, (n &lt;=? S n) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk88" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk88"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, (n &lt;=? S n) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk89" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk89"><span class="highlight"><span class="nb">intros</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(n &lt;=? S n) = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk8a" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk8a"><span class="highlight"><span class="nb">induction</span> n <span class="kr">as</span> [| n&#39; IHn&#39;].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="mi">0</span> &lt;=? <span class="mi">1</span>) = true</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Lists-v-chk8b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(n&#39; &lt;=? S n&#39;) = true</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Lists-v-chk8b"><hr></label><div class="goal-conclusion"><span class="highlight">(S n&#39; &lt;=? S (S n&#39;)) = true</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk8c" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk8c"><span class="highlight">- <span class="c">(* 0 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="mi">0</span> &lt;=? <span class="mi">1</span>) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk8d" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk8d"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk8e" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk8e"><span class="highlight">- <span class="c">(* S n&#39; *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(n&#39; &lt;=? S n&#39;) = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(S n&#39; &lt;=? S (S n&#39;)) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk8f" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk8f"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(n&#39; &lt;=? S n&#39;) = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(n&#39; &lt;=? S n&#39;) = true</span></div></blockquote></div></div></small><span class="coq-wsp">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk90" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk90"><span class="highlight"><span class="nb">rewrite</span> IHn&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(n&#39; &lt;=? S n&#39;) = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true = true</span></div></blockquote></div></div></small><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Before doing the next exercise, make sure you've filled in the
   definition of <span class="inlinecode"><span class="id" title="var">remove_one</span></span> above. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab28"></a><h4 class="section">Exercise: 3 stars, advanced (remove_does_not_increase_count)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk91" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk91"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">remove_does_not_increase_count</span>: <span class="kr">forall</span> (<span class="nv">s</span> : bag),
  (count <span class="mi">0</span> (remove_one <span class="mi">0</span> s)) &lt;=? (count <span class="mi">0</span> s) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s</span> : bag,
(count <span class="mi">0</span> (remove_one <span class="mi">0</span> s) &lt;=? count <span class="mi">0</span> s) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk92" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk92"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">s</span> : bag,
(count <span class="mi">0</span> (remove_one <span class="mi">0</span> s) &lt;=? count <span class="mi">0</span> s) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab29"></a><h4 class="section">Exercise: 3 stars, standard, optional (bag_count_sum)</h4>
<div class="paragraph"> </div>

    Write down an interesting theorem <span class="inlinecode"><span class="id" title="var">bag_count_sum</span></span> about bags
    involving the functions <span class="inlinecode"><span class="id" title="var">count</span></span> and <span class="inlinecode"><span class="id" title="var">sum</span></span>, and prove it using
    Coq.  (You may find that the difficulty of the proof depends on
    how you defined <span class="inlinecode"><span class="id" title="var">count</span></span>!) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE </span>

<span class="c">    [] *)</span></span></span></pre><div class="doc">
<a name="lab30"></a><h4 class="section">Exercise: 4 stars, advanced (rev_injective)</h4>
<div class="paragraph"> </div>

    Prove that the <span class="inlinecode"><span class="id" title="var">rev</span></span> function is injective -- that is,

<div class="paragraph"> </div>

    forall (l1 l2 : natlist), rev l1 = rev l2 -&gt; l1 = l2.

<div class="paragraph"> </div>

    (There is a hard way and an easy way to do this.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span>

<span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_rev_injective</span> : option (nat*string) := None.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab31"></a><h1 class="section">Options</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Suppose we want to write a function that returns the <span class="inlinecode"><span class="id" title="var">n</span></span>th
    element of some list.  If we give it type <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">natlist</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    then we'll have to choose some number to return when the list is
    too short... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">nth_bad</span> (<span class="nv">l</span>:natlist) (<span class="nv">n</span>:nat) : nat :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | nil =&gt; <span class="mi">42</span>  <span class="c">(* arbitrary! *)</span>
  | a :: l&#39; =&gt; <span class="kr">match</span> n =? O <span class="kr">with</span>
               | true =&gt; a
               | false =&gt; nth_bad l&#39; (pred n)
               <span class="kr">end</span>
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
This solution is not so good: If <span class="inlinecode"><span class="id" title="var">nth_bad</span></span> returns <span class="inlinecode">42</span>, we
    can't tell whether that value actually appears on the input
    without further processing. A better alternative is to change the
    return type of <span class="inlinecode"><span class="id" title="var">nth_bad</span></span> to include an error value as a possible
    outcome. We call this type <span class="inlinecode"><span class="id" title="var">natoption</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">natoption</span> : <span class="kt">Type</span> :=
  | Some (n : nat)
  | None.</span></span></span></pre><div class="doc">
We can then change the above definition of <span class="inlinecode"><span class="id" title="var">nth_bad</span></span> to
    return <span class="inlinecode"><span class="id" title="var">None</span></span> when the list is too short and <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> when the
    list has enough members and <span class="inlinecode"><span class="id" title="var">a</span></span> appears at position <span class="inlinecode"><span class="id" title="var">n</span></span>. We call
    this new function <span class="inlinecode"><span class="id" title="var">nth_error</span></span> to indicate that it may result in an
    error. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">nth_error</span> (<span class="nv">l</span>:natlist) (<span class="nv">n</span>:nat) : natoption :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | nil =&gt; None
  | a :: l&#39; =&gt; <span class="kr">match</span> n =? O <span class="kr">with</span>
               | true =&gt; Some a
               | false =&gt; nth_error l&#39; (pred n)
               <span class="kr">end</span>
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk93" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk93"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_nth_error1</span> : nth_error [<span class="mi">4</span>;<span class="mi">5</span>;<span class="mi">6</span>;<span class="mi">7</span>] <span class="mi">0</span> = Some <span class="mi">4</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nth_error [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>; <span class="mi">7</span>] <span class="mi">0</span> = Some <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk94" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk94"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nth_error [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>; <span class="mi">7</span>] <span class="mi">0</span> = Some <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk95" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk95"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_nth_error2</span> : nth_error [<span class="mi">4</span>;<span class="mi">5</span>;<span class="mi">6</span>;<span class="mi">7</span>] <span class="mi">3</span> = Some <span class="mi">7</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nth_error [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>; <span class="mi">7</span>] <span class="mi">3</span> = Some <span class="mi">7</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk96" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk96"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nth_error [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>; <span class="mi">7</span>] <span class="mi">3</span> = Some <span class="mi">7</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk97" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk97"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_nth_error3</span> : nth_error [<span class="mi">4</span>;<span class="mi">5</span>;<span class="mi">6</span>;<span class="mi">7</span>] <span class="mi">9</span> = None.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nth_error [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>; <span class="mi">7</span>] <span class="mi">9</span> = None</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk98" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk98"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nth_error [<span class="mi">4</span>; <span class="mi">5</span>; <span class="mi">6</span>; <span class="mi">7</span>] <span class="mi">9</span> = None</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
(In the HTML version, the boilerplate proofs of these
    examples are elided.  Click on a box if you want to see one.)

<div class="paragraph"> </div>

    This example is also an opportunity to introduce one more small
    feature of Coq's programming language: conditional
    expressions... 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">nth_error&#39;</span> (<span class="nv">l</span>:natlist) (<span class="nv">n</span>:nat) : natoption :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | nil =&gt; None
  | a :: l&#39; =&gt; <span class="kr">if</span> n =? O <span class="kr">then</span> Some a
               <span class="kr">else</span> nth_error&#39; l&#39; (pred n)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Coq's conditionals are exactly like those found in any other
    language, with one small generalization.  Since the boolean type
    is not built in, Coq actually supports conditional expressions over
    <i>any</i> inductively defined type with exactly two constructors.  The
    guard is considered true if it evaluates to the first constructor
    in the <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> definition and false if it evaluates to the
    second. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The function below pulls the <span class="inlinecode"><span class="id" title="var">nat</span></span> out of a <span class="inlinecode"><span class="id" title="var">natoption</span></span>, returning
    a supplied default in the <span class="inlinecode"><span class="id" title="var">None</span></span> case. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">option_elim</span> (<span class="nv">d</span> : nat) (<span class="nv">o</span> : natoption) : nat :=
  <span class="kr">match</span> o <span class="kr">with</span>
  | Some n&#39; =&gt; n&#39;
  | None =&gt; d
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab32"></a><h4 class="section">Exercise: 2 stars, standard (hd_error)</h4>
<div class="paragraph"> </div>

    Using the same idea, fix the <span class="inlinecode"><span class="id" title="var">hd</span></span> function from earlier so we don't
    have to pass a default element for the <span class="inlinecode"><span class="id" title="var">nil</span></span> case.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk99" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk99"><span class="highlight"><span class="kn">Definition</span> <span class="nf">hd_error</span> (<span class="nv">l</span> : natlist) : natoption
  <span class="c">(* REPLACE THIS LINE WITH &quot;:= _your_definition_ .&quot; *)</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">natlist</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">natoption</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk9a" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk9a"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_hd_error1</span> : hd_error [] = None.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hd_error [ ] = None</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk9b" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk9b"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_hd_error2</span> : hd_error [<span class="mi">1</span>] = Some <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hd_error [<span class="mi">1</span>] = Some <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk9c" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk9c"><span class="highlight"><span class="kn">Example</span> <span class="nf">test_hd_error3</span> : hd_error [<span class="mi">5</span>;<span class="mi">6</span>] = Some <span class="mi">5</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hd_error [<span class="mi">5</span>; <span class="mi">6</span>] = Some <span class="mi">5</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab33"></a><h4 class="section">Exercise: 1 star, standard, optional (option_elim_hd)</h4>
<div class="paragraph"> </div>

    This exercise relates your new <span class="inlinecode"><span class="id" title="var">hd_error</span></span> to the old <span class="inlinecode"><span class="id" title="var">hd</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk9d" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk9d"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">option_elim_hd</span> : <span class="kr">forall</span> (<span class="nv">l</span>:natlist) (<span class="nv">default</span>:nat),
  hd default l = option_elim default (hd_error l).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">l</span> : natlist) (<span class="nv">default</span> : nat),
hd default l = option_elim default (hd_error l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk9e" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk9e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">l</span> : natlist) (<span class="nv">default</span> : nat),
hd default l = option_elim default (hd_error l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">NatList</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* ################################################################# *)</span></span></span></pre><div class="doc">
<a name="lab34"></a><h1 class="section">Partial Maps</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
As a final illustration of how data structures can be defined in
    Coq, here is a simple <i>partial map</i> data type, analogous to the
    map or dictionary data structures found in most programming
    languages. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
First, we define a new inductive datatype <span class="inlinecode"><span class="id" title="var">id</span></span> to serve as the
    "keys" of our partial maps. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">id</span> : <span class="kt">Type</span> :=
  | Id (n : nat).</span></span></span></pre><div class="doc">
Internally, an <span class="inlinecode"><span class="id" title="var">id</span></span> is just a number.  Introducing a separate type
    by wrapping each nat with the tag <span class="inlinecode"><span class="id" title="var">Id</span></span> makes definitions more
    readable and gives us the flexibility to change representations
    later if we wish. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
We'll also need an equality test for <span class="inlinecode"><span class="id" title="var">id</span></span>s: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eqb_id</span> (<span class="nv">x1</span> <span class="nv">x2</span> : id) :=
  <span class="kr">match</span> x1, x2 <span class="kr">with</span>
  | Id n1, Id n2 =&gt; n1 =? n2
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab35"></a><h4 class="section">Exercise: 1 star, standard (eqb_id_refl)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chk9f" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chk9f"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">eqb_id_refl</span> : <span class="kr">forall</span> <span class="nv">x</span>, true = eqb_id x x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : id, true = eqb_id x x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chka0" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chka0"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : id, true = eqb_id x x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Now we define the type of partial maps: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">PartialMap</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Export</span> NatList.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">partial_map</span> : <span class="kt">Type</span> :=
  | empty
  | record (i : id) (v : nat) (m : partial_map).</span></span></span></pre><div class="doc">
This declaration can be read: "There are two ways to construct a
    <span class="inlinecode"><span class="id" title="var">partial_map</span></span>: either using the constructor <span class="inlinecode"><span class="id" title="var">empty</span></span> to represent an
    empty partial map, or by applying the constructor <span class="inlinecode"><span class="id" title="var">record</span></span> to
    a key, a value, and an existing <span class="inlinecode"><span class="id" title="var">partial_map</span></span> to construct a
    <span class="inlinecode"><span class="id" title="var">partial_map</span></span> with an additional key-to-value mapping." 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">update</span></span> function overrides the entry for a given key in a
    partial map by shadowing it with a new one (or simply adds a new
    entry if the given key is not already present). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">update</span> (<span class="nv">d</span> : partial_map)
                  (<span class="nv">x</span> : id) (<span class="nv">value</span> : nat)
                  : partial_map :=
  record x value d.</span></span></span></pre><div class="doc">
Last, the <span class="inlinecode"><span class="id" title="var">find</span></span> function searches a <span class="inlinecode"><span class="id" title="var">partial_map</span></span> for a given
    key.  It returns <span class="inlinecode"><span class="id" title="var">None</span></span> if the key was not found and <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">val</span></span> if
    the key was associated with <span class="inlinecode"><span class="id" title="var">val</span></span>. If the same key is mapped to
    multiple values, <span class="inlinecode"><span class="id" title="var">find</span></span> will return the first one it
    encounters. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">find</span> (<span class="nv">x</span> : id) (<span class="nv">d</span> : partial_map) : natoption :=
  <span class="kr">match</span> d <span class="kr">with</span>
  | empty         =&gt; None
  | record y v d&#39; =&gt; <span class="kr">if</span> eqb_id x y
                     <span class="kr">then</span> Some v
                     <span class="kr">else</span> find x d&#39;
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab36"></a><h4 class="section">Exercise: 1 star, standard (update_eq)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chka1" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chka1"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">update_eq</span> :
  <span class="kr">forall</span> (<span class="nv">d</span> : partial_map) (<span class="nv">x</span> : id) (<span class="nv">v</span>: nat),
    find x (update d x v) = Some v.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">d</span> : partial_map) (<span class="nv">x</span> : id) (<span class="nv">v</span> : nat),
find x (update d x v) = Some v</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chka2" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chka2"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">d</span> : partial_map) (<span class="nv">x</span> : id) (<span class="nv">v</span> : nat),
find x (update d x v) = Some v</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab37"></a><h4 class="section">Exercise: 1 star, standard (update_neq)</h4>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chka3" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chka3"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">update_neq</span> :
  <span class="kr">forall</span> (<span class="nv">d</span> : partial_map) (<span class="nv">x</span> <span class="nv">y</span> : id) (<span class="nv">o</span>: nat),
    eqb_id x y = false -&gt; find x (update d y o) = find x d.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">d</span> : partial_map) (<span class="nv">x</span> <span class="nv">y</span> : id) (<span class="nv">o</span> : nat),
eqb_id x y = false -&gt; find x (update d y o) = find x d</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Lists-v-chka4" style="display: none" type="checkbox"><label class="coq-input" for="Lists-v-chka4"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">d</span> : partial_map) (<span class="nv">x</span> <span class="nv">y</span> : id) (<span class="nv">o</span> : nat),
eqb_id x y = false -&gt; find x (update d y o) = find x d</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* FILL IN HERE *)</span></span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">PartialMap</span>.</span></span></span></pre><div class="doc">
<a name="lab38"></a><h4 class="section">Exercise: 2 stars, standard (baz_num_elts)</h4>
<div class="paragraph"> </div>

    Consider the following inductive definition: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">baz</span> : <span class="kt">Type</span> :=
  | Baz1 (x : baz)
  | Baz2 (y : baz) (b : bool).</span></span></span></pre><div class="doc">
How <i>many</i> elements does the type <span class="inlinecode"><span class="id" title="var">baz</span></span> have? (Explain in words,
    in a comment.) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* FILL IN HERE *)</span>

<span class="c">(* Do not modify the following line: *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">manual_grade_for_baz_num_elts</span> : option (nat*string) := None.</span></span></span></pre><div class="doc">
<font size="-2">‚òê</font>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* Wed Jan 9 12:02:44 EST 2019 *)</span></span></span></pre></article></body></html>