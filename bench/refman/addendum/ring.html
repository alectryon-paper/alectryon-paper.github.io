

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The ring and field tactic families &mdash; Coq 8.10.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/notations.js"></script>
        <script src="../_static/alectryon.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
  <link rel="stylesheet" href="../_static/alectryon.css" type="text/css" />
  <link rel="stylesheet" href="../_static/tango_subtle.css" type="text/css" />
  <link rel="stylesheet" href="../_static/tango_subtle.min.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Nsatz: tactics for proving equalities in integral domains" href="nsatz.html" />
    <link rel="prev" title="Program" href="program.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.10.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Indexes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">Preamble</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction and Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">Early history of Coq</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../history.html#historical-roots">Historical roots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-1-to-5">Versions 1 to 5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-1">Version 1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-2">Version 2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-3">Version 3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-4">Version 4</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-5">Version 5</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-6">Versions 6</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-1">Version 6.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-2">Version 6.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-3">Version 6.3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-7">Versions 7</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-0-and-7-1">Details of changes in 7.0 and 7.1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#main-novelties">Main novelties</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-2">Details of changes in 7.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-3">Details of changes in 7.3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#changes-in-7-3-1">Changes in 7.3.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-4">Details of changes in 7.4</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changes.html">Recent changes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-10">Version 8.10</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#other-changes-in-8-10-beta1">Other changes in 8.10+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-beta2">Changes in 8.10+beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-beta3">Changes in 8.10+beta3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-0">Changes in 8.10.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-1">Changes in 8.10.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-2">Changes in 8.10.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-9">Version 8.9</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id147">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-9-beta1">Details of changes in 8.9+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-8-0">Changes in 8.8.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-8-1">Changes in 8.8.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-8">Version 8.8</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id149">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-beta1">Details of changes in 8.8+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-0">Details of changes in 8.8.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-1">Details of changes in 8.8.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-2">Details of changes in 8.8.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-7">Version 8.7</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id150">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#potential-compatibility-issues">Potential compatibility issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta1">Details of changes in 8.7+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta2">Details of changes in 8.7+beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-0">Details of changes in 8.7.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-1">Details of changes in 8.7.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-2">Details of changes in 8.7.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-6">Version 8.6</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id151">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#potential-sources-of-incompatibilities">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6beta1">Details of changes in 8.6beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6">Details of changes in 8.6</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6-1">Details of changes in 8.6.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-5">Version 8.5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id152">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id153">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta1">Details of changes in 8.5beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta2">Details of changes in 8.5beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta3">Details of changes in 8.5beta3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5">Details of changes in 8.5</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl1">Details of changes in 8.5pl1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl2">Details of changes in 8.5pl2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl3">Details of changes in 8.5pl3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-4">Version 8.4</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id154">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id156">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta">Details of changes in 8.4beta</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta2">Details of changes in 8.4beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4">Details of changes in 8.4</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-3">Version 8.3</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id157">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-2">Version 8.2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id158">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id159">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-1">Version 8.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id160">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1beta">Details of changes in 8.1beta</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1gamma">Details of changes in 8.1gamma</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1">Details of changes in 8.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-0">Version 8.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id161">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-old-syntax">Details of changes in 8.0beta old syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-new-syntax">Details of changes in 8.0beta new syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0">Details of changes in 8.0</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">The language</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-specification-language.html">The Gallina specification language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#about-the-grammars-in-the-manual">About the grammars in the manual</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#lexical-conventions">Lexical conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#terms">Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#syntax-of-terms">Syntax of terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#types">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#qualified-identifiers-and-simple-identifiers">Qualified identifiers and simple identifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#numerals">Numerals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#binders">Binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#abstractions">Abstractions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#products">Products</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#applications">Applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#type-cast">Type cast</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#inferable-subterms">Inferable subterms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#let-in-definitions">Let-in definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#definition-by-case-analysis">Definition by case analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#recursive-functions">Recursive functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#the-vernacular">The Vernacular</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#assumptions">Assumptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#inductive-definitions">Inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#simple-inductive-types">Simple inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#simple-annotated-inductive-types">Simple annotated inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#parameterized-inductive-types">Parameterized inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#variants">Variants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#mutually-defined-inductive-types">Mutually defined inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#co-inductive-types">Co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#definition-of-recursive-functions">Definition of recursive functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#definition-of-functions-by-recursion-over-inductive-objects">Definition of functions by recursion over inductive objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#definitions-of-recursive-objects-in-co-inductive-types">Definitions of recursive objects in co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#assertions-and-proofs">Assertions and proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#attributes">Attributes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#record-types">Record types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#primitive-projections">Primitive Projections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#primitive-record-types">Primitive Record Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#compatibility-projections-and-match">Compatibility Projections and <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">match</span></span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#variants-and-extensions-of-match">Variants and extensions of <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">match</span></span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#multiple-and-nested-pattern-matching">Multiple and nested pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#pattern-matching-on-boolean-values-the-if-expression">Pattern-matching on boolean values: the if expression</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#irrefutable-patterns-the-destructuring-let-variants">Irrefutable patterns: the destructuring let variants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#first-destructuring-let-syntax">First destructuring let syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#second-destructuring-let-syntax">Second destructuring let syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-pretty-printing-of-match-expressions">Controlling pretty-printing of match expressions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-nested-patterns">Printing nested patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#factorization-of-clauses-with-same-right-hand-side">Factorization of clauses with same right-hand side</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#use-of-a-default-clause">Use of a default clause</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-of-wildcard-patterns">Printing of wildcard patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-of-the-elimination-predicate">Printing of the elimination predicate</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-matching-on-irrefutable-patterns">Printing matching on irrefutable patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-matching-on-booleans">Printing matching on booleans</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions">Advanced recursive functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#section-mechanism">Section mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#module-system">Module system</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#reserved-commands-inside-an-interactive-module">Reserved commands inside an interactive module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#reserved-commands-inside-an-interactive-module-type">Reserved commands inside an interactive module type:</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#libraries-and-qualified-names">Libraries and qualified names</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#names-of-libraries">Names of libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#qualified-names">Qualified names</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#libraries-and-filesystem">Libraries and filesystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#implicit-arguments">Implicit arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#the-different-kinds-of-implicit-arguments">The different kinds of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function">Implicit arguments inferable from the knowledge of other arguments of a function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#implicit-arguments-inferable-by-resolution">Implicit arguments inferable by resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#maximal-or-non-maximal-insertion-of-implicit-arguments">Maximal or non maximal insertion of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#casual-use-of-implicit-arguments">Casual use of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#declaration-of-implicit-arguments">Declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#implicit-argument-binders">Implicit Argument Binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#declaring-implicit-arguments">Declaring Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#automatic-declaration-of-implicit-arguments">Automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#mode-for-automatic-declaration-of-implicit-arguments">Mode for automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-strict-implicit-arguments">Controlling strict implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-contextual-implicit-arguments">Controlling contextual implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-reversible-pattern-implicit-arguments">Controlling reversible-pattern implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments">Controlling the insertion of implicit arguments not followed by explicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#explicit-applications">Explicit applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#renaming-implicit-arguments">Renaming implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#displaying-what-the-implicit-arguments-are">Displaying what the implicit arguments are</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#explicit-displaying-of-implicit-arguments-for-pretty-printing">Explicit displaying of implicit arguments for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#interaction-with-subtyping">Interaction with subtyping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#deactivation-of-implicit-arguments-for-parsing">Deactivation of implicit arguments for parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#canonical-structures">Canonical structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#implicit-types-of-variables">Implicit types of variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#implicit-generalization">Implicit generalization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#coercions">Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#printing-constructions-in-full">Printing constructions in full</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#printing-universes">Printing universes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#existential-variables">Existential variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#explicit-displaying-of-existential-instances-for-pretty-printing">Explicit displaying of existential instances for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#solving-existential-variables-using-tactics">Solving existential variables using tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#primitive-integers">Primitive Integers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/coq-library.html">The <span class="smallcaps">Coq</span> library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html#the-basic-library">The basic library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#notations">Notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#logic">Logic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#propositional-connectives">Propositional Connectives</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#quantifiers">Quantifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#equality">Equality</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#lemmas">Lemmas</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#datatypes">Datatypes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#programming">Programming</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#specification">Specification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#basic-arithmetics">Basic Arithmetics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#well-founded-recursion">Well-founded recursion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#accessing-the-type-level">Accessing the Type level</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#tactics">Tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html#the-standard-library">The standard library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#survey">Survey</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#peanos-arithmetic-nat">Peano’s arithmetic (nat)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#notations-for-integer-arithmetics">Notations for integer arithmetics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#real-numbers-library">Real numbers library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#notations-for-real-numbers">Notations for real numbers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#some-tactics-for-real-numbers">Some tactics for real numbers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#list-library">List library</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html#users-contributions">Users’ contributions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/cic.html">Calculus of Inductive Constructions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#the-terms">The terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#terms">Terms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#typing-rules">Typing rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#conversion-rules">Conversion rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#reduction">β-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#iota-reduction">ι-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#delta-reduction">δ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#zeta-reduction">ζ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#expansion">η-expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#proof-irrelevance">Proof Irrelevance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#convertibility">Convertibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#subtyping-rules">Subtyping rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#inductive-definitions">Inductive Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#types-of-inductive-objects">Types of inductive objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#well-formed-inductive-definitions">Well-formed inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#arity-of-a-given-sort">Arity of a given sort</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#arity">Arity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#type-of-constructor">Type of constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#positivity-condition">Positivity Condition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#strict-positivity">Strict positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#nested-positivity">Nested Positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#correctness-rules">Correctness rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#template-polymorphism">Template polymorphism</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#destructors">Destructors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#the-match-with-end-construction">The match ... with ... end construction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#fixpoint-definitions">Fixpoint definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#id29">Typing rule</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#reduction-rule">Reduction rule</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#admissible-rules-for-global-environments">Admissible rules for global environments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#co-inductive-types">Co-inductive types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#the-calculus-of-inductive-constructions-with-impredicative-set">The Calculus of Inductive Constructions with impredicative Set</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/module-system.html">The Module System</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/module-system.html#modules-and-module-types">Modules and module types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/module-system.html#typing-modules">Typing Modules</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">The proof engine</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/vernacular-commands.html">Vernacular commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#displaying">Displaying</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#flags-options-and-tables">Flags, Options and Tables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#scope-qualifiers-for-set-and-unset">Scope qualifiers for <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Set</span></code> and <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Unset</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#requests-to-the-environment">Requests to the environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#printing-flags">Printing flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#loading-files">Loading files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#compiled-files">Compiled files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#loadpath">Loadpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#backtracking">Backtracking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#quitting-and-debugging">Quitting and debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-display">Controlling display</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-the-reduction-strategies-and-the-conversion-algorithm">Controlling the reduction strategies and the conversion algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-the-locality-of-commands">Controlling the locality of commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#internal-registration-commands">Internal registration commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#exposing-constants-to-ocaml-libraries">Exposing constants to OCaml libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#inlining-hints-for-the-fast-reduction-machines">Inlining hints for the fast reduction machines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#registering-primitive-operations">Registering primitive operations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/proof-handling.html">Proof handling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#switching-on-off-the-proof-editing-mode">Switching on/off the proof editing mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#proof-using-options">Proof using options</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#name-a-set-of-section-hypotheses-for-proof-using">Name a set of section hypotheses for <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#navigation-in-the-proof-tree">Navigation in the proof tree</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#bullets">Bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#set-bullet-behavior">Set Bullet Behavior</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#requesting-information">Requesting information</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#showing-differences-between-proof-steps">Showing differences between proof steps</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#how-to-enable-diffs">How to enable diffs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#how-diffs-are-calculated">How diffs are calculated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#controlling-the-effect-of-proof-editing-commands">Controlling the effect of proof editing commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#controlling-memory-usage">Controlling memory usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/tactics.html">Tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#common-elements-of-tactics">Common elements of tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#invocation-of-tactics">Invocation of tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#bindings-list">Bindings list</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#occurrence-sets-and-occurrence-clauses">Occurrence sets and occurrence clauses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#applying-theorems">Applying theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#managing-the-local-context">Managing the local context</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#controlling-the-proof-flow">Controlling the proof flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#case-analysis-and-induction">Case analysis and induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#rewriting-expressions">Rewriting expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#performing-computations">Performing computations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#conversion-tactics-applied-to-hypotheses">Conversion tactics applied to hypotheses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#automation">Automation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#controlling-automation">Controlling automation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#the-hints-databases-for-auto-and-eauto">The hints databases for auto and eauto</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/tactics.html#creating-hint-databases">Creating Hint databases</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#hint-databases-defined-in-the-coq-standard-library">Hint databases defined in the Coq standard library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#hint-locality">Hint locality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#setting-implicit-automation-tactics">Setting implicit automation tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#decision-procedures">Decision procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#checking-properties-of-terms">Checking properties of terms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#equality">Equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#equality-and-inductive-sets">Equality and inductive sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#inversion">Inversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#classical-tactics">Classical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#automating">Automating</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#non-logical-tactics">Non-logical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#delaying-solving-unification-constraints">Delaying solving unification constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#proof-maintenance">Proof maintenance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#performance-oriented-tactic-variants">Performance-oriented tactic variants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ltac.html">The tactic language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html#semantics">Semantics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#sequence">Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#local-application-of-tactics">Local application of tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#goal-selectors">Goal selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#for-loop">For loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#repeat-loop">Repeat loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#error-catching">Error catching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#detecting-progress">Detecting progress</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#backtracking-branching">Backtracking branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#first-tactic-to-work">First tactic to work</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#left-biased-branching">Left-biased branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#generalized-biased-branching">Generalized biased branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#soft-cut">Soft cut</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#checking-the-successes">Checking the successes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#checking-the-failure">Checking the failure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#checking-the-success">Checking the success</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#solving">Solving</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#identity">Identity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#failing">Failing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#timeout">Timeout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#timing-a-tactic">Timing a tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#timing-a-tactic-that-evaluates-to-a-term">Timing a tactic that evaluates to a term</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#local-definitions">Local definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#application">Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#function-construction">Function construction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#pattern-matching-on-terms">Pattern matching on terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#pattern-matching-on-goals">Pattern matching on goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#filling-a-term-context">Filling a term context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#generating-fresh-hypothesis-names">Generating fresh hypothesis names</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#computing-in-a-constr">Computing in a constr</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#recovering-the-type-of-a-term">Recovering the type of a term</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#manipulating-untyped-terms">Manipulating untyped terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#counting-the-goals">Counting the goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#testing-boolean-expressions">Testing boolean expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#proving-a-subgoal-as-a-separate-lemma">Proving a subgoal as a separate lemma</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html#tactic-toplevel-definitions">Tactic toplevel definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#defining-ltac-functions">Defining <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#printing-ltac-tactics">Printing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html#examples-of-using-ltac">Examples of using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#proof-that-the-natural-numbers-have-at-least-two-elements">Proof that the natural numbers have at least two elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#proving-that-a-list-is-a-permutation-of-a-second-list">Proving that a list is a permutation of a second list</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#deciding-intuitionistic-propositional-logic">Deciding intuitionistic propositional logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#deciding-type-isomorphisms">Deciding type isomorphisms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html#debugging-ltac-tactics">Debugging <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#backtraces">Backtraces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#info-trace">Info trace</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#interactive-debugger">Interactive debugger</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#profiling-ltac-tactics">Profiling <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#run-time-optimization-tactic">Run-time optimization tactic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html">Detailed examples of tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html#dependent-induction">dependent induction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html#a-larger-example">A larger example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html#autorewrite">autorewrite</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#usage">Usage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#getting-started">Getting started</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#compatibility-issues">Compatibility issues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#gallina-extensions"><span class="smallcaps">Gallina</span> extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#pattern-assignment">Pattern assignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#pattern-conditional">Pattern conditional</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#parametric-polymorphism">Parametric polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#anonymous-arguments">Anonymous arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#wildcards">Wildcards</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#abbreviations">Abbreviations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#matching">Matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#occurrence-selection">Occurrence selection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#basic-localization">Basic localization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#basic-tactics">Basic tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#bookkeeping">Bookkeeping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-defective-tactics">The defective tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-move-tactic">The move tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-case-tactic">The case tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-elim-tactic">The elim tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-apply-tactic">The apply tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#discharge">Discharge</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#clear-rules">Clear rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#matching-for-apply-and-exact">Matching for apply and exact</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-abstract-tactic">The abstract tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#introduction-in-the-context">Introduction in the context</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#simplification-items">Simplification items</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#views">Views</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#clear-switch">Clear switch</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#branching-and-destructuring">Branching and destructuring</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#block-introduction">Block introduction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#generation-of-equations">Generation of equations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#type-families">Type families</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#control-flow">Control flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#indentation-and-bullets">Indentation and bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#terminators">Terminators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#selectors">Selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#iteration">Iteration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#localization">Localization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#structure">Structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-have-tactic">The have tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#generating-let-in-context-entries-with-have">Generating let in context entries with have</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-have-tactic-and-typeclass-resolution">The have tactic and typeclass resolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#variants-the-suff-and-wlog-tactics">Variants: the suff and wlog tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#rewriting">Rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#an-extended-rewrite-tactic">An extended rewrite tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#remarks-and-examples">Remarks and examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#rewrite-redex-selection">Rewrite redex selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#chained-rewrite-steps">Chained rewrite steps</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#explicit-redex-switches-are-matched-first">Explicit redex switches are matched first</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#occurrence-switches-and-redex-switches">Occurrence switches and redex switches</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#occurrence-selection-and-repetition">Occurrence selection and repetition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#multi-rule-rewriting">Multi-rule rewriting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#wildcards-vs-abstractions">Wildcards vs abstractions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#when-ssr-rewrite-fails-on-standard-coq-licit-rewrite">When <span class="smallcaps">SSReflect</span> rewrite fails on standard <span class="smallcaps">Coq</span> licit rewrite</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#existential-metavariables-and-rewriting">Existential metavariables and rewriting</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#rewriting-under-binders">Rewriting under binders</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-under-tactic">The under tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interactive-mode">Interactive mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#one-liner-mode">One-liner mode</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#locking-unlocking">Locking, unlocking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#congruence">Congruence</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#contextual-patterns">Contextual patterns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#matching-contextual-patterns">Matching contextual patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#examples">Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#contextual-pattern-in-set-and-the-tactical">Contextual pattern in set and the : tactical</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#contextual-patterns-in-rewrite">Contextual patterns in rewrite</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#patterns-for-recurrent-contexts">Patterns for recurrent contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#views-and-reflection">Views and reflection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-eliminations">Interpreting eliminations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-assumptions">Interpreting assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#specializing-assumptions">Specializing assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-goals">Interpreting goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#boolean-reflection">Boolean reflection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-reflect-predicate">The reflect predicate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#general-mechanism-for-interpreting-goals-and-assumptions">General mechanism for interpreting goals and assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#id13">Specializing assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#id14">Interpreting assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-equivalences">Interpreting equivalences</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#declaring-new-hint-views">Declaring new Hint Views</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#multiple-views">Multiple views</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#ssr-searching-tool"><span class="smallcaps">SSReflect</span> searching tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#synopsis-and-index">Synopsis and Index</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#parameters">Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#items-and-switches">Items and switches</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#tacticals">Tacticals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#commands">Commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#settings">Settings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">User extensions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations">Notations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#basic-notations">Basic notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#precedences-and-associativity">Precedences and associativity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#complex-notations">Complex notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simple-factorization-rules">Simple factorization rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-symbolic-notations">Displaying symbolic notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-infix-command">The Infix command</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#reserving-notations">Reserving notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simultaneous-definition-of-terms-and-notations">Simultaneous definition of terms and notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-notations">Displaying information about notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#locating-notations">Locating notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-and-binders">Notations and binders</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-identifiers">Binders bound in the notation and parsed as identifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-patterns">Binders bound in the notation and parsed as patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-terms">Binders bound in the notation and parsed as terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-not-bound-in-the-notation">Binders not bound in the notation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns">Notations with recursive patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns-involving-binders">Notations with recursive patterns involving binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#predefined-entries">Predefined entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#custom-entries">Custom entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#summary">Summary</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#syntax-of-notations">Syntax of notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#persistence-of-notations">Persistence of notations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes">Interpretation scopes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#global-interpretation-rules-for-notations">Global interpretation rules for notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-interpretation-rules-for-notations">Local interpretation rules for notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-opening-of-an-interpretation-scope">Local opening of an interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binding-arguments-of-a-constant-to-an-interpretation-scope">Binding arguments of a constant to an interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binding-types-of-arguments-to-an-interpretation-scope">Binding types of arguments to an interpretation scope</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-type-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">type_scope</span></code> interpretation scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-function-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">function_scope</span></code> interpretation scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes-used-in-the-standard-library-of-coq">Interpretation scopes used in the standard library of Coq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-scopes">Displaying information about scopes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#numeral-notations">Numeral notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#string-notations">String notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#tactic-notations">Tactic Notations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-induction-principles-with-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#automatic-declaration-of-schemes">Automatic declaration of schemes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#combined-scheme">Combined Scheme</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-induction-principles-with-functional-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Functional</span></code> <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-inversion-principles-with-derive-inversion">Generation of inversion principles with <code class="docutils literal notranslate"><span class="pre">Derive</span></code> <code class="docutils literal notranslate"><span class="pre">Inversion</span></code></a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Practical tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#interactive-use-coqtop">Interactive use (coqtop)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#batch-compilation-coqc">Batch compilation (coqc)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#customization-at-launch-time">Customization at launch time</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-resource-file">By resource file</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-environment-variables">By environment variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-command-line-options">By command line options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-libraries-checker-coqchk">Compiled libraries checker (coqchk)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#using-coq-as-a-library">Using Coq as a library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project">Building a <span class="smallcaps">Coq</span> project</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-coq-makefile">Building a <span class="smallcaps">Coq</span> project with coq_makefile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#coqmakefile-local">CoqMakefile.local</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#timing-targets-and-performance-testing">Timing targets and performance testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#reusing-extending-the-generated-makefile">Reusing/extending the generated Makefile</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#building-a-subset-of-the-targets-with-j">Building a subset of the targets with <code class="docutils literal notranslate"><span class="pre">-j</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-dune">Building a <span class="smallcaps">Coq</span> project with Dune</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#computing-module-dependencies">Computing Module dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#documenting-coq-files-with-coqdoc">Documenting <span class="smallcaps">Coq</span> files with coqdoc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#principles">Principles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#coq-material-inside-documentation"><span class="smallcaps">Coq</span> material inside documentation.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#pretty-printing">Pretty-printing.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#sections">Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#lists">Lists.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#rules">Rules.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#emphasis">Emphasis.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#escaping-to-latex-and-html">Escaping to <span class="smallcaps">LaTeX</span> and HTML.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#verbatim">Verbatim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#hyperlinks">Hyperlinks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#hiding-showing-parts-of-the-source">Hiding / Showing parts of the source.</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#the-coqdoc-latex-style-file">The coqdoc <span class="smallcaps">LaTeX</span> style file</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#embedded-coq-phrases-inside-latex-documents">Embedded Coq phrases inside <span class="smallcaps">LaTeX</span> documents</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#man-pages">Man pages</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#managing-files-and-buffers-basic-editing">Managing files and buffers, basic editing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#interactive-navigation-into-coq-scripts">Interactive navigation into Coq scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#proof-folding">Proof folding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#vernacular-commands-templates">Vernacular commands, templates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#queries">Queries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#compilation">Compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#customizations">Customizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#using-unicode-symbols">Using Unicode symbols</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#displaying-unicode-symbols">Displaying Unicode symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#bindings-for-input-of-unicode-symbols">Bindings for input of Unicode symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#adding-custom-bindings">Adding custom bindings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#character-encoding-for-saved-files">Character encoding for saved files</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Addendum</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="extended-pattern-matching.html">Extended pattern matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="extended-pattern-matching.html#patterns">Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="extended-pattern-matching.html#multiple-patterns">Multiple patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="extended-pattern-matching.html#aliasing-subpatterns">Aliasing subpatterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="extended-pattern-matching.html#nested-patterns">Nested patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="extended-pattern-matching.html#disjunctive-patterns">Disjunctive patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="extended-pattern-matching.html#about-patterns-of-parametric-types">About patterns of parametric types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="extended-pattern-matching.html#parameters-in-patterns">Parameters in patterns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="extended-pattern-matching.html#implicit-arguments-in-patterns">Implicit arguments in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="extended-pattern-matching.html#matching-objects-of-dependent-types">Matching objects of dependent types</a></li>
<li class="toctree-l2"><a class="reference internal" href="extended-pattern-matching.html#understanding-dependencies-in-patterns">Understanding dependencies in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="extended-pattern-matching.html#when-the-elimination-predicate-must-be-provided">When the elimination predicate must be provided</a><ul>
<li class="toctree-l3"><a class="reference internal" href="extended-pattern-matching.html#dependent-pattern-matching">Dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="extended-pattern-matching.html#multiple-dependent-pattern-matching">Multiple dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="extended-pattern-matching.html#patterns-in-in">Patterns in <code class="docutils literal notranslate"><span class="pre">in</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="extended-pattern-matching.html#using-pattern-matching-to-write-proofs">Using pattern matching to write proofs</a></li>
<li class="toctree-l2"><a class="reference internal" href="extended-pattern-matching.html#pattern-matching-on-inductive-objects-involving-local-definitions">Pattern-matching on inductive objects involving local definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="extended-pattern-matching.html#pattern-matching-and-coercions">Pattern-matching and coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="extended-pattern-matching.html#when-does-the-expansion-strategy-fail">When does the expansion strategy fail?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="implicit-coercions.html">Implicit Coercions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="implicit-coercions.html#general-presentation">General Presentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="implicit-coercions.html#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="implicit-coercions.html#coercions">Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="implicit-coercions.html#identity-coercions">Identity Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="implicit-coercions.html#inheritance-graph">Inheritance Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="implicit-coercions.html#declaring-coercions">Declaring Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="implicit-coercions.html#displaying-available-coercions">Displaying Available Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="implicit-coercions.html#activating-the-printing-of-coercions">Activating the Printing of Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="implicit-coercions.html#classes-as-records">Classes as Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="implicit-coercions.html#coercions-and-sections">Coercions and Sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="implicit-coercions.html#coercions-and-modules">Coercions and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="implicit-coercions.html#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="implicit-coercions.html#coercion-at-function-application">Coercion at function application</a></li>
<li class="toctree-l3"><a class="reference internal" href="implicit-coercions.html#coercion-to-a-type">Coercion to a type</a></li>
<li class="toctree-l3"><a class="reference internal" href="implicit-coercions.html#coercion-to-a-function">Coercion to a function</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="canonical-structures.html">Canonical Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="canonical-structures.html#notation-overloading">Notation overloading</a><ul>
<li class="toctree-l3"><a class="reference internal" href="canonical-structures.html#derived-canonical-structures">Derived Canonical Structures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="canonical-structures.html#hierarchy-of-structures">Hierarchy of structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="canonical-structures.html#compact-declaration-of-canonical-structures">Compact declaration of Canonical Structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="type-classes.html">Typeclasses</a><ul>
<li class="toctree-l2"><a class="reference internal" href="type-classes.html#class-and-instance-declarations">Class and Instance declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="type-classes.html#binding-classes">Binding classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="type-classes.html#parameterized-instances">Parameterized Instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="type-classes.html#sections-and-contexts">Sections and contexts</a></li>
<li class="toctree-l2"><a class="reference internal" href="type-classes.html#building-hierarchies">Building hierarchies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="type-classes.html#superclasses">Superclasses</a></li>
<li class="toctree-l3"><a class="reference internal" href="type-classes.html#substructures">Substructures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="type-classes.html#summary-of-the-commands">Summary of the commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="type-classes.html#typeclasses-transparent-typeclasses-opaque">Typeclasses Transparent, Typeclasses Opaque</a></li>
<li class="toctree-l3"><a class="reference internal" href="type-classes.html#settings">Settings</a></li>
<li class="toctree-l3"><a class="reference internal" href="type-classes.html#typeclasses-eauto">Typeclasses eauto <code class="docutils literal notranslate"><span class="pre">:=</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="omega.html#description-of-omega">Description of <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="omega.html#arithmetical-goals-recognized-by-omega">Arithmetical goals recognized by <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="omega.html#messages-from-omega">Messages from <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="omega.html#using-omega">Using <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="omega.html#options">Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="omega.html#technical-data">Technical data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="omega.html#overview-of-the-tactic">Overview of the tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="omega.html#overview-of-the-omega-decision-procedure">Overview of the OMEGA decision procedure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="omega.html#bugs">Bugs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="micromega.html#short-description-of-the-tactics">Short description of the tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="micromega.html#positivstellensatz-refutations"><em>Positivstellensatz</em> refutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="micromega.html#lra-a-decision-procedure-for-linear-real-and-rational-arithmetic"><code class="docutils literal notranslate"><span class="pre">lra</span></code>: a decision procedure for linear real and rational arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="micromega.html#lia-a-tactic-for-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">lia</span></code>: a tactic for linear integer arithmetic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="micromega.html#high-level-view-of-lia">High level view of <code class="docutils literal notranslate"><span class="pre">lia</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="micromega.html#cutting-plane-proofs">Cutting plane proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="micromega.html#case-split">Case split</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="micromega.html#nra-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">nra</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="micromega.html#nia-a-proof-procedure-for-non-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">nia</span></code>: a proof procedure for non-linear integer arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="micromega.html#psatz-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">psatz</span></code>: a proof procedure for non-linear arithmetic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a><ul>
<li class="toctree-l2"><a class="reference internal" href="extraction.html#generating-ml-code">Generating ML Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="extraction.html#extraction-options">Extraction Options</a><ul>
<li class="toctree-l3"><a class="reference internal" href="extraction.html#setting-the-target-language">Setting the target language</a></li>
<li class="toctree-l3"><a class="reference internal" href="extraction.html#inlining-and-optimizations">Inlining and optimizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="extraction.html#extra-elimination-of-useless-arguments">Extra elimination of useless arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="extraction.html#realizing-axioms">Realizing axioms</a></li>
<li class="toctree-l3"><a class="reference internal" href="extraction.html#realizing-inductive-types">Realizing inductive types</a></li>
<li class="toctree-l3"><a class="reference internal" href="extraction.html#avoiding-conflicts-with-existing-filenames">Avoiding conflicts with existing filenames</a></li>
<li class="toctree-l3"><a class="reference internal" href="extraction.html#additional-settings">Additional settings</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="extraction.html#differences-between-coq-and-ml-type-systems">Differences between <span class="smallcaps">Coq</span> and ML type systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="extraction.html#some-examples">Some examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="extraction.html#a-detailed-example-euclidean-division">A detailed example: Euclidean division</a></li>
<li class="toctree-l3"><a class="reference internal" href="extraction.html#extraction-s-horror-museum">Extraction's horror museum</a></li>
<li class="toctree-l3"><a class="reference internal" href="extraction.html#users-contributions">Users' Contributions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="program.html">Program</a><ul>
<li class="toctree-l2"><a class="reference internal" href="program.html#elaborating-programs">Elaborating programs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="program.html#syntactic-control-over-equalities">Syntactic control over equalities</a></li>
<li class="toctree-l3"><a class="reference internal" href="program.html#program-definition">Program Definition</a></li>
<li class="toctree-l3"><a class="reference internal" href="program.html#program-fixpoint">Program Fixpoint</a></li>
<li class="toctree-l3"><a class="reference internal" href="program.html#program-lemma">Program Lemma</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="program.html#solving-obligations">Solving obligations</a></li>
<li class="toctree-l2"><a class="reference internal" href="program.html#frequently-asked-questions">Frequently Asked Questions</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">The ring and field tactic families</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-does-this-tactic-do">What does this tactic do?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-variables-map">The variables map</a></li>
<li class="toctree-l2"><a class="reference internal" href="#is-it-automatic">Is it automatic?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#concrete-usage-in-coq">Concrete usage in Coq</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adding-a-ring-structure">Adding a ring structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-does-it-work">How does it work?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dealing-with-fields">Dealing with fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adding-a-new-field-structure">Adding a new field structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#history-of-ring">History of ring</a></li>
<li class="toctree-l2"><a class="reference internal" href="#discussion">Discussion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nsatz.html">Nsatz: tactics for proving equalities in integral domains</a><ul>
<li class="toctree-l2"><a class="reference internal" href="nsatz.html#more-about-nsatz">More about <code class="docutils literal notranslate"><span class="pre">nsatz</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="generalized-rewriting.html">Generalized rewriting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="generalized-rewriting.html#introduction-to-generalized-rewriting">Introduction to generalized rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generalized-rewriting.html#relations-and-morphisms">Relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="generalized-rewriting.html#adding-new-relations-and-morphisms">Adding new relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="generalized-rewriting.html#rewriting-and-non-reflexive-relations">Rewriting and non reflexive relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="generalized-rewriting.html#rewriting-and-non-symmetric-relations">Rewriting and non symmetric relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="generalized-rewriting.html#rewriting-in-ambiguous-setoid-contexts">Rewriting in ambiguous setoid contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="generalized-rewriting.html#commands-and-tactics">Commands and tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generalized-rewriting.html#first-class-setoids-and-morphisms">First class setoids and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="generalized-rewriting.html#tactics-enabled-on-user-provided-relations">Tactics enabled on user provided relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="generalized-rewriting.html#printing-relations-and-morphisms">Printing relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="generalized-rewriting.html#deprecated-syntax-and-backward-incompatibilities">Deprecated syntax and backward incompatibilities</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="generalized-rewriting.html#extensions">Extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generalized-rewriting.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="generalized-rewriting.html#subrelations">Subrelations</a></li>
<li class="toctree-l3"><a class="reference internal" href="generalized-rewriting.html#constant-unfolding">Constant unfolding</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="generalized-rewriting.html#strategies-for-rewriting">Strategies for rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generalized-rewriting.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="generalized-rewriting.html#usage">Usage</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="parallel-proof-processing.html#proof-annotations">Proof annotations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="parallel-proof-processing.html#automatic-suggestion-of-proof-annotations">Automatic suggestion of proof annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="parallel-proof-processing.html#proof-blocks-and-error-resilience">Proof blocks and error resilience</a><ul>
<li class="toctree-l3"><a class="reference internal" href="parallel-proof-processing.html#caveats">Caveats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="parallel-proof-processing.html#interactive-mode">Interactive mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="parallel-proof-processing.html#id2">Caveats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="parallel-proof-processing.html#batch-mode">Batch mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-proof-processing.html#limiting-the-number-of-parallel-workers">Limiting the number of parallel workers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="miscellaneous-extensions.html">Miscellaneous extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous-extensions.html#program-derivation">Program derivation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="universe-polymorphism.html">Polymorphic Universes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="universe-polymorphism.html#general-presentation">General Presentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="universe-polymorphism.html#polymorphic-monomorphic">Polymorphic, Monomorphic</a></li>
<li class="toctree-l2"><a class="reference internal" href="universe-polymorphism.html#cumulative-noncumulative">Cumulative, NonCumulative</a><ul>
<li class="toctree-l3"><a class="reference internal" href="universe-polymorphism.html#an-example-of-a-proof-using-cumulativity">An example of a proof using cumulativity</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="universe-polymorphism.html#cumulativity-weak-constraints">Cumulativity Weak Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="universe-polymorphism.html#global-and-local-universes">Global and local universes</a></li>
<li class="toctree-l2"><a class="reference internal" href="universe-polymorphism.html#conversion-and-unification">Conversion and unification</a></li>
<li class="toctree-l2"><a class="reference internal" href="universe-polymorphism.html#minimization">Minimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="universe-polymorphism.html#explicit-universes">Explicit Universes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="universe-polymorphism.html#polymorphic-definitions">Polymorphic definitions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="sprop.html">SProp (proof irrelevant propositions)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="sprop.html#basic-constructs">Basic constructs</a></li>
<li class="toctree-l2"><a class="reference internal" href="sprop.html#encodings-for-strict-propositions">Encodings for strict propositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sprop.html#issues-with-non-cumulativity">Issues with non-cumulativity</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>The ring and field tactic families</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/addendum/ring.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="the-ring-and-field-tactic-families">
<span id="theringandfieldtacticfamilies"></span><h1>The ring and field tactic families<a class="headerlink" href="#the-ring-and-field-tactic-families" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Bruno Barras, Benjamin Grégoire, Assia Mahboubi, Laurent Théry <a class="footnote-reference brackets" href="#f1" id="id1">1</a></p>
</dd>
</dl>
<p>This chapter presents the tactics dedicated to dealing with ring and
field equations.</p>
<div class="section" id="what-does-this-tactic-do">
<h2>What does this tactic do?<a class="headerlink" href="#what-does-this-tactic-do" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ring</span></code> does associative-commutative rewriting in ring and semiring
structures. Assume you have two binary functions <span class="math notranslate nohighlight">\(\oplus\)</span> and
<span class="math notranslate nohighlight">\(\otimes\)</span> that are associative and commutative, with <span class="math notranslate nohighlight">\(\oplus\)</span>
distributive on <span class="math notranslate nohighlight">\(\otimes\)</span>, and two constants 0 and 1 that are unities for
<span class="math notranslate nohighlight">\(\oplus\)</span> and <span class="math notranslate nohighlight">\(\otimes\)</span>. A polynomial is an expression built on
variables <span class="math notranslate nohighlight">\(V_0\)</span>, <span class="math notranslate nohighlight">\(V_1\)</span>, <span class="math notranslate nohighlight">\(\dots\)</span> and constants by application
of <span class="math notranslate nohighlight">\(\oplus\)</span> and <span class="math notranslate nohighlight">\(\otimes\)</span>.</p>
<p>Let an ordered product be a product of variables <span class="math notranslate nohighlight">\(V_{i_1} \otimes \dots
\otimes V_{i_n}\)</span> verifying <span class="math notranslate nohighlight">\(i_1 ≤ i_2 ≤ \dots ≤ i_n\)</span> . Let a monomial be
the product of a constant and an ordered product. We can order the monomials by
the lexicographic order on products of variables. Let a canonical sum be an
ordered sum of monomials that are all different, i.e. each monomial in the sum
is strictly less than the following monomial according to the lexicographic
order. It is an easy theorem to show that every polynomial is equivalent (modulo
the ring properties) to exactly one canonical sum. This canonical sum is called
the normal form of the polynomial. In fact, the actual representation shares
monomials with same prefixes. So what does the <code class="docutils literal notranslate"><span class="pre">ring</span></code> tactic do? It normalizes polynomials over
any ring or semiring structure. The basic use of <code class="docutils literal notranslate"><span class="pre">ring</span></code> is to simplify ring
expressions, so that the user does not have to deal manually with the theorems
of associativity and commutativity.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<dl class="simple">
<dt>In the ring of integers, the normal form of</dt><dd><p><span class="math notranslate nohighlight">\(x (3 + yx + 25(1 − z)) + zx\)</span></p>
</dd>
<dt>is</dt><dd><p><span class="math notranslate nohighlight">\(28x + (−24)xz + xxy\)</span>.</p>
</dd>
</dl>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ring</span></code> is also able to compute a normal form modulo monomial equalities.
For example, under the hypothesis that <span class="math notranslate nohighlight">\(2x^2 = yz+1\)</span>, the normal form of
<span class="math notranslate nohighlight">\(2(x + 1)x − x − zy\)</span> is <span class="math notranslate nohighlight">\(x+1\)</span>.</p>
</div>
<div class="section" id="the-variables-map">
<h2>The variables map<a class="headerlink" href="#the-variables-map" title="Permalink to this headline">¶</a></h2>
<p>It is frequent to have an expression built with <span class="math notranslate nohighlight">\(+\)</span> and <span class="math notranslate nohighlight">\(\times\)</span>,
but rarely on variables only. Let us associate a number to each subterm of a
ring expression in the Gallina language. For example, consider this expression
in the semiring <code class="docutils literal notranslate"><span class="pre">nat</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(plus (mult (plus (f (5)) x) x)
      (mult (if b then (4) else (f (3))) (2)))
</pre></div>
</div>
<p>As a ring expression, it has 3 subterms. Give each subterm a number in
an arbitrary order:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 33%" />
<col style="width: 57%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>0</p></td>
<td><p><span class="math notranslate nohighlight">\(\mapsto\)</span></p></td>
<td><p>if b then (4) else (f (3))</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p><span class="math notranslate nohighlight">\(\mapsto\)</span></p></td>
<td><p>(f (5))</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p><span class="math notranslate nohighlight">\(\mapsto\)</span></p></td>
<td><p>x</p></td>
</tr>
</tbody>
</table>
<p>Then normalize the “abstract” polynomial
<span class="math notranslate nohighlight">\(((V_1 \oplus V_2 ) \otimes V_2) \oplus (V_0 \otimes 2)\)</span>
In our example the normal form is:
<span class="math notranslate nohighlight">\((2 \otimes V_0 ) \oplus (V_1 \otimes V_2) \oplus (V_2 \otimes V_2 )\)</span>.
Then substitute the variables by their values in the variables map to
get the concrete normal polynomial:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(plus (mult (2) (if b then (4) else (f (3))))
      (plus (mult (f (5)) x) (mult x x)))
</pre></div>
</div>
</div>
<div class="section" id="is-it-automatic">
<h2>Is it automatic?<a class="headerlink" href="#is-it-automatic" title="Permalink to this headline">¶</a></h2>
<p>Yes, building the variables map and doing the substitution after
normalizing is automatically done by the tactic. So you can just
forget this paragraph and use the tactic according to your intuition.</p>
</div>
<div class="section" id="concrete-usage-in-coq">
<h2>Concrete usage in Coq<a class="headerlink" href="#concrete-usage-in-coq" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>ring</span></span></code></dt>
<dd><p>This tactic solves equations upon polynomial expressions of a ring
(or semiring) structure. It proceeds by normalizing both sides
of the equation (w.r.t. associativity, commutativity and
distributivity, constant propagation, rewriting of monomials) and
comparing syntactically the results.</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>ring</span><span>_</span><span>simplify</span></span></code></dt>
<dd><p>This tactic applies the normalization procedure described above to
the given terms. The tactic then replaces all occurrences of the terms
given in the conclusion of the goal by their normal forms. If no term
is given, then the conclusion should be an equation and both
sides are normalized. The tactic can also be applied in a hypothesis.</p>
<p>The tactic must be loaded by <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">Ring</span></code>. The ring structures
must be declared with the <code class="docutils literal notranslate"><span class="pre">Add</span> <span class="pre">Ring</span></code> command (see below). The ring of
booleans is predefined; if one wants to use the tactic on <code class="docutils literal notranslate"><span class="pre">nat</span></code> one must
first require the module <code class="docutils literal notranslate"><span class="pre">ArithRing</span></code> exported by <code class="docutils literal notranslate"><span class="pre">Arith</span></code>); for <code class="docutils literal notranslate"><span class="pre">Z</span></code>, do
<code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">ZArithRing</span></code> or simply <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">ZArith</span></code>; for <code class="docutils literal notranslate"><span class="pre">N</span></code>, do
<code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">NArithRing</span></code> or <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">NArith</span></code>.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> ZArith.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Open Scope</span> Z_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ring-rst-chk0" style="display: none" type="checkbox"><label class="coq-input" for="ring-rst-chk0"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>:Z,
    (a + b + c) ^ <span class="mi">2</span> =
     a * a + b ^ <span class="mi">2</span> + c * c + <span class="mi">2</span> * a * b + <span class="mi">2</span> * a * c + <span class="mi">2</span> * b * c.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Z,
(a + b + c) ^ <span class="mi">2</span> =
a * a + b ^ <span class="mi">2</span> + c * c + <span class="mi">2</span> * a * b + <span class="mi">2</span> * a * c +
<span class="mi">2</span> * b * c</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span>; <span class="bp">ring</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ring-rst-chk1" style="display: none" type="checkbox"><label class="coq-input" for="ring-rst-chk1"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>:Z,
     <span class="mi">2</span> * a * b = <span class="mi">30</span> -&gt; (a + b) ^ <span class="mi">2</span> = a ^ <span class="mi">2</span> + b ^ <span class="mi">2</span> + <span class="mi">30</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Z,
<span class="mi">2</span> * a * b = <span class="mi">30</span> -&gt; (a + b) ^ <span class="mi">2</span> = a ^ <span class="mi">2</span> + b ^ <span class="mi">2</span> + <span class="mi">30</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span> a b H; <span class="bp">ring</span> [H].</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre></div></div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>ring</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">*</span></span><span>]</span></span></code></dt>
<dd><p>This tactic decides the equality of two terms modulo ring operations and
the equalities defined by the <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>s.
Each <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> has to be a proof of some equality <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">p</span></span></code>, where <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span></code>
is a monomial (after “abstraction”), <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">p</span></span></code> a polynomial and <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">=</span></span></code> the
corresponding equality of the ring structure.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>ring</span><span>_</span><span>simplify</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">*</span></span><span>]</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">*</span></span> <span>in</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This tactic performs the simplification in the hypothesis named <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">ring</span></span><span><span class="pre">_</span></span><span><span class="pre">simplify</span></span> <span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span><span><span class="pre">;</span></span> <span><span class="pre">ring</span></span><span><span class="pre">_</span></span><span><span class="pre">simplify</span></span> <span class="hole"><span class="pre">term</span><sub><span class="pre">2</span></sub></span></span></code> is not equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">ring</span></span><span><span class="pre">_</span></span><span><span class="pre">simplify</span></span> <span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span> <span class="hole"><span class="pre">term</span><sub><span class="pre">2</span></sub></span></span></code>.</p>
<p>In the latter case the variables map is shared between the two terms, and
common subterm <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span><sub><span class="pre">2</span></sub></span></span></code>
will have the same associated variable number. So the first
alternative should be avoided for terms belonging to the same ring
theory.</p>
</div>
<p>Error messages:</p>
<dl class="coq exn">
<dt id="coq:exn.not-a-valid-ring-equation">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>a</span> <span>valid</span> <span>ring</span> <span>equation.</span></span></code><a class="headerlink" href="#coq:exn.not-a-valid-ring-equation" title="Permalink to this definition">¶</a></dt>
<dd><p>The conclusion of the goal is not provable in the corresponding ring theory.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.arguments-of-ring-simplify-do-not-have-all-the-same-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Arguments</span> <span>of</span> <span>ring</span><span>_</span><span>simplify</span> <span>do</span> <span>not</span> <span>have</span> <span>all</span> <span>the</span> <span>same</span> <span>type.</span></span></code><a class="headerlink" href="#coq:exn.arguments-of-ring-simplify-do-not-have-all-the-same-type" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.ring-simplify" title="ring_simplify"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">ring_simplify</span></code></a> cannot simplify terms of several rings at the same
time. Invoke the tactic once per ring structure.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.cannot-find-a-declared-ring-structure-over-term">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>find</span> <span>a</span> <span>declared</span> <span>ring</span> <span>structure</span> <span>over</span> <span class="hole">term</span><span>.</span></span></code><a class="headerlink" href="#coq:exn.cannot-find-a-declared-ring-structure-over-term" title="Permalink to this definition">¶</a></dt>
<dd><p>No ring has been declared for the type of the terms to be simplified.
Use <a class="reference internal" href="#coq:cmd.add-ring" title="Add Ring"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Add</span> <span class="pre">Ring</span></code></a> first.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.cannot-find-a-declared-ring-structure-for-equality-term">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>find</span> <span>a</span> <span>declared</span> <span>ring</span> <span>structure</span> <span>for</span> <span>equality</span> <span class="hole">term</span><span>.</span></span></code><a class="headerlink" href="#coq:exn.cannot-find-a-declared-ring-structure-for-equality-term" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as above in the case of the <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.ring" title="ring"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">ring</span></code></a> tactic.</p>
</dd></dl>

</div>
<div class="section" id="adding-a-ring-structure">
<h2>Adding a ring structure<a class="headerlink" href="#adding-a-ring-structure" title="Permalink to this headline">¶</a></h2>
<p>Declaring a new ring consists in proving that a ring signature (a
carrier set, an equality, and ring operations: <code class="docutils literal notranslate"><span class="pre">Ring_theory.ring_theory</span></code>
and <code class="docutils literal notranslate"><span class="pre">Ring_theory.semi_ring_theory</span></code>) satisfies the ring axioms. Semi-
rings (rings without + inverse) are also supported. The equality can
be either Leibniz equality, or any relation declared as a setoid (see
<a class="reference internal" href="generalized-rewriting.html#tactics-enabled-on-user-provided-relations"><span class="std std-ref">Tactics enabled on user provided relations</span></a>).
The definitions of ring and semiring (see module <code class="docutils literal notranslate"><span class="pre">Ring_theory</span></code>) are:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Record</span> <span class="nf">ring_theory</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">mk_rt</span> <span class="o">{</span>
  <span class="n">Radd_0_l</span>    <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span><span class="o">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">;</span>
  <span class="n">Radd_sym</span>    <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span><span class="o">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span><span class="o">;</span>
  <span class="n">Radd_assoc</span>  <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="o">,</span> <span class="n">x</span> <span class="o">+</span> <span class="o">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">)</span> <span class="o">==</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span> <span class="o">+</span> <span class="n">z</span><span class="o">;</span>
  <span class="n">Rmul_1_l</span>    <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span><span class="o">,</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">;</span>
  <span class="n">Rmul_sym</span>    <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span><span class="o">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">==</span> <span class="n">y</span> <span class="o">*</span> <span class="n">x</span><span class="o">;</span>
  <span class="n">Rmul_assoc</span>  <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="o">,</span> <span class="n">x</span> <span class="o">*</span> <span class="o">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">z</span><span class="o">)</span> <span class="o">==</span> <span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">)</span> <span class="o">*</span> <span class="n">z</span><span class="o">;</span>
  <span class="n">Rdistr_l</span>    <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span> <span class="o">*</span> <span class="n">z</span> <span class="o">==</span> <span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">z</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">z</span><span class="o">);</span>
  <span class="n">Rsub_def</span>    <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span><span class="o">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">==</span> <span class="n">x</span> <span class="o">+</span> <span class="o">-</span><span class="n">y</span><span class="o">;</span>
  <span class="n">Ropp_def</span>    <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span><span class="o">,</span> <span class="n">x</span> <span class="o">+</span> <span class="o">(-</span> <span class="n">x</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="o">}.</span>

<span class="kn">Record</span> <span class="nf">semi_ring_theory</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">mk_srt</span> <span class="o">{</span>
  <span class="n">SRadd_0_l</span>   <span class="o">:</span> <span class="kr">forall</span> <span class="nv">n</span><span class="o">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">n</span> <span class="o">==</span> <span class="n">n</span><span class="o">;</span>
  <span class="n">SRadd_sym</span>   <span class="o">:</span> <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span><span class="o">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span> <span class="o">==</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">;</span>
  <span class="n">SRadd_assoc</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span><span class="o">,</span> <span class="n">n</span> <span class="o">+</span> <span class="o">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">p</span><span class="o">)</span> <span class="o">==</span> <span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="o">)</span> <span class="o">+</span> <span class="n">p</span><span class="o">;</span>
  <span class="n">SRmul_1_l</span>   <span class="o">:</span> <span class="kr">forall</span> <span class="nv">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">*</span><span class="n">n</span> <span class="o">==</span> <span class="n">n</span><span class="o">;</span>
  <span class="n">SRmul_0_l</span>   <span class="o">:</span> <span class="kr">forall</span> <span class="nv">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">*</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
  <span class="n">SRmul_sym</span>   <span class="o">:</span> <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span><span class="o">,</span> <span class="n">n</span><span class="o">*</span><span class="n">m</span> <span class="o">==</span> <span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="o">;</span>
  <span class="n">SRmul_assoc</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span><span class="o">,</span> <span class="n">n</span><span class="o">*(</span><span class="n">m</span><span class="o">*</span><span class="n">p</span><span class="o">)</span> <span class="o">==</span> <span class="o">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="o">)*</span><span class="n">p</span><span class="o">;</span>
  <span class="n">SRdistr_l</span>   <span class="o">:</span> <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="o">)*</span><span class="n">p</span> <span class="o">==</span> <span class="n">n</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">p</span>
<span class="o">}.</span>
</pre></div>
</div>
<p>This implementation of <code class="docutils literal notranslate"><span class="pre">ring</span></code> also features a notion of constant that
can be parameterized. This can be used to improve the handling of
closed expressions when operations are effective. It consists in
introducing a type of <em>coefficients</em> and an implementation of the ring
operations, and a morphism from the coefficient type to the ring
carrier type. The morphism needs not be injective, nor surjective.</p>
<p>As an example, one can consider the real numbers. The set of
coefficients could be the rational numbers, upon which the ring
operations can be implemented. The fact that there exists a morphism
is defined by the following properties:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Record</span> <span class="nf">ring_morph</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">mkmorph</span> <span class="o">{</span>
  <span class="n">morph0</span>    <span class="o">:</span> <span class="o">[</span><span class="n">cO</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
  <span class="n">morph1</span>    <span class="o">:</span> <span class="o">[</span><span class="n">cI</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">morph_add</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span> <span class="o">+!</span> <span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="o">[</span><span class="n">x</span><span class="o">]+[</span><span class="n">y</span><span class="o">];</span>
  <span class="n">morph_sub</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span> <span class="o">-!</span> <span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="o">[</span><span class="n">x</span><span class="o">]-[</span><span class="n">y</span><span class="o">];</span>
  <span class="n">morph_mul</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span> <span class="o">*!</span> <span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="o">[</span><span class="n">x</span><span class="o">]*[</span><span class="n">y</span><span class="o">];</span>
  <span class="n">morph_opp</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span><span class="o">,</span> <span class="o">[-!</span><span class="n">x</span><span class="o">]</span> <span class="o">==</span> <span class="o">-[</span><span class="n">x</span><span class="o">];</span>
  <span class="n">morph_eq</span>  <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span><span class="o">,</span> <span class="n">x</span><span class="o">?=!</span><span class="n">y</span> <span class="o">=</span> <span class="n">true</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">==</span> <span class="o">[</span><span class="n">y</span><span class="o">]</span>
<span class="o">}.</span>

<span class="kn">Record</span> <span class="nf">semi_morph</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">mkRmorph</span> <span class="o">{</span>
  <span class="n">Smorph0</span> <span class="o">:</span> <span class="o">[</span><span class="n">cO</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
  <span class="n">Smorph1</span> <span class="o">:</span> <span class="o">[</span><span class="n">cI</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">Smorph_add</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span> <span class="o">+!</span> <span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="o">[</span><span class="n">x</span><span class="o">]+[</span><span class="n">y</span><span class="o">];</span>
  <span class="n">Smorph_mul</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span> <span class="o">*!</span> <span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="o">[</span><span class="n">x</span><span class="o">]*[</span><span class="n">y</span><span class="o">];</span>
  <span class="n">Smorph_eq</span>  <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span><span class="o">,</span> <span class="n">x</span><span class="o">?=!</span><span class="n">y</span> <span class="o">=</span> <span class="n">true</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">==</span> <span class="o">[</span><span class="n">y</span><span class="o">]</span>
<span class="o">}.</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">c0</span></code> and <code class="docutils literal notranslate"><span class="pre">cI</span></code> denote the 0 and 1 of the coefficient set, <code class="docutils literal notranslate"><span class="pre">+!</span></code>, <code class="docutils literal notranslate"><span class="pre">*!</span></code>, <code class="docutils literal notranslate"><span class="pre">-!</span></code>
are the implementations of the ring operations, <code class="docutils literal notranslate"><span class="pre">==</span></code> is the equality of
the coefficients, <code class="docutils literal notranslate"><span class="pre">?+!</span></code> is an implementation of this equality, and <code class="docutils literal notranslate"><span class="pre">[x]</span></code>
is a notation for the image of <code class="docutils literal notranslate"><span class="pre">x</span></code> by the ring morphism.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">Z</span></code> is an initial ring (and <code class="docutils literal notranslate"><span class="pre">N</span></code> is an initial semiring), it can
always be considered as a set of coefficients. There are basically
three kinds of (semi-)rings:</p>
<dl class="simple">
<dt>abstract rings</dt><dd><p>to be used when operations are not effective. The set
of coefficients is <code class="docutils literal notranslate"><span class="pre">Z</span></code> (or <code class="docutils literal notranslate"><span class="pre">N</span></code> for semirings).</p>
</dd>
<dt>computational rings</dt><dd><p>to be used when operations are effective. The
set of coefficients is the ring itself. The user only has to provide
an implementation for the equality.</p>
</dd>
<dt>customized ring</dt><dd><p>for other cases. The user has to provide the
coefficient set and the morphism.</p>
</dd>
</dl>
<p>This implementation of ring can also recognize simple power
expressions as ring expressions. A power function is specified by the
following property:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Reals.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">POWER</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">Cpow</span> : <span class="kt">Set</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">Cp_phi</span> : N -&gt; Cpow.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">rpow</span> : R -&gt; Cpow -&gt; R.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">power_theory</span> : <span class="kt">Prop</span> := mkpow_th {
    rpow_pow_N : <span class="kr">forall</span> <span class="nv">r</span> <span class="nv">n</span>, rpow r (Cp_phi n) = pow_N <span class="mi">1</span>%R Rmult r n
  }.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">POWER</span>.</span></span></span></pre></div><p>The syntax for adding a new ring is</p>
<dl class="coq cmd">
<dt id="coq:cmd.add-ring">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Add</span> <span>Ring</span> <span class="hole">ident</span> <span>:</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <span class="hole">ring_mod</span> <span class="repeat-wrapper"><span class="repeat"><span>,</span> <span class="hole">ring_mod</span></span><span class="notation-sup">*</span></span> <span>)</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.add-ring" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is not relevant. It is used just for error messages. The
<code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> is a proof that the ring signature satisfies the (semi-)ring
axioms. The optional list of modifiers is used to tailor the behavior
of the tactic. The following list describes their syntax and effects:</p>
<pre>
<strong id="grammar-token-coq-ring_mod"><span id="grammar-token-ring-mod"></span>ring_mod</strong> ::=  abstract | decidable <code class="xref docutils literal notranslate"><span class="pre">term</span></code> | morphism <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
              setoid <code class="xref docutils literal notranslate"><span class="pre">term</span></code> <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
              constants [ <code class="xref docutils literal notranslate"><span class="pre">tactic</span></code> ]
              preprocess [ <code class="xref docutils literal notranslate"><span class="pre">tactic</span></code> ]
              postprocess [ <code class="xref docutils literal notranslate"><span class="pre">tactic</span></code> ]
              power_tac <code class="xref docutils literal notranslate"><span class="pre">term</span></code> [ <code class="xref docutils literal notranslate"><span class="pre">tactic</span></code> ]
              sign <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
              div <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
</pre>
<dl class="simple">
<dt>abstract</dt><dd><p>declares the ring as abstract. This is the default.</p>
</dd>
<dt>decidable <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code></dt><dd><p>declares the ring as computational. The expression
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> is the correctness proof of an equality test <code class="docutils literal notranslate"><span class="pre">?=!</span></code>
(which should be evaluable). Its type should be of the form
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">x</span> <span class="pre">y,</span> <span class="pre">x</span> <span class="pre">?=!</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">true</span> <span class="pre">→</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code>.</p>
</dd>
<dt>morphism <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code></dt><dd><p>declares the ring as a customized one. The expression
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> is a proof that there exists a morphism between a set of
coefficient and the ring carrier (see <code class="docutils literal notranslate"><span class="pre">Ring_theory.ring_morph</span></code> and
<code class="docutils literal notranslate"><span class="pre">Ring_theory.semi_morph</span></code>).</p>
</dd>
<dt>setoid <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code></dt><dd><p>forces the use of given setoid. The first
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> is a proof that the equality is indeed a setoid (see
<code class="docutils literal notranslate"><span class="pre">Setoid.Setoid_Theory</span></code>), and the second <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> a proof that the
ring operations are morphisms (see <code class="docutils literal notranslate"><span class="pre">Ring_theory.ring_eq_ext</span></code> and
<code class="docutils literal notranslate"><span class="pre">Ring_theory.sring_eq_ext</span></code>).
This modifier needs not be used if the setoid and morphisms have been
declared.</p>
</dd>
<dt>constants [ <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> ]</dt><dd><p>specifies a tactic expression <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> that, given a
term, returns either an object of the coefficient set that is mapped
to the expression via the morphism, or returns
<code class="docutils literal notranslate"><span class="pre">InitialRing.NotConstant</span></code>. The default behavior is to map only 0 and 1
to their counterpart in the coefficient set. This is generally not
desirable for non trivial computational rings.</p>
</dd>
<dt>preprocess [ <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> ]</dt><dd><p>specifies a tactic <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> that is applied as a
preliminary step for <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.ring" title="ring"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">ring</span></code></a> and <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.ring-simplify" title="ring_simplify"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">ring_simplify</span></code></a>. It can be used to
transform a goal so that it is better recognized. For instance, <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">n</span></code>
can be changed to <code class="docutils literal notranslate"><span class="pre">plus</span> <span class="pre">1</span> <span class="pre">n</span></code>.</p>
</dd>
<dt>postprocess [ <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> ]</dt><dd><p>specifies a tactic <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> that is applied as a final
step for <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.ring-simplify" title="ring_simplify"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">ring_simplify</span></code></a>. For instance, it can be used to undo
modifications of the preprocessor.</p>
</dd>
<dt>power_tac <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> [ <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> ]</dt><dd><p>allows <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.ring" title="ring"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">ring</span></code></a> and <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.ring-simplify" title="ring_simplify"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">ring_simplify</span></code></a> to recognize
power expressions with a constant positive integer exponent (example:
<span class="math notranslate nohighlight">\(x^2\)</span> ). The term <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> is a proof that a given power function satisfies
the specification of a power function (term has to be a proof of
<code class="docutils literal notranslate"><span class="pre">Ring_theory.power_theory</span></code>) and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> specifies a tactic expression
that, given a term, “abstracts” it into an object of type <code class="docutils literal notranslate"><span class="pre">N</span></code> whose
interpretation via <code class="docutils literal notranslate"><span class="pre">Cp_phi</span></code> (the evaluation function of power
coefficient) is the original term, or returns <code class="docutils literal notranslate"><span class="pre">InitialRing.NotConstant</span></code>
if not a constant coefficient (i.e. <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> is the inverse function of
<code class="docutils literal notranslate"><span class="pre">Cp_phi</span></code>). See files <code class="docutils literal notranslate"><span class="pre">plugins/setoid_ring/ZArithRing.v</span></code>
and <code class="docutils literal notranslate"><span class="pre">plugins/setoid_ring/RealField.v</span></code> for examples. By default the tactic
does not recognize power expressions as ring expressions.</p>
</dd>
<dt>sign <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code></dt><dd><p>allows <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.ring-simplify" title="ring_simplify"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">ring_simplify</span></code></a> to use a minus operation when
outputting its normal form, i.e writing <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">−</span> <span class="pre">y</span></code> instead of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">(−</span> <span class="pre">y)</span></code>. The
term <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> is a proof that a given sign function indicates expressions
that are signed (<code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> has to be a proof of <code class="docutils literal notranslate"><span class="pre">Ring_theory.get_sign</span></code>). See
<code class="docutils literal notranslate"><span class="pre">plugins/setoid_ring/InitialRing.v</span></code> for examples of sign function.</p>
</dd>
<dt>div <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code></dt><dd><p>allows <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.ring" title="ring"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">ring</span></code></a> and <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.ring-simplify" title="ring_simplify"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">ring_simplify</span></code></a> to use monomials with
coefficients other than 1 in the rewriting. The term <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> is a proof
that a given division function satisfies the specification of an
euclidean division function (<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> has to be a proof of
<code class="docutils literal notranslate"><span class="pre">Ring_theory.div_theory</span></code>). For example, this function is called when
trying to rewrite <span class="math notranslate nohighlight">\(7x\)</span> by <span class="math notranslate nohighlight">\(2x = z\)</span> to tell that <span class="math notranslate nohighlight">\(7 = 3 \times 2 + 1\)</span>. See
<code class="docutils literal notranslate"><span class="pre">plugins/setoid_ring/InitialRing.v</span></code> for examples of div function.</p>
</dd>
</dl>
</dd></dl>

<p>Error messages:</p>
<dl class="coq exn">
<dt id="coq:exn.bad-ring-structure">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Bad</span> <span>ring</span> <span>structure.</span></span></code><a class="headerlink" href="#coq:exn.bad-ring-structure" title="Permalink to this definition">¶</a></dt>
<dd><p>The proof of the ring structure provided is not
of the expected type.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.bad-lemma-for-decidability-of-equality">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Bad</span> <span>lemma</span> <span>for</span> <span>decidability</span> <span>of</span> <span>equality.</span></span></code><a class="headerlink" href="#coq:exn.bad-lemma-for-decidability-of-equality" title="Permalink to this definition">¶</a></dt>
<dd><p>The equality function
provided in the case of a computational ring has not the expected
type.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.ring-operation-should-be-declared-as-a-morphism">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Ring</span> <span>operation</span> <span>should</span> <span>be</span> <span>declared</span> <span>as</span> <span>a</span> <span>morphism.</span></span></code><a class="headerlink" href="#coq:exn.ring-operation-should-be-declared-as-a-morphism" title="Permalink to this definition">¶</a></dt>
<dd><p>A setoid associated to the carrier of the ring structure has been found,
but the ring operation should be declared as morphism. See <a class="reference internal" href="generalized-rewriting.html#tactics-enabled-on-user-provided-relations"><span class="std std-ref">Tactics enabled on user provided relations</span></a>.</p>
</dd></dl>

</div>
<div class="section" id="how-does-it-work">
<h2>How does it work?<a class="headerlink" href="#how-does-it-work" title="Permalink to this headline">¶</a></h2>
<p>The code of <code class="docutils literal notranslate"><span class="pre">ring</span></code> is a good example of a tactic written using <em>reflection</em>.
What is reflection? Basically, using it means that a part of a tactic is written
in Gallina, Coq's language of terms, rather than <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> or <span class="smallcaps">OCaml</span>. From the
philosophical point of view, reflection is using the ability of the Calculus of
Constructions to speak and reason about itself. For the <code class="docutils literal notranslate"><span class="pre">ring</span></code> tactic we used
Coq as a programming language and also as a proof environment to build a tactic
and to prove its correctness.</p>
<p>The interested reader is strongly advised to have a look at the
file <code class="docutils literal notranslate"><span class="pre">Ring_polynom.v</span></code>. Here a type for polynomials is defined:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Inductive</span> <span class="nf">PExpr</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="o">|</span> <span class="n">PEc</span> <span class="o">:</span> <span class="n">C</span> <span class="o">-&gt;</span> <span class="n">PExpr</span>
  <span class="o">|</span> <span class="n">PEX</span> <span class="o">:</span> <span class="n">positive</span> <span class="o">-&gt;</span> <span class="n">PExpr</span>
  <span class="o">|</span> <span class="n">PEadd</span> <span class="o">:</span> <span class="n">PExpr</span> <span class="o">-&gt;</span> <span class="n">PExpr</span> <span class="o">-&gt;</span> <span class="n">PExpr</span>
  <span class="o">|</span> <span class="n">PEsub</span> <span class="o">:</span> <span class="n">PExpr</span> <span class="o">-&gt;</span> <span class="n">PExpr</span> <span class="o">-&gt;</span> <span class="n">PExpr</span>
  <span class="o">|</span> <span class="n">PEmul</span> <span class="o">:</span> <span class="n">PExpr</span> <span class="o">-&gt;</span> <span class="n">PExpr</span> <span class="o">-&gt;</span> <span class="n">PExpr</span>
  <span class="o">|</span> <span class="n">PEopp</span> <span class="o">:</span> <span class="n">PExpr</span> <span class="o">-&gt;</span> <span class="n">PExpr</span>
  <span class="o">|</span> <span class="n">PEpow</span> <span class="o">:</span> <span class="n">PExpr</span> <span class="o">-&gt;</span> <span class="n">N</span> <span class="o">-&gt;</span> <span class="n">PExpr</span><span class="o">.</span>
</pre></div>
</div>
<p>Polynomials in normal form are defined as:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Inductive</span> <span class="nf">Pol</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="o">|</span> <span class="n">Pc</span> <span class="o">:</span> <span class="n">C</span> <span class="o">-&gt;</span> <span class="n">Pol</span>
  <span class="o">|</span> <span class="n">Pinj</span> <span class="o">:</span> <span class="n">positive</span> <span class="o">-&gt;</span> <span class="n">Pol</span> <span class="o">-&gt;</span> <span class="n">Pol</span>
  <span class="o">|</span> <span class="n">PX</span> <span class="o">:</span> <span class="n">Pol</span> <span class="o">-&gt;</span> <span class="n">positive</span> <span class="o">-&gt;</span> <span class="n">Pol</span> <span class="o">-&gt;</span> <span class="n">Pol</span><span class="o">.</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Pinj</span> <span class="pre">n</span> <span class="pre">P</span></code> denotes <code class="docutils literal notranslate"><span class="pre">P</span></code> in which <span class="math notranslate nohighlight">\(V_i\)</span> is replaced by <span class="math notranslate nohighlight">\(V_{i+n}\)</span> ,
and <code class="docutils literal notranslate"><span class="pre">PX</span> <span class="pre">P</span> <span class="pre">n</span> <span class="pre">Q</span></code> denotes <span class="math notranslate nohighlight">\(P \otimes V_1^n \oplus Q'\)</span>, <code class="docutils literal notranslate"><span class="pre">Q'</span></code> being <code class="docutils literal notranslate"><span class="pre">Q</span></code> where <span class="math notranslate nohighlight">\(V_i\)</span> is replaced by <span class="math notranslate nohighlight">\(V_{i+1}\)</span>.</p>
<p>Variable maps are represented by lists of ring elements, and two
interpretation functions, one that maps a variables map and a
polynomial to an element of the concrete ring, and the second one that
does the same for normal forms:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Definition</span> <span class="nf">PEeval</span> <span class="o">:</span> <span class="n">list</span> <span class="n">R</span> <span class="o">-&gt;</span> <span class="n">PExpr</span> <span class="o">-&gt;</span> <span class="n">R</span> <span class="o">:=</span> <span class="o">[...].</span>
<span class="kn">Definition</span> <span class="nf">Pphi_dev</span> <span class="o">:</span> <span class="n">list</span> <span class="n">R</span> <span class="o">-&gt;</span> <span class="n">Pol</span> <span class="o">-&gt;</span> <span class="n">R</span> <span class="o">:=</span> <span class="o">[...].</span>
</pre></div>
</div>
<p>A function to normalize polynomials is defined, and the big theorem is
its correctness w.r.t interpretation, that is:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Definition</span> <span class="nf">norm</span> <span class="o">:</span> <span class="n">PExpr</span> <span class="o">-&gt;</span> <span class="n">Pol</span> <span class="o">:=</span> <span class="o">[...].</span>
<span class="kn">Lemma</span> <span class="nf">Pphi_dev_ok</span> <span class="o">:</span>
   <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">pe</span> <span class="nv">npe</span><span class="o">,</span> <span class="n">norm</span> <span class="n">pe</span> <span class="o">=</span> <span class="n">npe</span> <span class="o">-&gt;</span> <span class="n">PEeval</span> <span class="n">l</span> <span class="n">pe</span> <span class="o">==</span> <span class="n">Pphi_dev</span> <span class="n">l</span> <span class="n">npe</span><span class="o">.</span>
</pre></div>
</div>
<p>So now, what is the scheme for a normalization proof? Let p be the
polynomial expression that the user wants to normalize. First a little
piece of <span class="smallcaps">ML</span> code guesses the type of <code class="docutils literal notranslate"><span class="pre">p</span></code>, the ring theory <code class="docutils literal notranslate"><span class="pre">T</span></code> to use, an
abstract polynomial <code class="docutils literal notranslate"><span class="pre">ap</span></code> and a variables map <code class="docutils literal notranslate"><span class="pre">v</span></code> such that <code class="docutils literal notranslate"><span class="pre">p</span></code> is <span class="math notranslate nohighlight">\(\beta\delta\iota\)</span>-
equivalent to <code class="docutils literal notranslate"><span class="pre">(PEeval</span> <span class="pre">v</span> <span class="pre">ap)</span></code>. Then we replace it by <code class="docutils literal notranslate"><span class="pre">(Pphi_dev</span> <span class="pre">v</span> <span class="pre">(norm</span> <span class="pre">ap))</span></code>,
using the main correctness theorem and we reduce it to a
concrete expression <code class="docutils literal notranslate"><span class="pre">p’</span></code>, which is the concrete normal form of <code class="docutils literal notranslate"><span class="pre">p</span></code>. This is summarized in this diagram:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 47%" />
<col style="width: 32%" />
<col style="width: 21%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">p</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\rightarrow_{\beta\delta\iota}\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(PEeval</span></code> <code class="docutils literal notranslate"><span class="pre">v</span></code> <code class="docutils literal notranslate"><span class="pre">ap</span></code><code class="docutils literal notranslate"><span class="pre">)</span></code></p></td>
</tr>
<tr class="row-even"><td><p></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code><sub>(by the main correctness theorem)</sub></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">p’</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\leftarrow_{\beta\delta\iota}\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(Pphi_dev</span></code> <code class="docutils literal notranslate"><span class="pre">v</span></code> <code class="docutils literal notranslate"><span class="pre">(norm</span></code> <code class="docutils literal notranslate"><span class="pre">ap</span></code><code class="docutils literal notranslate"><span class="pre">))</span></code></p></td>
</tr>
</tbody>
</table>
<p>The user does not see the right part of the diagram. From outside, the
tactic behaves like a <span class="math notranslate nohighlight">\(\beta\delta\iota\)</span> simplification extended with rewriting rules
for associativity and commutativity. Basically, the proof is only the
application of the main correctness theorem to well-chosen arguments.</p>
</div>
<div class="section" id="dealing-with-fields">
<h2>Dealing with fields<a class="headerlink" href="#dealing-with-fields" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>field</span></span></code></dt>
<dd><p>This tactic is an extension of the <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.ring" title="ring"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">ring</span></code></a> tactic that deals with rational
expressions. Given a rational expression <span class="math notranslate nohighlight">\(F = 0\)</span>. It first reduces the
expression <code class="docutils literal notranslate"><span class="pre">F</span></code> to a common denominator <span class="math notranslate nohighlight">\(N/D = 0\)</span> where <code class="docutils literal notranslate"><span class="pre">N</span></code> and <code class="docutils literal notranslate"><span class="pre">D</span></code>
are two ring expressions. For example, if we take <span class="math notranslate nohighlight">\(F = (1 − 1/x) x − x + 1\)</span>, this
gives <span class="math notranslate nohighlight">\(N = (x − 1) x − x^2 + x\)</span> and <span class="math notranslate nohighlight">\(D = x\)</span>. It then calls ring to solve
<span class="math notranslate nohighlight">\(N = 0\)</span>.</p>
<p>Note that <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">field</span></span></span></code> also generates nonzero conditions for all the
denominators it encounters in the reduction. In our example, it
generates the condition <span class="math notranslate nohighlight">\(x \neq 0\)</span>. These conditions appear as one subgoal
which is a conjunction if there are several denominators. Nonzero
conditions are always polynomial expressions. For example when
reducing the expression <span class="math notranslate nohighlight">\(1/(1 + 1/x)\)</span>, two side conditions are
generated: <span class="math notranslate nohighlight">\(x \neq 0\)</span> and <span class="math notranslate nohighlight">\(x + 1 \neq 0\)</span>. Factorized expressions are broken since
a field is an integral domain, and when the equality test on
coefficients is complete w.r.t. the equality of the target field,
constants can be proven different from zero automatically.</p>
<p>The tactic must be loaded by <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">Field</span></code>. New field
structures can be declared to the system with the <code class="docutils literal notranslate"><span class="pre">Add</span> <span class="pre">Field</span></code> command
(see below). The field of real numbers is defined in module <code class="docutils literal notranslate"><span class="pre">RealField</span></code>
(in <code class="docutils literal notranslate"><span class="pre">plugins/setoid_ring</span></code>). It is exported by module <code class="docutils literal notranslate"><span class="pre">Rbase</span></code>, so
that requiring <code class="docutils literal notranslate"><span class="pre">Rbase</span></code> or <code class="docutils literal notranslate"><span class="pre">Reals</span></code> is enough to use the field tactics on
real numbers. Rational numbers in canonical form are also declared as
a field in the module <code class="docutils literal notranslate"><span class="pre">Qcanon</span></code>.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Reals.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Open Scope</span> R_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ring-rst-chk2" style="display: none" type="checkbox"><label class="coq-input" for="ring-rst-chk2"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">x</span>,
       x &lt;&gt; <span class="mi">0</span> -&gt; (<span class="mi">1</span> - <span class="mi">1</span> / x) * x - x + <span class="mi">1</span> = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : R, x &lt;&gt; <span class="mi">0</span> -&gt; (<span class="mi">1</span> - <span class="mi">1</span> / x) * x - x + <span class="mi">1</span> = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span>; <span class="bp">field</span>; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ring-rst-chk3" style="display: none" type="checkbox"><label class="coq-input" for="ring-rst-chk3"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>,
       y &lt;&gt; <span class="mi">0</span> -&gt; y = x -&gt; x / y = <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : R, y &lt;&gt; <span class="mi">0</span> -&gt; y = x -&gt; x / y = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span> x y H H1; <span class="bp">field</span> [H1]; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre></div></div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>field</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">*</span></span><span>]</span></span></code></dt>
<dd><p>This tactic decides the equality of two terms modulo
field operations and the equalities defined
by the <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>s. Each <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> has to be a proof of some equality
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">p</span></span></code>, where <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span></code> is a monomial (after “abstraction”), <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">p</span></span></code> a polynomial
and <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">=</span></span></code> the corresponding equality of the field structure.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rewriting works with the equality  <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">p</span></span></code> only if <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">p</span></span></code> is a polynomial since
rewriting is handled by the underlying ring tactic.</p>
</div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span></span></code></dt>
<dd><p>performs the simplification in the conclusion of the
goal, <span class="math notranslate nohighlight">\(F_1 = F_2\)</span> becomes <span class="math notranslate nohighlight">\(N_1 / D_1 = N_2 / D_2\)</span>. A normalization step
(the same as the one for rings) is then applied to <span class="math notranslate nohighlight">\(N_1\)</span>, <span class="math notranslate nohighlight">\(D_1\)</span>,
<span class="math notranslate nohighlight">\(N_2\)</span> and <span class="math notranslate nohighlight">\(D_2\)</span>. This way, polynomials remain in factorized form during
fraction simplification. This yields smaller expressions when
reducing to the same denominator since common factors can be canceled.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">*</span></span><span>]</span></span></code></dt>
<dd><p>This variant performs the simplification in the conclusion of the goal using the equalities
defined by the <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>s.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">*</span></span><span>]</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This variant performs the simplification in the terms <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>s  of the conclusion of the goal
using the equalities defined by <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>s inside the brackets.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span> <span>in</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This variant performs the simplification in the assumption <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">*</span></span><span>]</span> <span>in</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This variant performs the simplification
in the assumption <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> using the equalities defined by the <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>s.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">*</span></span><span>]</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">*</span></span> <span>in</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This variant performs the simplification in the <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>s of the
assumption <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> using the
equalities defined by the <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>s inside the brackets.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span><span>_</span><span>eq</span></span></code></dt>
<dd><p>performs the simplification in the conclusion of
the goal removing the denominator. <span class="math notranslate nohighlight">\(F_1 = F_2\)</span> becomes <span class="math notranslate nohighlight">\(N_1 D_2 = N_2 D_1\)</span>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span><span>_</span><span>eq</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">*</span></span><span>]</span></span></code></dt>
<dd><p>This variant performs the simplification in
the conclusion of the goal using the equalities defined by <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>s.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span><span>_</span><span>eq</span> <span>in</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This variant performs the simplification in the assumption <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span><span>_</span><span>eq</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">*</span></span><span>]</span> <span>in</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This variant performs the simplification in the assumption <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>
using the equalities defined by <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>s and removing the denominator.</p>
</dd></dl>

</div>
<div class="section" id="adding-a-new-field-structure">
<h2>Adding a new field structure<a class="headerlink" href="#adding-a-new-field-structure" title="Permalink to this headline">¶</a></h2>
<p>Declaring a new field consists in proving that a field signature (a
carrier set, an equality, and field operations:
<code class="docutils literal notranslate"><span class="pre">Field_theory.field_theory</span></code> and <code class="docutils literal notranslate"><span class="pre">Field_theory.semi_field_theory</span></code>)
satisfies the field axioms. Semi-fields (fields without + inverse) are
also supported. The equality can be either Leibniz equality, or any
relation declared as a setoid (see <a class="reference internal" href="generalized-rewriting.html#tactics-enabled-on-user-provided-relations"><span class="std std-ref">Tactics enabled on user provided relations</span></a>). The definition of
fields and semifields is:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Record</span> <span class="nf">field_theory</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">mk_field</span> <span class="o">{</span>
  <span class="n">F_R</span> <span class="o">:</span> <span class="n">ring_theory</span> <span class="n">rO</span> <span class="n">rI</span> <span class="n">radd</span> <span class="n">rmul</span> <span class="n">rsub</span> <span class="n">ropp</span> <span class="n">req</span><span class="o">;</span>
  <span class="n">F_1_neq_0</span> <span class="o">:</span> <span class="o">~</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
  <span class="n">Fdiv_def</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span><span class="o">,</span> <span class="n">p</span> <span class="o">/</span> <span class="n">q</span> <span class="o">==</span> <span class="n">p</span> <span class="o">*</span> <span class="o">/</span> <span class="n">q</span><span class="o">;</span>
  <span class="n">Finv_l</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">p</span><span class="o">,</span> <span class="o">~</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">-&gt;</span>  <span class="o">/</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">1</span>
<span class="o">}.</span>

<span class="kn">Record</span> <span class="nf">semi_field_theory</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">mk_sfield</span> <span class="o">{</span>
  <span class="n">SF_SR</span> <span class="o">:</span> <span class="n">semi_ring_theory</span> <span class="n">rO</span> <span class="n">rI</span> <span class="n">radd</span> <span class="n">rmul</span> <span class="n">req</span><span class="o">;</span>
  <span class="n">SF_1_neq_0</span> <span class="o">:</span> <span class="o">~</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
  <span class="n">SFdiv_def</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">q</span><span class="o">,</span> <span class="n">p</span> <span class="o">/</span> <span class="n">q</span> <span class="o">==</span> <span class="n">p</span> <span class="o">*</span> <span class="o">/</span> <span class="n">q</span><span class="o">;</span>
  <span class="n">SFinv_l</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">p</span><span class="o">,</span> <span class="o">~</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">-&gt;</span>  <span class="o">/</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">1</span>
<span class="o">}.</span>
</pre></div>
</div>
<p>The result of the normalization process is a fraction represented by
the following type:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Record</span> <span class="nf">linear</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">mk_linear</span> <span class="o">{</span>
  <span class="n">num</span> <span class="o">:</span> <span class="n">PExpr</span> <span class="n">C</span><span class="o">;</span>
  <span class="n">denum</span> <span class="o">:</span> <span class="n">PExpr</span> <span class="n">C</span><span class="o">;</span>
  <span class="n">condition</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">PExpr</span> <span class="n">C</span><span class="o">)</span>
<span class="o">}.</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">num</span></code> and <code class="docutils literal notranslate"><span class="pre">denum</span></code> are the numerator and denominator; <code class="docutils literal notranslate"><span class="pre">condition</span></code> is a
list of expressions that have appeared as a denominator during the
normalization process. These expressions must be proven different from
zero for the correctness of the algorithm.</p>
<p>The syntax for adding a new field is</p>
<dl class="coq cmd">
<dt id="coq:cmd.add-field">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Add</span> <span>Field</span> <span class="hole">ident</span> <span>:</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <span class="hole">field_mod</span> <span class="repeat-wrapper"><span class="repeat"><span>,</span> <span class="hole">field_mod</span></span><span class="notation-sup">*</span></span> <span>)</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.add-field" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is not relevant. It is used just for error
messages. <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> is a proof that the field signature satisfies the
(semi-)field axioms. The optional list of modifiers is used to tailor
the behavior of the tactic.</p>
<pre>
<strong id="grammar-token-coq-field_mod"><span id="grammar-token-field-mod"></span>field_mod</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">ring_mod</span></code> | completeness <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
</pre>
<p>Since field tactics are built upon <code class="docutils literal notranslate"><span class="pre">ring</span></code>
tactics, all modifiers of the <code class="docutils literal notranslate"><span class="pre">Add</span> <span class="pre">Ring</span></code> apply. There is only one
specific modifier:</p>
<dl class="simple">
<dt>completeness <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code></dt><dd><p>allows the field tactic to prove automatically
that the image of nonzero coefficients are mapped to nonzero
elements of the field. <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> is a proof of
<code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">x</span></span> <span class="name variable"><span class="pre">y</span></span><span class="operator"><span class="pre">,</span></span> <span class="operator"><span class="pre">[</span></span><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">]</span></span> <span class="operator"><span class="pre">==</span></span> <span class="operator"><span class="pre">[</span></span><span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">]</span></span> <span class="operator"><span class="pre">-&gt;</span></span>&#160; <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">?=!</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">true</span></span></code>,
which is the completeness of equality on coefficients
w.r.t. the field equality.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="history-of-ring">
<h2>History of ring<a class="headerlink" href="#history-of-ring" title="Permalink to this headline">¶</a></h2>
<p>First Samuel Boutin designed the tactic <code class="docutils literal notranslate"><span class="pre">ACDSimpl</span></code>. This tactic did lot
of rewriting. But the proofs terms generated by rewriting were too big
for <span class="smallcaps">Coq</span>’s type checker. Let us see why:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> ZArith.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Open Scope</span> Z_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ring-rst-chk4" style="display: none" type="checkbox"><label class="coq-input" for="ring-rst-chk4"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : Z,
       x + <span class="mi">3</span> + y + y * z = x + <span class="mi">3</span> + y + z * y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : Z,
x + <span class="mi">3</span> + y + y * z = x + <span class="mi">3</span> + y + z * y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span>; <span class="nb">rewrite</span> (Zmult_comm y z); <span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Save</span> <span class="nf">foo</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ring-rst-chk5" style="display: none" type="checkbox"><label class="coq-input" for="ring-rst-chk5"><span class="highlight"><span class="kn">Print</span> foo.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">foo = 
<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : Z =&gt;
eq_ind_r
  (<span class="kr">fun</span> <span class="nv">z0</span> : Z =&gt; x + <span class="mi">3</span> + y + z0 = x + <span class="mi">3</span> + y + z * y)
  eq_refl (Z.mul_comm y z)
     : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : Z,
       x + <span class="mi">3</span> + y + y * z = x + <span class="mi">3</span> + y + z * y

Argument scopes are [Z_scope Z_scope Z_scope]</span></blockquote></div></div></small></span></pre></div><p>At each step of rewriting, the whole context is duplicated in the
proof term. Then, a tactic that does hundreds of rewriting generates
huge proof terms. Since <code class="docutils literal notranslate"><span class="pre">ACDSimpl</span></code> was too slow, Samuel Boutin rewrote
it using reflection (see <a class="bibtex reference internal" href="../zebibliography.html#bou97" id="id2">[Bou97]</a>). Later, it
was rewritten by Patrick Loiseleur: the new tactic does not any
more require <code class="docutils literal notranslate"><span class="pre">ACDSimpl</span></code> to compile and it makes use of <span class="math notranslate nohighlight">\(\beta\delta\iota\)</span>-reduction not
only to replace the rewriting steps, but also to achieve the
interleaving of computation and reasoning (see <a class="reference internal" href="#discussion-reflection"><span class="std std-ref">Discussion</span></a>). He also wrote
some <span class="smallcaps">ML</span> code for the <code class="docutils literal notranslate"><span class="pre">Add</span> <span class="pre">Ring</span></code> command that allows registering new rings dynamically.</p>
<p>Proofs terms generated by ring are quite small, they are linear in the
number of <span class="math notranslate nohighlight">\(\oplus\)</span> and <span class="math notranslate nohighlight">\(\otimes\)</span> operations in the normalized terms. Type checking
those terms requires some time because it makes a large use of the
conversion rule, but memory requirements are much smaller.</p>
</div>
<div class="section" id="discussion">
<span id="discussion-reflection"></span><h2>Discussion<a class="headerlink" href="#discussion" title="Permalink to this headline">¶</a></h2>
<p>Efficiency is not the only motivation to use reflection here. <code class="docutils literal notranslate"><span class="pre">ring</span></code>
also deals with constants, it rewrites for example the expression
<code class="docutils literal notranslate"><span class="pre">34</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">−</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">12</span></code> to the expected result <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">46</span></code>.
For the tactic <code class="docutils literal notranslate"><span class="pre">ACDSimpl</span></code>, the only constants were 0 and 1.
So the expression <code class="docutils literal notranslate"><span class="pre">34</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">(x</span> <span class="pre">−</span> <span class="pre">1)</span> <span class="pre">+</span> <span class="pre">12</span></code>
is interpreted as <span class="math notranslate nohighlight">\(V_0 \oplus V_1 \otimes (V_2 \ominus 1) \oplus V_3\)</span>,
with the variables mapping
<span class="math notranslate nohighlight">\(\{V_0 \mapsto 34; V_1 \mapsto 2; V_2 \mapsto x; V_3 \mapsto 12\}\)</span>.
Then it is rewritten to <code class="docutils literal notranslate"><span class="pre">34</span> <span class="pre">−</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">12</span></code>, very far from the expected result.
Here rewriting is not sufficient: you have to do some kind of reduction
(some kind of computation) to achieve the normalization.</p>
<p>The tactic <code class="docutils literal notranslate"><span class="pre">ring</span></code> is not only faster than the old one: by using
reflection, we get for free the integration of computation and reasoning
that would be very difficult to implement without it.</p>
<p>Is it the ultimate way to write tactics? The answer is: yes and no.
The <code class="docutils literal notranslate"><span class="pre">ring</span></code> tactic intensively uses the conversion rules of the Calculus of
Inductive Constructions, i.e. it replaces proofs by computations as much as possible.
It can be useful in all situations where a classical tactic generates huge proof
terms, like symbolic processing and tautologies. But there
are also tactics like <code class="docutils literal notranslate"><span class="pre">auto</span></code> or <code class="docutils literal notranslate"><span class="pre">linear</span></code> that do many complex computations,
using side-effects and backtracking, and generate a small proof term.
Clearly, it would be significantly less efficient to replace them by
tactics using reflection.</p>
<p>Another idea suggested by Benjamin Werner: reflection could be used to
couple an external tool (a rewriting program or a model checker)
with <span class="smallcaps">Coq</span>. We define (in <span class="smallcaps">Coq</span>) a type of terms, a type of <em>traces</em>, and
prove a correctness theorem that states that <em>replaying traces</em> is safe
with respect to some interpretation. Then we let the external tool do every
computation (using side-effects, backtracking, exception, or others
features that are not available in pure lambda calculus) to produce
the trace. Now we can check in <span class="smallcaps">Coq</span> that the trace has the expected
semantics by applying the correctness theorem.</p>
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>based on previous work from Patrick Loiseleur and Samuel Boutin</p>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="nsatz.html" class="btn btn-neutral float-right" title="Nsatz: tactics for proving equalities in integral domains" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="program.html" class="btn btn-neutral float-left" title="Program" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>