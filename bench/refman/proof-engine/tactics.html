

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Tactics &mdash; Coq 8.10.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/notations.js"></script>
        <script src="../_static/alectryon.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
  <link rel="stylesheet" href="../_static/alectryon.css" type="text/css" />
  <link rel="stylesheet" href="../_static/tango_subtle.css" type="text/css" />
  <link rel="stylesheet" href="../_static/tango_subtle.min.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The tactic language" href="ltac.html" />
    <link rel="prev" title="Proof handling" href="proof-handling.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.10.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Indexes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">Preamble</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction and Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">Early history of Coq</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../history.html#historical-roots">Historical roots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-1-to-5">Versions 1 to 5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-1">Version 1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-2">Version 2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-3">Version 3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-4">Version 4</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-5">Version 5</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-6">Versions 6</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-1">Version 6.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-2">Version 6.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-3">Version 6.3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-7">Versions 7</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-0-and-7-1">Details of changes in 7.0 and 7.1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#main-novelties">Main novelties</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-2">Details of changes in 7.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-3">Details of changes in 7.3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#changes-in-7-3-1">Changes in 7.3.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-4">Details of changes in 7.4</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changes.html">Recent changes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-10">Version 8.10</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#other-changes-in-8-10-beta1">Other changes in 8.10+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-beta2">Changes in 8.10+beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-beta3">Changes in 8.10+beta3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-0">Changes in 8.10.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-1">Changes in 8.10.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-2">Changes in 8.10.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-9">Version 8.9</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id147">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-9-beta1">Details of changes in 8.9+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-8-0">Changes in 8.8.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-8-1">Changes in 8.8.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-8">Version 8.8</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id149">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-beta1">Details of changes in 8.8+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-0">Details of changes in 8.8.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-1">Details of changes in 8.8.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-2">Details of changes in 8.8.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-7">Version 8.7</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id150">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#potential-compatibility-issues">Potential compatibility issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta1">Details of changes in 8.7+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta2">Details of changes in 8.7+beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-0">Details of changes in 8.7.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-1">Details of changes in 8.7.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-2">Details of changes in 8.7.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-6">Version 8.6</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id151">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#potential-sources-of-incompatibilities">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6beta1">Details of changes in 8.6beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6">Details of changes in 8.6</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6-1">Details of changes in 8.6.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-5">Version 8.5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id152">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id153">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta1">Details of changes in 8.5beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta2">Details of changes in 8.5beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta3">Details of changes in 8.5beta3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5">Details of changes in 8.5</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl1">Details of changes in 8.5pl1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl2">Details of changes in 8.5pl2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl3">Details of changes in 8.5pl3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-4">Version 8.4</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id154">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id156">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta">Details of changes in 8.4beta</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta2">Details of changes in 8.4beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4">Details of changes in 8.4</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-3">Version 8.3</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id157">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-2">Version 8.2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id158">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id159">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-1">Version 8.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id160">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1beta">Details of changes in 8.1beta</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1gamma">Details of changes in 8.1gamma</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1">Details of changes in 8.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-0">Version 8.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id161">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-old-syntax">Details of changes in 8.0beta old syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-new-syntax">Details of changes in 8.0beta new syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0">Details of changes in 8.0</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">The language</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-specification-language.html">The Gallina specification language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#about-the-grammars-in-the-manual">About the grammars in the manual</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#lexical-conventions">Lexical conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#terms">Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#syntax-of-terms">Syntax of terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#types">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#qualified-identifiers-and-simple-identifiers">Qualified identifiers and simple identifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#numerals">Numerals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#binders">Binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#abstractions">Abstractions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#products">Products</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#applications">Applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#type-cast">Type cast</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#inferable-subterms">Inferable subterms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#let-in-definitions">Let-in definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#definition-by-case-analysis">Definition by case analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#recursive-functions">Recursive functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#the-vernacular">The Vernacular</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#assumptions">Assumptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#inductive-definitions">Inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#simple-inductive-types">Simple inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#simple-annotated-inductive-types">Simple annotated inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#parameterized-inductive-types">Parameterized inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#variants">Variants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#mutually-defined-inductive-types">Mutually defined inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#co-inductive-types">Co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#definition-of-recursive-functions">Definition of recursive functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#definition-of-functions-by-recursion-over-inductive-objects">Definition of functions by recursion over inductive objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#definitions-of-recursive-objects-in-co-inductive-types">Definitions of recursive objects in co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#assertions-and-proofs">Assertions and proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#attributes">Attributes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#record-types">Record types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#primitive-projections">Primitive Projections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#primitive-record-types">Primitive Record Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#compatibility-projections-and-match">Compatibility Projections and <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">match</span></span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#variants-and-extensions-of-match">Variants and extensions of <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">match</span></span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#multiple-and-nested-pattern-matching">Multiple and nested pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#pattern-matching-on-boolean-values-the-if-expression">Pattern-matching on boolean values: the if expression</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#irrefutable-patterns-the-destructuring-let-variants">Irrefutable patterns: the destructuring let variants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#first-destructuring-let-syntax">First destructuring let syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#second-destructuring-let-syntax">Second destructuring let syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-pretty-printing-of-match-expressions">Controlling pretty-printing of match expressions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-nested-patterns">Printing nested patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#factorization-of-clauses-with-same-right-hand-side">Factorization of clauses with same right-hand side</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#use-of-a-default-clause">Use of a default clause</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-of-wildcard-patterns">Printing of wildcard patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-of-the-elimination-predicate">Printing of the elimination predicate</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-matching-on-irrefutable-patterns">Printing matching on irrefutable patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-matching-on-booleans">Printing matching on booleans</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions">Advanced recursive functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#section-mechanism">Section mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#module-system">Module system</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#reserved-commands-inside-an-interactive-module">Reserved commands inside an interactive module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#reserved-commands-inside-an-interactive-module-type">Reserved commands inside an interactive module type:</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#libraries-and-qualified-names">Libraries and qualified names</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#names-of-libraries">Names of libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#qualified-names">Qualified names</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#libraries-and-filesystem">Libraries and filesystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#implicit-arguments">Implicit arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#the-different-kinds-of-implicit-arguments">The different kinds of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function">Implicit arguments inferable from the knowledge of other arguments of a function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#implicit-arguments-inferable-by-resolution">Implicit arguments inferable by resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#maximal-or-non-maximal-insertion-of-implicit-arguments">Maximal or non maximal insertion of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#casual-use-of-implicit-arguments">Casual use of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#declaration-of-implicit-arguments">Declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#implicit-argument-binders">Implicit Argument Binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#declaring-implicit-arguments">Declaring Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#automatic-declaration-of-implicit-arguments">Automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#mode-for-automatic-declaration-of-implicit-arguments">Mode for automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-strict-implicit-arguments">Controlling strict implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-contextual-implicit-arguments">Controlling contextual implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-reversible-pattern-implicit-arguments">Controlling reversible-pattern implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments">Controlling the insertion of implicit arguments not followed by explicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#explicit-applications">Explicit applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#renaming-implicit-arguments">Renaming implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#displaying-what-the-implicit-arguments-are">Displaying what the implicit arguments are</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#explicit-displaying-of-implicit-arguments-for-pretty-printing">Explicit displaying of implicit arguments for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#interaction-with-subtyping">Interaction with subtyping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#deactivation-of-implicit-arguments-for-parsing">Deactivation of implicit arguments for parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#canonical-structures">Canonical structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#implicit-types-of-variables">Implicit types of variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#implicit-generalization">Implicit generalization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#coercions">Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#printing-constructions-in-full">Printing constructions in full</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#printing-universes">Printing universes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#existential-variables">Existential variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#explicit-displaying-of-existential-instances-for-pretty-printing">Explicit displaying of existential instances for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#solving-existential-variables-using-tactics">Solving existential variables using tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#primitive-integers">Primitive Integers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/coq-library.html">The <span class="smallcaps">Coq</span> library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html#the-basic-library">The basic library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#notations">Notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#logic">Logic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#propositional-connectives">Propositional Connectives</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#quantifiers">Quantifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#equality">Equality</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#lemmas">Lemmas</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#datatypes">Datatypes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#programming">Programming</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#specification">Specification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#basic-arithmetics">Basic Arithmetics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#well-founded-recursion">Well-founded recursion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#accessing-the-type-level">Accessing the Type level</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#tactics">Tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html#the-standard-library">The standard library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#survey">Survey</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#peanos-arithmetic-nat">Peano’s arithmetic (nat)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#notations-for-integer-arithmetics">Notations for integer arithmetics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#real-numbers-library">Real numbers library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#notations-for-real-numbers">Notations for real numbers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#some-tactics-for-real-numbers">Some tactics for real numbers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#list-library">List library</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html#users-contributions">Users’ contributions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/cic.html">Calculus of Inductive Constructions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#the-terms">The terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#terms">Terms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#typing-rules">Typing rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#conversion-rules">Conversion rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#reduction">β-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#iota-reduction">ι-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#delta-reduction">δ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#zeta-reduction">ζ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#expansion">η-expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#proof-irrelevance">Proof Irrelevance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#convertibility">Convertibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#subtyping-rules">Subtyping rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#inductive-definitions">Inductive Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#types-of-inductive-objects">Types of inductive objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#well-formed-inductive-definitions">Well-formed inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#arity-of-a-given-sort">Arity of a given sort</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#arity">Arity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#type-of-constructor">Type of constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#positivity-condition">Positivity Condition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#strict-positivity">Strict positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#nested-positivity">Nested Positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#correctness-rules">Correctness rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#template-polymorphism">Template polymorphism</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#destructors">Destructors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#the-match-with-end-construction">The match ... with ... end construction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#fixpoint-definitions">Fixpoint definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#id29">Typing rule</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#reduction-rule">Reduction rule</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#admissible-rules-for-global-environments">Admissible rules for global environments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#co-inductive-types">Co-inductive types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#the-calculus-of-inductive-constructions-with-impredicative-set">The Calculus of Inductive Constructions with impredicative Set</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/module-system.html">The Module System</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/module-system.html#modules-and-module-types">Modules and module types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/module-system.html#typing-modules">Typing Modules</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">The proof engine</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="vernacular-commands.html">Vernacular commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#displaying">Displaying</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#flags-options-and-tables">Flags, Options and Tables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#scope-qualifiers-for-set-and-unset">Scope qualifiers for <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Set</span></code> and <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Unset</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#requests-to-the-environment">Requests to the environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#printing-flags">Printing flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#loading-files">Loading files</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#compiled-files">Compiled files</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#loadpath">Loadpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#backtracking">Backtracking</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#quitting-and-debugging">Quitting and debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#controlling-display">Controlling display</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#controlling-the-reduction-strategies-and-the-conversion-algorithm">Controlling the reduction strategies and the conversion algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#controlling-the-locality-of-commands">Controlling the locality of commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#internal-registration-commands">Internal registration commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#exposing-constants-to-ocaml-libraries">Exposing constants to OCaml libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#inlining-hints-for-the-fast-reduction-machines">Inlining hints for the fast reduction machines</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#registering-primitive-operations">Registering primitive operations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="proof-handling.html">Proof handling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#switching-on-off-the-proof-editing-mode">Switching on/off the proof editing mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#proof-using-options">Proof using options</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#name-a-set-of-section-hypotheses-for-proof-using">Name a set of section hypotheses for <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#navigation-in-the-proof-tree">Navigation in the proof tree</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#bullets">Bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#set-bullet-behavior">Set Bullet Behavior</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#requesting-information">Requesting information</a></li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#showing-differences-between-proof-steps">Showing differences between proof steps</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#how-to-enable-diffs">How to enable diffs</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#how-diffs-are-calculated">How diffs are calculated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#controlling-the-effect-of-proof-editing-commands">Controlling the effect of proof editing commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#controlling-memory-usage">Controlling memory usage</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#common-elements-of-tactics">Common elements of tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#invocation-of-tactics">Invocation of tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bindings-list">Bindings list</a></li>
<li class="toctree-l3"><a class="reference internal" href="#intro-patterns">Intro patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#occurrence-sets-and-occurrence-clauses">Occurrence sets and occurrence clauses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#applying-theorems">Applying theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#managing-the-local-context">Managing the local context</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-the-proof-flow">Controlling the proof flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="#case-analysis-and-induction">Case analysis and induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rewriting-expressions">Rewriting expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#performing-computations">Performing computations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#conversion-tactics-applied-to-hypotheses">Conversion tactics applied to hypotheses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#automation">Automation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-automation">Controlling automation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-hints-databases-for-auto-and-eauto">The hints databases for auto and eauto</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creating-hint-databases">Creating Hint databases</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hint-databases-defined-in-the-coq-standard-library">Hint databases defined in the Coq standard library</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hint-locality">Hint locality</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setting-implicit-automation-tactics">Setting implicit automation tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#decision-procedures">Decision procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="#checking-properties-of-terms">Checking properties of terms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#equality">Equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="#equality-and-inductive-sets">Equality and inductive sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inversion">Inversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#classical-tactics">Classical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#automating">Automating</a></li>
<li class="toctree-l2"><a class="reference internal" href="#non-logical-tactics">Non-logical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#delaying-solving-unification-constraints">Delaying solving unification constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="#proof-maintenance">Proof maintenance</a></li>
<li class="toctree-l2"><a class="reference internal" href="#performance-oriented-tactic-variants">Performance-oriented tactic variants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ltac.html">The tactic language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ltac.html#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="ltac.html#semantics">Semantics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#sequence">Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#local-application-of-tactics">Local application of tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#goal-selectors">Goal selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#for-loop">For loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#repeat-loop">Repeat loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#error-catching">Error catching</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#detecting-progress">Detecting progress</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#backtracking-branching">Backtracking branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#first-tactic-to-work">First tactic to work</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#left-biased-branching">Left-biased branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#generalized-biased-branching">Generalized biased branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#soft-cut">Soft cut</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#checking-the-successes">Checking the successes</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#checking-the-failure">Checking the failure</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#checking-the-success">Checking the success</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#solving">Solving</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#identity">Identity</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#failing">Failing</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#timeout">Timeout</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#timing-a-tactic">Timing a tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#timing-a-tactic-that-evaluates-to-a-term">Timing a tactic that evaluates to a term</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#local-definitions">Local definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#application">Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#function-construction">Function construction</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#pattern-matching-on-terms">Pattern matching on terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#pattern-matching-on-goals">Pattern matching on goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#filling-a-term-context">Filling a term context</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#generating-fresh-hypothesis-names">Generating fresh hypothesis names</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#computing-in-a-constr">Computing in a constr</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#recovering-the-type-of-a-term">Recovering the type of a term</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#manipulating-untyped-terms">Manipulating untyped terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#counting-the-goals">Counting the goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#testing-boolean-expressions">Testing boolean expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#proving-a-subgoal-as-a-separate-lemma">Proving a subgoal as a separate lemma</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ltac.html#tactic-toplevel-definitions">Tactic toplevel definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#defining-ltac-functions">Defining <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#printing-ltac-tactics">Printing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ltac.html#examples-of-using-ltac">Examples of using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub></a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#proof-that-the-natural-numbers-have-at-least-two-elements">Proof that the natural numbers have at least two elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#proving-that-a-list-is-a-permutation-of-a-second-list">Proving that a list is a permutation of a second list</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#deciding-intuitionistic-propositional-logic">Deciding intuitionistic propositional logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#deciding-type-isomorphisms">Deciding type isomorphisms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ltac.html#debugging-ltac-tactics">Debugging <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#backtraces">Backtraces</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#info-trace">Info trace</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#interactive-debugger">Interactive debugger</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#profiling-ltac-tactics">Profiling <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#run-time-optimization-tactic">Run-time optimization tactic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="detailed-tactic-examples.html">Detailed examples of tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="detailed-tactic-examples.html#dependent-induction">dependent induction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="detailed-tactic-examples.html#a-larger-example">A larger example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="detailed-tactic-examples.html#autorewrite">autorewrite</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#usage">Usage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#getting-started">Getting started</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#compatibility-issues">Compatibility issues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#gallina-extensions"><span class="smallcaps">Gallina</span> extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#pattern-assignment">Pattern assignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#pattern-conditional">Pattern conditional</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#parametric-polymorphism">Parametric polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#anonymous-arguments">Anonymous arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#wildcards">Wildcards</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#abbreviations">Abbreviations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#matching">Matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#occurrence-selection">Occurrence selection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#basic-localization">Basic localization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#basic-tactics">Basic tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#bookkeeping">Bookkeeping</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#the-defective-tactics">The defective tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-move-tactic">The move tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-case-tactic">The case tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-elim-tactic">The elim tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-apply-tactic">The apply tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#discharge">Discharge</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#clear-rules">Clear rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#matching-for-apply-and-exact">Matching for apply and exact</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-abstract-tactic">The abstract tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#introduction-in-the-context">Introduction in the context</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#simplification-items">Simplification items</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#views">Views</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#clear-switch">Clear switch</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#branching-and-destructuring">Branching and destructuring</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#block-introduction">Block introduction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#generation-of-equations">Generation of equations</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#type-families">Type families</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#control-flow">Control flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#indentation-and-bullets">Indentation and bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#terminators">Terminators</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#selectors">Selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#iteration">Iteration</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#localization">Localization</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#structure">Structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-have-tactic">The have tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#generating-let-in-context-entries-with-have">Generating let in context entries with have</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-have-tactic-and-typeclass-resolution">The have tactic and typeclass resolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#variants-the-suff-and-wlog-tactics">Variants: the suff and wlog tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#rewriting">Rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#an-extended-rewrite-tactic">An extended rewrite tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#remarks-and-examples">Remarks and examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#rewrite-redex-selection">Rewrite redex selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#chained-rewrite-steps">Chained rewrite steps</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#explicit-redex-switches-are-matched-first">Explicit redex switches are matched first</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#occurrence-switches-and-redex-switches">Occurrence switches and redex switches</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#occurrence-selection-and-repetition">Occurrence selection and repetition</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#multi-rule-rewriting">Multi-rule rewriting</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#wildcards-vs-abstractions">Wildcards vs abstractions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#when-ssr-rewrite-fails-on-standard-coq-licit-rewrite">When <span class="smallcaps">SSReflect</span> rewrite fails on standard <span class="smallcaps">Coq</span> licit rewrite</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#existential-metavariables-and-rewriting">Existential metavariables and rewriting</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#rewriting-under-binders">Rewriting under binders</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-under-tactic">The under tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#interactive-mode">Interactive mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#one-liner-mode">One-liner mode</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#locking-unlocking">Locking, unlocking</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#congruence">Congruence</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#contextual-patterns">Contextual patterns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#matching-contextual-patterns">Matching contextual patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#examples">Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#contextual-pattern-in-set-and-the-tactical">Contextual pattern in set and the : tactical</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#contextual-patterns-in-rewrite">Contextual patterns in rewrite</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#patterns-for-recurrent-contexts">Patterns for recurrent contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#views-and-reflection">Views and reflection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-eliminations">Interpreting eliminations</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-assumptions">Interpreting assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#specializing-assumptions">Specializing assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-goals">Interpreting goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#boolean-reflection">Boolean reflection</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#the-reflect-predicate">The reflect predicate</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#general-mechanism-for-interpreting-goals-and-assumptions">General mechanism for interpreting goals and assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#id13">Specializing assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#id14">Interpreting assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-equivalences">Interpreting equivalences</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#declaring-new-hint-views">Declaring new Hint Views</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#multiple-views">Multiple views</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#ssr-searching-tool"><span class="smallcaps">SSReflect</span> searching tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#synopsis-and-index">Synopsis and Index</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#parameters">Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#items-and-switches">Items and switches</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#tacticals">Tacticals</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#commands">Commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#settings">Settings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">User extensions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations">Notations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#basic-notations">Basic notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#precedences-and-associativity">Precedences and associativity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#complex-notations">Complex notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simple-factorization-rules">Simple factorization rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-symbolic-notations">Displaying symbolic notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-infix-command">The Infix command</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#reserving-notations">Reserving notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simultaneous-definition-of-terms-and-notations">Simultaneous definition of terms and notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-notations">Displaying information about notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#locating-notations">Locating notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-and-binders">Notations and binders</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-identifiers">Binders bound in the notation and parsed as identifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-patterns">Binders bound in the notation and parsed as patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-terms">Binders bound in the notation and parsed as terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-not-bound-in-the-notation">Binders not bound in the notation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns">Notations with recursive patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns-involving-binders">Notations with recursive patterns involving binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#predefined-entries">Predefined entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#custom-entries">Custom entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#summary">Summary</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#syntax-of-notations">Syntax of notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#persistence-of-notations">Persistence of notations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes">Interpretation scopes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#global-interpretation-rules-for-notations">Global interpretation rules for notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-interpretation-rules-for-notations">Local interpretation rules for notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-opening-of-an-interpretation-scope">Local opening of an interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binding-arguments-of-a-constant-to-an-interpretation-scope">Binding arguments of a constant to an interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binding-types-of-arguments-to-an-interpretation-scope">Binding types of arguments to an interpretation scope</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-type-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">type_scope</span></code> interpretation scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-function-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">function_scope</span></code> interpretation scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes-used-in-the-standard-library-of-coq">Interpretation scopes used in the standard library of Coq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-scopes">Displaying information about scopes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#numeral-notations">Numeral notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#string-notations">String notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#tactic-notations">Tactic Notations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-induction-principles-with-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#automatic-declaration-of-schemes">Automatic declaration of schemes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#combined-scheme">Combined Scheme</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-induction-principles-with-functional-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Functional</span></code> <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-inversion-principles-with-derive-inversion">Generation of inversion principles with <code class="docutils literal notranslate"><span class="pre">Derive</span></code> <code class="docutils literal notranslate"><span class="pre">Inversion</span></code></a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Practical tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#interactive-use-coqtop">Interactive use (coqtop)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#batch-compilation-coqc">Batch compilation (coqc)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#customization-at-launch-time">Customization at launch time</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-resource-file">By resource file</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-environment-variables">By environment variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-command-line-options">By command line options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-libraries-checker-coqchk">Compiled libraries checker (coqchk)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#using-coq-as-a-library">Using Coq as a library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project">Building a <span class="smallcaps">Coq</span> project</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-coq-makefile">Building a <span class="smallcaps">Coq</span> project with coq_makefile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#coqmakefile-local">CoqMakefile.local</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#timing-targets-and-performance-testing">Timing targets and performance testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#reusing-extending-the-generated-makefile">Reusing/extending the generated Makefile</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#building-a-subset-of-the-targets-with-j">Building a subset of the targets with <code class="docutils literal notranslate"><span class="pre">-j</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-dune">Building a <span class="smallcaps">Coq</span> project with Dune</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#computing-module-dependencies">Computing Module dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#documenting-coq-files-with-coqdoc">Documenting <span class="smallcaps">Coq</span> files with coqdoc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#principles">Principles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#coq-material-inside-documentation"><span class="smallcaps">Coq</span> material inside documentation.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#pretty-printing">Pretty-printing.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#sections">Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#lists">Lists.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#rules">Rules.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#emphasis">Emphasis.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#escaping-to-latex-and-html">Escaping to <span class="smallcaps">LaTeX</span> and HTML.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#verbatim">Verbatim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#hyperlinks">Hyperlinks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#hiding-showing-parts-of-the-source">Hiding / Showing parts of the source.</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#the-coqdoc-latex-style-file">The coqdoc <span class="smallcaps">LaTeX</span> style file</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#embedded-coq-phrases-inside-latex-documents">Embedded Coq phrases inside <span class="smallcaps">LaTeX</span> documents</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#man-pages">Man pages</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#managing-files-and-buffers-basic-editing">Managing files and buffers, basic editing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#interactive-navigation-into-coq-scripts">Interactive navigation into Coq scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#proof-folding">Proof folding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#vernacular-commands-templates">Vernacular commands, templates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#queries">Queries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#compilation">Compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#customizations">Customizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#using-unicode-symbols">Using Unicode symbols</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#displaying-unicode-symbols">Displaying Unicode symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#bindings-for-input-of-unicode-symbols">Bindings for input of Unicode symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#adding-custom-bindings">Adding custom bindings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#character-encoding-for-saved-files">Character encoding for saved files</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Addendum</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extended-pattern-matching.html">Extended pattern matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#patterns">Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#multiple-patterns">Multiple patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#aliasing-subpatterns">Aliasing subpatterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#nested-patterns">Nested patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#disjunctive-patterns">Disjunctive patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#about-patterns-of-parametric-types">About patterns of parametric types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#parameters-in-patterns">Parameters in patterns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#implicit-arguments-in-patterns">Implicit arguments in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#matching-objects-of-dependent-types">Matching objects of dependent types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#understanding-dependencies-in-patterns">Understanding dependencies in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#when-the-elimination-predicate-must-be-provided">When the elimination predicate must be provided</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#dependent-pattern-matching">Dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#multiple-dependent-pattern-matching">Multiple dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#patterns-in-in">Patterns in <code class="docutils literal notranslate"><span class="pre">in</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#using-pattern-matching-to-write-proofs">Using pattern matching to write proofs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#pattern-matching-on-inductive-objects-involving-local-definitions">Pattern-matching on inductive objects involving local definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#pattern-matching-and-coercions">Pattern-matching and coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#when-does-the-expansion-strategy-fail">When does the expansion strategy fail?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#general-presentation">General Presentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions">Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#identity-coercions">Identity Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#inheritance-graph">Inheritance Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#declaring-coercions">Declaring Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#displaying-available-coercions">Displaying Available Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#activating-the-printing-of-coercions">Activating the Printing of Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#classes-as-records">Classes as Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-sections">Coercions and Sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-modules">Coercions and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-at-function-application">Coercion at function application</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-to-a-type">Coercion to a type</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-to-a-function">Coercion to a function</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/canonical-structures.html">Canonical Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/canonical-structures.html#notation-overloading">Notation overloading</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/canonical-structures.html#derived-canonical-structures">Derived Canonical Structures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/canonical-structures.html#hierarchy-of-structures">Hierarchy of structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/canonical-structures.html#compact-declaration-of-canonical-structures">Compact declaration of Canonical Structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/type-classes.html">Typeclasses</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#class-and-instance-declarations">Class and Instance declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#binding-classes">Binding classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#parameterized-instances">Parameterized Instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#sections-and-contexts">Sections and contexts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#building-hierarchies">Building hierarchies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#superclasses">Superclasses</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#substructures">Substructures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#summary-of-the-commands">Summary of the commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-transparent-typeclasses-opaque">Typeclasses Transparent, Typeclasses Opaque</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#settings">Settings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-eauto">Typeclasses eauto <code class="docutils literal notranslate"><span class="pre">:=</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#description-of-omega">Description of <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#arithmetical-goals-recognized-by-omega">Arithmetical goals recognized by <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#messages-from-omega">Messages from <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#using-omega">Using <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#options">Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#technical-data">Technical data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#overview-of-the-tactic">Overview of the tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#overview-of-the-omega-decision-procedure">Overview of the OMEGA decision procedure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#bugs">Bugs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#short-description-of-the-tactics">Short description of the tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#positivstellensatz-refutations"><em>Positivstellensatz</em> refutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#lra-a-decision-procedure-for-linear-real-and-rational-arithmetic"><code class="docutils literal notranslate"><span class="pre">lra</span></code>: a decision procedure for linear real and rational arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#lia-a-tactic-for-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">lia</span></code>: a tactic for linear integer arithmetic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#high-level-view-of-lia">High level view of <code class="docutils literal notranslate"><span class="pre">lia</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#cutting-plane-proofs">Cutting plane proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#case-split">Case split</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#nra-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">nra</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#nia-a-proof-procedure-for-non-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">nia</span></code>: a proof procedure for non-linear integer arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#psatz-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">psatz</span></code>: a proof procedure for non-linear arithmetic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#generating-ml-code">Generating ML Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#extraction-options">Extraction Options</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#setting-the-target-language">Setting the target language</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#inlining-and-optimizations">Inlining and optimizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extra-elimination-of-useless-arguments">Extra elimination of useless arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#realizing-axioms">Realizing axioms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#realizing-inductive-types">Realizing inductive types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#avoiding-conflicts-with-existing-filenames">Avoiding conflicts with existing filenames</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#additional-settings">Additional settings</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#differences-between-coq-and-ml-type-systems">Differences between <span class="smallcaps">Coq</span> and ML type systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#some-examples">Some examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#a-detailed-example-euclidean-division">A detailed example: Euclidean division</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extraction-s-horror-museum">Extraction's horror museum</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#users-contributions">Users' Contributions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/program.html">Program</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#elaborating-programs">Elaborating programs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#syntactic-control-over-equalities">Syntactic control over equalities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-definition">Program Definition</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-fixpoint">Program Fixpoint</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-lemma">Program Lemma</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#solving-obligations">Solving obligations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#frequently-asked-questions">Frequently Asked Questions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/ring.html">The ring and field tactic families</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#what-does-this-tactic-do">What does this tactic do?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#the-variables-map">The variables map</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#is-it-automatic">Is it automatic?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#concrete-usage-in-coq">Concrete usage in Coq</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#adding-a-ring-structure">Adding a ring structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#how-does-it-work">How does it work?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#dealing-with-fields">Dealing with fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#adding-a-new-field-structure">Adding a new field structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#history-of-ring">History of ring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#discussion">Discussion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: tactics for proving equalities in integral domains</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/nsatz.html#more-about-nsatz">More about <code class="docutils literal notranslate"><span class="pre">nsatz</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#introduction-to-generalized-rewriting">Introduction to generalized rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#relations-and-morphisms">Relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#adding-new-relations-and-morphisms">Adding new relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-non-reflexive-relations">Rewriting and non reflexive relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-non-symmetric-relations">Rewriting and non symmetric relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-in-ambiguous-setoid-contexts">Rewriting in ambiguous setoid contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#commands-and-tactics">Commands and tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#first-class-setoids-and-morphisms">First class setoids and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#tactics-enabled-on-user-provided-relations">Tactics enabled on user provided relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#printing-relations-and-morphisms">Printing relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#deprecated-syntax-and-backward-incompatibilities">Deprecated syntax and backward incompatibilities</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#extensions">Extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#subrelations">Subrelations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#constant-unfolding">Constant unfolding</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#strategies-for-rewriting">Strategies for rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#usage">Usage</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-annotations">Proof annotations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#automatic-suggestion-of-proof-annotations">Automatic suggestion of proof annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-blocks-and-error-resilience">Proof blocks and error resilience</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#caveats">Caveats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#interactive-mode">Interactive mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#id2">Caveats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#batch-mode">Batch mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#limiting-the-number-of-parallel-workers">Limiting the number of parallel workers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Miscellaneous extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/miscellaneous-extensions.html#program-derivation">Program derivation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#general-presentation">General Presentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-monomorphic">Polymorphic, Monomorphic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulative-noncumulative">Cumulative, NonCumulative</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#an-example-of-a-proof-using-cumulativity">An example of a proof using cumulativity</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulativity-weak-constraints">Cumulativity Weak Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#global-and-local-universes">Global and local universes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#conversion-and-unification">Conversion and unification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#minimization">Minimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#explicit-universes">Explicit Universes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-definitions">Polymorphic definitions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/sprop.html">SProp (proof irrelevant propositions)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#basic-constructs">Basic constructs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#encodings-for-strict-propositions">Encodings for strict propositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#issues-with-non-cumulativity">Issues with non-cumulativity</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Tactics</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/proof-engine/tactics.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="tactics">
<span id="id1"></span><h1>Tactics<a class="headerlink" href="#tactics" title="Permalink to this headline">¶</a></h1>
<p>A deduction rule is a link between some (unique) formula, that we call
the <em>conclusion</em> and (several) formulas that we call the <em>premises</em>. A
deduction rule can be read in two ways. The first one says: “if I know
this and this then I can deduce this”. For instance, if I have a proof
of A and a proof of B then I have a proof of A ∧ B. This is forward
reasoning from premises to conclusion. The other way says: “to prove
this I have to prove this and this”. For instance, to prove A ∧ B, I
have to prove A and I have to prove B. This is backward reasoning from
conclusion to premises. We say that the conclusion is the <em>goal</em> to
prove and premises are the <em>subgoals</em>. The tactics implement <em>backward
reasoning</em>. When applied to a goal, a tactic replaces this goal with
the subgoals it generates. We say that a tactic reduces a goal to its
subgoal(s).</p>
<p>Each (sub)goal is denoted with a number. The current goal is numbered
1. By default, a tactic is applied to the current goal, but one can
address a particular goal in the list by writing n:tactic which means
“apply tactic tactic to goal number n”. We can show the list of
subgoals by typing Show (see Section <a class="reference internal" href="proof-handling.html#requestinginformation"><span class="std std-ref">Requesting information</span></a>).</p>
<p>Since not every rule applies to a given statement, not every tactic can
be used to reduce a given goal. In other words, before applying a tactic
to a given goal, the system checks that some <em>preconditions</em> are
satisfied. If it is not the case, the tactic raises an error message.</p>
<p>Tactics are built from atomic tactics and tactic expressions (which
extends the folklore notion of tactical) to combine those atomic
tactics. This chapter is devoted to atomic tactics. The tactic
language will be described in Chapter <a class="reference internal" href="ltac.html#ltac"><span class="std std-ref">The tactic language</span></a>.</p>
<div class="section" id="common-elements-of-tactics">
<h2>Common elements of tactics<a class="headerlink" href="#common-elements-of-tactics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="invocation-of-tactics">
<span id="id2"></span><h3>Invocation of tactics<a class="headerlink" href="#invocation-of-tactics" title="Permalink to this headline">¶</a></h3>
<p>A tactic is applied as an ordinary command. It may be preceded by a
goal selector (see Section <a class="reference internal" href="ltac.html#ltac-semantics"><span class="std std-ref">Semantics</span></a>). If no selector is
specified, the default selector is used.</p>
<blockquote id="tactic-invocation-grammar">
<div><pre>
<strong id="grammar-token-sentence-tactic_invocation"><span id="grammar-token-tactic-invocation"></span>tactic_invocation</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">toplevel_selector</span></code> : <code class="xref docutils literal notranslate"><span class="pre">tactic</span></code>.
                       <code class="xref docutils literal notranslate"><span class="pre">tactic</span></code>.
</pre>
</div></blockquote>
<dl class="coq opt">
<dt id="coq:opt.default-goal-selector">
<em class="property"><span class="sigannot">Option</span></em> <code class="sig-name descname"><span class="notation"><span>Default</span> <span>Goal</span> <span>Selector</span> <span>&quot;</span><span class="hole">toplevel_selector</span><span>&quot;</span></span></code><a class="headerlink" href="#coq:opt.default-goal-selector" title="Permalink to this definition">¶</a></dt>
<dd><p>This option controls the default selector, used when no selector is
specified when applying a tactic. The initial value is 1, hence the
tactics are, by default, applied to the first goal.</p>
<p>Using value <code class="docutils literal notranslate"><span class="pre">all</span></code> will make it so that tactics are, by default,
applied to every goal simultaneously. Then, to apply a tactic tac
to the first goal only, you can write <code class="docutils literal notranslate"><span class="pre">1:tac</span></code>.</p>
<p>Using value <code class="docutils literal notranslate"><span class="pre">!</span></code> enforces that all tactics are used either on a
single focused goal or with a local selector (’’strict focusing
mode’’).</p>
<p>Although more selectors are available, only <code class="docutils literal notranslate"><span class="pre">all</span></code>, <code class="docutils literal notranslate"><span class="pre">!</span></code> or a
single natural number are valid default goal selectors.</p>
</dd></dl>

</div>
<div class="section" id="bindings-list">
<span id="bindingslist"></span><h3>Bindings list<a class="headerlink" href="#bindings-list" title="Permalink to this headline">¶</a></h3>
<p>Tactics that take a term as an argument may also support a bindings list
to instantiate some parameters of the term by name or position.
The general form of a term with a bindings list is
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span> <span><span class="pre">with</span></span> <span class="hole"><span class="pre">bindings_list</span></span></span></code> where <code class="xref std std-token docutils literal notranslate"><span class="pre">bindings_list</span></code> can take two different forms:</p>
<blockquote id="bindings-list-grammar">
<div><pre>
<strong id="grammar-token-bindings_list-ref"><span id="grammar-token-ref"></span>ref          </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>
                   <code class="xref docutils literal notranslate"><span class="pre">num</span></code>
<strong id="grammar-token-bindings_list-bindings_list"><span id="grammar-token-bindings-list"></span>bindings_list</strong> ::=  (<code class="xref docutils literal notranslate"><span class="pre">ref</span></code> := <code class="xref docutils literal notranslate"><span class="pre">term</span></code>) ... (<code class="xref docutils literal notranslate"><span class="pre">ref</span></code> := <code class="xref docutils literal notranslate"><span class="pre">term</span></code>)
                   <code class="xref docutils literal notranslate"><span class="pre">term</span></code> ... <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
</pre>
</div></blockquote>
<ul>
<li><p>In a bindings list of the form <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">(</span></span><span class="hole"><span class="pre">ref</span></span><span><span class="pre">:=</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">)</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>, <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ref</span></span></span></code> is either an
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> or a <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code>. The references are determined according to the type of
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>. If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ref</span></span></span></code> is an identifier, this identifier has to be bound in the
type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> and the binding provides the tactic with an instance for the
parameter of this name. If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ref</span></span></span></code> is a number <code class="docutils literal notranslate"><span class="pre">n</span></code>, it refers to
the <code class="docutils literal notranslate"><span class="pre">n</span></code>-th non dependent premise of the <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>, as determined by the type
of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>.</p>
<dl class="coq exn">
<dt id="coq:exn.no-such-binder">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>such</span> <span>binder.</span></span></code><a class="headerlink" href="#coq:exn.no-such-binder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</li>
<li><p>A bindings list can also be a simple list of terms <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code>.
In that case the references to which these terms correspond are
determined by the tactic. In case of <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>, <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>, <a class="reference internal" href="#coq:tacv.elim" title="elim"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">elim</span></code></a>
and <a class="reference internal" href="#coq:tacn.case" title="case"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">case</span></code></a>, the terms have to
provide instances for all the dependent products in the type of term while in
the case of <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>, or of <a class="reference internal" href="#coq:tacn.constructor" title="constructor"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">constructor</span></code></a> and its variants, only instances
for the dependent products that are not bound in the conclusion of the type
are required.</p>
<dl class="coq exn">
<dt id="coq:exn.not-the-right-number-of-missing-arguments">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>the</span> <span>right</span> <span>number</span> <span>of</span> <span>missing</span> <span>arguments.</span></span></code><a class="headerlink" href="#coq:exn.not-the-right-number-of-missing-arguments" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</li>
</ul>
</div>
<div class="section" id="intro-patterns">
<span id="intropatterns"></span><h3>Intro patterns<a class="headerlink" href="#intro-patterns" title="Permalink to this headline">¶</a></h3>
<p>Intro patterns let you specify the name to assign to variables and hypotheses
introduced by tactics.  They also let you split an introduced hypothesis into
multiple hypotheses or subgoals.  Common tactics that accept intro patterns
include <a class="reference internal" href="#coq:tacn.assert" title="assert"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assert</span></code></a>, <a class="reference internal" href="#coq:tacv.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> and <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>.</p>
<pre>
<strong id="grammar-token-coq-intropattern_list"><span id="grammar-token-intropattern-list"></span>intropattern_list         </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">intropattern</span></code> ... <code class="xref docutils literal notranslate"><span class="pre">intropattern</span></code>
                                <code class="xref docutils literal notranslate"><span class="pre">empty</span></code>
<strong id="grammar-token-coq-empty"><span id="grammar-token-empty"></span>empty                     </strong> ::= 
<strong id="grammar-token-coq-intropattern"><span id="grammar-token-intropattern"></span>intropattern              </strong> ::=  *
                                **
                                <code class="xref docutils literal notranslate"><span class="pre">simple_intropattern</span></code>
<strong id="grammar-token-coq-simple_intropattern"><span id="grammar-token-simple-intropattern"></span>simple_intropattern       </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">simple_intropattern_closed</span></code> [ % <code class="xref docutils literal notranslate"><span class="pre">term</span></code> ... % <code class="xref docutils literal notranslate"><span class="pre">term</span></code> ]
<strong id="grammar-token-coq-simple_intropattern_closed"><span id="grammar-token-simple-intropattern-closed"></span>simple_intropattern_closed</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">naming_intropattern</span></code>
                                _
                                <code class="xref docutils literal notranslate"><span class="pre">or_and_intropattern</span></code>
                                <code class="xref docutils literal notranslate"><span class="pre">equality_intropattern</span></code>
<strong id="grammar-token-coq-naming_intropattern"><span id="grammar-token-naming-intropattern"></span>naming_intropattern       </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>
                                ?
                                ?<code class="xref docutils literal notranslate"><span class="pre">ident</span></code>
<strong id="grammar-token-coq-or_and_intropattern"><span id="grammar-token-or-and-intropattern"></span>or_and_intropattern       </strong> ::=  [ <code class="xref docutils literal notranslate"><span class="pre">intropattern_list</span></code> | ... | <code class="xref docutils literal notranslate"><span class="pre">intropattern_list</span></code> ]
                                ( <code class="xref docutils literal notranslate"><span class="pre">simple_intropattern</span></code> , ... , <code class="xref docutils literal notranslate"><span class="pre">simple_intropattern</span></code> )
                                ( <code class="xref docutils literal notranslate"><span class="pre">simple_intropattern</span></code> &amp; ... &amp; <code class="xref docutils literal notranslate"><span class="pre">simple_intropattern</span></code> )
<strong id="grammar-token-coq-equality_intropattern"><span id="grammar-token-equality-intropattern"></span>equality_intropattern     </strong> ::=  -&gt;
                                &lt;-
                                [= <code class="xref docutils literal notranslate"><span class="pre">intropattern_list</span></code> ]
<strong id="grammar-token-coq-or_and_intropattern_loc"><span id="grammar-token-or-and-intropattern-loc"></span>or_and_intropattern_loc   </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">or_and_intropattern</span></code>
                                <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>
</pre>
<p>Note that the intro pattern syntax varies between tactics.
Most tactics use <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">simple_intropattern</span></span></span></code> in the grammar.
<a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>, <a class="reference internal" href="#coq:tacv.edestruct" title="edestruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">edestruct</span></code></a>, <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>,
<a class="reference internal" href="#coq:tacv.einduction" title="einduction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">einduction</span></code></a>, <a class="reference internal" href="#coq:tacn.case" title="case"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">case</span></code></a>, <a class="reference internal" href="#coq:tacv.ecase" title="ecase"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">ecase</span></code></a> and the various
<a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> tactics use <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">or_and_intropattern_loc</span></span></span></code>, while
<a class="reference internal" href="#coq:tacv.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> and <a class="reference internal" href="#coq:tacn.eintros" title="eintros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eintros</span></code></a> use <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">intropattern_list</span></span></span></code>.
The <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">eqn:</span></span></span></code> construct in various tactics uses <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">naming_intropattern</span></span></span></code>.</p>
<p><strong>Naming patterns</strong></p>
<p>Use these elementary patterns to specify a name:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> — use the specified name</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">?</span></span></span></code> — let Coq choose a name</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">?</span></span><span class="hole"><span class="pre">ident</span></span></span></code> — generate a name that begins with <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">_</span></span></span></code> — discard the matched part (unless it is required for another
hypothesis)</p></li>
<li><p>if a disjunction pattern omits a name, such as <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">[|</span></span><span class="name"><span class="pre">H2</span></span><span class="operator"><span class="pre">]</span></span></code>, Coq will choose a name</p></li>
</ul>
<p><strong>Splitting patterns</strong></p>
<p>The most common splitting patterns are:</p>
<ul class="simple">
<li><p>split a hypothesis in the form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">A</span></span> <span><span class="pre">/\</span></span> <span><span class="pre">B</span></span></span></code> into two
hypotheses <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H1</span></span><span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H2</span></span><span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">B</span></span></code> using the pattern <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">H1</span></span> <span class="operator"><span class="pre">&amp;</span></span> <span class="name"><span class="pre">H2</span></span><span class="operator"><span class="pre">)</span></span></code> or
<code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">H1</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">H2</span></span><span class="operator"><span class="pre">)</span></span></code> or <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">[</span></span><span class="name"><span class="pre">H1</span></span> <span class="name"><span class="pre">H2</span></span><span class="operator"><span class="pre">]</span></span></code>.
<a class="reference internal" href="#intropattern-conj-ex"><span class="std std-ref">Example</span></a>.  This also works on <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">A</span></span> <span><span class="pre">&lt;-&gt;</span></span> <span><span class="pre">B</span></span></span></code>, which
is just a notation representing <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(A</span></span> <span><span class="pre">-&gt;</span></span> <span><span class="pre">B)</span></span> <span><span class="pre">/\</span></span> <span><span class="pre">(B</span></span> <span><span class="pre">-&gt;</span></span> <span><span class="pre">A)</span></span></span></code>.</p></li>
<li><p>split a hypothesis in the form <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">\/</span></span> <span class="name"><span class="pre">B</span></span></code> into two
subgoals using the pattern <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">[</span></span><span class="name"><span class="pre">H1</span></span><span class="operator"><span class="pre">|</span></span><span class="name"><span class="pre">H2</span></span><span class="operator"><span class="pre">]</span></span></code>.  The first subgoal will have the hypothesis
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H1</span></span><span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span></code> and the second subgoal will have the hypothesis <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H2</span></span><span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">B</span></span></code>.
<a class="reference internal" href="#intropattern-disj-ex"><span class="std std-ref">Example</span></a></p></li>
<li><p>split a hypothesis in either of the forms <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">/\</span></span> <span class="name"><span class="pre">B</span></span></code> or <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">\/</span></span> <span class="name"><span class="pre">B</span></span></code> using the pattern <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">[]</span></span></code>.</p></li>
</ul>
<p>Patterns can be nested: <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[[Ha</span></span><span class="pre">|</span><span><span class="pre">Hb]</span></span> <span><span class="pre">H]</span></span></span></code> can be used to split <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(A</span></span> <span><span class="pre">\/</span></span> <span><span class="pre">B)</span></span> <span><span class="pre">/\</span></span> <span><span class="pre">C</span></span></span></code>.</p>
<p>Note that there is no equivalent to intro patterns for goals.  For a goal <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">/\</span></span> <span class="name"><span class="pre">B</span></span></code>,
use the <a class="reference internal" href="#coq:tacv.split" title="split"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">split</span></code></a> tactic to replace the current goal with subgoals <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code>.
For a goal <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">\/</span></span> <span class="name"><span class="pre">B</span></span></code>, use <a class="reference internal" href="#coq:tacv.left" title="left"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">left</span></code></a> to replace the current goal with <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code>, or
<a class="reference internal" href="#coq:tacv.right" title="right"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">right</span></code></a> to replace the current goal with <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">simple_intropattern</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></code> ) — matches
a product over an inductive type with a
<a class="reference internal" href="#intropattern-cons-note"><span class="std std-ref">single constructor</span></a>.
If the number of patterns
equals the number of constructor arguments, then it applies the patterns only to
the arguments, and
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">simple_intropattern</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <span><span class="pre">)</span></span></span></code> is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[</span></span><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">simple_intropattern</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span><span><span class="pre">]</span></span></span></code>.
If the number of patterns equals the number of constructor arguments plus the number
of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let-ins</span></span></span></code>, the patterns are applied to the arguments and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let-in</span></span></span></code> variables.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">simple_intropattern</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">&amp;</span></span></span> <span><span class="pre">)</span></span></span></code> — matches a right-hand nested term that consists
of one or more nested binary inductive types such as <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">a1</span></span> <span class="name"><span class="pre">OP1</span></span> <span class="name"><span class="pre">a2</span></span> <span class="name"><span class="pre">OP2</span></span> <span class="operator"><span class="pre">...</span></span></code>
(where the <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">OPn</span></span></code> are right-associative).
(If the <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">OPn</span></span></code> are left-associative, additional parentheses will be needed to make the
term right-hand nested, such as <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">a1</span></span> <span class="name"><span class="pre">OP1</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">a2</span></span> <span class="name"><span class="pre">OP2</span></span> <span class="operator"><span class="pre">...)</span></span></code>.)
The splitting pattern can have more than 2 names, for example <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">H1</span></span> <span class="operator"><span class="pre">&amp;</span></span> <span class="name"><span class="pre">H2</span></span> <span class="operator"><span class="pre">&amp;</span></span> <span class="name"><span class="pre">H3</span></span><span class="operator"><span class="pre">)</span></span></code>
matches <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">/\</span></span> <span class="name"><span class="pre">B</span></span> <span class="operator"><span class="pre">/\</span></span> <span class="name"><span class="pre">C</span></span></code>.
The inductive types must have a
<a class="reference internal" href="#intropattern-cons-note"><span class="std std-ref">single constructor with two parameters</span></a>.
<a class="reference internal" href="#intropattern-ampersand-ex"><span class="std std-ref">Example</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">intropattern_list</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">|</span></span></span> <span><span class="pre">]</span></span></span></code> — splits an inductive type that has
<a class="reference internal" href="#intropattern-cons-note"><span class="std std-ref">multiple constructors</span></a>
such as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">A</span></span> <span><span class="pre">\/</span></span> <span><span class="pre">B</span></span></span></code>
into multiple subgoals.  The number of <code class="xref std std-token docutils literal notranslate"><span class="pre">intropattern_list</span></code> must be the same as the number of
constructors for the matched part.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">intropattern</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">]</span></span></span></code> — splits an inductive type that has a
<a class="reference internal" href="#intropattern-cons-note"><span class="std std-ref">single constructor with multiple parameters</span></a>
such as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">A</span></span> <span><span class="pre">/\</span></span> <span><span class="pre">B</span></span></span></code> into multiple hypotheses.  Use <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[H1</span></span> <span><span class="pre">[H2</span></span> <span><span class="pre">H3]]</span></span></span></code> to match <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">/\</span></span> <span class="name"><span class="pre">B</span></span> <span class="operator"><span class="pre">/\</span></span> <span class="name"><span class="pre">C</span></span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[]</span></span></span></code> — splits an inductive type:  If the inductive
type has multiple constructors, such as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">A</span></span> <span><span class="pre">\/</span></span> <span><span class="pre">B</span></span></span></code>,
create one subgoal for each constructor.  If the inductive type has a single constructor with
multiple parameters, such as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">A</span></span> <span><span class="pre">/\</span></span> <span><span class="pre">B</span></span></span></code>, split it into multiple hypotheses.</p></li>
</ul>
<p><strong>Equality patterns</strong></p>
<p>These patterns can be used when the hypothesis is an equality:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">-&gt;</span></span></span></code> — replaces the right-hand side of the hypothesis with the left-hand
side of the hypothesis in the conclusion of the goal; the hypothesis is
cleared; if the left-hand side of the hypothesis is a variable, it is
substituted everywhere in the context and the variable is removed.
<a class="reference internal" href="#intropattern-rarrow-ex"><span class="std std-ref">Example</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">&lt;-</span></span></span></code> — similar to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">-&gt;</span></span></span></code>, but replaces the left-hand side of the hypothesis
with the right-hand side of the hypothesis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[=</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">intropattern</span></span></span><span class="notation-sup"><span class="pre">*</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <span><span class="pre">]</span></span></span></code> — If the product is over an equality type,
applies either <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> or <a class="reference internal" href="#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a>.
If <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> is applicable, the intropattern
is used on the hypotheses generated by <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a>.  If the
number of patterns is smaller than the number of hypotheses generated, the
pattern <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">?</span></span></span></code> is used to complete the list.
<a class="reference internal" href="#intropattern-inj-discr-ex"><span class="std std-ref">Example</span></a></p></li>
</ul>
<p><strong>Other patterns</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">*</span></span></span></code> — introduces one or more quantified variables from the result
until there are no more quantified variables.
<a class="reference internal" href="#intropattern-star-ex"><span class="std std-ref">Example</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">**</span></span></span></code> — introduces one or more quantified variables or hypotheses from the result until there are
no more quantified variables or implications (<code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">-&gt;</span></span></code>).  <code class="code highlight coq docutils literal notranslate"><span class="name builtin"><span class="pre">intros</span></span> <span class="operator"><span class="pre">**</span></span></code> is equivalent
to <code class="code highlight coq docutils literal notranslate"><span class="name builtin"><span class="pre">intros</span></span></code>.
<a class="reference internal" href="#intropattern-2stars-ex"><span class="std std-ref">Example</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">simple_intropattern_closed</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">%</span></span> <span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code> — first applies each of the terms
with the <a class="reference internal" href="#coq:tacn.apply-in" title="apply ... in"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span> <span class="pre">...</span> <span class="pre">in</span></code></a> tactic on the hypothesis to be introduced, then it uses
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">simple_intropattern_closed</span></span></span></code>.
<a class="reference internal" href="#intropattern-injection-ex"><span class="std std-ref">Example</span></a></p></li>
</ul>
<dl class="coq flag">
<dt id="coq:flag.bracketing-last-introduction-pattern">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Bracketing</span> <span>Last</span> <span>Introduction</span> <span>Pattern</span></span></code><a class="headerlink" href="#coq:flag.bracketing-last-introduction-pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>For <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span class="hole"><span class="pre">intropattern_list</span></span></span></code>, controls how to handle a
conjunctive pattern that doesn't give enough simple patterns to match
all the arguments in the constructor.  If set (the default), <span class="smallcaps">Coq</span> generates
additional names to match the number of arguments.
Unsetting the option will put the additional hypotheses in the goal instead, behavior that is more
similar to <span class="smallcaps">SSReflect</span>'s intro patterns.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 8.10.</span></p>
</div>
</dd></dl>

<div class="admonition note" id="intropattern-cons-note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">A</span></span> <span><span class="pre">\/</span></span> <span><span class="pre">B</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">A</span></span> <span><span class="pre">/\</span></span> <span><span class="pre">B</span></span></span></code> use infix notation to refer to the inductive
types <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">or</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">and</span></span></span></code>.
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">or</span></span></span></code> has multiple constructors (<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">or</span></span><span><span class="pre">_</span></span><span><span class="pre">introl</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">or</span></span><span><span class="pre">_</span></span><span><span class="pre">intror</span></span></span></code>),
while <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">and</span></span></span></code> has a single constructor (<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">conj</span></span></span></code>) with multiple parameters
(<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">A</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">B</span></span></span></code>).
These are defined in theories/Init/Logic.v.  The &quot;where&quot; clauses define the
infix notation for &quot;or&quot; and &quot;and&quot;.</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Inductive</span> <span class="nf">or</span> <span class="o">(</span><span class="nv">A</span> <span class="nv">B</span><span class="o">:</span><span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="o">|</span> <span class="n">or_introl</span> <span class="o">:</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">\/</span> <span class="n">B</span>
  <span class="o">|</span> <span class="n">or_intror</span> <span class="o">:</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">\/</span> <span class="n">B</span>
<span class="kn">where</span> <span class="s2">&quot;A \/ B&quot;</span> <span class="o">:=</span> <span class="o">(</span><span class="n">or</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">type_scope</span><span class="o">.</span>

<span class="kn">Inductive</span> <span class="nf">and</span> <span class="o">(</span><span class="nv">A</span> <span class="nv">B</span><span class="o">:</span><span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="n">conj</span> <span class="o">:</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">/\</span> <span class="n">B</span>
<span class="kn">where</span> <span class="s2">&quot;A /\ B&quot;</span> <span class="o">:=</span> <span class="o">(</span><span class="kn">and</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">type_scope</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">p</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> is not always equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">p;</span></span> <span><span class="pre">...</span></span> <span><span class="pre">;</span></span> <span><span class="pre">intros</span></span> <span><span class="pre">p</span></span></span></code>
if some of the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">p</span></span></span></code> are <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">_</span></span></code>.  In the first form, all erasures are done
at once, while they're done sequentially for each tactic in the second form.
If the second matched term depends on the first matched term and the pattern
for both is <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">_</span></span></code> (i.e., both will be erased), the first <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span></span></code> in the second
form will fail because the second matched term still has the dependency on the first.</p>
</div>
<p>Examples:</p>
<blockquote id="intropattern-conj-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: intro pattern for /\</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk0" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A /\ B</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk1" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk1"><span class="highlight"><span class="nb">destruct</span> H <span class="kr">as</span> (HA &amp; HB).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HB</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">B</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div></div>
</div></blockquote>
<blockquote id="intropattern-disj-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: intro pattern for \/</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk2" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A \/ B</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk3" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk3"><span class="highlight"><span class="nb">destruct</span> H <span class="kr">as</span> [HA|HB].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk4" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HB</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">B</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk4"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk5" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk5"><span class="highlight"><span class="kp">all</span>: <span class="nb">swap</span> <span class="mi">1</span> <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HB</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">B</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk6" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HA</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk6"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></div></small></span></pre></div></div>
</div></blockquote>
<blockquote id="intropattern-rarrow-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: -&gt; intro pattern</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk7" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">y = z -&gt; x = z</span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk8" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk8"><span class="highlight"><span class="nb">intros</span> -&gt;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = z</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x = z</span></div></blockquote></div></div></small></span></pre></div></div>
</div></blockquote>
<blockquote id="intropattern-inj-discr-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: [=] intro pattern</p>
<p>The first <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">[=]</span></span></span></code> uses <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> to strip <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(S</span></span> <span><span class="pre">...)</span></span></span></code> from
both sides of the matched equality.  The second uses <a class="reference internal" href="#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a> on
the contradiction <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">1</span></span> <span><span class="pre">=</span></span> <span><span class="pre">2</span></span></span></code> (internally represented as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(S</span></span> <span><span class="pre">O)</span></span> <span><span class="pre">=</span></span> <span><span class="pre">(S</span></span> <span><span class="pre">(S</span></span> <span><span class="pre">O))</span></span></span></code>)
to complete the goal.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk9" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">S n = S m -&gt; <span class="mi">1</span> = <span class="mi">2</span> -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chka" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chka"><span class="highlight"><span class="nb">intros</span> [= H].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> = <span class="mi">2</span> -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span> [=].</span></span></span></pre></div></div>
</div></blockquote>
<blockquote id="intropattern-ampersand-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: (A &amp; B &amp; ...) intro pattern</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chkb" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">A /\ (<span class="kr">exists</span> <span class="nv">x</span> : nat, B x /\ C) -&gt; <span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chkc" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chkc"><span class="highlight"><span class="nb">intros</span> (a &amp; x &amp; b &amp; c).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">B x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">C</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div></div>
</div></blockquote>
<blockquote id="intropattern-star-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: * intro pattern</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chkd" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Prop</span>, A -&gt; B</span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chke" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chke"><span class="highlight"><span class="nb">intros</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">A -&gt; B</span></div></blockquote></div></div></small></span></pre></div></div>
</div></blockquote>
<blockquote id="intropattern-2stars-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: ** pattern (&quot;intros **&quot; is equivalent to &quot;intros&quot;)</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chkf" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Prop</span>, A -&gt; B</span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk10" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk10"><span class="highlight"><span class="nb">intros</span> **.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">B</span></div></blockquote></div></div></small></span></pre></div></div>
<div class="admonition note">
<p class="admonition-title">Example: compound intro pattern</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk11" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Prop</span>, A \/ B /\ C -&gt; (A -&gt; C) -&gt; C</span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk12" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk12"><span class="highlight"><span class="nb">intros</span> * [a | (_,c)] f.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; C</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">C</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk13" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">C</span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; C</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk13"><hr></label><div class="goal-conclusion"><span class="highlight">C</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk14" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk14"><span class="highlight"><span class="kp">all</span>: <span class="nb">swap</span> <span class="mi">1</span> <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">C</span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; C</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">C</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk15" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; C</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk15"><hr></label><div class="goal-conclusion"><span class="highlight">C</span></div></blockquote></div></div></div></small></span></pre></div></div>
</div></blockquote>
<blockquote id="intropattern-injection-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: combined intro pattern using [=] -&gt; and %</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk16" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs, ys</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">S (length ys) = <span class="mi">1</span> -&gt; xs ++ ys = xs</span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk17" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk17"><span class="highlight"><span class="nb">intros</span> [=-&gt;%length_zero_iff_nil].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">xs ++ nil = xs</span></div></blockquote></div></div></small></span></pre></div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">intros</span></code> would add <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">length</span></span> <span class="name"><span class="pre">ys</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">1</span></span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">intros</span> <span class="pre">[=]</span></code> would additionally apply <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> to <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> to yield <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H0</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">length</span></span> <span class="name"><span class="pre">ys</span></span> <span class="operator"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">0</span></span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">intros</span> <span class="pre">[=-&gt;%length_zero_iff_nil]</span></code> applies the theorem, making H the equality <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">nil</span></span></code>,
which is then applied as for <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">-&gt;</span></span></code>.</p></li>
</ul>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Theorem</span> <span class="nf">length_zero_iff_nil</span> <span class="o">(</span><span class="nv">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">):</span>
   <span class="n">length</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;-&gt;</span> <span class="n">l</span><span class="o">=</span><span class="n">nil</span><span class="o">.</span>
</pre></div>
</div>
<p>The example is based on <a class="reference external" href="https://github.com/tchajed/coq-tricks/blob/8e6efe4971ed828ac8bdb5512c1f615d7d62691e/src/IntroPatterns.v">Tej Chajed's coq-tricks</a></p>
</div>
</div></blockquote>
</div>
<div class="section" id="occurrence-sets-and-occurrence-clauses">
<span id="occurrencessets"></span><h3>Occurrence sets and occurrence clauses<a class="headerlink" href="#occurrence-sets-and-occurrence-clauses" title="Permalink to this headline">¶</a></h3>
<p>An occurrence clause is a modifier to some tactics that obeys the
following syntax:</p>
<blockquote>
<div><pre>
<strong id="grammar-token-coq-occurrence_clause"><span id="grammar-token-occurrence-clause"></span>occurrence_clause</strong> ::=  in <code class="xref docutils literal notranslate"><span class="pre">goal_occurrences</span></code>
<strong id="grammar-token-coq-goal_occurrences"><span id="grammar-token-goal-occurrences"></span>goal_occurrences </strong> ::=  [<code class="xref docutils literal notranslate"><span class="pre">ident</span></code> [<code class="xref docutils literal notranslate"><span class="pre">at_occurrences</span></code>], ... , <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> [<code class="xref docutils literal notranslate"><span class="pre">at_occurrences</span></code>] [|- [* [<code class="xref docutils literal notranslate"><span class="pre">at_occurrences</span></code>]]]]
                       * |- [* [<code class="xref docutils literal notranslate"><span class="pre">at_occurrences</span></code>]]
                       *
<strong id="grammar-token-coq-at_occurrences"><span id="grammar-token-at-occurrences"></span>at_occurrences   </strong> ::=  at <code class="xref docutils literal notranslate"><span class="pre">occurrences</span></code>
<strong id="grammar-token-coq-occurrences"><span id="grammar-token-occurrences"></span>occurrences      </strong> ::=  [-] <code class="xref docutils literal notranslate"><span class="pre">num</span></code> ... <code class="xref docutils literal notranslate"><span class="pre">num</span></code>
</pre>
</div></blockquote>
<p>The role of an occurrence clause is to select a set of occurrences of a term
in a goal. In the first case, the <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">at</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">num</span></span></span><span class="notation-sup"><span class="pre">*</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code> parts indicate
that occurrences have to be selected in the hypotheses named <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>.
If no numbers are given for hypothesis <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>, then all the
occurrences of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> in the hypothesis are selected. If numbers are
given, they refer to occurrences of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> when the term is printed
using option <a class="reference internal" href="../language/gallina-extensions.html#coq:flag.printing-all" title="Printing All"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">All</span></code></a>, counting from left to right. In particular,
occurrences of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> in implicit arguments
(see <a class="reference internal" href="../language/gallina-extensions.html#implicitarguments"><span class="std std-ref">Implicit arguments</span></a>) or coercions (see <a class="reference internal" href="../language/gallina-extensions.html#coercions"><span class="std std-ref">Coercions</span></a>) are
counted.</p>
<p>If a minus sign is given between <code class="docutils literal notranslate"><span class="pre">at</span></code> and the list of occurrences, it
negates the condition so that the clause denotes all the occurrences
except the ones explicitly mentioned after the minus sign.</p>
<p>As an exception to the left-to-right order, the occurrences in
the return subexpression of a match are considered <em>before</em> the
occurrences in the matched term.</p>
<p>In the second case, the <code class="docutils literal notranslate"><span class="pre">*</span></code> on the left of <code class="docutils literal notranslate"><span class="pre">|-</span></code> means that all occurrences
of term are selected in every hypothesis.</p>
<p>In the first and second case, if <code class="docutils literal notranslate"><span class="pre">*</span></code> is mentioned on the right of <code class="docutils literal notranslate"><span class="pre">|-</span></code>, the
occurrences of the conclusion of the goal have to be selected. If some numbers
are given, then only the occurrences denoted by these numbers are selected. If
no numbers are given, all occurrences of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> in the goal are selected.</p>
<p>Finally, the last notation is an abbreviation for <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">|-</span> <span class="pre">*</span></code>. Note also
that <code class="docutils literal notranslate"><span class="pre">|-</span></code> is optional in the first case when no <code class="docutils literal notranslate"><span class="pre">*</span></code> is given.</p>
<p>Here are some tactics that understand occurrence clauses: <a class="reference internal" href="#coq:tacn.set" title="set"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">set</span></code></a>,
<a class="reference internal" href="#coq:tacn.remember" title="remember"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">remember</span></code></a>, <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>, <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#managingthelocalcontext"><span class="std std-ref">Managing the local context</span></a>, <a class="reference internal" href="#caseanalysisandinduction"><span class="std std-ref">Case analysis and induction</span></a>,
<a class="reference internal" href="../language/gallina-extensions.html#printing-constructions-full"><span class="std std-ref">Printing constructions in full</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="applying-theorems">
<span id="applyingtheorems"></span><h2>Applying theorems<a class="headerlink" href="#applying-theorems" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt id="coq:tacn.exact">
<code class="sig-name descname"><span class="notation"><span>exact</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.exact" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. It gives directly the exact proof
term of the goal. Let <code class="docutils literal notranslate"><span class="pre">T</span></code> be our goal, let <code class="docutils literal notranslate"><span class="pre">p</span></code> be a term of type <code class="docutils literal notranslate"><span class="pre">U</span></code> then
<code class="docutils literal notranslate"><span class="pre">exact</span> <span class="pre">p</span></code> succeeds iff <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">U</span></code> are convertible (see
<a class="reference internal" href="../language/cic.html#conversion-rules"><span class="std std-ref">Conversion rules</span></a>).</p>
<dl class="coq exn">
<dt id="coq:exn.not-an-exact-proof">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>an</span> <span>exact</span> <span>proof.</span></span></code><a class="headerlink" href="#coq:exn.not-an-exact-proof" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.eexact">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>eexact</span> <span class="hole">term</span><span>.</span></span></code><a class="headerlink" href="#coq:tacv.eexact" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves like <a class="reference internal" href="#coq:tacn.exact" title="exact"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exact</span></code></a> but is able to handle terms and
goals with existential variables.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.assumption">
<code class="sig-name descname"><span class="notation"><span>assumption</span></span></code><a class="headerlink" href="#coq:tacn.assumption" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic looks in the local context for a hypothesis whose type is
convertible to the goal. If it is the case, the subgoal is proved.
Otherwise, it fails.</p>
<dl class="coq exn">
<dt id="coq:exn.no-such-assumption">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>such</span> <span>assumption.</span></span></code><a class="headerlink" href="#coq:exn.no-such-assumption" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.eassumption">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>eassumption</span></span></code><a class="headerlink" href="#coq:tacv.eassumption" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves like <a class="reference internal" href="#coq:tacn.assumption" title="assumption"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assumption</span></code></a> but is able to handle
goals with existential variables.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.refine">
<code class="sig-name descname"><span class="notation"><span>refine</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. It behaves like <a class="reference internal" href="#coq:tacn.exact" title="exact"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exact</span></code></a> with a big
difference: the user can leave some holes (denoted by <code class="docutils literal notranslate"><span class="pre">_</span></code>
or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span><span class="pre">_</span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">)</span></span></span></code>) in the term. <a class="reference internal" href="#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> will generate as many
subgoals as there are holes in the term. The type of holes must be either
synthesized by the system or declared by an explicit cast
like <code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">:</span> <span class="pre">nat</span> <span class="pre">-&gt;</span> <span class="pre">Prop)</span></code>. Any subgoal that
occurs in other subgoals is automatically shelved, as if calling
<a class="reference internal" href="#coq:tacv.shelve-unifiable" title="shelve_unifiable"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">shelve_unifiable</span></code></a>. This low-level tactic can be
useful to advanced users.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">Option</span> : <span class="kt">Set</span> :=
| <span class="kn">Fail</span> : Option
| Ok : bool -&gt; Option.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk18" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk18"><span class="highlight"><span class="kn">Definition</span> <span class="nf">get</span> : <span class="kr">forall</span> <span class="nv">x</span>:Option, x &lt;&gt; <span class="kn">Fail</span> -&gt; bool.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Option, x &lt;&gt; <span class="kn">Fail</span> -&gt; bool</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk19" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk19"><span class="highlight"><span class="nb">refine</span>
    (<span class="kr">fun</span> <span class="nv">x</span>:Option =&gt;
      <span class="kr">match</span> x <span class="kr">return</span> x &lt;&gt; <span class="kn">Fail</span> -&gt; bool <span class="kr">with</span>
      | <span class="kn">Fail</span> =&gt; _
      | Ok b =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; b
      <span class="kr">end</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Option</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kn">Fail</span> &lt;&gt; <span class="kn">Fail</span> -&gt; bool</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span>; <span class="nb">absurd</span> (<span class="kn">Fail</span> = <span class="kn">Fail</span>); <span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Defined</span>.</span></span></span></pre></div></div>
<dl class="coq exn">
<dt id="coq:exn.invalid-argument">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Invalid</span> <span>argument.</span></span></code><a class="headerlink" href="#coq:exn.invalid-argument" title="Permalink to this definition">¶</a></dt>
<dd><p>The tactic <a class="reference internal" href="#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> does not know what to do with the term you gave.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.refine-passed-ill-formed-term">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Refine</span> <span>passed</span> <span>ill-formed</span> <span>term.</span></span></code><a class="headerlink" href="#coq:exn.refine-passed-ill-formed-term" title="Permalink to this definition">¶</a></dt>
<dd><p>The term you gave is not a valid proof (not easy to debug in general). This
message may also occur in higher-level tactics that call <a class="reference internal" href="#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a>
internally.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.cannot-infer-a-term-for-this-placeholder-refine">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>infer</span> <span>a</span> <span>term</span> <span>for</span> <span>this</span> <span>placeholder.</span></span></code><a class="headerlink" href="#coq:exn.cannot-infer-a-term-for-this-placeholder-refine" title="Permalink to this definition">¶</a></dt>
<dd><p>There is a hole in the term you gave whose type cannot be inferred. Put a
cast around it.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.simple-refine">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simple</span> <span>refine</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacv.simple-refine" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves like refine, but it does not shelve any subgoal. It does
not perform any beta-reduction either.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.notypeclasses-refine">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>notypeclasses</span> <span>refine</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacv.notypeclasses-refine" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves like <a class="reference internal" href="#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> except it performs type checking without
resolution of typeclasses.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.simple-notypeclasses-refine">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simple</span> <span>notypeclasses</span> <span>refine</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacv.simple-notypeclasses-refine" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves like <a class="reference internal" href="#coq:tacv.simple-refine" title="simple refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simple</span> <span class="pre">refine</span></code></a> except it performs type checking
without resolution of typeclasses.</p>
</dd></dl>

<dl class="coq flag">
<dt id="coq:flag.debug-unification">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Debug</span> <span>Unification</span></span></code><a class="headerlink" href="#coq:flag.debug-unification" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables printing traces of unification steps used during
elaboration/typechecking and the <a class="reference internal" href="#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> tactic.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.apply">
<code class="sig-name descname"><span class="notation"><span>apply</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. The argument term is a term well-formed in
the local context. The tactic <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> tries to match the current goal
against the conclusion of the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>. If it succeeds, then
the tactic returns as many subgoals as the number of non-dependent premises
of the type of term. If the conclusion of the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> does
not match the goal <em>and</em> the conclusion is an inductive type isomorphic to
a tuple type, then each component of the tuple is recursively matched to
the goal in the left-to-right order.</p>
<p>The tactic <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> relies on first-order unification with dependent
types unless the conclusion of the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> is of the form
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">P</span></span> <span><span class="pre">(t</span><sub><span class="pre">1</span></sub></span> <span><span class="pre">...</span></span> <span><span class="pre">t</span><sub><span class="pre">n</span></sub></span><span><span class="pre">)</span></span></span></code> with <code class="docutils literal notranslate"><span class="pre">P</span></code> to be instantiated. In the latter case,
the behavior depends on the form of the goal. If the goal is of the form
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(fun</span></span> <span><span class="pre">x</span></span> <span><span class="pre">=&gt;</span></span> <span><span class="pre">Q)</span></span> <span><span class="pre">u</span><sub><span class="pre">1</span></sub></span> <span><span class="pre">...</span></span> <span><span class="pre">u</span><sub><span class="pre">n</span></sub></span></span></code> and the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">t</span><sub><span class="pre">i</span></sub></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">u</span><sub><span class="pre">i</span></sub></span></span></code> unify,
then <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> is taken to be <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="keyword reserved"><span class="pre">fun</span></span> <span class="name variable"><span class="pre">x</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">Q</span></span><span class="operator"><span class="pre">)</span></span></code>. Otherwise, <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>
tries to define <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> by abstracting over <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t_1</span></span> <span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">t__n</span></span></code> in the goal.
See <a class="reference internal" href="#coq:tacn.pattern" title="pattern"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pattern</span></code></a> to transform the goal so that it
gets the form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(fun</span></span> <span><span class="pre">x</span></span> <span><span class="pre">=&gt;</span></span> <span><span class="pre">Q)</span></span> <span><span class="pre">u</span><sub><span class="pre">1</span></sub></span> <span><span class="pre">...</span></span> <span><span class="pre">u</span><sub><span class="pre">n</span></sub></span></span></code>.</p>
<dl class="coq exn">
<dt id="coq:exn.unable-to-unify-term-with-term">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Unable</span> <span>to</span> <span>unify</span> <span class="hole">term</span> <span>with</span> <span class="hole">term</span><span>.</span></span></code><a class="headerlink" href="#coq:exn.unable-to-unify-term-with-term" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> tactic failed to match the conclusion of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>
and the current goal. You can help the <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> tactic by
transforming your goal with the <a class="reference internal" href="#coq:tacn.change" title="change"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change</span></code></a> or <a class="reference internal" href="#coq:tacn.pattern" title="pattern"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pattern</span></code></a>
tactics.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.unable-to-find-an-instance-for-the-variables-ident-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Unable</span> <span>to</span> <span>find</span> <span>an</span> <span>instance</span> <span>for</span> <span>the</span> <span>variables</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span><span>.</span></span></code><a class="headerlink" href="#coq:exn.unable-to-find-an-instance-for-the-variables-ident-ident" title="Permalink to this definition">¶</a></dt>
<dd><p>This occurs when some instantiations of the premises of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> are not deducible
from the unification. This is the case, for instance, when you want to apply a
transitivity property. In this case, you have to use one of the variants below:</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>apply</span> <span class="hole">term</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Provides apply with explicit instantiations for all dependent premises of the
type of term that do not occur in the conclusion and consequently cannot be
found by unification. Notice that the collection <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> must be given
according to the order of these dependent premises of the type of term.</p>
<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>the</span> <span>right</span> <span>number</span> <span>of</span> <span>missing</span> <span>arguments.</span></span></code></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>apply</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span></span></code></dt>
<dd><p>This also provides apply with values for instantiating premises. Here, variables
are referred by names and non-dependent products by increasing numbers (see
<a class="reference internal" href="#bindingslist"><span class="std std-ref">bindings list</span></a>).</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>apply</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>This is a shortcut for <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span><span><span class="pre">;</span></span> <span><span class="pre">[..</span></span> <span class="pre">|</span> <span><span class="pre">...</span></span> <span><span class="pre">;</span></span> <span><span class="pre">[</span></span> <span><span class="pre">..</span></span> <span class="pre">|</span> <span><span class="pre">apply</span></span> <span class="hole"><span class="pre">term</span><sub><span class="pre">n</span></sub></span><span><span class="pre">]</span></span> <span><span class="pre">...</span></span> <span><span class="pre">]</span></span></span></code>,
i.e. for the successive applications of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code><sub>i+1</sub> on the last subgoal
generated by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <span class="hole"><span class="pre">term</span><sub><span class="pre">i</span></sub></span></span></code> , starting from the application of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.eapply">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>eapply</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacv.eapply" title="Permalink to this definition">¶</a></dt>
<dd><p>The tactic <a class="reference internal" href="#coq:tacv.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a> behaves like <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> but it does not fail when no
instantiations are deducible for some variables in the premises. Rather, it
turns these variables into existential variables which are variables still to
instantiate (see <a class="reference internal" href="../language/gallina-extensions.html#existential-variables"><span class="std std-ref">Existential variables</span></a>). The instantiation is
intended to be found later in the proof.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simple</span> <span>apply</span> <span class="hole">term</span><span>.</span></span></code></dt>
<dd><p>This behaves like <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> but it reasons modulo conversion only on subterms
that contain no variables to instantiate. For instance, the following example
does not succeed because it would require the conversion of <code class="docutils literal notranslate"><span class="pre">id</span> <span class="pre">?foo</span></code> and
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">id</span> (<span class="nv">x</span> : nat) := x.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">y</span>, id y = y.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk1a" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk1a"><span class="highlight"><span class="kn">Goal</span> O = O.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk1b"><span class="highlight"><span class="kn">Fail</span> <span class="nb">simple apply</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
Unable to <span class="nb">unify</span> <span class="s2">&quot;id ?M160 = ?M160&quot;</span> <span class="kr">with</span> <span class="s2">&quot;0 = 0&quot;</span>.</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span></span></div></blockquote></div></div></small></span></pre></div></div>
<p>Because it reasons modulo a limited amount of conversion, <a class="reference internal" href="#coq:tacv.simple-apply" title="simple apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simple</span> <span class="pre">apply</span></code></a> fails
quicker than <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> and it is then well-suited for uses in user-defined
tactics that backtrack often. Moreover, it does not traverse tuples as <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>
does.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.simple-apply">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>simple</span></span><span class="notation-sup">?</span></span> <span>apply</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code><a class="headerlink" href="#coq:tacv.simple-apply" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacv.simple-eapply">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>simple</span></span><span class="notation-sup">?</span></span> <span>eapply</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code><a class="headerlink" href="#coq:tacv.simple-eapply" title="Permalink to this definition">¶</a></dt>
<dd><p>This summarizes the different syntaxes for <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> and <a class="reference internal" href="#coq:tacv.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a>.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.lapply">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>lapply</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacv.lapply" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal, say <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">G</span></span></code>. The argument term has to be
well-formed in the current context, its type being reducible to a non-dependent
product <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">B</span></span></code> with <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> possibly containing products. Then it generates
two subgoals <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">G</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code>. Applying <code class="docutils literal notranslate"><span class="pre">lapply</span> <span class="pre">H</span></code> (where <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> has type
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">B</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> does not start with a product) does the same as giving the
sequence <code class="docutils literal notranslate"><span class="pre">cut</span> <span class="pre">B.</span> <span class="pre">2:apply</span> <span class="pre">H.</span></code> where <code class="docutils literal notranslate"><span class="pre">cut</span></code> is described below.</p>
<dl class="coq warn">
<dt id="coq:warn.when-term-contains-more-than-one-non-dependent-product-the-tactic-lapply-only-takes-into-account-the-first-product">
<em class="property"><span class="sigannot">Warning</span></em> <code class="sig-name descname"><span class="notation"><span>When</span> <span class="hole">term</span> <span>contains</span> <span>more</span> <span>than</span> <span>one</span> <span>non</span> <span>dependent</span> <span>product</span> <span>the</span> <span>tactic</span> <span>lapply</span> <span>only</span> <span>takes</span> <span>into</span> <span>account</span> <span>the</span> <span>first</span> <span>product.</span></span></code><a class="headerlink" href="#coq:warn.when-term-contains-more-than-one-non-dependent-product-the-tactic-lapply-only-takes-into-account-the-first-product" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Assume we have a transitive relation <code class="docutils literal notranslate"><span class="pre">R</span></code> on <code class="docutils literal notranslate"><span class="pre">nat</span></code>:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">R</span> : nat -&gt; nat -&gt; <span class="kt">Prop</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">Rtrans</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>:nat, R x y -&gt; R y z -&gt; R x z.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameters</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">p</span> : nat.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">Rnm</span> : R n m.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">Rmp</span> : R m p.</span></span></span></pre></div><p>Consider the goal <code class="docutils literal notranslate"><span class="pre">(R</span> <span class="pre">n</span> <span class="pre">p)</span></code> provable using the transitivity of <code class="docutils literal notranslate"><span class="pre">R</span></code>:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="tactics-rst-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk1c"><span class="highlight"><span class="kn">Goal</span> R n p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">R n p</span></div></blockquote></div></div></small></span></pre></div><p>The direct application of <code class="docutils literal notranslate"><span class="pre">Rtrans</span></code> with <code class="docutils literal notranslate"><span class="pre">apply</span></code> fails because no value
for <code class="docutils literal notranslate"><span class="pre">y</span></code> in <code class="docutils literal notranslate"><span class="pre">Rtrans</span></code> is found by <code class="docutils literal notranslate"><span class="pre">apply</span></code>:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk1d" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="tactics-rst-chk1d"><span class="highlight"><span class="nb">apply</span> Rtrans.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">Unable to find an instance <span class="kr">for</span> the variable y.</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">R n p</span></div></blockquote></div></div></small></span></pre></div><p>A solution is to <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">(Rtrans</span> <span class="pre">n</span> <span class="pre">m</span> <span class="pre">p)</span></code> or <code class="docutils literal notranslate"><span class="pre">(Rtrans</span> <span class="pre">n</span> <span class="pre">m)</span></code>.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk1e"><span class="highlight"><span class="nb">apply</span> (Rtrans n m p).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">R n m</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk1f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk1f"><hr></label><div class="goal-conclusion"><span class="highlight">R m p</span></div></blockquote></div></div></div></small></span></pre></div><p>Note that <code class="docutils literal notranslate"><span class="pre">n</span></code> can be inferred from the goal, so the following would work
too.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="tactics-rst-chk20" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk20"><span class="highlight"><span class="nb">apply</span> (Rtrans _ m).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">R n m</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk21" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk21"><hr></label><div class="goal-conclusion"><span class="highlight">R m p</span></div></blockquote></div></div></div></small></span></pre></div><p>More elegantly, <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">Rtrans</span> <span class="pre">with</span> <span class="pre">(y:=m)</span></code> allows only mentioning the
unknown m:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="tactics-rst-chk22" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk22"><span class="highlight"><span class="nb">apply</span> Rtrans <span class="kr">with</span> (y := m).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">R n m</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk23" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk23"><hr></label><div class="goal-conclusion"><span class="highlight">R m p</span></div></blockquote></div></div></div></small></span></pre></div><p>Another solution is to mention the proof of <code class="docutils literal notranslate"><span class="pre">(R</span> <span class="pre">x</span> <span class="pre">y)</span></code> in <code class="docutils literal notranslate"><span class="pre">Rtrans</span></code></p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk24" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk24"><span class="highlight"><span class="nb">apply</span> Rtrans <span class="kr">with</span> (<span class="mi">1</span> := Rnm).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">R m p</span></div></blockquote></div></div></small></span></pre></div><p>... or the proof of <code class="docutils literal notranslate"><span class="pre">(R</span> <span class="pre">y</span> <span class="pre">z)</span></code>.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk25" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk25"><span class="highlight"><span class="nb">apply</span> Rtrans <span class="kr">with</span> (<span class="mi">2</span> := Rmp).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">R n m</span></div></blockquote></div></div></small></span></pre></div><p>On the opposite, one can use <code class="docutils literal notranslate"><span class="pre">eapply</span></code> which postpones the problem of
finding <code class="docutils literal notranslate"><span class="pre">m</span></code>. Then one can apply the hypotheses <code class="docutils literal notranslate"><span class="pre">Rnm</span></code> and <code class="docutils literal notranslate"><span class="pre">Rmp</span></code>. This
instantiates the existential variable and completes the proof.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk26" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk26"><span class="highlight"><span class="nb">eapply</span> Rtrans.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">R n ?y</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk27" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk27"><hr></label><div class="goal-conclusion"><span class="highlight">R ?y p</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk28" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk28"><span class="highlight"><span class="nb">apply</span> Rnm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">R m p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> Rmp.</span></span></span></pre></div></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the conclusion of the type of the term to <code class="docutils literal notranslate"><span class="pre">apply</span></code> is an inductive
type isomorphic to a tuple type and <code class="docutils literal notranslate"><span class="pre">apply</span></code> looks recursively whether a
component of the tuple matches the goal, it excludes components whose
statement would result in applying an universal lemma of the form
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">A,</span> <span class="pre">...</span> <span class="pre">-&gt;</span> <span class="pre">A</span></code>. Excluding this kind of lemma can be avoided by
setting the following option:</p>
</div>
<dl class="coq flag">
<dt id="coq:flag.universal-lemma-under-conjunction">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Universal</span> <span>Lemma</span> <span>Under</span> <span>Conjunction</span></span></code><a class="headerlink" href="#coq:flag.universal-lemma-under-conjunction" title="Permalink to this definition">¶</a></dt>
<dd><p>This option, which preserves compatibility with versions of Coq prior to
8.4 is also available for <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">in</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> (see <a class="reference internal" href="#coq:tacn.apply-in" title="apply ... in"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span> <span class="pre">...</span> <span class="pre">in</span></code></a>).</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.apply-in">
<code class="sig-name descname"><span class="notation"><span>apply</span> <span class="hole">term</span> <span>in</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacn.apply-in" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. The argument <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> is a term
well-formed in the local context and the argument <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is an
hypothesis of the context.
The tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">in</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> tries to match the conclusion of the
type of <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> against a non-dependent premise of the type
of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>, trying them from right to left. If it succeeds, the
statement of hypothesis <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is replaced by the conclusion of
the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>. The tactic also returns as many subgoals as the
number of other non-dependent premises in the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> and of
the non-dependent premises of the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>. If the conclusion
of the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> does not match the goal <em>and</em> the conclusion
is an inductive type isomorphic to a tuple type, then
the tuple is (recursively) decomposed and the first component of the tuple
of which a non-dependent premise matches the conclusion of the type of
<code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>. Tuples are decomposed in a width-first left-to-right order
(for instance if the type of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H1</span></span></code> is <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">&lt;-&gt;</span></span> <span class="name"><span class="pre">B</span></span></code> and the type of
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H2</span></span></code> is <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> then <code class="code highlight coq docutils literal notranslate"><span class="name builtin"><span class="pre">apply</span></span> <span class="name"><span class="pre">H1</span></span> <span class="keyword reserved"><span class="pre">in</span></span> <span class="name"><span class="pre">H2</span></span></code> transforms the type of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H2</span></span></code>
into <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code>). The tactic <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> relies on first-order pattern matching
with dependent types.</p>
<dl class="coq exn">
<dt id="coq:exn.statement-without-assumptions">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Statement</span> <span>without</span> <span>assumptions.</span></span></code><a class="headerlink" href="#coq:exn.statement-without-assumptions" title="Permalink to this definition">¶</a></dt>
<dd><p>This happens if the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> has no non-dependent premise.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.unable-to-apply">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Unable</span> <span>to</span> <span>apply.</span></span></code><a class="headerlink" href="#coq:exn.unable-to-apply" title="Permalink to this definition">¶</a></dt>
<dd><p>This happens if the conclusion of <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> does not match any of
the non-dependent premises of the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>apply</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>in</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This applies each <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> in sequence in <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>apply</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>in</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This does the same but uses the bindings in each <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">)</span></span></span></code> to
instantiate the parameters of the corresponding type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>
(see <a class="reference internal" href="#bindingslist"><span class="std std-ref">bindings list</span></a>).</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>eapply</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>in</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This works as <a class="reference internal" href="#coq:tacn.apply-in" title="apply ... in"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span> <span class="pre">...</span> <span class="pre">in</span></code></a> but turns unresolved bindings into
existential variables, if any, instead of failing.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.apply-in-as">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>apply</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>in</span> <span class="hole">ident</span> <span>as</span> <span class="hole">simple_intropattern</span></span></code><a class="headerlink" href="#coq:tacv.apply-in-as" title="Permalink to this definition">¶</a></dt>
<dd><p>This works as <a class="reference internal" href="#coq:tacn.apply-in" title="apply ... in"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span> <span class="pre">...</span> <span class="pre">in</span></code></a> then applies the <code class="xref std std-token docutils literal notranslate"><span class="pre">simple_intropattern</span></code>
to the hypothesis <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simple</span> <span>apply</span> <span class="hole">term</span> <span>in</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This behaves like <a class="reference internal" href="#coq:tacn.apply-in" title="apply ... in"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span> <span class="pre">...</span> <span class="pre">in</span></code></a> but it reasons modulo conversion
only on subterms that contain no variables to instantiate. For instance,
if <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">id</span></span> <span class="operator"><span class="pre">:=</span></span> <span class="keyword reserved"><span class="pre">fun</span></span> <span class="name variable"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">x</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span><span class="operator"><span class="pre">:</span></span> <span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">y</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">id</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="keyword type"><span class="pre">True</span></span></code> and
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H0</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">O</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">O</span></span></code> then <code class="code highlight coq docutils literal notranslate"><span class="name builtin"><span class="pre">simple</span> <span class="pre">apply</span></span> <span class="name"><span class="pre">H</span></span> <span class="keyword reserved"><span class="pre">in</span></span> <span class="name"><span class="pre">H0</span></span></code> does not succeed because it
would require the conversion of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">id</span></span> <span class="operator"><span class="pre">?</span></span><span class="name"><span class="pre">x</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> where <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">?</span></span><span class="name"><span class="pre">x</span></span></code> is
an existential variable to instantiate.
Tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simple</span></span> <span><span class="pre">apply</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">in</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> does not
either traverse tuples as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">in</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> does.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>simple</span></span><span class="notation-sup">?</span></span> <span>apply</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>in</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span class="hole">simple_intropattern</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>simple</span></span><span class="notation-sup">?</span></span> <span>eapply</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>in</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span class="hole">simple_intropattern</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This summarizes the different syntactic variants of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">in</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>
and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">eapply</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">in</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.constructor">
<code class="sig-name descname"><span class="notation"><span>constructor</span> <span class="hole">num</span></span></code><a class="headerlink" href="#coq:tacn.constructor" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to a goal such that its conclusion is an inductive
type (say <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code>). The argument <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code> must be less or equal to the
numbers of constructor(s) of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code>. Let <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">c</span><sub><span class="pre">i</span></sub></span></span></code> be the i-th
constructor of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code>, then <code class="code highlight coq docutils literal notranslate"><span class="name builtin"><span class="pre">constructor</span></span> <span class="name"><span class="pre">i</span></span></code> is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros;</span></span> <span><span class="pre">apply</span></span> <span><span class="pre">c</span><sub><span class="pre">i</span></sub></span></span></code>.</p>
<dl class="coq exn">
<dt id="coq:exn.not-an-inductive-product">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>an</span> <span>inductive</span> <span>product.</span></span></code><a class="headerlink" href="#coq:exn.not-an-inductive-product" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.not-enough-constructors">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>enough</span> <span>constructors.</span></span></code><a class="headerlink" href="#coq:exn.not-enough-constructors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>constructor</span></span></code></dt>
<dd><p>This tries <code class="code highlight coq docutils literal notranslate"><span class="name builtin"><span class="pre">constructor</span></span> <span class="literal number integer"><span class="pre">1</span></span></code> then <code class="code highlight coq docutils literal notranslate"><span class="name builtin"><span class="pre">constructor</span></span> <span class="literal number integer"><span class="pre">2</span></span></code>, ..., then
<code class="code highlight coq docutils literal notranslate"><span class="name builtin"><span class="pre">constructor</span></span> <span class="name"><span class="pre">n</span></span></code> where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of constructors of the head
of the goal.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>constructor</span> <span class="hole">num</span> <span>with</span> <span class="hole">bindings_list</span></span></code></dt>
<dd><p>Let <code class="docutils literal notranslate"><span class="pre">c</span></code> be the i-th constructor of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code>, then
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">constructor</span></span> <span><span class="pre">i</span></span> <span><span class="pre">with</span></span> <span class="hole"><span class="pre">bindings_list</span></span></span></code> is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros;</span></span> <span><span class="pre">apply</span></span> <span><span class="pre">c</span></span> <span><span class="pre">with</span></span> <span class="hole"><span class="pre">bindings_list</span></span></span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The terms in the <code class="xref std std-token docutils literal notranslate"><span class="pre">bindings_list</span></code> are checked in the context
where constructor is executed and not in the context where <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>
is executed (the introductions are not taken into account).</p>
</div>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.split">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>split</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.split" title="Permalink to this definition">¶</a></dt>
<dd><p>This applies only if <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> has a single constructor. It is then
equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">constructor</span></span> <span><span class="pre">1</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">with</span></span> <span class="hole"><span class="pre">bindings_list</span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code>. It is
typically used in the case of a conjunction <span class="math notranslate nohighlight">\(A \wedge B\)</span>.</p>
<dl class="coq tacv">
<dt id="coq:tacv.exists">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>exists</span> <span class="hole">bindings_list</span></span></code><a class="headerlink" href="#coq:tacv.exists" title="Permalink to this definition">¶</a></dt>
<dd><p>This applies only if <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> has a single constructor. It is then equivalent
to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros;</span></span> <span><span class="pre">constructor</span></span> <span><span class="pre">1</span></span> <span><span class="pre">with</span></span> <span class="hole"><span class="pre">bindings_list</span></span><span><span class="pre">.</span></span></span></code> It is typically used in
the case of an existential quantification <span class="math notranslate nohighlight">\(\exists x, P(x).\)</span></p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>exists</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">bindings_list</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>This iteratively applies <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">exists</span></span> <span class="hole"><span class="pre">bindings_list</span></span></span></code>.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.not-an-inductive-goal-with-1-constructor">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>an</span> <span>inductive</span> <span>goal</span> <span>with</span> <span>1</span> <span>constructor.</span></span></code><a class="headerlink" href="#coq:exn.not-an-inductive-goal-with-1-constructor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.left">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>left</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.left" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacv.right">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>right</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.right" title="Permalink to this definition">¶</a></dt>
<dd><p>These tactics apply only if <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> has two constructors, for
instance in the case of a disjunction <span class="math notranslate nohighlight">\(A \vee B\)</span>.
Then, they are respectively equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">constructor</span></span> <span><span class="pre">1</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">with</span></span> <span class="hole"><span class="pre">bindings_list</span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code> and
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">constructor</span></span> <span><span class="pre">2</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">with</span></span> <span class="hole"><span class="pre">bindings_list</span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code>.</p>
<dl class="coq exn">
<dt id="coq:exn.not-an-inductive-goal-with-2-constructors">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>an</span> <span>inductive</span> <span>goal</span> <span>with</span> <span>2</span> <span>constructors.</span></span></code><a class="headerlink" href="#coq:exn.not-an-inductive-goal-with-2-constructors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.econstructor">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>econstructor</span></span></code><a class="headerlink" href="#coq:tacv.econstructor" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacv.eexists">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>eexists</span></span></code><a class="headerlink" href="#coq:tacv.eexists" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacv.esplit">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>esplit</span></span></code><a class="headerlink" href="#coq:tacv.esplit" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacv.eleft">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>eleft</span></span></code><a class="headerlink" href="#coq:tacv.eleft" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacv.eright">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>eright</span></span></code><a class="headerlink" href="#coq:tacv.eright" title="Permalink to this definition">¶</a></dt>
<dd><p>These tactics and their variants behave like <a class="reference internal" href="#coq:tacn.constructor" title="constructor"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">constructor</span></code></a>,
<a class="reference internal" href="#coq:tacv.exists" title="exists"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exists</span></code></a>, <a class="reference internal" href="#coq:tacv.split" title="split"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">split</span></code></a>, <a class="reference internal" href="#coq:tacv.left" title="left"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">left</span></code></a>, <a class="reference internal" href="#coq:tacv.right" title="right"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">right</span></code></a> and their
variants but they introduce existential variables instead of failing
when the instantiation of a variable cannot be found
(cf. <a class="reference internal" href="#coq:tacv.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a> and <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>).</p>
</dd></dl>

</dd></dl>

<dl class="coq flag">
<dt id="coq:flag.debug-tactic-unification">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Debug</span> <span>Tactic</span> <span>Unification</span></span></code><a class="headerlink" href="#coq:flag.debug-tactic-unification" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables printing traces of unification steps in tactic unification.
Tactic unification is used in tactics such as <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> and <a class="reference internal" href="#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="managing-the-local-context">
<span id="managingthelocalcontext"></span><h2>Managing the local context<a class="headerlink" href="#managing-the-local-context" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt id="coq:tacn.intro">
<code class="sig-name descname"><span class="notation"><span>intro</span></span></code><a class="headerlink" href="#coq:tacn.intro" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to a goal that is either a product or starts with a
let-binder. If the goal is a product, the tactic implements the &quot;Lam&quot; rule
given in <a class="reference internal" href="../language/cic.html#typing-rules"><span class="std std-ref">Typing rules</span></a> <a class="footnote-reference brackets" href="#id14" id="id3">1</a>. If the goal starts with a let-binder,
then the tactic implements a mix of the &quot;Let&quot; and &quot;Conv&quot;.</p>
<p>If the current goal is a dependent product <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">U</span></span></code>
(resp <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">let</span></span> <span class="name variable"><span class="pre">x</span></span><span class="operator"><span class="pre">:=</span></span><span class="name"><span class="pre">t</span></span> <span class="keyword reserved"><span class="pre">in</span></span> <span class="name"><span class="pre">U</span></span></code>) then <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> puts <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span></code> (resp <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:=</span></span><span class="name"><span class="pre">t</span></span></code>)
in the local context. The new subgoal is <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span></code>.</p>
<p>If the goal is a non-dependent product <span class="math notranslate nohighlight">\(T \rightarrow U\)</span>, then it
puts in the local context either <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">Hn</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span></code> (if <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> is of type <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Set</span></span></code>
or <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>) or <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">Xn</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span></code> (if the type of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> is <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code>).
The optional index <code class="docutils literal notranslate"><span class="pre">n</span></code> is such that <code class="docutils literal notranslate"><span class="pre">Hn</span></code> or <code class="docutils literal notranslate"><span class="pre">Xn</span></code> is a fresh
identifier. In both cases, the new subgoal is <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span></code>.</p>
<p>If the goal is an existential variable, <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> forces the resolution
of the existential variable into a dependent product <span class="math notranslate nohighlight">\(\forall\)</span> <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:?</span></span><span class="name"><span class="pre">X</span></span><span class="operator"><span class="pre">,</span></span> <span class="operator"><span class="pre">?</span></span><span class="name"><span class="pre">Y</span></span></code>,
puts <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:?</span></span><span class="name"><span class="pre">X</span></span></code> in the local context and leaves <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">?</span></span><span class="name"><span class="pre">Y</span></span></code> as a new subgoal
allowed to depend on <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code>.</p>
<p>The tactic <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> applies the tactic <a class="reference internal" href="#coq:tacn.hnf" title="hnf"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">hnf</span></code></a>
until <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> can be applied or the goal is not head-reducible.</p>
<dl class="coq exn">
<dt id="coq:exn.no-product-even-after-head-reduction">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>product</span> <span>even</span> <span>after</span> <span>head-reduction.</span></span></code><a class="headerlink" href="#coq:exn.no-product-even-after-head-reduction" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>intro</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This applies <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> but forces <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> to be the name of
the introduced hypothesis.</p>
<dl class="coq exn">
<dt id="coq:exn.ident-is-already-used">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">ident</span> <span>is</span> <span>already</span> <span>used.</span></span></code><a class="headerlink" href="#coq:exn.ident-is-already-used" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a name used by intro hides the base name of a global constant then
the latter can still be referred to by a qualified name
(see <a class="reference internal" href="../language/gallina-extensions.html#qualified-names"><span class="std std-ref">Qualified names</span></a>).</p>
</div>
<dl class="coq tacv">
<dt id="coq:tacv.intros">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>intros</span></span></code><a class="headerlink" href="#coq:tacv.intros" title="Permalink to this definition">¶</a></dt>
<dd><p>This repeats <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> until it meets the head-constant. It never
reduces head-constants and it never fails.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>intros</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span><span>.</span></span></code></dt>
<dd><p>This is equivalent to the composed tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span> <span class="hole"><span class="pre">ident</span></span><span><span class="pre">;</span></span> <span><span class="pre">...</span></span> <span><span class="pre">;</span></span> <span><span class="pre">intro</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>intros</span> <span>until</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This repeats intro until it meets a premise of the goal having the
form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">)</span></span></span></code> and discharges the variable
named <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> of the current goal.</p>
<dl class="coq exn">
<dt id="coq:exn.no-such-hypothesis-in-current-goal">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis</span> <span>in</span> <span>current</span> <span>goal.</span></span></code><a class="headerlink" href="#coq:exn.no-such-hypothesis-in-current-goal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>intros</span> <span>until</span> <span class="hole">num</span></span></code></dt>
<dd><p>This repeats <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> until the <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code>-th non-dependent
product.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>On the subgoal <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">x</span></span> <span class="name variable"><span class="pre">y</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">x</span></span></code> the
tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span><span class="pre">1</span></span></span></code> is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">x</span></span> <span><span class="pre">y</span></span> <span><span class="pre">H</span></span></span></code>,
as <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">x</span></span></code> is the first non-dependent product.</p>
<p>On the subgoal <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">x</span></span> <span class="name variable"><span class="pre">y</span></span> <span class="name variable"><span class="pre">z</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">x</span></span></code> the
tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span><span class="pre">1</span></span></span></code> is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">x</span></span> <span><span class="pre">y</span></span> <span><span class="pre">z</span></span></span></code>
as the product on <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">z</span></span></code> can be rewritten as a non-dependent
product: <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">x</span></span> <span class="name variable"><span class="pre">y</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">nat</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">x</span></span></code>.</p>
</div>
<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis</span> <span>in</span> <span>current</span> <span>goal.</span></span></code></dt>
<dd><p>This happens when <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code> is 0 or is greater than the number of
non-dependent products of the goal.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>intro</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident<sub>1</sub></span></span><span class="notation-sup">?</span></span> <span>after</span> <span class="hole">ident<sub>2</sub></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>intro</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident<sub>1</sub></span></span><span class="notation-sup">?</span></span> <span>before</span> <span class="hole">ident<sub>2</sub></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>intro</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident<sub>1</sub></span></span><span class="notation-sup">?</span></span> <span>at</span> <span>top</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>intro</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident<sub>1</sub></span></span><span class="notation-sup">?</span></span> <span>at</span> <span>bottom</span></span></code></dt>
<dd><p>These tactics apply <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code> and move the freshly
introduced hypothesis respectively after the hypothesis <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></span></code>,
before the hypothesis <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></span></code>, at the top of the local context,
or at the bottom of the local context. All hypotheses on which the new
hypothesis depends are moved too so as to respect the order of
dependencies between hypotheses. It is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code>
followed by the appropriate call to <a class="reference internal" href="#coq:tacn.move-after" title="move ... after ..."><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">move</span> <span class="pre">...</span> <span class="pre">after</span> <span class="pre">...</span></code></a>,
<a class="reference internal" href="#coq:tacv.move-before" title="move ... before ..."><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">move</span> <span class="pre">...</span> <span class="pre">before</span> <span class="pre">...</span></code></a>, <a class="reference internal" href="#coq:tacv.move-at-top" title="move ... at top"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">move</span> <span class="pre">...</span> <span class="pre">at</span> <span class="pre">top</span></code></a>,
or <a class="reference internal" href="#coq:tacv.move-at-bottom" title="move ... at bottom"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">move</span> <span class="pre">...</span> <span class="pre">at</span> <span class="pre">bottom</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span> <span><span class="pre">at</span></span> <span><span class="pre">bottom</span></span></span></code> is a synonym for <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span></span></code> with no argument.</p>
</div>
<dl class="coq exn">
<dt id="coq:exn.no-such-hypothesis-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis:</span> <span class="hole">ident</span><span>.</span></span></code><a class="headerlink" href="#coq:exn.no-such-hypothesis-ident" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.intros">
<code class="sig-name descname"><span class="notation"><span>intros</span> <span class="hole">intropattern_list</span></span></code><a class="headerlink" href="#coq:tacn.intros" title="Permalink to this definition">¶</a></dt>
<dd><p>Introduces one or more variables or hypotheses from the goal by matching the
intro patterns.  See the description in <a class="reference internal" href="#intropatterns"><span class="std std-ref">Intro patterns</span></a>.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.eintros">
<code class="sig-name descname"><span class="notation"><span>eintros</span> <span class="hole">intropattern_list</span></span></code><a class="headerlink" href="#coq:tacn.eintros" title="Permalink to this definition">¶</a></dt>
<dd><p>Works just like <a class="reference internal" href="#coq:tacn.intros" title="intros ..."><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span> <span class="pre">...</span></code></a> except that it creates existential variables
for any unresolved variables rather than failing.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.clear">
<code class="sig-name descname"><span class="notation"><span>clear</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacn.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic erases the hypothesis named <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> in the local context of
the current goal. As a consequence, <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is no more displayed and no
more usable in the proof development.</p>
<dl class="coq exn">
<dt id="coq:exn.no-such-hypothesis">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis.</span></span></code><a class="headerlink" href="#coq:exn.no-such-hypothesis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.ident-is-used-in-the-conclusion">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">ident</span> <span>is</span> <span>used</span> <span>in</span> <span>the</span> <span>conclusion.</span></span></code><a class="headerlink" href="#coq:exn.ident-is-used-in-the-conclusion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.ident-is-used-in-the-hypothesis-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">ident</span> <span>is</span> <span>used</span> <span>in</span> <span>the</span> <span>hypothesis</span> <span class="hole">ident</span><span>.</span></span></code><a class="headerlink" href="#coq:exn.ident-is-used-in-the-hypothesis-ident" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>clear</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">clear</span></span> <span class="hole"><span class="pre">ident</span></span><span><span class="pre">.</span></span> <span><span class="pre">...</span></span> <span><span class="pre">clear</span></span> <span class="hole"><span class="pre">ident</span></span><span><span class="pre">.</span></span></span></code></p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>clear</span> <span>-</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This variant clears all the hypotheses except the ones depending in the
hypotheses named <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> and in the goal.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>clear</span></span></code></dt>
<dd><p>This variants clears all the hypotheses except the ones the goal depends on.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>clear</span> <span>dependent</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This clears the hypothesis <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> and all the hypotheses that
depend on it.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.clearbody">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>clearbody</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacv.clearbody" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic expects <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> to be local definitions and clears
their respective bodies.
In other words, it turns the given definitions into assumptions.</p>
<dl class="coq exn">
<dt id="coq:exn.ident-is-not-a-local-definition">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">ident</span> <span>is</span> <span>not</span> <span>a</span> <span>local</span> <span>definition.</span></span></code><a class="headerlink" href="#coq:exn.ident-is-not-a-local-definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.revert">
<code class="sig-name descname"><span class="notation"><span>revert</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn.revert" title="Permalink to this definition">¶</a></dt>
<dd><p>This applies to any goal with variables <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>. It moves the hypotheses
(possibly defined) to the goal, if this respects dependencies. This tactic is
the inverse of <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a>.</p>
<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis.</span></span></code></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">ident<sub>1</sub></span> <span>is</span> <span>used</span> <span>in</span> <span>the</span> <span>hypothesis</span> <span class="hole">ident<sub>2</sub></span><span>.</span></span></code></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.revert-dependent">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>revert</span> <span>dependent</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacv.revert-dependent" title="Permalink to this definition">¶</a></dt>
<dd><p>This moves to the goal the hypothesis <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> and all the
hypotheses that depend on it.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.move-after">
<code class="sig-name descname"><span class="notation"><span>move</span> <span class="hole">ident<sub>1</sub></span> <span>after</span> <span class="hole">ident<sub>2</sub></span></span></code><a class="headerlink" href="#coq:tacn.move-after" title="Permalink to this definition">¶</a></dt>
<dd><p>This moves the hypothesis named <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></span></code> in the local context after
the hypothesis named <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></span></code>, where “after” is in reference to the
direction of the move. The proof term is not changed.</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></span></code> comes before <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></span></code> in the order of dependencies,
then all the hypotheses between <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></span></code> that
(possibly indirectly) depend on <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></span></code> are moved too, and all of
them are thus moved after <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></span></code> in the order of dependencies.</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></span></code> comes after <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></span></code> in the order of dependencies,
then all the hypotheses between <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></span></code> that
(possibly indirectly) occur in the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></span></code> are moved too,
and all of them are thus moved before <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></span></code> in the order of
dependencies.</p>
<dl class="coq tacv">
<dt id="coq:tacv.move-before">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>move</span> <span class="hole">ident<sub>1</sub></span> <span>before</span> <span class="hole">ident<sub>2</sub></span></span></code><a class="headerlink" href="#coq:tacv.move-before" title="Permalink to this definition">¶</a></dt>
<dd><p>This moves <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></span></code> towards and just before the hypothesis
named <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></span></code>.  As for <a class="reference internal" href="#coq:tacn.move-after" title="move ... after ..."><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">move</span> <span class="pre">...</span> <span class="pre">after</span> <span class="pre">...</span></code></a>, dependencies
over <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></span></code> (when <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></span></code> comes before <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></span></code> in
the order of dependencies) or in the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></span></code>
(when <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></span></code> comes after <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></span></code> in the order of
dependencies) are moved too.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.move-at-top">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>move</span> <span class="hole">ident</span> <span>at</span> <span>top</span></span></code><a class="headerlink" href="#coq:tacv.move-at-top" title="Permalink to this definition">¶</a></dt>
<dd><p>This moves <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> at the top of the local context (at the beginning
of the context).</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.move-at-bottom">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>move</span> <span class="hole">ident</span> <span>at</span> <span>bottom</span></span></code><a class="headerlink" href="#coq:tacv.move-at-bottom" title="Permalink to this definition">¶</a></dt>
<dd><p>This moves <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> at the bottom of the local context (at the end of
the context).</p>
</dd></dl>

<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis.</span></span></code></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.cannot-move-ident-after-ident-it-occurs-in-the-type-of-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>move</span> <span class="hole">ident<sub>1</sub></span> <span>after</span> <span class="hole">ident<sub>2</sub></span><span>:</span> <span>it</span> <span>occurs</span> <span>in</span> <span>the</span> <span>type</span> <span>of</span> <span class="hole">ident<sub>2</sub></span><span>.</span></span></code><a class="headerlink" href="#coq:exn.cannot-move-ident-after-ident-it-occurs-in-the-type-of-ident" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.cannot-move-ident-after-ident-it-depends-on-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>move</span> <span class="hole">ident<sub>1</sub></span> <span>after</span> <span class="hole">ident<sub>2</sub></span><span>:</span> <span>it</span> <span>depends</span> <span>on</span> <span class="hole">ident<sub>2</sub></span><span>.</span></span></code><a class="headerlink" href="#coq:exn.cannot-move-ident-after-ident-it-depends-on-ident" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk29" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk29"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">x</span> :nat, x = <span class="mi">0</span> -&gt; <span class="kr">forall</span> <span class="nv">z</span> <span class="nv">y</span>:nat, y=y-&gt; <span class="mi">0</span>=x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : nat,
x = <span class="mi">0</span> -&gt; nat -&gt; <span class="kr">forall</span> <span class="nv">y</span> : nat, y = y -&gt; <span class="mi">0</span> = x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk2a" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk2a"><span class="highlight"><span class="nb">intros</span> x H z y H0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk2b" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk2b"><span class="highlight"><span class="nb">move</span> x <span class="nb">after</span> H0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">z, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk2c" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk2c"><span class="highlight"><span class="kn">Undo</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk2d" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk2d"><span class="highlight"><span class="nb">move</span> x <span class="nb">before</span> H0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">z, y, x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk2e"><span class="highlight"><span class="kn">Undo</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk2f" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk2f"><span class="highlight"><span class="nb">move</span> H0 <span class="nb">after</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk30" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk30"><span class="highlight"><span class="kn">Undo</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk31" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk31"><span class="highlight"><span class="nb">move</span> H0 <span class="nb">before</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = x</span></div></blockquote></div></div></small></span></pre></div></div>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.rename">
<code class="sig-name descname"><span class="notation"><span>rename</span> <span class="hole">ident<sub>1</sub></span> <span>into</span> <span class="hole">ident<sub>2</sub></span></span></code><a class="headerlink" href="#coq:tacn.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>This renames hypothesis <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></span></code> into <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></span></code> in the current
context. The name of the hypothesis in the proof-term, however, is left
unchanged.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>rename</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident<sub>i</sub></span> <span>into</span> <span class="hole">ident<sub>j</sub></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>This renames the variables <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">i</span></sub></span></span></code> into <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">j</span></sub></span></span></code> in parallel.
In particular, the target identifiers may contain identifiers that exist in
the source context, as long as the latter are also renamed by the same
tactic.</p>
</dd></dl>

<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis.</span></span></code></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">ident</span> <span>is</span> <span>already</span> <span>used.</span></span></code></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.set">
<code class="sig-name descname"><span class="notation"><span>set</span> <span>(</span><span class="hole">ident</span> <span>:=</span> <span class="hole">term</span><span>)</span></span></code><a class="headerlink" href="#coq:tacn.set" title="Permalink to this definition">¶</a></dt>
<dd><p>This replaces <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> by <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> in the conclusion of the
current goal and adds the new definition <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span class="hole"><span class="pre">term</span></span></span></code> to the
local context.</p>
<p>If <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> has holes (i.e. subexpressions of the form “<code class="docutils literal notranslate"><span class="pre">_</span></code>”), the
tactic first checks that all subterms matching the pattern are compatible
before doing the replacement using the leftmost subterm matching the
pattern.</p>
<dl class="coq exn">
<dt id="coq:exn.the-variable-ident-is-already-defined">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>The</span> <span>variable</span> <span class="hole">ident</span> <span>is</span> <span>already</span> <span>defined.</span></span></code><a class="headerlink" href="#coq:exn.the-variable-ident-is-already-defined" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>set</span> <span>(</span><span class="hole">ident</span> <span>:=</span> <span class="hole">term</span><span>)</span> <span>in</span> <span class="hole">goal_occurrences</span></span></code></dt>
<dd><p>This notation allows specifying which occurrences of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> have
to be substituted in the context. The <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <span class="hole"><span class="pre">goal_occurrences</span></span></span></code> clause
is an occurrence clause whose syntax and behavior are described in
<a class="reference internal" href="#occurrencessets"><span class="std std-ref">goal occurrences</span></a>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>set</span> <span>(</span><span class="hole">ident</span> <span class="hole">binders</span> <span>:=</span> <span class="hole">term</span><span>)</span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <span class="hole">goal_occurrences</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">set</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span><span class="pre">fun</span></span> <span class="hole"><span class="pre">binders</span></span> <span><span class="pre">=&gt;</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">)</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">in</span></span> <span class="hole"><span class="pre">goal_occurrences</span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>set</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <span class="hole">goal_occurrences</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">set</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">)</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">in</span></span> <span class="hole"><span class="pre">goal_occurrences</span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code>
but <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is generated by Coq.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.eset">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>eset</span> <span>(</span><span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="hole">term</span><span>)</span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <span class="hole">goal_occurrences</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.eset" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacv.">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>eset</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <span class="hole">goal_occurrences</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv." title="Permalink to this definition">¶</a></dt>
<dd><p>While the different variants of <a class="reference internal" href="#coq:tacn.set" title="set"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">set</span></code></a> expect that no existential
variables are generated by the tactic, <a class="reference internal" href="#coq:tacv.eset" title="eset"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eset</span></code></a> removes this
constraint. In practice, this is relevant only when <a class="reference internal" href="#coq:tacv.eset" title="eset"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eset</span></code></a> is
used as a synonym of <a class="reference internal" href="#coq:tacv.epose" title="epose"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">epose</span></code></a>, i.e. when the <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> does
not occur in the goal.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.remember">
<code class="sig-name descname"><span class="notation"><span>remember</span> <span class="hole">term</span> <span>as</span> <span class="hole">ident<sub>1</sub></span> <span class="repeat-wrapper"><span class="repeat"><span>eqn:</span><span class="hole">naming_intropattern</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.remember" title="Permalink to this definition">¶</a></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">set</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">)</span></span> <span><span class="pre">in</span></span> <span><span class="pre">*</span></span></span></code>, using a logical
(Leibniz’s) equality instead of a local definition.
Use <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">naming_intropattern</span></span></span></code> to name or split up the new equation.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>remember</span> <span class="hole">term</span> <span>as</span> <span class="hole">ident<sub>1</sub></span> <span class="repeat-wrapper"><span class="repeat"><span>eqn:</span><span class="hole">naming_intropattern</span></span><span class="notation-sup">?</span></span> <span>in</span> <span class="hole">goal_occurrences</span></span></code></dt>
<dd><p>This is a more general form of <a class="reference internal" href="#coq:tacn.remember" title="remember"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">remember</span></code></a> that remembers the
occurrences of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> specified by an occurrence set.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.eremember">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>eremember</span> <span class="hole">term</span> <span>as</span> <span class="hole">ident<sub>1</sub></span> <span class="repeat-wrapper"><span class="repeat"><span>eqn:</span><span class="hole">naming_intropattern</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <span class="hole">goal_occurrences</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.eremember" title="Permalink to this definition">¶</a></dt>
<dd><p>While the different variants of <a class="reference internal" href="#coq:tacn.remember" title="remember"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">remember</span></code></a> expect that no
existential variables are generated by the tactic, <a class="reference internal" href="#coq:tacv.eremember" title="eremember"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eremember</span></code></a>
removes this constraint.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.pose">
<code class="sig-name descname"><span class="notation"><span>pose</span> <span>(</span><span class="hole">ident</span> <span>:=</span> <span class="hole">term</span><span>)</span></span></code><a class="headerlink" href="#coq:tacn.pose" title="Permalink to this definition">¶</a></dt>
<dd><p>This adds the local definition <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span class="hole"><span class="pre">term</span></span></span></code> to the current context
without performing any replacement in the goal or in the hypotheses. It is
equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">set</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">)</span></span> <span><span class="pre">in</span></span> <span class="pre">|</span><span><span class="pre">-</span></span></span></code>.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>pose</span> <span>(</span><span class="hole">ident</span> <span class="hole">binders</span> <span>:=</span> <span class="hole">term</span><span>)</span></span></code></dt>
<dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pose</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span><span class="pre">fun</span></span> <span class="hole"><span class="pre">binders</span></span> <span><span class="pre">=&gt;</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">)</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>pose</span> <span class="hole">term</span></span></code></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pose</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">)</span></span></span></code> but <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is
generated by Coq.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.epose">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>epose</span> <span>(</span><span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="hole">term</span><span>)</span></span></code><a class="headerlink" href="#coq:tacv.epose" title="Permalink to this definition">¶</a></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>epose</span> <span class="hole">term</span></span></code></dt>
<dd><p>While the different variants of <a class="reference internal" href="#coq:tacn.pose" title="pose"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span></code></a> expect that no
existential variables are generated by the tactic, <a class="reference internal" href="#coq:tacv.epose" title="epose"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">epose</span></code></a>
removes this constraint.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.decompose">
<code class="sig-name descname"><span class="notation"><span>decompose</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span><span>]</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.decompose" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic recursively decomposes a complex proposition in order to
obtain atomic ones.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk32" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk32"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>:<span class="kt">Prop</span>, A /\ B /\ C \/ B /\ C \/ C /\ A -&gt; C.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Prop</span>,
A /\ B /\ C \/ B /\ C \/ C /\ A -&gt; C</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk33" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk33"><span class="highlight"><span class="nb">intros</span> A B C H; <span class="nb">decompose</span> [<span class="kn">and</span> or] H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A /\ B /\ C \/ B /\ C \/ C /\ A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">C</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">C</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk34" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A /\ B /\ C \/ B /\ C \/ C /\ A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">C</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk34"><hr></label><div class="goal-conclusion"><span class="highlight">C</span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk35" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A /\ B /\ C \/ B /\ C \/ C /\ A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">C</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk35"><hr></label><div class="goal-conclusion"><span class="highlight">C</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kp">all</span>: <span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#coq:tacn.decompose" title="decompose"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">decompose</span></code></a> does not work on right-hand sides of implications or
products.</p>
</div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>decompose</span> <span>sum</span> <span class="hole">term</span></span></code></dt>
<dd><p>This decomposes sum types (like <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span></code>).</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>decompose</span> <span>record</span> <span class="hole">term</span></span></code></dt>
<dd><p>This decomposes record types (inductive types with one constructor,
like <code class="code highlight coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">and</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">exists</span></span></code> and those defined with the <a class="reference internal" href="../language/gallina-extensions.html#coq:cmd.record" title="Record"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Record</span></code></a>
command.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="controlling-the-proof-flow">
<span id="controllingtheproofflow"></span><h2>Controlling the proof flow<a class="headerlink" href="#controlling-the-proof-flow" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt id="coq:tacn.assert">
<code class="sig-name descname"><span class="notation"><span>assert</span> <span>(</span><span class="hole">ident</span> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a><span>)</span></span></code><a class="headerlink" href="#coq:tacn.assert" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <span><span class="pre">(H</span></span> <span><span class="pre">:</span></span> <span><span class="pre">U)</span></span></span></code> adds a new hypothesis
of name <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">H</span></span></span></code> asserting <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span></code> to the current goal and opens a new subgoal
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span></code> <a class="footnote-reference brackets" href="#id15" id="id4">2</a>. The subgoal <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span></code> comes first in the list of subgoals remaining to
prove.</p>
<dl class="coq exn">
<dt id="coq:exn.not-a-proposition-or-a-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>a</span> <span>proposition</span> <span>or</span> <span>a</span> <span>type.</span></span></code><a class="headerlink" href="#coq:exn.not-a-proposition-or-a-type" title="Permalink to this definition">¶</a></dt>
<dd><p>Arises when the argument <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is neither of type <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>,
<code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Set</span></span></code> nor <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>assert</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a></span></code></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">)</span></span></span></code> but <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is
generated by Coq.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>assert</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>This tactic behaves like <a class="reference internal" href="#coq:tacn.assert" title="assert"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assert</span></code></a> but applies tactic to solve the
subgoals generated by assert.</p>
<dl class="coq exn">
<dt id="coq:exn.proof-is-not-complete-assert">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Proof</span> <span>is</span> <span>not</span> <span>complete.</span></span></code><a class="headerlink" href="#coq:exn.proof-is-not-complete-assert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>assert</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a> <span>as</span> <span class="hole">simple_intropattern</span></span></code></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simple</span></span><span><span class="pre">_</span></span><span><span class="pre">intropattern</span></span></span></code> is an intro pattern (see <a class="reference internal" href="#intropatterns"><span class="std std-ref">Intro patterns</span></a>),
the hypothesis is named after this introduction pattern (in particular, if
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simple</span></span><span><span class="pre">_</span></span><span><span class="pre">intropattern</span></span></span></code> is <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>, the tactic behaves like
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">)</span></span></span></code>). If <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simple</span></span><span><span class="pre">_</span></span><span><span class="pre">intropattern</span></span></span></code> is an action
introduction pattern, the tactic behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> followed by
the action done by this introduction pattern.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>assert</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a> <span>as</span> <span class="hole">simple_intropattern</span> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>This combines the two previous variants of <a class="reference internal" href="#coq:tacn.assert" title="assert"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assert</span></code></a>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>assert</span> <span>(</span><span class="hole">ident</span> <span>:=</span> <span class="hole">term</span><span>)</span></span></code></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">)</span></span> <span><span class="pre">by</span></span> <span><span class="pre">exact</span></span> <span class="hole"><span class="pre">term</span></span></span></code> where
<a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>. This is equivalent to using
<a class="reference internal" href="#coq:tacv.pose-proof" title="pose proof"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span> <span class="pre">proof</span></code></a>. If the head of term is <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>, the tactic
behaves as <a class="reference internal" href="#coq:tacv.specialize" title="specialize"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">specialize</span></code></a>.</p>
<dl class="coq exn">
<dt id="coq:exn.variable-ident-is-already-declared">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Variable</span> <span class="hole">ident</span> <span>is</span> <span>already</span> <span>declared.</span></span></code><a class="headerlink" href="#coq:exn.variable-ident-is-already-declared" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.eassert">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>eassert</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a> <span>as</span> <span class="hole">simple_intropattern</span> <span>by</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:tacv.eassert" title="Permalink to this definition">¶</a></dt>
<dd><p>While the different variants of <a class="reference internal" href="#coq:tacn.assert" title="assert"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assert</span></code></a> expect that no existential
variables are generated by the tactic, <a class="reference internal" href="#coq:tacv.eassert" title="eassert"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eassert</span></code></a> removes this constraint.
This lets you avoid specifying the asserted statement completely before starting
to prove it.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.pose-proof">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>pose</span> <span>proof</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span class="hole">simple_intropattern</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.pose-proof" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">as</span></span> <span class="hole"><span class="pre">simple_intropattern</span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span class="pre">by</span></span> <span><span class="pre">exact</span></span> <span class="hole"><span class="pre">term</span></span></span></code>
where <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>. In particular,
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pose</span></span> <span><span class="pre">proof</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">as</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">)</span></span></span></code>
and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pose</span></span> <span><span class="pre">proof</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">as</span></span> <span class="hole"><span class="pre">simple_intropattern</span></span></span></code> is the same as applying the
<code class="xref std std-token docutils literal notranslate"><span class="pre">simple_intropattern</span></code> to <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.epose-proof">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>epose</span> <span>proof</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span class="hole">simple_intropattern</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.epose-proof" title="Permalink to this definition">¶</a></dt>
<dd><p>While <a class="reference internal" href="#coq:tacv.pose-proof" title="pose proof"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span> <span class="pre">proof</span></code></a> expects that no existential variables are generated by
the tactic, <a class="reference internal" href="#coq:tacv.epose-proof" title="epose proof"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">epose</span> <span class="pre">proof</span></code></a> removes this constraint.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.enough">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>enough</span> <span>(</span><span class="hole">ident</span> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a><span>)</span></span></code><a class="headerlink" href="#coq:tacv.enough" title="Permalink to this definition">¶</a></dt>
<dd><p>This adds a new hypothesis of name <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> asserting <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> to the
goal the tactic <a class="reference internal" href="#coq:tacv.enough" title="enough"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">enough</span></code></a> is applied to. A new subgoal stating <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is
inserted after the initial goal rather than before it as <a class="reference internal" href="#coq:tacn.assert" title="assert"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assert</span></code></a> would do.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>enough</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a></span></code></dt>
<dd><p>This behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">enough</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">)</span></span></span></code> with the name <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> of
the hypothesis generated by Coq.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>enough</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a> <span>as</span> <span class="hole">simple_intropattern</span></span></code></dt>
<dd><p>This behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">enough</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> using <code class="xref std std-token docutils literal notranslate"><span class="pre">simple_intropattern</span></code> to name or
destruct the new hypothesis.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>enough</span> <span>(</span><span class="hole">ident</span> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a><span>)</span> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>enough</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span class="hole">simple_intropattern</span></span><span class="notation-sup">?</span></span> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>This behaves as above but with <code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code> expected to solve the initial goal
after the extra assumption <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is added and possibly destructed. If the
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">as</span></span> <span class="hole"><span class="pre">simple_intropattern</span></span></span></code> clause generates more than one subgoal, <code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code> is
applied to all of them.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.eenough">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>eenough</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span class="hole">simple_intropattern</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.eenough" title="Permalink to this definition">¶</a></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>eenough</span> <span>(</span><span class="hole">ident</span> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a><span>)</span> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>While the different variants of <a class="reference internal" href="#coq:tacv.enough" title="enough"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">enough</span></code></a> expect that no existential
variables are generated by the tactic, <a class="reference internal" href="#coq:tacv.eenough" title="eenough"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eenough</span></code></a> removes this constraint.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.cut">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>cut</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:tacv.cut" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. It implements the non-dependent case of
the “App” rule given in <a class="reference internal" href="../language/cic.html#typing-rules"><span class="std std-ref">Typing rules</span></a>. (This is Modus Ponens inference
rule.) <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cut</span></span> <span><span class="pre">U</span></span></span></code> transforms the current goal <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> into the two following
subgoals: <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">T</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span></code>. The subgoal <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">T</span></span></code> comes first in the
list of remaining subgoal to prove.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.specialize">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>specialize</span> <span>(</span><span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">*</span></span><span>)</span> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span class="hole">simple_intropattern</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.specialize" title="Permalink to this definition">¶</a></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>specialize</span> <span class="hole">ident</span> <span>with</span> <span class="hole">bindings_list</span> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span class="hole">simple_intropattern</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This tactic works on local hypothesis <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>. The
premises of this hypothesis (either universal quantifications or
non-dependent implications) are instantiated by concrete terms coming either
from arguments <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code> or from a <a class="reference internal" href="#bindingslist"><span class="std std-ref">bindings list</span></a>.
In the first form the application to <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code>  can be partial. The
first form is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span class="hole"><span class="pre">ident</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">*</span></span></span><span><span class="pre">)</span></span></span></code>. In the
second form, instantiation elements can also be partial. In this case the
uninstantiated arguments are inferred by unification if possible or left
quantified in the hypothesis otherwise. With the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">as</span></span></span></code> clause, the local
hypothesis <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is left unchanged and instead, the modified hypothesis
is introduced as specified by the <code class="xref std std-token docutils literal notranslate"><span class="pre">simple_intropattern</span></code>. The name <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>
can also refer to a global lemma or hypothesis. In this case, for
compatibility reasons, the behavior of <a class="reference internal" href="#coq:tacv.specialize" title="specialize"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">specialize</span></code></a> is close to that of
<a class="reference internal" href="#coq:tacn.generalize" title="generalize"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">generalize</span></code></a>: the instantiated statement becomes an additional premise of
the goal. The <code class="docutils literal notranslate"><span class="pre">as</span></code> clause is especially useful in this case to immediately
introduce the instantiated statement as a local hypothesis.</p>
<dl class="coq exn">
<dt id="coq:exn.ident-is-used-in-hypothesis-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">ident</span> <span>is</span> <span>used</span> <span>in</span> <span>hypothesis</span> <span class="hole">ident</span><span>.</span></span></code><a class="headerlink" href="#coq:exn.ident-is-used-in-hypothesis-ident" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.ident-is-used-in-conclusion">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">ident</span> <span>is</span> <span>used</span> <span>in</span> <span>conclusion.</span></span></code><a class="headerlink" href="#coq:exn.ident-is-used-in-conclusion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.generalize">
<code class="sig-name descname"><span class="notation"><span>generalize</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.generalize" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. It generalizes the conclusion with
respect to some term.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk36" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk36"><span class="highlight"><span class="kn">Show</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight"><span class="mi">1</span> subgoal

  x, y : nat
  ============================
  <span class="mi">0</span> &lt;= x + y + y</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt;= x + y + y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk37" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk37"><span class="highlight"><span class="nb">generalize</span> (x + y + y).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="mi">0</span> &lt;= n</span></div></blockquote></div></div></small></span></pre></div></div>
<p>If the goal is <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">G</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> is a subterm of type <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> in the goal,
then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">generalize</span></span> <span><span class="pre">t</span></span></span></code> replaces the goal by <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span> <span class="operator"><span class="pre">(</span></span><span class="name variable"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span><span class="operator"><span class="pre">),</span></span> <span class="name"><span class="pre">G</span></span><span class="operator"><span class="pre">′</span></span></code> where <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">G</span></span><span class="operator"><span class="pre">′</span></span></code>
is obtained from <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">G</span></span></code> by replacing all occurrences of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> by <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code>. The
name of the variable (here <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>) is chosen based on <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code>.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>generalize</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">generalize</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">;</span></span> <span><span class="pre">...</span></span> <span><span class="pre">;</span></span> <span><span class="pre">generalize</span></span> <span class="hole"><span class="pre">term</span></span></span></code>.
Note that the sequence of term <sub>i</sub> 's are processed from n to 1.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>generalize</span> <span class="hole">term</span> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">generalize</span></span> <span class="hole"><span class="pre">term</span></span></span></code> but it generalizes only over the
specified occurrences of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> (counting from left to right on the
expression printed using option <a class="reference internal" href="../language/gallina-extensions.html#coq:flag.printing-all" title="Printing All"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">All</span></code></a>).</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>generalize</span> <span class="hole">term</span> <span>as</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">generalize</span></span> <span class="hole"><span class="pre">term</span></span></span></code> but it uses <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> to name
the generalized hypothesis.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>generalize</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">+</span></span> <span>as</span> <span class="hole">ident</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>This is the most general form of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">generalize</span></span></span></code> that combines the previous
behaviors.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>generalize</span> <span>dependent</span> <span class="hole">term</span></span></code></dt>
<dd><p>This generalizes term but also <em>all</em> hypotheses that depend on <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>. It
clears the generalized hypotheses.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.evar">
<code class="sig-name descname"><span class="notation"><span>evar</span> <span>(</span><span class="hole">ident</span> <span>:</span> <span class="hole">term</span><span>)</span></span></code><a class="headerlink" href="#coq:tacn.evar" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">evar</span></span></span></code> tactic creates a new local definition named <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> with type
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> in the context. The body of this binding is a fresh existential
variable.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.instantiate">
<code class="sig-name descname"><span class="notation"><span>instantiate</span> <span>(</span><span class="hole">ident</span> <span>:=</span> <span class="hole">term</span> <span>)</span></span></code><a class="headerlink" href="#coq:tacn.instantiate" title="Permalink to this definition">¶</a></dt>
<dd><p>The instantiate tactic refines (see <a class="reference internal" href="#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a>) an existential variable
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> with the term <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>. It is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">only</span></span> <span><span class="pre">[ident]:</span></span> <span><span class="pre">refine</span></span> <span class="hole"><span class="pre">term</span></span></span></code> (preferred alternative).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To be able to refer to an existential variable by name, the user
must have given the name explicitly (see <a class="reference internal" href="../language/gallina-extensions.html#existential-variables"><span class="std std-ref">Existential variables</span></a>).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When you are referring to hypotheses which you did not name
explicitly, be aware that Coq may make a different decision on how to
name the variable in the current goal and in the context of the
existential variable. This can lead to surprising behaviors.</p>
</div>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>instantiate</span> <span>(</span><span class="hole">num</span> <span>:=</span> <span class="hole">term</span><span>)</span></span></code></dt>
<dd><p>This variant allows to refer to an existential variable which was not named
by the user. The <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code> argument is the position of the existential variable
from right to left in the goal. Because this variant is not robust to slight
changes in the goal, its use is strongly discouraged.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>instantiate</span> <span>(</span> <span class="hole">num</span> <span>:=</span> <span class="hole">term</span> <span>)</span> <span>in</span> <span class="hole">ident</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>instantiate</span> <span>(</span> <span class="hole">num</span> <span>:=</span> <span class="hole">term</span> <span>)</span> <span>in</span> <span>(</span> <span>value</span> <span>of</span> <span class="hole">ident</span> <span>)</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>instantiate</span> <span>(</span> <span class="hole">num</span> <span>:=</span> <span class="hole">term</span> <span>)</span> <span>in</span> <span>(</span> <span>type</span> <span>of</span> <span class="hole">ident</span> <span>)</span></span></code></dt>
<dd><p>These allow to refer respectively to existential variables occurring in a
hypothesis or in the body or the type of a local definition.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>instantiate</span></span></code></dt>
<dd><p>Without argument, the instantiate tactic tries to solve as many existential
variables as possible, using information gathered from other tactics in the
same tactical. This is automatically done after each complete tactic (i.e.
after a dot in proof mode), but not, for example, between each tactic when
they are sequenced by semicolons.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.admit">
<code class="sig-name descname"><span class="notation"><span>admit</span></span></code><a class="headerlink" href="#coq:tacn.admit" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic allows temporarily skipping a subgoal so as to
progress further in the rest of the proof. A proof containing admitted
goals cannot be closed with <a class="reference internal" href="proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a> but only with <a class="reference internal" href="proof-handling.html#coq:cmd.admitted" title="Admitted"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Admitted</span></code></a>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>give</span><span>_</span><span>up</span></span></code></dt>
<dd><p>Synonym of <a class="reference internal" href="#coq:tacn.admit" title="admit"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">admit</span></code></a>.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.absurd">
<code class="sig-name descname"><span class="notation"><span>absurd</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.absurd" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. The argument term is any proposition
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> of type <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>. This tactic applies False elimination, that is it
deduces the current goal from False, and generates as subgoals <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">∼</span></span><span class="name"><span class="pre">P</span></span></code> and
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code>. It is very useful in proofs by cases, where some cases are
impossible. In most cases, <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> or <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">∼</span></span><span class="name"><span class="pre">P</span></span></code> is one of the hypotheses of the
local context.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.contradiction">
<code class="sig-name descname"><span class="notation"><span>contradiction</span></span></code><a class="headerlink" href="#coq:tacn.contradiction" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. The contradiction tactic attempts to
find in the current context (after all intros) a hypothesis that is
equivalent to an empty inductive type (e.g. <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">False</span></span></code>), to the negation of
a singleton inductive type (e.g. <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">True</span></span></code> or <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">x</span></span></code>), or two contradictory
hypotheses.</p>
<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>such</span> <span>assumption.</span></span></code></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>contradiction</span> <span class="hole">ident</span></span></code></dt>
<dd><p>The proof of False is searched in the hypothesis named <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.contradict">
<code class="sig-name descname"><span class="notation"><span>contradict</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacn.contradict" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic allows manipulating negated hypothesis and goals. The name
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> should correspond to a hypothesis. With <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">contradict</span></span> <span><span class="pre">H</span></span></span></code>, the
current goal and context is transformed in the following way:</p>
<ul class="simple">
<li><p>H:¬A ⊢ B becomes ⊢ A</p></li>
<li><p>H:¬A ⊢ ¬B becomes H: B ⊢ A</p></li>
<li><p>H: A ⊢ B becomes ⊢ ¬A</p></li>
<li><p>H: A ⊢ ¬B becomes H: B ⊢ ¬A</p></li>
</ul>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.exfalso">
<code class="sig-name descname"><span class="notation"><span>exfalso</span></span></code><a class="headerlink" href="#coq:tacn.exfalso" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic implements the “ex falso quodlibet” logical principle: an
elimination of False is performed on the current goal, and the user is
then required to prove that False is indeed provable in the current
context. This tactic is a macro for <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elimtype</span></span> <span><span class="pre">False</span></span></span></code>.</p>
</dd></dl>

</div>
<div class="section" id="case-analysis-and-induction">
<span id="caseanalysisandinduction"></span><h2>Case analysis and induction<a class="headerlink" href="#case-analysis-and-induction" title="Permalink to this headline">¶</a></h2>
<p>The tactics presented in this section implement induction or case
analysis on inductive or co-inductive objects (see <a class="reference internal" href="../language/cic.html#inductive-definitions"><span class="std std-ref">Inductive Definitions</span></a>).</p>
<dl class="coq tacn">
<dt id="coq:tacn.destruct">
<code class="sig-name descname"><span class="notation"><span>destruct</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.destruct" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. The argument <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> must be of
inductive or co-inductive type and the tactic generates subgoals, one
for each possible form of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>, i.e. one for each constructor of the
inductive or co-inductive type. Unlike <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>, no induction
hypothesis is generated by <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>destruct</span> <span class="hole">ident</span></span></code></dt>
<dd><p>If <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> denotes a quantified variable of the conclusion
of the goal, then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> behaves
as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">ident</span></span><span><span class="pre">;</span></span> <span><span class="pre">destruct</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>. If <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is not
anymore dependent in the goal after application of <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>, it
is erased (to avoid erasure, use parentheses, as in <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span><span><span class="pre">)</span></span></span></code>).</p>
<p>If <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is a hypothesis of the context, and <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>
is not anymore dependent in the goal after application
of <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>, it is erased (to avoid erasure, use parentheses, as
in <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span><span><span class="pre">)</span></span></span></code>).</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>destruct</span> <span class="hole">num</span></span></code></dt>
<dd><blockquote>
<div><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <span class="hole"><span class="pre">num</span></span></span></code> behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">num</span></span></span></code>
followed by destruct applied to the last introduced hypothesis.</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For destruction of a numeral, use syntax <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">num</span></span><span><span class="pre">)</span></span></span></code> (not
very interesting anyway).</p>
</div>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>destruct</span> <span class="hole">pattern</span></span></code></dt>
<dd><p>The argument of <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a> can also be a pattern of which holes are
denoted by “_”. In this case, the tactic checks that all subterms
matching the pattern in the conclusion and the hypotheses are compatible
and performs case analysis using this subterm.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>destruct</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>This is a shortcut for <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">;</span></span> <span><span class="pre">...;</span></span> <span><span class="pre">destruct</span></span> <span class="hole"><span class="pre">term</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>destruct</span> <span class="hole">term</span> <span>as</span> <span class="hole">or_and_intropattern_loc</span></span></code></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <span class="hole"><span class="pre">term</span></span></span></code> but uses the names
in <code class="xref std std-token docutils literal notranslate"><span class="pre">or_and_intropattern_loc</span></code> to name the variables introduced in the
context. The <code class="xref std std-token docutils literal notranslate"><span class="pre">or_and_intropattern_loc</span></code> must have the
form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[p11</span></span> <span><span class="pre">...</span></span> <span><span class="pre">p1n</span></span> <span class="pre">|</span> <span><span class="pre">...</span></span> <span class="pre">|</span> <span><span class="pre">pm1</span></span> <span><span class="pre">...</span></span> <span><span class="pre">pmn</span></span> <span><span class="pre">]</span></span></span></code> with <code class="docutils literal notranslate"><span class="pre">m</span></code> being the
number of constructors of the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>. Each variable
introduced by <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a> in the context of the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th goal
gets its name from the list <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pi1</span></span> <span><span class="pre">...</span></span> <span><span class="pre">pin</span></span></span></code> in order. If there are not
enough names, <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a> invents names for the remaining variables
to introduce. More generally, the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pij</span></span></span></code> can be any introduction
pattern (see <a class="reference internal" href="#coq:tacv.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a>). This provides a concise notation for
chaining destruction of a hypothesis.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.destruct-eqn">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>destruct</span> <span class="hole">term</span> <span>eqn:</span><span class="hole">naming_intropattern</span></span></code><a class="headerlink" href="#coq:tacv.destruct-eqn" title="Permalink to this definition">¶</a></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <span class="hole"><span class="pre">term</span></span></span></code> but adds an equation
between <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> and the value that it takes in each of the
possible cases. The name of the equation is specified
by <code class="xref std std-token docutils literal notranslate"><span class="pre">naming_intropattern</span></code> (see <a class="reference internal" href="#coq:tacv.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a>),
in particular <code class="docutils literal notranslate"><span class="pre">?</span></code> can be used to let Coq generate a fresh name.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>destruct</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span></span></code></dt>
<dd><p>This behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <span class="hole"><span class="pre">term</span></span></span></code> providing explicit instances for
the dependent premises of the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.edestruct">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>edestruct</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacv.edestruct" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <span class="hole"><span class="pre">term</span></span></span></code> except that it does not
fail if the instance of a dependent premises of the type
of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> is not inferable. Instead, the unresolved instances
are left as existential variables to be inferred later, in the same way
as <a class="reference internal" href="#coq:tacv.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a> does.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>destruct</span> <span class="hole">term</span> <span>using</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This is synonym of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">using</span></span> <span class="hole"><span class="pre">term</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">with</span></span> <span class="hole"><span class="pre">bindings_list</span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>destruct</span> <span class="hole">term</span> <span>in</span> <span class="hole">goal_occurrences</span></span></code></dt>
<dd><p>This syntax is used for selecting which occurrences of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>
the case analysis has to be done on. The <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <span class="hole"><span class="pre">goal_occurrences</span></span></span></code>
clause is an occurrence clause whose syntax and behavior is described
in <a class="reference internal" href="#occurrencessets"><span class="std std-ref">occurrences sets</span></a>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>destruct</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span class="hole">or_and_intropattern_loc</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>eqn:</span><span class="hole">naming_intropattern</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>using</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <span class="hole">goal_occurrences</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>edestruct</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span class="hole">or_and_intropattern_loc</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>eqn:</span><span class="hole">naming_intropattern</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>using</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <span class="hole">goal_occurrences</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>These are the general forms of <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a> and <a class="reference internal" href="#coq:tacv.edestruct" title="edestruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">edestruct</span></code></a>.
They combine the effects of the <code class="docutils literal notranslate"><span class="pre">with</span></code>, <code class="docutils literal notranslate"><span class="pre">as</span></code>, <code class="docutils literal notranslate"><span class="pre">eqn:</span></code>, <code class="docutils literal notranslate"><span class="pre">using</span></code>,
and <code class="docutils literal notranslate"><span class="pre">in</span></code> clauses.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.case">
<code class="sig-name descname"><span class="notation"><span>case</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.case" title="Permalink to this definition">¶</a></dt>
<dd><p>The tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">case</span></span></span></code> is a more basic tactic to perform case analysis without
recursion. It behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elim</span></span> <span class="hole"><span class="pre">term</span></span></span></code> but using a case-analysis
elimination principle and not a recursive one.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>case</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span></span></code></dt>
<dd><p>Analogous to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elim</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">with</span></span> <span class="hole"><span class="pre">bindings_list</span></span></span></code> above.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.ecase">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>ecase</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.ecase" title="Permalink to this definition">¶</a></dt>
<dd><p>In case the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> has dependent premises, or dependent premises
whose values are not inferable from the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">with</span></span> <span class="hole"><span class="pre">bindings_list</span></span></span></code> clause,
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">ecase</span></span></span></code> turns them into existential variables to be resolved later on.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.simple-destruct">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simple</span> <span>destruct</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacv.simple-destruct" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">ident</span></span><span><span class="pre">;</span></span> <span><span class="pre">case</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> when <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>
is a quantified variable of the goal.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simple</span> <span>destruct</span> <span class="hole">num</span></span></code></dt>
<dd><p>This tactic behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">num</span></span><span><span class="pre">;</span></span> <span><span class="pre">case</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> where <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>
is the name given by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">num</span></span></span></code> to the <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code> -th
non-dependent premise of the goal.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>case</span><span>_</span><span>eq</span> <span class="hole">term</span></span></code></dt>
<dd><p>The tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">case</span></span><span><span class="pre">_</span></span><span><span class="pre">eq</span></span></span></code> is a variant of the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">case</span></span></span></code> tactic that allows to
perform case analysis on a term without completely forgetting its original
form. This is done by generating equalities between the original form of the
term and the outcomes of the case analysis.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.induction">
<code class="sig-name descname"><span class="notation"><span>induction</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.induction" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. The argument <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> must be of
inductive type and the tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span></span></code> generates subgoals, one for
each possible form of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>, i.e. one for each constructor of the
inductive type.</p>
<p>If the argument is dependent in either the conclusion or some
hypotheses of the goal, the argument is replaced by the appropriate
constructor form in each of the resulting subgoals and induction
hypotheses are added to the local context using names whose prefix
is <strong>IH</strong>.</p>
<p>There are particular cases:</p>
<ul>
<li><p>If term is an identifier <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> denoting a quantified variable of the
conclusion of the goal, then inductionident behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span>
</span><span class="hole"><span class="pre">ident</span></span><span><span class="pre">;</span></span> <span><span class="pre">induction</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>. If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is not anymore dependent in the
goal after application of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span></span></code>, it is erased (to avoid erasure,
use parentheses, as in <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span><span><span class="pre">)</span></span></span></code>).</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> is a <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code>, then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <span class="hole"><span class="pre">num</span></span></span></code> behaves as
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">num</span></span></span></code> followed by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span></span></code> applied to the last
introduced hypothesis.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For simple induction on a numeral, use syntax induction (num)
(not very interesting anyway).</p>
</div>
</li>
<li><p>In case term is a hypothesis <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> of the context, and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>
is not anymore dependent in the goal after application of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span></span></code>,
it is erased (to avoid erasure, use parentheses, as in
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span><span><span class="pre">)</span></span></span></code>).</p></li>
<li><p>The argument <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> can also be a pattern of which holes are denoted
by “_”. In this case, the tactic checks that all subterms matching the
pattern in the conclusion and the hypotheses are compatible and
performs induction using this subterm.</p></li>
</ul>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk38" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk38"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">induction_test</span> : <span class="kr">forall</span> <span class="nv">n</span>:nat, n = n -&gt; n &lt;= n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, n = n -&gt; n &lt;= n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk39" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk39"><span class="highlight"><span class="nb">intros</span> n H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk3a" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk3a"><span class="highlight"><span class="nb">induction</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt;= <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk3b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n = S n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = n -&gt; n &lt;= n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk3b"><hr></label><div class="goal-conclusion"><span class="highlight">S n &lt;= S n</span></div></blockquote></div></div></div></small></span></pre></div></div>
<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>an</span> <span>inductive</span> <span>product.</span></span></code></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Unable</span> <span>to</span> <span>find</span> <span>an</span> <span>instance</span> <span>for</span> <span>the</span> <span>variables</span> <span class="hole">ident</span> <span>...</span> <span class="hole">ident</span><span>.</span></span></code></dt>
<dd><p>Use in this case the variant <a class="reference internal" href="#coq:tacv.elim-with" title="elim ... with"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">elim</span> <span class="pre">...</span> <span class="pre">with</span></code></a> below.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>induction</span> <span class="hole">term</span> <span>as</span> <span class="hole">or_and_intropattern_loc</span></span></code></dt>
<dd><p>This behaves as <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> but uses the names in
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">or_and_intropattern_loc</span></span></span></code> to name the variables introduced in the
context. The <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">or_and_intropattern_loc</span></span></span></code> must typically be of the form
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[</span></span> <span><span class="pre">p</span></span></span></code> <sub>11</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code> <sub>1n</sub> <code class="docutils literal notranslate"><span class="notation"><span class="pre">|</span> <span><span class="pre">...</span></span> <span class="pre">|</span> <span><span class="pre">p</span></span></span></code><sub>m1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code><sub>mn</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">]</span></span></span></code>
with <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">m</span></span></span></code> being the number of constructors of the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>. Each
variable introduced by induction in the context of the i-th goal gets its
name from the list <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">p</span></span></span></code><sub>i1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code><sub>in</sub> in order. If there are
not enough names, induction invents names for the remaining variables to
introduce. More generally, the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">p</span></span></span></code><sub>ij</sub> can be any
disjunctive/conjunctive introduction pattern (see <a class="reference internal" href="#coq:tacn.intros" title="intros ..."><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span> <span class="pre">...</span></code></a>). For
instance, for an inductive type with  one constructor, the pattern notation
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(p</span></span></span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">,</span></span> <span><span class="pre">...</span></span> <span><span class="pre">,</span></span> <span><span class="pre">p</span></span></span></code><sub>n</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">)</span></span></span></code> can be used instead of
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[</span></span> <span><span class="pre">p</span></span></span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code><sub>n</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">]</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>induction</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span></span></code></dt>
<dd><p>This behaves like <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> providing explicit instances for the
premises of the type of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">term</span></span></span></code> (see <a class="reference internal" href="#bindingslist"><span class="std std-ref">bindings list</span></a>).</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.einduction">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>einduction</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacv.einduction" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves like <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> except that it does not fail if
some dependent premise of the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> is not inferable. Instead,
the unresolved premises are posed as existential variables to be inferred
later, in the same way as <a class="reference internal" href="#coq:tacv.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a> does.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.induction-using">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>induction</span> <span class="hole">term</span> <span>using</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacv.induction-using" title="Permalink to this definition">¶</a></dt>
<dd><p>This behaves as <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>  but using <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> as induction scheme.
It does not expect the conclusion of the type of the first <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> to be
inductive.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>induction</span> <span class="hole">term</span> <span>using</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span></span></code></dt>
<dd><p>This behaves as <a class="reference internal" href="#coq:tacv.induction-using" title="induction ... using ..."><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span> <span class="pre">...</span> <span class="pre">using</span> <span class="pre">...</span></code></a> but also providing instances
for the premises of the type of the second <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>induction</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>using</span> <span class="hole">qualid</span></span></code></dt>
<dd><p>This syntax is used for the case <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> denotes an induction principle
with complex predicates as the induction principles generated by
<code class="docutils literal notranslate"><span class="pre">Function</span></code> or <code class="docutils literal notranslate"><span class="pre">Functional</span> <span class="pre">Scheme</span></code> may be.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>induction</span> <span class="hole">term</span> <span>in</span> <span class="hole">goal_occurrences</span></span></code></dt>
<dd><p>This syntax is used for selecting which occurrences of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> the
induction has to be carried on. The <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <span class="hole"><span class="pre">goal_occurrences</span></span></span></code> clause is an
occurrence clause whose syntax and behavior is described in
<a class="reference internal" href="#occurrencessets"><span class="std std-ref">occurrences sets</span></a>. If variables or hypotheses not
mentioning <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> in their type are listed in <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">goal_occurrences</span></span></span></code>,
those are generalized as well in the statement to prove.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk3c" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk3c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">comm</span> <span class="nv">x</span> <span class="nv">y</span> : x + y = y + x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y = y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk3d" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk3d"><span class="highlight"><span class="nb">induction</span> y <span class="kr">in</span> x |-   *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + <span class="mi">0</span> = <span class="mi">0</span> + x</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk3e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHy</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : nat, x0 + y = y + x0</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk3e"><hr></label><div class="goal-conclusion"><span class="highlight">x + S y = S y + x</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk3f" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk3f"><span class="highlight"><span class="kn">Show</span> <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">subgoal <span class="mi">2</span> <span class="kr">is</span>:

  x, y : nat
  IHy : <span class="kr">forall</span> <span class="nv">x</span> : nat, x + y = y + x
  ============================
  x + S y = S y + x</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + <span class="mi">0</span> = <span class="mi">0</span> + x</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk40" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHy</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : nat, x0 + y = y + x0</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk40"><hr></label><div class="goal-conclusion"><span class="highlight">x + S y = S y + x</span></div></blockquote></div></div></div></small></span></pre></div></div>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>induction</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span> <span>as</span> <span class="hole">or_and_intropattern_loc</span> <span>using</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span> <span>in</span> <span class="hole">goal_occurrences</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>einduction</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span> <span>as</span> <span class="hole">or_and_intropattern_loc</span> <span>using</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span> <span>in</span> <span class="hole">goal_occurrences</span></span></code></dt>
<dd><p>These are the most general forms of <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> and <a class="reference internal" href="#coq:tacv.einduction" title="einduction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">einduction</span></code></a>. It combines the
effects of the with, as, using, and in clauses.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.elim">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>elim</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacv.elim" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a more basic induction tactic. Again, the type of the argument
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> must be an inductive type. Then, according to the type of the
goal, the tactic <code class="docutils literal notranslate"><span class="pre">elim</span></code> chooses the appropriate destructor and applies it
as the tactic <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> would do. For instance, if the proof context
contains <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span></code> and the current goal is <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> of type <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>, then
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elim</span></span> <span><span class="pre">n</span></span></span></code> is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <span><span class="pre">nat</span></span><span><span class="pre">_</span></span><span><span class="pre">ind</span></span> <span><span class="pre">with</span></span> <span><span class="pre">(n:=n)</span></span></span></code>. The tactic
<code class="docutils literal notranslate"><span class="pre">elim</span></code> does not modify the context of the goal, neither introduces the
induction loading into the context of hypotheses. More generally,
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elim</span></span> <span class="hole"><span class="pre">term</span></span></span></code> also works when the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> is a statement
with premises and whose conclusion is inductive. In that case the tactic
performs induction on the conclusion of the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> and leaves the
non-dependent premises of the type as subgoals. In the case of dependent
products, the tactic tries to find an instance for which the elimination
lemma applies and fails otherwise.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.elim-with">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>elim</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span></span></code><a class="headerlink" href="#coq:tacv.elim-with" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows to give explicit instances to the premises of the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>
(see <a class="reference internal" href="#bindingslist"><span class="std std-ref">bindings list</span></a>).</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.eelim">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>eelim</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacv.eelim" title="Permalink to this definition">¶</a></dt>
<dd><p>In case the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> has dependent premises, this turns them into
existential variables to be resolved later on.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>elim</span> <span class="hole">term</span> <span>using</span> <span class="hole">term</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>elim</span> <span class="hole">term</span> <span>using</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span></span></code></dt>
<dd><p>Allows the user to give explicitly an induction principle <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> that
is not the standard one for the underlying inductive type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>. The
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">bindings_list</span></span></span></code> clause allows instantiating premises of the type of
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>elim</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span> <span>using</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>eelim</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span> <span>using</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span></span></code></dt>
<dd><p>These are the most general forms of <a class="reference internal" href="#coq:tacv.elim" title="elim"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">elim</span></code></a> and <a class="reference internal" href="#coq:tacv.eelim" title="eelim"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eelim</span></code></a>. It combines the
effects of the <code class="docutils literal notranslate"><span class="pre">using</span></code> clause and of the two uses of the <code class="docutils literal notranslate"><span class="pre">with</span></code> clause.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.elimtype">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>elimtype</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:tacv.elimtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The argument <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> must be inductively defined. <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elimtype</span></span> <span><span class="pre">I</span></span></span></code> is
equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cut</span></span> <span><span class="pre">I.</span></span> <span><span class="pre">intro</span></span> <span><span class="pre">Hn;</span></span> <span><span class="pre">elim</span></span> <span><span class="pre">Hn;</span></span> <span><span class="pre">clear</span></span> <span><span class="pre">Hn.</span></span></span></code> Therefore the
hypothesis <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">Hn</span></span></code> will not appear in the context(s) of the subgoal(s).
Conversely, if <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> is a <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> of (inductive) type <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> that does
not occur in the goal, then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elim</span></span> <span><span class="pre">t</span></span></span></code> is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elimtype</span></span> <span><span class="pre">I;</span></span> <span><span class="pre">2:exact</span></span> <span><span class="pre">t.</span></span></span></code></p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.simple-induction">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simple</span> <span>induction</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacv.simple-induction" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">ident</span></span><span><span class="pre">;</span></span> <span><span class="pre">elim</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> when
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is a quantified variable of the goal.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simple</span> <span>induction</span> <span class="hole">num</span></span></code></dt>
<dd><p>This tactic behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">num</span></span><span><span class="pre">;</span></span> <span><span class="pre">elim</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> where <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>
is the name given by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">num</span></span></span></code> to the <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code>-th non-dependent
premise of the goal.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.double-induction">
<code class="sig-name descname"><span class="notation"><span>double</span> <span>induction</span> <span class="hole">ident</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacn.double-induction" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic is deprecated and should be replaced by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <span class="hole"><span class="pre">ident</span></span><span><span class="pre">;</span></span> <span><span class="pre">induction</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> (or
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <span class="hole"><span class="pre">ident</span></span> <span><span class="pre">;</span></span> <span><span class="pre">destruct</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> depending on the exact needs).</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>double</span> <span>induction</span> <span class="hole">num<sub>1</sub></span> <span class="hole">num<sub>2</sub></span></span></code></dt>
<dd><p>This tactic is deprecated and should be replaced by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <span><span class="pre">num1;</span></span> <span><span class="pre">induction</span></span> <span><span class="pre">num3</span></span></span></code> where <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">num3</span></span></span></code> is the result
of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">num2</span></span> <span><span class="pre">-</span></span> <span><span class="pre">num1</span></span></span></code></p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.dependent-induction">
<code class="sig-name descname"><span class="notation"><span>dependent</span> <span>induction</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacn.dependent-induction" title="Permalink to this definition">¶</a></dt>
<dd><p>The <em>experimental</em> tactic dependent induction performs induction-
inversion on an instantiated inductive predicate. One needs to first
require the Coq.Program.Equality module to use this tactic. The tactic
is based on the BasicElim tactic by Conor McBride
<a class="bibtex reference internal" href="../zebibliography.html#dblp-conf-types-mcbride00" id="id5">[McB00]</a> and the work of Cristina Cornes around
inversion <a class="bibtex reference internal" href="../zebibliography.html#dblp-conf-types-cornest95" id="id6">[CT95]</a>. From an instantiated
inductive predicate and a goal, it generates an equivalent goal where
the hypothesis has been generalized over its indexes which are then
constrained by equalities to be the right instances. This permits to
state lemmas without resorting to manually adding these equalities and
still get enough information in the proofs.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk41" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk41"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">lt_1_r</span> : <span class="kr">forall</span> <span class="nv">n</span>:nat, n &lt; <span class="mi">1</span> -&gt; n = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; <span class="mi">1</span> -&gt; n = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk42" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk42"><span class="highlight"><span class="nb">intros</span> n H ; <span class="nb">induction</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n = <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk43" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk43"><hr></label><div class="goal-conclusion"><span class="highlight">n = <span class="mi">0</span></span></div></blockquote></div></div></div></small></span></pre></div><p>Here we did not get any information on the indexes to help fulfill
this proof. The problem is that, when we use the <code class="docutils literal notranslate"><span class="pre">induction</span></code> tactic, we
lose information on the hypothesis instance, notably that the second
argument is 1 here. Dependent induction solves this problem by adding
the corresponding equality to the context.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Coq.Program.Equality.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk44" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk44"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">lt_1_r</span> : <span class="kr">forall</span> <span class="nv">n</span>:nat, n &lt; <span class="mi">1</span> -&gt; n = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; <span class="mi">1</span> -&gt; n = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk45" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk45"><span class="highlight"><span class="nb">intros</span> n H ; <span class="nb">dependent induction</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk46" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = <span class="mi">1</span> -&gt; n = <span class="mi">0</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk46"><hr></label><div class="goal-conclusion"><span class="highlight">n = <span class="mi">0</span></span></div></blockquote></div></div></div></small></span></pre></div><p>The subgoal is cleaned up as the tactic tries to automatically
simplify the subgoals with respect to the generated equalities. In
this enriched context, it becomes possible to solve this subgoal.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk47" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk47"><span class="highlight"><span class="bp">reflexivity</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = <span class="mi">1</span> -&gt; n = <span class="mi">0</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n = <span class="mi">0</span></span></div></blockquote></div></div></small></span></pre></div><p>Now we are in a contradictory context and the proof can be solved.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H.</span></span></span></pre></div><p>This technique works with any inductive predicate. In fact, the
<code class="docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code> tactic is just a wrapper around the <code class="docutils literal notranslate"><span class="pre">induction</span></code>
tactic. One can make its own variant by just writing a new tactic
based on the definition found in <code class="docutils literal notranslate"><span class="pre">Coq.Program.Equality</span></code>.</p>
</div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>dependent</span> <span>induction</span> <span class="hole">ident</span> <span>generalizing</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This performs dependent induction on the hypothesis <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> but first
generalizes the goal by the given variables so that they are universally
quantified in the goal. This is generally what one wants to do with the
variables that are inside some constructors in the induction hypothesis. The
other ones need not be further generalized.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.dependent-destruction">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>dependent</span> <span>destruction</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacv.dependent-destruction" title="Permalink to this definition">¶</a></dt>
<dd><p>This performs the generalization of the instance <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> but uses
<code class="docutils literal notranslate"><span class="pre">destruct</span></code> instead of induction on the generalized hypothesis. This gives
results equivalent to <code class="docutils literal notranslate"><span class="pre">inversion</span></code> or <code class="docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">inversion</span></code> if the
hypothesis is dependent.</p>
</dd></dl>

<p>See also the larger example of <a class="reference internal" href="#coq:tacn.dependent-induction" title="dependent induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code></a>
and an explanation of the underlying technique.</p>
<dl class="coq tacn">
<dt id="coq:tacn.function-induction">
<code class="sig-name descname"><span class="notation"><span>function</span> <span>induction</span> <span>(</span><span class="hole">qualid</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span></span><span>)</span></span></code><a class="headerlink" href="#coq:tacn.function-induction" title="Permalink to this definition">¶</a></dt>
<dd><p>The tactic functional induction performs case analysis and induction
following the definition of a function. It makes use of a principle
generated by <code class="docutils literal notranslate"><span class="pre">Function</span></code> (see <a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions"><span class="std std-ref">Advanced recursive functions</span></a>) or
<code class="docutils literal notranslate"><span class="pre">Functional</span> <span class="pre">Scheme</span></code> (see <a class="reference internal" href="../user-extensions/proof-schemes.html#functional-scheme"><span class="std std-ref">Generation of induction principles with Functional Scheme</span></a>).
Note that this tactic is only available after a <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">FunInd</span></code>.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> FunInd.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Functional Scheme</span> <span class="nf">minus_ind</span> := <span class="kn">Induction for</span> minus <span class="kn">Sort</span> <span class="kt">Prop</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk48" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk48"><span class="highlight"><span class="kn">Check</span> minus_ind.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">minus_ind
     : <span class="kr">forall</span> <span class="nv">P</span> : nat -&gt; nat -&gt; nat -&gt; <span class="kt">Prop</span>,
       (<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n = <span class="mi">0</span> -&gt; P <span class="mi">0</span> m n) -&gt;
       (<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">k</span> : nat,
        n = S k -&gt; m = <span class="mi">0</span> -&gt; P (S k) <span class="mi">0</span> n) -&gt;
       (<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">k</span> : nat,
        n = S k -&gt;
        <span class="kr">forall</span> <span class="nv">l</span> : nat,
        m = S l -&gt;
        P k l (k - l) -&gt; P (S k) (S l) (k - l)) -&gt;
       <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, P n m (n - m)</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk49" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk49"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">le_minus</span> (<span class="nv">n</span> <span class="nv">m</span>:nat) : n - m &lt;= n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">n - m &lt;= n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">functional induction</span> (minus n m) <span class="nb">using</span> minus_ind; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="hole"><span class="pre">qualid</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span><span><span class="pre">)</span></span></span></code> must be a correct full application
of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code>. In particular, the rules for implicit arguments are the
same as usual. For example use <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> if you want to write implicit
arguments explicitly.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Parentheses around <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> are not mandatory and can be skipped.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">functional</span></span> <span><span class="pre">induction</span></span> <span><span class="pre">(f</span></span> <span><span class="pre">x1</span></span> <span><span class="pre">x2</span></span> <span><span class="pre">x3)</span></span></span></code> is actually a wrapper for
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <span><span class="pre">x1,</span></span> <span><span class="pre">x2,</span></span> <span><span class="pre">x3,</span></span> <span><span class="pre">(f</span></span> <span><span class="pre">x1</span></span> <span><span class="pre">x2</span></span> <span><span class="pre">x3)</span></span> <span><span class="pre">using</span></span> <span class="hole"><span class="pre">qualid</span></span></span></code> followed by a cleaning
phase, where <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> is the induction principle registered for <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">f</span></span></code>
(by the <code class="docutils literal notranslate"><span class="pre">Function</span></code> (see <a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions"><span class="std std-ref">Advanced recursive functions</span></a>) or
<code class="docutils literal notranslate"><span class="pre">Functional</span> <span class="pre">Scheme</span></code> (see <a class="reference internal" href="../user-extensions/proof-schemes.html#functional-scheme"><span class="std std-ref">Generation of induction principles with Functional Scheme</span></a>)
command) corresponding to the sort of the goal. Therefore
<code class="docutils literal notranslate"><span class="pre">functional</span> <span class="pre">induction</span></code> may fail if the induction scheme <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> is not
defined. See also <a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions"><span class="std std-ref">Advanced recursive functions</span></a> for the function
terms accepted by <code class="docutils literal notranslate"><span class="pre">Function</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a difference between obtaining an induction scheme
for a function by using <code class="code highlight coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Function</span></span></code> (see <a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions"><span class="std std-ref">Advanced recursive functions</span></a>)
and by using <code class="code highlight coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Functional</span> <span class="pre">Scheme</span></span></code> after a normal definition using
<code class="code highlight coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Fixpoint</span></span></code> or <code class="code highlight coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Definition</span></span></code>. See <a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions"><span class="std std-ref">Advanced recursive functions</span></a>
for details.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions"><span class="std std-ref">Advanced recursive functions</span></a>, <a class="reference internal" href="../user-extensions/proof-schemes.html#functional-scheme"><span class="std std-ref">Generation of induction principles with Functional Scheme</span></a> and <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a></p>
</div>
<dl class="coq exn">
<dt id="coq:exn.cannot-find-induction-information-on-qualid">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>find</span> <span>induction</span> <span>information</span> <span>on</span> <span class="hole">qualid</span><span>.</span></span></code><a class="headerlink" href="#coq:exn.cannot-find-induction-information-on-qualid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.not-the-right-number-of-induction-arguments">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>the</span> <span>right</span> <span>number</span> <span>of</span> <span>induction</span> <span>arguments.</span></span></code><a class="headerlink" href="#coq:exn.not-the-right-number-of-induction-arguments" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>functional</span> <span>induction</span> <span>(</span><span class="hole">qualid</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span></span><span>)</span> <span>as</span> <span class="hole">simple_intropattern</span> <span>using</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span></span></code></dt>
<dd><p>Similarly to <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> and <a class="reference internal" href="#coq:tacv.elim" title="elim"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">elim</span></code></a>, this allows giving
explicitly the name of the introduced variables, the induction principle, and
the values of dependent premises of the elimination scheme, including
<em>predicates</em> for mutual induction when <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> is part of a mutually
recursive definition.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.discriminate">
<code class="sig-name descname"><span class="notation"><span>discriminate</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.discriminate" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic proves any goal from an assumption stating that two
structurally different <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>s of an inductive set are equal. For
example, from <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">O</span></span><span class="operator"><span class="pre">))=(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">O</span></span><span class="operator"><span class="pre">)</span></span></code> we can derive by absurdity any
proposition.</p>
<p>The argument <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> is assumed to be a proof of a statement of
conclusion <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">term</span></span></span></code> with the two terms being elements of an
inductive set. To build the proof, the tactic traverses the normal forms
<a class="footnote-reference brackets" href="#id16" id="id7">3</a> of the terms looking for a couple of subterms <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">u</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">w</span></span></code> (<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">u</span></span></code>
subterm of the normal form of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">w</span></span></code> subterm of the normal
form of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>), placed at the same positions and whose head symbols are
two different constructors. If such a couple of subterms exists, then the
proof of the current goal is completed, otherwise the tactic fails.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The syntax <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">discriminate</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> can be used to refer to a hypothesis
quantified in the goal. In this case, the quantified hypothesis whose name is
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is first introduced in the local context using
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>.</p>
</div>
<dl class="coq exn">
<dt id="coq:exn.no-primitive-equality-found">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>primitive</span> <span>equality</span> <span>found.</span></span></code><a class="headerlink" href="#coq:exn.no-primitive-equality-found" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.not-a-discriminable-equality">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>a</span> <span>discriminable</span> <span>equality.</span></span></code><a class="headerlink" href="#coq:exn.not-a-discriminable-equality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>discriminate</span> <span class="hole">num</span></span></code></dt>
<dd><p>This does the same thing as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">num</span></span></span></code> followed by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">discriminate</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> where <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is the identifier for the last
introduced hypothesis.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>discriminate</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span></span></code></dt>
<dd><p>This does the same thing as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">discriminate</span></span> <span class="hole"><span class="pre">term</span></span></span></code> but using the given
bindings to instantiate parameters or hypotheses of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.ediscriminate">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>ediscriminate</span> <span class="hole">num</span></span></code><a class="headerlink" href="#coq:tacv.ediscriminate" title="Permalink to this definition">¶</a></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>ediscriminate</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This works the same as <a class="reference internal" href="#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a> but if the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>, or the
type of the hypothesis referred to by <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code>, has uninstantiated
parameters, these parameters are left as existential variables.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>discriminate</span></span></code></dt>
<dd><p>This behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">discriminate</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> if ident is the name of an
hypothesis to which <code class="docutils literal notranslate"><span class="pre">discriminate</span></code> is applicable; if the current goal is of
the form <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span> <span><span class="pre">&lt;&gt;</span></span> <span class="hole"><span class="pre">term</span></span></span></code>, this behaves as
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span> <span class="hole"><span class="pre">ident</span></span><span><span class="pre">;</span></span> <span><span class="pre">discriminate</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>.</p>
<dl class="coq exn">
<dt id="coq:exn.no-discriminable-equalities">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>discriminable</span> <span>equalities.</span></span></code><a class="headerlink" href="#coq:exn.no-discriminable-equalities" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.injection">
<code class="sig-name descname"><span class="notation"><span>injection</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.injection" title="Permalink to this definition">¶</a></dt>
<dd><p>The injection tactic exploits the property that constructors of
inductive types are injective, i.e. that if <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span></code> is a constructor of an
inductive type and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span> <span class="name"><span class="pre">t</span></span></code><sub>1</sub> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span> <span class="name"><span class="pre">t</span></span></code><sub>2</sub> are equal then
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code><sub>1</sub> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code><sub>2</sub> are equal too.</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> is a proof of a statement of conclusion <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">term</span></span></span></code>,
then <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> applies the injectivity of constructors as deep as
possible to derive the equality of all the subterms of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> and
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> at positions where the terms start to differ. For example, from
<code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">p</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">=</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">q</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">))</span></span></code> we may derive <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">p</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">q</span></span></code> and
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">m</span></span></code>. For this tactic to work, the terms should be typed with an
inductive type and they should be neither convertible, nor having a different
head constructor. If these conditions are satisfied, the tactic derives the
equality of all the subterms at positions where they differ and adds them as
antecedents to the conclusion of the current goal.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Consider the following goal:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">list</span> : <span class="kt">Set</span> :=
| nil : list
| cons : nat -&gt; list -&gt; list.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">P</span> : list -&gt; <span class="kt">Prop</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="tactics-rst-chk4a" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk4a"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">n</span>, P nil -&gt; cons n l = cons <span class="mi">0</span> nil -&gt; P l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">l</span> : list) (<span class="nv">n</span> : nat),
P nil -&gt; cons n l = cons <span class="mi">0</span> nil -&gt; P l</span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk4b" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk4b"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P nil</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cons n l = cons <span class="mi">0</span> nil</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk4c" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk4c"><span class="highlight"><span class="nb">injection</span> H0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P nil</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cons n l = cons <span class="mi">0</span> nil</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">l = nil -&gt; n = <span class="mi">0</span> -&gt; P l</span></div></blockquote></div></div></small></span></pre></div></div>
<p>Beware that injection yields an equality in a sigma type whenever the
injected object has a dependent type <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> with its two instances in
different types <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">t</span></span></code><sub>1</sub> <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">t</span></span></code><sub>n</sub> <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">)</span></span></code> and
<code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">u</span></span></code><sub>1</sub> <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">u</span></span></code><sub>n</sub> <sub>)</sub>. If <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code><sub>1</sub> and
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">u</span></span></code><sub>1</sub> are the same and have for type an inductive type for which a decidable
equality has been declared using the command <a class="reference internal" href="../user-extensions/proof-schemes.html#coq:cmdv.scheme-equality" title="Scheme Equality"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Scheme</span> <span class="pre">Equality</span></code></a>
(see <a class="reference internal" href="../user-extensions/proof-schemes.html#proofschemes-induction-principles"><span class="std std-ref">Generation of induction principles with Scheme</span></a>),
the use of a sigma type is avoided.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If some quantified hypothesis of the goal is named <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>,
then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">injection</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> first introduces the hypothesis in the local
context using <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>.</p>
</div>
<dl class="coq exn">
<dt id="coq:exn.not-a-projectable-equality-but-a-discriminable-one">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>a</span> <span>projectable</span> <span>equality</span> <span>but</span> <span>a</span> <span>discriminable</span> <span>one.</span></span></code><a class="headerlink" href="#coq:exn.not-a-projectable-equality-but-a-discriminable-one" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.nothing-to-do-it-is-an-equality-between-convertible-terms">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Nothing</span> <span>to</span> <span>do,</span> <span>it</span> <span>is</span> <span>an</span> <span>equality</span> <span>between</span> <span>convertible</span> <span>terms.</span></span></code><a class="headerlink" href="#coq:exn.nothing-to-do-it-is-an-equality-between-convertible-terms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.not-a-primitive-equality">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>a</span> <span>primitive</span> <span>equality.</span></span></code><a class="headerlink" href="#coq:exn.not-a-primitive-equality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.nothing-to-inject">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Nothing</span> <span>to</span> <span>inject.</span></span></code><a class="headerlink" href="#coq:exn.nothing-to-inject" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>injection</span> <span class="hole">num</span></span></code></dt>
<dd><p>This does the same thing as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">num</span></span></span></code> followed by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">injection</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> where <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is the identifier for the last
introduced hypothesis.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>injection</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span></span></code></dt>
<dd><p>This does the same as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">injection</span></span> <span class="hole"><span class="pre">term</span></span></span></code> but using the given bindings to
instantiate parameters or hypotheses of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.einjection">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>einjection</span> <span class="hole">num</span></span></code><a class="headerlink" href="#coq:tacv.einjection" title="Permalink to this definition">¶</a></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>einjection</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This works the same as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">injection</span></span></span></code> but if the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>, or the
type of the hypothesis referred to by <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code>, has uninstantiated
parameters, these parameters are left as existential variables.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>injection</span></span></code></dt>
<dd><p>If the current goal is of the form <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span> <span><span class="pre">&lt;&gt;</span></span> <span class="hole"><span class="pre">term</span></span></span></code> , this behaves as
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span> <span class="hole"><span class="pre">ident</span></span><span><span class="pre">;</span></span> <span><span class="pre">injection</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>.</p>
<dl class="coq exn">
<dt id="coq:exn.goal-does-not-satisfy-the-expected-preconditions">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>goal</span> <span>does</span> <span>not</span> <span>satisfy</span> <span>the</span> <span>expected</span> <span>preconditions.</span></span></code><a class="headerlink" href="#coq:exn.goal-does-not-satisfy-the-expected-preconditions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>injection</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span> <span>as</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">simple_intropattern</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>injection</span> <span class="hole">num</span> <span>as</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">simple_intropattern</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>injection</span> <span>as</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">simple_intropattern</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>einjection</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span> <span>as</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">simple_intropattern</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>einjection</span> <span class="hole">num</span> <span>as</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">simple_intropattern</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>einjection</span> <span>as</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">simple_intropattern</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>These variants apply <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">simple_intropattern</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> after the call to
<a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> or <a class="reference internal" href="#coq:tacv.einjection" title="einjection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">einjection</span></code></a> so that all equalities generated are moved in
the context of hypotheses. The number of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">simple_intropattern</span></span></span></code> must not exceed
the number of equalities newly generated. If it is smaller, fresh
names are automatically generated to adjust the list of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">simple_intropattern</span></span></span></code>
to the number of new equalities. The original equality is erased if it
corresponds to a hypothesis.</p>
</dd></dl>

<dl class="coq flag">
<dt id="coq:flag.structural-injection">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Structural</span> <span>Injection</span></span></code><a class="headerlink" href="#coq:flag.structural-injection" title="Permalink to this definition">¶</a></dt>
<dd><p>This option ensure that <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">injection</span></span> <span class="hole"><span class="pre">term</span></span></span></code> erases the original hypothesis
and leaves the generated equalities in the context rather than putting them
as antecedents of the current goal, as if giving <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">injection</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">as</span></span></span></code>
(with an empty list of names). This option is off by default.</p>
</dd></dl>

<dl class="coq flag">
<dt id="coq:flag.keep-proof-equalities">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Keep</span> <span>Proof</span> <span>Equalities</span></span></code><a class="headerlink" href="#coq:flag.keep-proof-equalities" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> only creates new equalities between <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>s
whose type is in sort <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code> or <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Set</span></span></code>, thus implementing a special
behavior for objects that are proofs of a statement in <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>. This option
controls this behavior.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.inversion">
<code class="sig-name descname"><span class="notation"><span>inversion</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacn.inversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Let the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> in the local context be <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">I</span></span> <span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code>, where <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code>
is a (co)inductive predicate. Then, <code class="docutils literal notranslate"><span class="pre">inversion</span></code> applied to <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>
derives for each possible constructor <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span> <span class="name"><span class="pre">i</span></span></code> of <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">I</span></span> <span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code>, all the
necessary conditions that should hold for the instance <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">I</span></span> <span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code> to be
proved by <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span> <span class="name"><span class="pre">i</span></span></code>.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> does not denote a hypothesis in the local context but
refers to a hypothesis quantified in the goal, then the latter is
first introduced in the local context using <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As <code class="docutils literal notranslate"><span class="pre">inversion</span></code> proofs may be large in size, we recommend the
user to stock the lemmas whenever the same instance needs to be
inverted several times. See <a class="reference internal" href="../user-extensions/proof-schemes.html#derive-inversion"><span class="std std-ref">Generation of inversion principles with Derive Inversion</span></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Part of the behavior of the <code class="docutils literal notranslate"><span class="pre">inversion</span></code> tactic is to generate
equalities between expressions that appeared in the hypothesis that is
being processed. By default, no equalities are generated if they
relate two proofs (i.e. equalities between <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>s whose type is in sort
<code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>). This behavior can be turned off by using the
<a class="reference internal" href="#coq:flag.keep-proof-equalities" title="Keep Proof Equalities"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Keep</span> <span class="pre">Proof</span> <span class="pre">Equalities</span></code></a> setting.</p>
</div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>inversion</span> <span class="hole">num</span></span></code></dt>
<dd><p>This does the same thing as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">num</span></span></span></code> then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">inversion</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>
where <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is the identifier for the last introduced hypothesis.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.inversion-clear">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>inversion</span><span>_</span><span>clear</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacv.inversion-clear" title="Permalink to this definition">¶</a></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">inversion</span></span></span></code> and then erases <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> from the context.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>inversion</span> <span class="hole">ident</span> <span>as</span> <span class="hole">or_and_intropattern_loc</span></span></code></dt>
<dd><p>This generally behaves as inversion but using names in <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">or_and_intropattern_loc</span></span></span></code>
for naming hypotheses. The <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">or_and_intropattern_loc</span></span></span></code> must have the form
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[p</span></span></span></code><sub>11</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code><sub>1n</sub> <code class="docutils literal notranslate"><span class="notation"><span class="pre">|</span> <span><span class="pre">...</span></span> <span class="pre">|</span> <span><span class="pre">p</span></span></span></code><sub>m1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code><sub>mn</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">]</span></span></span></code>
with <code class="docutils literal notranslate"><span class="pre">m</span></code> being the number of constructors of the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>. Be
careful that the list must be of length <code class="docutils literal notranslate"><span class="pre">m</span></code> even if <code class="docutils literal notranslate"><span class="pre">inversion</span></code> discards
some cases (which is precisely one of its roles): for the discarded
cases, just use an empty list (i.e. <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">0</span></code>).The arguments of the i-th
constructor and the equalities that <code class="docutils literal notranslate"><span class="pre">inversion</span></code> introduces in the
context of the goal corresponding to the i-th constructor, if it
exists, get their names from the list <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">p</span></span></span></code><sub>i1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code><sub>in</sub> in
order. If there are not enough names, <code class="docutils literal notranslate"><span class="pre">inversion</span></code> invents names for the
remaining variables to introduce. In case an equation splits into several
equations (because <code class="docutils literal notranslate"><span class="pre">inversion</span></code> applies <code class="docutils literal notranslate"><span class="pre">injection</span></code> on the equalities it
generates), the corresponding name <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">p</span></span></span></code><sub>ij</sub> in the list must be
replaced by a sublist of the form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[p</span></span></span></code><sub>ij1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code><sub>ijq</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">]</span></span></span></code>
(or, equivalently, <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(p</span></span></span></code><sub>ij1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">,</span></span> <span><span class="pre">...,</span></span> <span><span class="pre">p</span></span></span></code><sub>ijq</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">)</span></span></span></code>) where
<code class="docutils literal notranslate"><span class="pre">q</span></code> is the number of subequalities obtained from splitting the original
equation. Here is an example. The <code class="docutils literal notranslate"><span class="pre">inversion</span> <span class="pre">...</span> <span class="pre">as</span></code> variant of
<code class="docutils literal notranslate"><span class="pre">inversion</span></code> generally behaves in a slightly more expectable way than
<code class="docutils literal notranslate"><span class="pre">inversion</span></code> (no artificial duplication of some hypotheses referring to
other hypotheses). To take benefit of these improvements, it is enough to use
<code class="docutils literal notranslate"><span class="pre">inversion</span> <span class="pre">...</span> <span class="pre">as</span> <span class="pre">[]</span></code>, letting the names being finally chosen by Coq.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">contains0</span> : list nat -&gt; <span class="kt">Prop</span> :=
| in_hd : <span class="kr">forall</span> <span class="nv">l</span>, contains0 (<span class="mi">0</span> :: l)
| in_tl : <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">b</span>, contains0 l -&gt; contains0 (b :: l).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk4d" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk4d"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">l</span>:list nat, contains0 (<span class="mi">1</span> :: l) -&gt; contains0 l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list nat, contains0 (<span class="mi">1</span> :: l) -&gt; contains0 l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk4e" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk4e"><span class="highlight"><span class="nb">intros</span> l H; <span class="nb">inversion</span> H <span class="kr">as</span> [ | l&#39; p Hl&#39; [Heqp Heql&#39;] ].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">contains0 (<span class="mi">1</span> :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">contains0 l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqp</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">p = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heql'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">l&#39; = l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">contains0 l</span></div></blockquote></div></div></small></span></pre></div></div>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>inversion</span> <span class="hole">num</span> <span>as</span> <span class="hole">or_and_intropattern_loc</span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">inversion</span></span> <span class="hole"><span class="pre">num</span></span></span></code> in the
context.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>inversion</span><span>_</span><span>clear</span> <span class="hole">ident</span> <span>as</span> <span class="hole">or_and_intropattern_loc</span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced by <code class="docutils literal notranslate"><span class="pre">inversion_clear</span></code> in the
context. Notice that hypothesis names can be provided as if <code class="docutils literal notranslate"><span class="pre">inversion</span></code>
were called, even though the <code class="docutils literal notranslate"><span class="pre">inversion_clear</span></code> will eventually erase the
hypotheses.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>inversion</span> <span class="hole">ident</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Let <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> be identifiers in the local context. This tactic behaves as
generalizing <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>, and then performing <code class="docutils literal notranslate"><span class="pre">inversion</span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>inversion</span> <span class="hole">ident</span> <span>as</span> <span class="hole">or_and_intropattern_loc</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced in the context by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">inversion</span></span> <span class="hole"><span class="pre">ident</span></span> <span><span class="pre">in</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>inversion</span><span>_</span><span>clear</span> <span class="hole">ident</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Let <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> be identifiers in the local context. This tactic behaves
as generalizing <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>, and then performing <code class="docutils literal notranslate"><span class="pre">inversion_clear</span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>inversion</span><span>_</span><span>clear</span> <span class="hole">ident</span> <span>as</span> <span class="hole">or_and_intropattern_loc</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced in the context by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">inversion</span></span><span><span class="pre">_</span></span><span><span class="pre">clear</span></span> <span class="hole"><span class="pre">ident</span></span> <span><span class="pre">in</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.dependent-inversion">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>dependent</span> <span>inversion</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacv.dependent-inversion" title="Permalink to this definition">¶</a></dt>
<dd><p>That must be used when <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> appears in the current goal. It acts like
<code class="docutils literal notranslate"><span class="pre">inversion</span></code> and then substitutes <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> for the corresponding
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">&#64;</span></span><span class="hole"><span class="pre">term</span></span></span></code> in the goal.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>dependent</span> <span>inversion</span> <span class="hole">ident</span> <span>as</span> <span class="hole">or_and_intropattern_loc</span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced in the context by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">dependent</span></span> <span><span class="pre">inversion</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>dependent</span> <span>inversion</span><span>_</span><span>clear</span> <span class="hole">ident</span></span></code></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">inversion</span></code>, except that <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is cleared from the
local context.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>dependent</span> <span>inversion</span><span>_</span><span>clear</span> <span class="hole">ident</span> <span>as</span> <span class="hole">or_and_intropattern_loc</span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced in the context by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">dependent</span></span> <span><span class="pre">inversion</span></span><span><span class="pre">_</span></span><span><span class="pre">clear</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.dependent-inversion-with">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>dependent</span> <span>inversion</span> <span class="hole">ident</span> <span>with</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacv.dependent-inversion-with" title="Permalink to this definition">¶</a></dt>
<dd><p>This variant allows you to specify the generalization of the goal. It is
useful when the system fails to generalize the goal automatically. If
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> has type <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">I</span></span> <span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> has type <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span> <span class="operator"><span class="pre">(</span></span><span class="name variable"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span><span class="operator"><span class="pre">),</span></span> <span class="name"><span class="pre">s</span></span></code>,
then <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> must be of type <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword reserved"><span class="pre">forall</span></span> <span class="operator"><span class="pre">(</span></span><span class="name variable"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span><span class="operator"><span class="pre">),</span></span> <span class="name"><span class="pre">I</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">s'</span></span></code> where
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">s'</span></span></code> is the type of the goal.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>dependent</span> <span>inversion</span> <span class="hole">ident</span> <span>as</span> <span class="hole">or_and_intropattern_loc</span> <span>with</span> <span class="hole">term</span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced in the context by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">dependent</span></span> <span><span class="pre">inversion</span></span> <span class="hole"><span class="pre">ident</span></span> <span><span class="pre">with</span></span> <span class="hole"><span class="pre">term</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>dependent</span> <span>inversion</span><span>_</span><span>clear</span> <span class="hole">ident</span> <span>with</span> <span class="hole">term</span></span></code></dt>
<dd><p>Like <a class="reference internal" href="#coq:tacv.dependent-inversion-with" title="dependent inversion ... with ..."><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">inversion</span> <span class="pre">...</span> <span class="pre">with</span> <span class="pre">...</span></code></a> with but clears <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> from the
local context.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>dependent</span> <span>inversion</span><span>_</span><span>clear</span> <span class="hole">ident</span> <span>as</span> <span class="hole">or_and_intropattern_loc</span> <span>with</span> <span class="hole">term</span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced in the context by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">dependent</span></span> <span><span class="pre">inversion</span></span><span><span class="pre">_</span></span><span><span class="pre">clear</span></span> <span class="hole"><span class="pre">ident</span></span> <span><span class="pre">with</span></span> <span class="hole"><span class="pre">term</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.simple-inversion">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simple</span> <span>inversion</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacv.simple-inversion" title="Permalink to this definition">¶</a></dt>
<dd><p>It is a very primitive inversion tactic that derives all the necessary
equalities but it does not simplify the constraints as <code class="docutils literal notranslate"><span class="pre">inversion</span></code> does.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simple</span> <span>inversion</span> <span class="hole">ident</span> <span>as</span> <span class="hole">or_and_intropattern_loc</span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced in the context by
<code class="docutils literal notranslate"><span class="pre">simple</span> <span class="pre">inversion</span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.inversion-using">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>inversion</span> <span class="hole">ident</span> <span>using</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacv.inversion-using" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> have type <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">I</span></span> <span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code> (<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> an inductive predicate) in the
local context, and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> be a (dependent) inversion lemma. Then, this
tactic refines the current goal with the specified lemma.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>inversion</span> <span class="hole">ident</span> <span>using</span> <span class="hole">ident</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This tactic behaves as generalizing <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>, then doing
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">inversion</span></span> <span class="hole"><span class="pre">ident</span></span> <span><span class="pre">using</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.inversion-sigma">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>inversion</span><span>_</span><span>sigma</span></span></code><a class="headerlink" href="#coq:tacv.inversion-sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic turns equalities of dependent pairs (e.g.,
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">existT</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">p</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">existT</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">y</span></span> <span class="name"><span class="pre">q</span></span></code>, frequently left over by inversion on
a dependent type family) into pairs of equalities (e.g., a hypothesis
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span></code> and a hypothesis of type <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">rew</span></span> <span class="name"><span class="pre">H</span></span> <span class="keyword reserved"><span class="pre">in</span></span> <span class="name"><span class="pre">p</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">q</span></span></code>); these
hypotheses can subsequently be simplified using <a class="reference internal" href="#coq:tacn.subst" title="subst"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">subst</span></code></a>, without ever
invoking any kind of axiom asserting uniqueness of identity proofs. If you
want to explicitly specify the hypothesis to be inverted, or name the
generated hypotheses, you can invoke
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <span><span class="pre">H</span></span> <span><span class="pre">as</span></span> <span><span class="pre">[H1</span></span> <span><span class="pre">H2]</span></span> <span><span class="pre">using</span></span> <span><span class="pre">eq</span></span><span><span class="pre">_</span></span><span><span class="pre">sigT</span></span><span><span class="pre">_</span></span><span><span class="pre">rect.</span></span></span></code> This tactic also works for
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">sig</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">sigT2</span></span></code>, and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">sig2</span></span></code>, and there are similar <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">eq_sig</span></span></code>
<code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">***</span></span><span class="name"><span class="pre">_rect</span></span></code> induction lemmas.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<p><em>Non-dependent inversion</em>.</p>
<p>Let us consider the relation <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">Le</span></span></code> over natural numbers:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">Le</span> : nat -&gt; nat -&gt; <span class="kt">Set</span> :=
| LeO : <span class="kr">forall</span> <span class="nv">n</span>:nat, Le <span class="mi">0</span> n
| LeS : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>:nat, Le n m -&gt; Le (S n) (S m).</span></span></span></pre></div><p>Let us consider the following goal:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk4f" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> <span class="nv">m0</span> : nat, Le n0 m0 -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Le (S n) m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P n m</span></div></blockquote></div></div></small></span></pre></div><p>To prove the goal, we may need to reason by cases on <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> and to derive
that <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span></code> is necessarily of the form <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">m0</span></span><span class="operator"><span class="pre">)</span></span></code> for certain <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">m0</span></span></code> and that
<code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">Le</span></span> <span class="name"><span class="pre">n</span></span> <span class="name"><span class="pre">m0</span></span><span class="operator"><span class="pre">)</span></span></code>. Deriving these conditions corresponds to proving that the only
possible constructor of <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">Le</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">)</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">)</span></span></code> is <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">LeS</span></span></code> and that we can invert
the arrow in the type of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">LeS</span></span></code>. This inversion is possible because <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">Le</span></span></code>
is the smallest set closed by the constructors <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">LeO</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">LeS</span></span></code>.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk50" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk50"><span class="highlight"><span class="nb">inversion_clear</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> <span class="nv">m1</span> : nat, Le n0 m1 -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, m, m0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Le n m0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P n (S m0)</span></div></blockquote></div></div></small></span></pre></div><p>Note that <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span></code> has been substituted in the goal for <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">m0</span></span><span class="operator"><span class="pre">)</span></span></code> and that the
hypothesis <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">Le</span></span> <span class="name"><span class="pre">n</span></span> <span class="name"><span class="pre">m0</span></span><span class="operator"><span class="pre">)</span></span></code> has been added to the context.</p>
<p>Sometimes it is interesting to have the equality <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span> <span class="operator"><span class="pre">=</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">m0</span></span><span class="operator"><span class="pre">)</span></span></code> in the
context to use it after. In that case we can use <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> that does
not clear the equalities:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk51" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk51"><span class="highlight"><span class="nb">inversion</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">m1</span> : nat, Le n1 m1 -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Le (S n) m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0, m0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Le n m0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n0 = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S m0 = m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P n (S m0)</span></div></blockquote></div></div></small></span></pre></div></div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p><em>Dependent inversion.</em></p>
<p>Let us consider the following goal:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk52" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> <span class="nv">m0</span> : nat, Le n0 m0 -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Le (S n) m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Q (S n) m H</span></div></blockquote></div></div></small></span></pre></div><p>As <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> occurs in the goal, we may want to reason by cases on its
structure and so, we would like inversion tactics to substitute <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> by
the corresponding &#64;term in constructor form. Neither <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> nor
<a class="reference internal" href="#coq:tacv.inversion-clear" title="inversion_clear"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion_clear</span></code></a> do such a substitution. To have such a behavior we
use the dependent inversion tactics:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk53" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk53"><span class="highlight"><span class="nb">dependent inversion_clear</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> <span class="nv">m1</span> : nat, Le n0 m1 -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, m, m0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Le n m0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Q (S n) (S m0) (LeS n m0 l)</span></div></blockquote></div></div></small></span></pre></div><p>Note that <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> has been substituted by <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">LeS</span></span> <span class="name"><span class="pre">n</span></span> <span class="name"><span class="pre">m0</span></span> <span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">)</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span></code> by <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">m0</span></span><span class="operator"><span class="pre">)</span></span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p><em>Using inversion_sigma.</em></p>
<p>Let us consider the following inductive type of
length-indexed lists, and a lemma about inverting equality of cons:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Coq.Logic.Eqdep_dec.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">vec</span> <span class="nv">A</span> : nat -&gt; <span class="kt">Type</span> :=
| nil : vec A O
| cons {n} (x : A) (xs : vec A n) : vec A (S n).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk54" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk54"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">invert_cons</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">n</span> <span class="nv">x</span> <span class="nv">xs</span> <span class="nv">y</span> <span class="nv">ys</span>,
         @cons A n x xs = @cons A n y ys
         -&gt; xs = ys.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A) (<span class="nv">xs</span> : vec A n)
  (<span class="nv">y</span> : A) (<span class="nv">ys</span> : vec A n),
cons A x xs = cons A y ys -&gt; xs = ys</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk55" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk55"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A) (<span class="nv">xs</span> : vec A n)
  (<span class="nv">y</span> : A) (<span class="nv">ys</span> : vec A n),
cons A x xs = cons A y ys -&gt; xs = ys</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk56" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk56"><span class="highlight"><span class="nb">intros</span> A n x xs y ys H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">vec A n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">ys</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">vec A n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cons A x xs = cons A y ys</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">xs = ys</span></div></blockquote></div></div></small></span></pre></div><p>After performing inversion, we are left with an equality of existTs:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk57" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk57"><span class="highlight"><span class="nb">inversion</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">vec A n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">ys</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">vec A n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cons A x xs = cons A y ys</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">existT (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; vec A n0) n xs =
existT (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; vec A n0) n ys</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">xs = ys</span></div></blockquote></div></div></small></span></pre></div><p>We can turn this equality into a usable form with inversion_sigma:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk58" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk58"><span class="highlight"><span class="nb">inversion_sigma</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">vec A n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">ys</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">vec A n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cons A x xs = cons A y ys</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">eq_rect n (<span class="kr">fun</span> <span class="nv">a</span> : nat =&gt; vec A a) xs n H0 = ys</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">xs = ys</span></div></blockquote></div></div></small></span></pre></div><p>To finish cleaning up the proof, we will need to use the fact that
that all proofs of n = n for n a nat are eq_refl:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk59" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk59"><span class="highlight"><span class="kr">let</span> <span class="nv">H</span> := <span class="kr">match goal with</span> H : n = n |- _ =&gt; H <span class="kr">end</span> <span class="kr">in</span>
<span class="nb">pose proof</span> (Eqdep_dec.UIP_refl_nat _ H); <span class="nb">subst</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">vec A n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">ys</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">vec A n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cons A x xs = cons A y ys</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">eq_rect n (<span class="kr">fun</span> <span class="nv">a</span> : nat =&gt; vec A a) xs n eq_refl =
ys</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">xs = ys</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk5a" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk5a"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">vec A n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">ys</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">vec A n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">cons A x xs = cons A y ys</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">xs = ys</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">xs = ys</span></div></blockquote></div></div></small></span></pre></div><p>Finally, we can finish the proof:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div></div>
<dl class="coq tacn">
<dt id="coq:tacn.fix">
<code class="sig-name descname"><span class="notation"><span>fix</span> <span class="hole">ident</span> <span class="hole">num</span></span></code><a class="headerlink" href="#coq:tacn.fix" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic is a primitive tactic to start a proof by induction. In
general, it is easier to rely on higher-level induction tactics such
as the ones described in <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>.</p>
<p>In the syntax of the tactic, the identifier <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is the name given to
the induction hypothesis. The natural number <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code> tells on which
premise of the current goal the induction acts, starting from 1,
counting both dependent and non dependent products, but skipping local
definitions. Especially, the current lemma must be composed of at
least <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code> products.</p>
<p>Like in a fix expression, the induction hypotheses have to be used on
structurally smaller arguments. The verification that inductive proof
arguments are correct is done only at the time of registering the
lemma in the environment. To know if the use of induction hypotheses
is correct at some time of the interactive development of a proof, use
the command <code class="docutils literal notranslate"><span class="pre">Guarded</span></code> (see Section <a class="reference internal" href="proof-handling.html#requestinginformation"><span class="std std-ref">Requesting information</span></a>).</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>fix</span> <span class="hole">ident</span> <span class="hole">num</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span><span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binder</span></span><span class="notation-sup">+</span></span> <span>[</span><span class="curlies">{<span>struct</span> <span class="hole">ident</span>}</span><span>]</span> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a><span>)</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This starts a proof by mutual induction. The statements to be simultaneously
proved are respectively <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">binder</span></span> <span class="operator"><span class="pre">...</span></span> <span class="keyword namespace"><span class="pre">binder</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">type</span></span></code>.
The identifiers <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> are the names of the induction hypotheses. The identifiers
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> are the respective names of the premises on which the induction
is performed in the statements to be simultaneously proved (if not given, the
system tries to guess itself what they are).</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.cofix">
<code class="sig-name descname"><span class="notation"><span>cofix</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacn.cofix" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic starts a proof by coinduction. The identifier <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is the
name given to the coinduction hypothesis. Like in a cofix expression,
the use of induction hypotheses have to guarded by a constructor. The
verification that the use of co-inductive hypotheses is correct is
done only at the time of registering the lemma in the environment. To
know if the use of coinduction hypotheses is correct at some time of
the interactive development of a proof, use the command <code class="docutils literal notranslate"><span class="pre">Guarded</span></code>
(see Section <a class="reference internal" href="proof-handling.html#requestinginformation"><span class="std std-ref">Requesting information</span></a>).</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>cofix</span> <span class="hole">ident</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span><span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binder</span></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a><span>)</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This starts a proof by mutual coinduction. The statements to be
simultaneously proved are respectively <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">binder</span></span> <span class="operator"><span class="pre">...</span></span> <span class="keyword namespace"><span class="pre">binder</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">type</span></span></code>
The identifiers <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> are the names of the coinduction hypotheses.</p>
</dd></dl>

</div>
<div class="section" id="rewriting-expressions">
<span id="rewritingexpressions"></span><h2>Rewriting expressions<a class="headerlink" href="#rewriting-expressions" title="Permalink to this headline">¶</a></h2>
<p>These tactics use the equality <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">A</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">Type</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Prop</span></span></code> defined in
file <code class="docutils literal notranslate"><span class="pre">Logic.v</span></code> (see <a class="reference internal" href="../language/coq-library.html#coq-library-logic"><span class="std std-ref">Logic</span></a>). The notation for <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">T</span></span> <span class="name"><span class="pre">t</span></span> <span class="name"><span class="pre">u</span></span></code> is
simply <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">u</span></span></code> dropping the implicit type of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">u</span></span></code>.</p>
<dl class="coq tacn">
<dt id="coq:tacn.rewrite">
<code class="sig-name descname"><span class="notation"><span>rewrite</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.rewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. The type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> must have the form</p>
<p><code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">(x</span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="pre">:A</span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="pre">)</span> <span class="pre">...</span> <span class="pre">(x</span></code><sub>n</sub> <code class="docutils literal notranslate"><span class="pre">:A</span></code><sub>n</sub> <code class="docutils literal notranslate"><span class="pre">),</span> <span class="pre">eq</span> <span class="pre">term</span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="pre">term</span></code><sub>2</sub> <code class="docutils literal notranslate"><span class="pre">.</span></code></p>
<p>where <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span></code> is the Leibniz equality or a registered setoid equality.</p>
<p>Then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span class="hole"><span class="pre">term</span></span></span></code> finds the first subterm matching <code class="docutils literal notranslate"><span class="pre">term</span></code><sub>1</sub> in the goal,
resulting in instances <code class="docutils literal notranslate"><span class="pre">term</span></code><sub>1</sub>' and <code class="docutils literal notranslate"><span class="pre">term</span></code><sub>2</sub>' and then
replaces every occurrence of <code class="docutils literal notranslate"><span class="pre">term</span></code><sub>1</sub>' by <code class="docutils literal notranslate"><span class="pre">term</span></code><sub>2</sub>'.
Hence, some of the variables <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code><sub>i</sub> are solved by unification,
and some of the types <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code><sub>1</sub><code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">,</span></span> <span class="operator"><span class="pre">...,</span></span> <span class="name"><span class="pre">A</span></span></code><sub>n</sub> become new
subgoals.</p>
<dl class="coq exn">
<dt id="coq:exn.the-term-provided-does-not-end-with-an-equation">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>The</span> <span class="hole">term</span> <span>provided</span> <span>does</span> <span>not</span> <span>end</span> <span>with</span> <span>an</span> <span>equation.</span></span></code><a class="headerlink" href="#coq:exn.the-term-provided-does-not-end-with-an-equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.tactic-generated-a-subgoal-identical-to-the-original-goal-this-happens-if-term-does-not-occur-in-the-goal">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Tactic</span> <span>generated</span> <span>a</span> <span>subgoal</span> <span>identical</span> <span>to</span> <span>the</span> <span>original</span> <span>goal.</span> <span>This</span> <span>happens</span> <span>if</span> <span class="hole">term</span> <span>does</span> <span>not</span> <span>occur</span> <span>in</span> <span>the</span> <span>goal.</span></span></code><a class="headerlink" href="#coq:exn.tactic-generated-a-subgoal-identical-to-the-original-goal-this-happens-if-term-does-not-occur-in-the-goal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>rewrite</span> <span>-&gt;</span> <span class="hole">term</span></span></code></dt>
<dd><p>Is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span class="hole"><span class="pre">term</span></span></span></code></p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>rewrite</span> <span>&lt;-</span> <span class="hole">term</span></span></code></dt>
<dd><p>Uses the equality <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">=</span></span> <span class="hole"><span class="pre">term</span></span></span></code> <sub>2</sub> from right to left</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>rewrite</span> <span class="hole">term</span> <span>in</span> <span class="hole">goal_occurrences</span></span></code></dt>
<dd><p>Analogous to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span class="hole"><span class="pre">term</span></span></span></code> but rewriting is done following
the clause <code class="xref std std-token docutils literal notranslate"><span class="pre">goal_occurrences</span></code>. For instance:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">H'</span></span></span></code> will rewrite <code class="docutils literal notranslate"><span class="pre">H</span></code> in the hypothesis
<code class="docutils literal notranslate"><span class="pre">H'</span></code> instead of the current goal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">H'</span></span> <span><span class="pre">at</span></span> <span><span class="pre">1,</span></span> <span><span class="pre">H''</span></span> <span><span class="pre">at</span></span> <span><span class="pre">-</span></span> <span><span class="pre">2</span></span> <span class="pre">|</span><span><span class="pre">-</span></span> <span><span class="pre">*</span></span></span></code> means
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H;</span></span> <span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">H'</span></span> <span><span class="pre">at</span></span> <span><span class="pre">1;</span></span> <span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">H''</span></span> <span><span class="pre">at</span></span> <span><span class="pre">-</span></span> <span><span class="pre">2.</span></span></span></code>
In particular a failure will happen if any of these three simpler tactics
fails.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">*</span></span> <span class="pre">|</span><span><span class="pre">-</span></span></span></code> will do <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">H'</span></span></span></code> for all hypotheses
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H'</span></span></code> different from <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code>.
A success will happen as soon as at least one of these simpler tactics succeeds.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">*</span></span></span></code> is a combination of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">*</span></span> <span class="pre">|</span><span><span class="pre">-</span></span></span></code>
that succeeds if at least one of these two tactics succeeds.</p></li>
</ul>
<p>Orientation <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">-&gt;</span></span></code> or <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">&lt;-</span></span></code> can be inserted before the <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> to rewrite.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>rewrite</span> <span class="hole">term</span> <span>at</span> <span class="hole">occurrences</span></span></code></dt>
<dd><p>Rewrite only the given <code class="xref std std-token docutils literal notranslate"><span class="pre">occurrences</span></code> of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>. Occurrences are
specified from left to right as for pattern (<a class="reference internal" href="#coq:tacn.pattern" title="pattern"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pattern</span></code></a>). The rewrite is
always performed using setoid rewriting, even for Leibniz’s equality, so one
has to <code class="docutils literal notranslate"><span class="pre">Import</span> <span class="pre">Setoid</span></code> to use this variant.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>rewrite</span> <span class="hole">term</span> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>Use tactic to completely solve the side-conditions arising from the
<a class="reference internal" href="#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>rewrite</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-orientation"><span class="hole">orientation</span></a> <span class="hole">term</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <span class="hole">ident</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>Is equivalent to the <code class="docutils literal notranslate"><span class="pre">n</span></code> successive tactics <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">rewrite</span></span> <span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">;</span></span></span></span></code>, each one
working on the first subgoal generated by the previous one. An <span class="inline-grammar-production"><span class="target" id="grammar-token-orientation"></span><code class="docutils literal notranslate"><span class="pre">orientation</span></code></span>
<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">&lt;-</span></code> can be inserted before each <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> to rewrite.  One
unique clause can be added at the end after the keyword in; it will then
affect all rewrite operations.</p>
</dd></dl>

<p>In all forms of rewrite described above, a <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> to rewrite can be
immediately prefixed by one of the following modifiers:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">?</span></code> : the tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">?</span></span><span class="hole"><span class="pre">term</span></span></span></code> performs the rewrite of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> as many
times as possible (perhaps zero time). This form never fails.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span><span><span class="pre">?</span></span></span></code> : works similarly, except that it will do at most <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code> rewrites.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!</span></code> : works as <code class="docutils literal notranslate"><span class="pre">?</span></code>, except that at least one rewrite should succeed, otherwise
the tactic fails.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span><span><span class="pre">!</span></span></span></code> (or simply <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code>) : precisely <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code> rewrites of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> will be done,
leading to failure if these <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code> rewrites are not possible.</p></li>
</ul>
<dl class="coq tacv">
<dt id="coq:tacv.erewrite">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>erewrite</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacv.erewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic works as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span class="hole"><span class="pre">term</span></span></span></code> but turning
unresolved bindings into existential variables, if any, instead of
failing. It has the same variants as <a class="reference internal" href="#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> has.</p>
</dd></dl>

<dl class="coq flag">
<dt id="coq:flag.keyed-unification">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Keyed</span> <span>Unification</span></span></code><a class="headerlink" href="#coq:flag.keyed-unification" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes higher-order unification used by <a class="reference internal" href="#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> rely on a set of keys to drive
unification.  The subterms, considered as rewriting candidates, must start with
the same key as the left- or right-hand side of the lemma given to rewrite, and the arguments
are then unified up to full reduction.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.replace">
<code class="sig-name descname"><span class="notation"><span>replace</span> <span class="hole">term</span> <span>with</span> <span class="hole">term</span><span>’</span></span></code><a class="headerlink" href="#coq:tacn.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. It replaces all free occurrences of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>
in the current goal with <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code> and generates an equality <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code>
as a subgoal. This equality is automatically solved if it occurs among
the assumptions, or if its symmetric form occurs. It is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cut</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">’;</span></span> <span><span class="pre">[intro</span></span> <span><span class="pre">H</span></span></span></code><sub>n</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">;</span></span> <span><span class="pre">rewrite</span></span> <span><span class="pre">&lt;-</span></span> <span><span class="pre">H</span></span></span></code><sub>n</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">;</span></span> <span><span class="pre">clear</span></span> <span><span class="pre">H</span></span></span></code><sub>n</sub><code class="docutils literal notranslate"><span class="notation"><span class="pre">|</span><span class="pre">|</span> <span><span class="pre">assumption</span></span> <span class="pre">|</span><span class="pre">|</span> <span><span class="pre">symmetry;</span></span> <span><span class="pre">try</span></span> <span><span class="pre">assumption]</span></span></span></code>.</p>
<dl class="coq exn">
<dt id="coq:exn.terms-do-not-have-convertible-types">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Terms</span> <span>do</span> <span>not</span> <span>have</span> <span>convertible</span> <span>types.</span></span></code><a class="headerlink" href="#coq:exn.terms-do-not-have-convertible-types" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>replace</span> <span class="hole">term</span> <span>with</span> <span class="hole">term</span><span>’</span> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>This acts as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">replace</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">with</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code> but applies <code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code> to solve the generated
subgoal <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>replace</span> <span class="hole">term</span></span></code></dt>
<dd><p>Replaces <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> with <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code> using the first assumption whose type has
the form <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">term</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>replace</span> <span>-&gt;</span> <span class="hole">term</span></span></code></dt>
<dd><p>Replaces <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> with <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code> using the first assumption whose type has
the form <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code></p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>replace</span> <span>&lt;-</span> <span class="hole">term</span></span></code></dt>
<dd><p>Replaces <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> with <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code> using the first assumption whose type has
the form <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">term</span></span></span></code></p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>replace</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">term</span></span><span class="notation-sup">?</span></span> <span>in</span> <span class="hole">goal_occurrences</span> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>replace</span> <span>-&gt;</span> <span class="hole">term</span> <span>in</span> <span class="hole">goal_occurrences</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>replace</span> <span>&lt;-</span> <span class="hole">term</span> <span>in</span> <span class="hole">goal_occurrences</span></span></code></dt>
<dd><p>Acts as before but the replacements take place in the specified clauses
(<code class="xref std std-token docutils literal notranslate"><span class="pre">goal_occurrences</span></code>) (see <a class="reference internal" href="#performingcomputations"><span class="std std-ref">Performing computations</span></a>) and not
only in the conclusion of the goal. The clause argument must not contain
any <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">of</span></code> nor <code class="docutils literal notranslate"><span class="pre">value</span> <span class="pre">of</span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.cutrewrite">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>cutrewrite</span> <span>&lt;-</span> <span>(</span><span class="hole">term</span> <span>=</span> <span class="hole">term</span><span>’)</span></span></code><a class="headerlink" href="#coq:tacv.cutrewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic is deprecated. It can be replaced by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">enough</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">term</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">’)</span></span> <span><span class="pre">as</span></span> <span><span class="pre">&lt;-</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>cutrewrite</span> <span>-&gt;</span> <span>(</span><span class="hole">term</span> <span>=</span> <span class="hole">term</span><span>’)</span></span></code></dt>
<dd><p>This tactic is deprecated. It can be replaced by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">enough</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">term</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">’)</span></span> <span><span class="pre">as</span></span> <span><span class="pre">-&gt;</span></span></span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.subst">
<code class="sig-name descname"><span class="notation"><span>subst</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacn.subst" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to a goal that has <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> in its context and (at
least) one hypothesis, say <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code>, of type <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">=</span></span> <span><span class="pre">t</span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">t</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>
with <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> not occurring in <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code>. Then it replaces <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> by
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> everywhere in the goal (in the hypotheses and in the conclusion) and
clears <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> from the context.</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is a local definition of the form <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span><span class="pre">t</span></span></span></code>, it is also
unfolded and cleared.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>When several hypotheses have the form <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">=</span></span> <span><span class="pre">t</span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">t</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>, the
first one is used.</p></li>
<li><p>If <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> is itself dependent in the goal, it is replaced by the proof of
reflexivity of equality.</p></li>
</ul>
</div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>subst</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">subst</span></span> <span class="hole"><span class="pre">ident</span></span></span></code><sub>1</sub><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">;</span></span> <span><span class="pre">...;</span></span> <span><span class="pre">subst</span></span> <span class="hole"><span class="pre">ident</span></span></span></code><sub>n</sub>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>subst</span></span></code></dt>
<dd><p>This applies subst repeatedly from top to bottom to all identifiers of the
context for which an equality of the form <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">=</span></span> <span><span class="pre">t</span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">t</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>
or <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span><span class="pre">t</span></span></span></code> exists, with <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> not occurring in <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
</dd></dl>

<dl class="coq flag">
<dt id="coq:flag.regular-subst-tactic">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Regular</span> <span>Subst</span> <span>Tactic</span></span></code><a class="headerlink" href="#coq:flag.regular-subst-tactic" title="Permalink to this definition">¶</a></dt>
<dd><p>This option controls the behavior of <a class="reference internal" href="#coq:tacn.subst" title="subst"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">subst</span></code></a>. When it is
activated (it is by default), <a class="reference internal" href="#coq:tacn.subst" title="subst"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">subst</span></code></a> also deals with the following corner cases:</p>
<ul class="simple">
<li><p>A context with ordered hypotheses <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">=</span></span> <span class="hole"><span class="pre">ident</span></span></span></code><sub>2</sub>
and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">=</span></span> <span><span class="pre">t</span></span></span></code>, or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">t′</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">ident</span></span></span></code><sub>1`</sub> with <code class="docutils literal notranslate"><span class="pre">t′</span></code> not
a variable, and no other hypotheses of the form <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code><sub>2</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">=</span></span> <span><span class="pre">u</span></span></span></code>
or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">u</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">ident</span></span></span></code><sub>2</sub>; without the option, a second call to
subst would be necessary to replace <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code><sub>2</sub> by <code class="docutils literal notranslate"><span class="pre">t</span></code> or
<code class="docutils literal notranslate"><span class="pre">t′</span></code> respectively.</p></li>
<li><p>The presence of a recursive equation which without the option would
be a cause of failure of <a class="reference internal" href="#coq:tacn.subst" title="subst"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">subst</span></code></a>.</p></li>
<li><p>A context with cyclic dependencies as with hypotheses <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">=</span></span> <span><span class="pre">f</span></span> <span class="hole"><span class="pre">ident</span></span></span></code><sub>2</sub>
and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code><sub>2</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">=</span></span> <span><span class="pre">g</span></span> <span class="hole"><span class="pre">ident</span></span></span></code><sub>1</sub> which without the
option would be a cause of failure of <a class="reference internal" href="#coq:tacn.subst" title="subst"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">subst</span></code></a>.</p></li>
</ul>
<p>Additionally, it prevents a local definition such as <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span><span class="pre">t</span></span></span></code> to be
unfolded which otherwise it would exceptionally unfold in configurations
containing hypotheses of the form <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">=</span></span> <span><span class="pre">u</span></span></span></code>, or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">u′</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>
with <code class="docutils literal notranslate"><span class="pre">u′</span></code> not a variable. Finally, it preserves the initial order of
hypotheses, which without the option it may break.
default.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.stepl">
<code class="sig-name descname"><span class="notation"><span>stepl</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.stepl" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic is for chaining rewriting steps. It assumes a goal of the
form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">R</span></span> <span class="hole"><span class="pre">term</span></span> <span class="hole"><span class="pre">term</span></span></span></code> where <code class="docutils literal notranslate"><span class="pre">R</span></code> is a binary relation and relies on a
database of lemmas of the form <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">x</span></span> <span class="name variable"><span class="pre">y</span></span> <span class="name variable"><span class="pre">z</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">R</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">z</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">R</span></span> <span class="name"><span class="pre">z</span></span> <span class="name"><span class="pre">y</span></span></code>
where <code class="docutils literal notranslate"><span class="pre">eq</span></code> is typically a setoid equality. The application of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">stepl</span></span> <span class="hole"><span class="pre">term</span></span></span></code>
then replaces the goal by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">R</span></span> <span class="hole"><span class="pre">term</span></span> <span class="hole"><span class="pre">term</span></span></span></code> and adds a new goal stating
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">eq</span></span> <span class="hole"><span class="pre">term</span></span> <span class="hole"><span class="pre">term</span></span></span></code>.</p>
<dl class="coq cmd">
<dt id="coq:cmd.declare-left-step">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Declare</span> <span>Left</span> <span>Step</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:cmd.declare-left-step" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> to the database used by <a class="reference internal" href="#coq:tacn.stepl" title="stepl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">stepl</span></code></a>.</p>
</dd></dl>

<p>This tactic is especially useful for parametric setoids which are not accepted
as regular setoids for <a class="reference internal" href="#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> and <a class="reference internal" href="../addendum/generalized-rewriting.html#coq:tacv.setoid-replace" title="setoid_replace"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">setoid_replace</span></code></a> (see
<a class="reference internal" href="../addendum/generalized-rewriting.html#generalizedrewriting"><span class="std std-ref">Generalized rewriting</span></a>).</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>stepl</span> <span class="hole">term</span> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>This applies <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">stepl</span></span> <span class="hole"><span class="pre">term</span></span></span></code> then applies <code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code> to the second goal.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.stepr">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>stepr</span> <span class="hole">term</span> <span>by</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:tacv.stepr" title="Permalink to this definition">¶</a></dt>
<dd><p>This behaves as <a class="reference internal" href="#coq:tacn.stepl" title="stepl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">stepl</span></code></a> but on the right-hand-side of the binary
relation. Lemmas are expected to be of the form
<code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">x</span></span> <span class="name variable"><span class="pre">y</span></span> <span class="name variable"><span class="pre">z</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">R</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">y</span></span> <span class="name"><span class="pre">z</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">R</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">z</span></span></code>.</p>
</dd></dl>

<dl class="coq cmd">
<dt id="coq:cmd.declare-right-step">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Declare</span> <span>Right</span> <span>Step</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:cmd.declare-right-step" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> to the database used by <a class="reference internal" href="#coq:tacv.stepr" title="stepr"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">stepr</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.change">
<code class="sig-name descname"><span class="notation"><span>change</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.change" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. It implements the rule <code class="docutils literal notranslate"><span class="pre">Conv</span></code> given in
<a class="reference internal" href="../language/cic.html#subtyping-rules"><span class="std std-ref">Subtyping rules</span></a>. <code class="code highlight coq docutils literal notranslate"><span class="name builtin"><span class="pre">change</span></span> <span class="name"><span class="pre">U</span></span></code> replaces the current goal <code class="docutils literal notranslate"><span class="pre">T</span></code>
with <code class="docutils literal notranslate"><span class="pre">U</span></code> providing that <code class="docutils literal notranslate"><span class="pre">U</span></code> is well-formed and that <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">U</span></code> are
convertible.</p>
<dl class="coq exn">
<dt id="coq:exn.not-convertible">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>convertible.</span></span></code><a class="headerlink" href="#coq:exn.not-convertible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>change</span> <span class="hole">term</span> <span>with</span> <span class="hole">term</span><span>’</span></span></code></dt>
<dd><p>This replaces the occurrences of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> by <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code> in the current goal.
The term <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code> must be convertible.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>change</span> <span class="hole">term</span> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">+</span></span> <span>with</span> <span class="hole">term</span><span>’</span></span></code></dt>
<dd><p>This replaces the occurrences numbered <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">num</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> by <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code>
in the current goal. The terms <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code> must be convertible.</p>
<dl class="coq exn">
<dt id="coq:exn.too-few-occurrences">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Too</span> <span>few</span> <span>occurrences.</span></span></code><a class="headerlink" href="#coq:exn.too-few-occurrences" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>change</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span>at</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span>with</span> <span class="hole">term</span></span><span class="notation-sup">?</span></span> <span>in</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This applies the <a class="reference internal" href="#coq:tacn.change" title="change"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change</span></code></a> tactic not to the goal but to the hypothesis <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>now</span><span>_</span><span>show</span> <span class="hole">term</span></span></code></dt>
<dd><p>This is a synonym of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">change</span></span> <span class="hole"><span class="pre">term</span></span></span></code>. It can be used to
make some proof steps explicit when refactoring a proof script
to make it readable.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#performingcomputations"><span class="std std-ref">Performing computations</span></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="performing-computations">
<span id="performingcomputations"></span><h2>Performing computations<a class="headerlink" href="#performing-computations" title="Permalink to this headline">¶</a></h2>
<p>This set of tactics implements different specialized usages of the
tactic <a class="reference internal" href="#coq:tacn.change" title="change"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change</span></code></a>.</p>
<p>All conversion tactics (including <a class="reference internal" href="#coq:tacn.change" title="change"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change</span></code></a>) can be parameterized by the
parts of the goal where the conversion can occur. This is done using
<em>goal clauses</em> which consists in a list of hypotheses and, optionally,
of a reference to the conclusion of the goal. For defined hypothesis
it is possible to specify if the conversion should occur on the type
part, the body part or both (default).</p>
<p>Goal clauses are written after a conversion tactic (tactics <a class="reference internal" href="#coq:tacn.set" title="set"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">set</span></code></a>,
<a class="reference internal" href="#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a>, <a class="reference internal" href="#coq:tacn.replace" title="replace"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">replace</span></code></a> and <a class="reference internal" href="#coq:tacn.autorewrite" title="autorewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">autorewrite</span></code></a> also use goal
clauses) and are introduced by the keyword <code class="docutils literal notranslate"><span class="pre">in</span></code>. If no goal clause is
provided, the default is to perform the conversion only in the
conclusion.</p>
<p>The syntax and description of the various goal clauses is the
following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span class="pre">|</span><span><span class="pre">-</span></span></span></code>  only in hypotheses <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span class="pre">|</span><span><span class="pre">-</span></span> <span><span class="pre">*</span></span></span></code> in hypotheses <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> and in the
conclusion</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <span><span class="pre">*</span></span> <span class="pre">|</span><span><span class="pre">-</span></span></span></code> in every hypothesis</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <span><span class="pre">*</span></span></span></code> (equivalent to in <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">*</span></span> <span class="pre">|</span><span><span class="pre">-</span></span> <span><span class="pre">*</span></span></span></code>) everywhere</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <span><span class="pre">(type</span></span> <span><span class="pre">of</span></span> <span class="hole"><span class="pre">ident</span></span><span><span class="pre">)</span></span> <span><span class="pre">(value</span></span> <span><span class="pre">of</span></span> <span class="hole"><span class="pre">ident</span></span><span><span class="pre">)</span></span> <span><span class="pre">...</span></span> <span class="pre">|</span><span><span class="pre">-</span></span></span></code> in type part of
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>, in the value part of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>, etc.</p></li>
</ul>
<p>For backward compatibility, the notation <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> performs
the conversion in hypotheses <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
<dl class="coq tacn">
<dt id="coq:tacn.cbv">
<code class="sig-name descname"><span class="notation"><span>cbv</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="vernacular-commands.html#grammar-token-flag"><span class="hole">flag</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:tacn.cbv" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacn.lazy">
<code class="sig-name descname"><span class="notation"><span>lazy</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="vernacular-commands.html#grammar-token-flag"><span class="hole">flag</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:tacn.lazy" title="Permalink to this definition">¶</a></dt>
<dd><p>These parameterized reduction tactics apply to any goal and perform
the normalization of the goal according to the specified flags. In
correspondence with the kinds of reduction considered in Coq namely
<span class="math notranslate nohighlight">\(\beta\)</span> (reduction of functional application), <span class="math notranslate nohighlight">\(\delta\)</span>
(unfolding of transparent constants, see <a class="reference internal" href="vernacular-commands.html#vernac-controlling-the-reduction-strategies"><span class="std std-ref">Controlling the reduction strategies and the conversion algorithm</span></a>),
<span class="math notranslate nohighlight">\(\iota\)</span> (reduction of
pattern matching over a constructed term, and unfolding of <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">fix</span></span></code> and
<code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">cofix</span></span></code> expressions) and <span class="math notranslate nohighlight">\(\zeta\)</span> (contraction of local definitions), the
flags are either <code class="docutils literal notranslate"><span class="pre">beta</span></code>, <code class="docutils literal notranslate"><span class="pre">delta</span></code>, <code class="docutils literal notranslate"><span class="pre">match</span></code>, <code class="docutils literal notranslate"><span class="pre">fix</span></code>, <code class="docutils literal notranslate"><span class="pre">cofix</span></code>,
<code class="docutils literal notranslate"><span class="pre">iota</span></code> or <code class="docutils literal notranslate"><span class="pre">zeta</span></code>. The <code class="docutils literal notranslate"><span class="pre">iota</span></code> flag is a shorthand for <code class="docutils literal notranslate"><span class="pre">match</span></code>, <code class="docutils literal notranslate"><span class="pre">fix</span></code>
and <code class="docutils literal notranslate"><span class="pre">cofix</span></code>. The <code class="docutils literal notranslate"><span class="pre">delta</span></code> flag itself can be refined into
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">delta</span></span> <span><span class="pre">[</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">qualid</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">]</span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">delta</span></span> <span><span class="pre">-</span></span> <span><span class="pre">[</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">qualid</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">]</span></span></span></code>, restricting in the first
case the constants to unfold to the constants listed, and restricting in the
second case the constant to unfold to all but the ones explicitly mentioned.
Notice that the <code class="docutils literal notranslate"><span class="pre">delta</span></code> flag does not apply to variables bound by a let-in
construction inside the <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> itself (use here the <code class="docutils literal notranslate"><span class="pre">zeta</span></code> flag). In
any cases, opaque constants are not unfolded (see <a class="reference internal" href="vernacular-commands.html#vernac-controlling-the-reduction-strategies"><span class="std std-ref">Controlling the reduction strategies and the conversion algorithm</span></a>).</p>
<p>Normalization according to the flags is done by first evaluating the
head of the expression into a <em>weak-head</em> normal form, i.e. until the
evaluation is blocked by a variable (or an opaque constant, or an
axiom), as e.g. in <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">u1</span></span> <span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">un</span></span></code> , or <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">match</span></span> <span class="name"><span class="pre">x</span></span> <span class="keyword reserved"><span class="pre">with</span></span> <span class="operator"><span class="pre">...</span></span> <span class="keyword reserved"><span class="pre">end</span></span></code>, or
<code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="keyword reserved"><span class="pre">fix</span></span> <span class="name"><span class="pre">f</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">{</span></span><span class="keyword reserved"><span class="pre">struct</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">}</span></span> <span class="operator"><span class="pre">:=</span></span> <span class="operator"><span class="pre">...)</span></span> <span class="name"><span class="pre">x</span></span></code>, or is a constructed form (a
<span class="math notranslate nohighlight">\(\lambda\)</span>-expression, a constructor, a cofixpoint, an inductive type, a
product type, a sort), or is a redex that the flags prevent to reduce. Once a
weak-head normal form is obtained, subterms are recursively reduced using the
same strategy.</p>
<p>Reduction to weak-head normal form can be done using two strategies:
<em>lazy</em> (<code class="docutils literal notranslate"><span class="pre">lazy</span></code> tactic), or <em>call-by-value</em> (<code class="docutils literal notranslate"><span class="pre">cbv</span></code> tactic). The lazy
strategy is a call-by-need strategy, with sharing of reductions: the
arguments of a function call are weakly evaluated only when necessary,
and if an argument is used several times then it is weakly computed
only once. This reduction is efficient for reducing expressions with
dead code. For instance, the proofs of a proposition <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">exists</span></span> <span class="name variable"><span class="pre">x</span></span><span class="operator"><span class="pre">.</span></span> <span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">)</span></span></code>
reduce to a pair of a witness <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code>, and a proof that <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> satisfies the
predicate <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code>. Most of the time, <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> may be computed without computing
the proof of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code>, thanks to the lazy strategy.</p>
<p>The call-by-value strategy is the one used in ML languages: the
arguments of a function call are systematically weakly evaluated
first. Despite the lazy strategy always performs fewer reductions than
the call-by-value strategy, the latter is generally more efficient for
evaluating purely computational expressions (i.e. with little dead code).</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.compute">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>compute</span></span></code><a class="headerlink" href="#coq:tacv.compute" title="Permalink to this definition">¶</a></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>cbv</span></span></code></dt>
<dd><p>These are synonyms for <code class="docutils literal notranslate"><span class="pre">cbv</span> <span class="pre">beta</span> <span class="pre">delta</span> <span class="pre">iota</span> <span class="pre">zeta</span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>lazy</span></span></code></dt>
<dd><p>This is a synonym for <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">beta</span> <span class="pre">delta</span> <span class="pre">iota</span> <span class="pre">zeta</span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>compute</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span> <span>]</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>cbv</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span> <span>]</span></span></code></dt>
<dd><p>These are synonyms of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cbv</span></span> <span><span class="pre">beta</span></span> <span><span class="pre">delta</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">qualid</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">iota</span></span> <span><span class="pre">zeta</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>compute</span> <span>-</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span> <span>]</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>cbv</span> <span>-</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span> <span>]</span></span></code></dt>
<dd><p>These are synonyms of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cbv</span></span> <span><span class="pre">beta</span></span> <span><span class="pre">delta</span></span> <span><span class="pre">-</span></span><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">qualid</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">iota</span></span> <span><span class="pre">zeta</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>lazy</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span> <span>]</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>lazy</span> <span>-</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span> <span>]</span></span></code></dt>
<dd><p>These are respectively synonyms of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">lazy</span></span> <span><span class="pre">beta</span></span> <span><span class="pre">delta</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">qualid</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">iota</span></span> <span><span class="pre">zeta</span></span></span></code>
and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">lazy</span></span> <span><span class="pre">beta</span></span> <span><span class="pre">delta</span></span> <span><span class="pre">-</span></span><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">qualid</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">iota</span></span> <span><span class="pre">zeta</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.vm-compute">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>vm</span><span>_</span><span>compute</span></span></code><a class="headerlink" href="#coq:tacv.vm-compute" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic evaluates the goal using the optimized call-by-value evaluation
bytecode-based virtual machine described in <a class="bibtex reference internal" href="../zebibliography.html#compiledstrongreduction" id="id8">[GregoireL02]</a>.
This algorithm is dramatically more efficient than the algorithm used for the
<a class="reference internal" href="#coq:tacn.cbv" title="cbv"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbv</span></code></a> tactic, but it cannot be fine-tuned. It is especially interesting for
full evaluation of algebraic objects. This includes the case of
reflection-based tactics.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.native-compute">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>native</span><span>_</span><span>compute</span></span></code><a class="headerlink" href="#coq:tacv.native-compute" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic evaluates the goal by compilation to OCaml as described
in <a class="bibtex reference internal" href="../zebibliography.html#fullreduction" id="id9">[BDenesGregoire11]</a>. If Coq is running in native code, it can be
typically two to five times faster than <a class="reference internal" href="#coq:tacv.vm-compute" title="vm_compute"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">vm_compute</span></code></a>. Note however that the
compilation cost is higher, so it is worth using only for intensive
computations.</p>
<dl class="coq flag">
<dt id="coq:flag.nativecompute-profiling">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>NativeCompute</span> <span>Profiling</span></span></code><a class="headerlink" href="#coq:flag.nativecompute-profiling" title="Permalink to this definition">¶</a></dt>
<dd><p>On Linux, if you have the <code class="docutils literal notranslate"><span class="pre">perf</span></code> profiler installed, this option makes
it possible to profile <a class="reference internal" href="#coq:tacv.native-compute" title="native_compute"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">native_compute</span></code></a> evaluations.</p>
</dd></dl>

<dl class="coq opt">
<dt id="coq:opt.nativecompute-profile-filename">
<em class="property"><span class="sigannot">Option</span></em> <code class="sig-name descname"><span class="notation"><span>NativeCompute</span> <span>Profile</span> <span>Filename</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code><a class="headerlink" href="#coq:opt.nativecompute-profile-filename" title="Permalink to this definition">¶</a></dt>
<dd><p>This option specifies the profile output; the default is
<code class="docutils literal notranslate"><span class="pre">native_compute_profile.data</span></code>. The actual filename used
will contain extra characters to avoid overwriting an existing file; that
filename is reported to the user.
That means you can individually profile multiple uses of
<a class="reference internal" href="#coq:tacv.native-compute" title="native_compute"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">native_compute</span></code></a> in a script. From the Linux command line, run <code class="docutils literal notranslate"><span class="pre">perf</span> <span class="pre">report</span></code>
on the profile file to see the results. Consult the <code class="docutils literal notranslate"><span class="pre">perf</span></code> documentation
for more details.</p>
</dd></dl>

</dd></dl>

<dl class="coq flag">
<dt id="coq:flag.debug-cbv">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Debug</span> <span>Cbv</span></span></code><a class="headerlink" href="#coq:flag.debug-cbv" title="Permalink to this definition">¶</a></dt>
<dd><p>This option makes <a class="reference internal" href="#coq:tacn.cbv" title="cbv"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbv</span></code></a> (and its derivative <a class="reference internal" href="#coq:tacv.compute" title="compute"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">compute</span></code></a>) print
information about the constants it encounters and the unfolding decisions it
makes.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.red">
<code class="sig-name descname"><span class="notation"><span>red</span></span></code><a class="headerlink" href="#coq:tacn.red" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to a goal that has the form:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall (x:T1) ... (xk:Tk), T
</pre></div>
</div>
<p>with <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> <span class="math notranslate nohighlight">\(\beta\)</span><span class="math notranslate nohighlight">\(\iota\)</span><span class="math notranslate nohighlight">\(\zeta\)</span>-reducing to <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span> <span class="name"><span class="pre">t</span></span></code><sub>1</sub> <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">t</span></span></code><sub>n</sub> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span></code> a
constant. If <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span></code> is transparent then it replaces <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span></code> with its
definition (say <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code>) and then reduces
<code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">t</span></span> <span class="name"><span class="pre">t</span></span></code><sub>1</sub> <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">t</span></span></code><sub>n</sub> <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">)</span></span></code> according to <span class="math notranslate nohighlight">\(\beta\)</span><span class="math notranslate nohighlight">\(\iota\)</span><span class="math notranslate nohighlight">\(\zeta\)</span>-reduction rules.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.not-reducible">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>reducible.</span></span></code><a class="headerlink" href="#coq:exn.not-reducible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.no-head-constant-to-reduce">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>head</span> <span>constant</span> <span>to</span> <span>reduce.</span></span></code><a class="headerlink" href="#coq:exn.no-head-constant-to-reduce" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.hnf">
<code class="sig-name descname"><span class="notation"><span>hnf</span></span></code><a class="headerlink" href="#coq:tacn.hnf" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. It replaces the current goal with its
head normal form according to the <span class="math notranslate nohighlight">\(\beta\)</span><span class="math notranslate nohighlight">\(\delta\)</span><span class="math notranslate nohighlight">\(\iota\)</span><span class="math notranslate nohighlight">\(\zeta\)</span>-reduction rules, i.e. it
reduces the head of the goal until it becomes a product or an
irreducible term. All inner <span class="math notranslate nohighlight">\(\beta\)</span><span class="math notranslate nohighlight">\(\iota\)</span>-redexes are also reduced.</p>
<p>Example: The term <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">fun</span></span> <span class="name variable"><span class="pre">n</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">nat</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n</span></span> <span class="operator"><span class="pre">+</span></span> <span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n</span></span></code> is not reduced by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">hnf</span></span></span></code>.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <span class="math notranslate nohighlight">\(\delta\)</span> rule only applies to transparent constants (see <a class="reference internal" href="vernacular-commands.html#vernac-controlling-the-reduction-strategies"><span class="std std-ref">Controlling the reduction strategies and the conversion algorithm</span></a>
on transparency and opacity).</p>
</div>
<dl class="coq tacn">
<dt id="coq:tacn.cbn">
<code class="sig-name descname"><span class="notation"><span>cbn</span></span></code><a class="headerlink" href="#coq:tacn.cbn" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacn.simpl">
<code class="sig-name descname"><span class="notation"><span>simpl</span></span></code><a class="headerlink" href="#coq:tacn.simpl" title="Permalink to this definition">¶</a></dt>
<dd><p>These tactics apply to any goal. They try to reduce a term to
something still readable instead of fully normalizing it. They perform
a sort of strong normalization with two key differences:</p>
<ul class="simple">
<li><p>They unfold a constant if and only if it leads to a <span class="math notranslate nohighlight">\(\iota\)</span>-reduction,
i.e. reducing a match or unfolding a fixpoint.</p></li>
<li><p>While reducing a constant unfolding to (co)fixpoints, the tactics
use the name of the constant the (co)fixpoint comes from instead of
the (co)fixpoint definition in recursive calls.</p></li>
</ul>
<p>The <a class="reference internal" href="#coq:tacn.cbn" title="cbn"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbn</span></code></a> tactic is claimed to be a more principled, faster and more
predictable replacement for <a class="reference internal" href="#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a>.</p>
<p>The <a class="reference internal" href="#coq:tacn.cbn" title="cbn"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbn</span></code></a> tactic accepts the same flags as <a class="reference internal" href="#coq:tacn.cbv" title="cbv"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbv</span></code></a> and
<a class="reference internal" href="#coq:tacn.lazy" title="lazy"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">lazy</span></code></a>. The behavior of both <a class="reference internal" href="#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a> and <a class="reference internal" href="#coq:tacn.cbn" title="cbn"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbn</span></code></a>
can be tuned using the Arguments vernacular command as follows:</p>
<ul>
<li><p>A constant can be marked to be never unfolded by <a class="reference internal" href="#coq:tacn.cbn" title="cbn"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbn</span></code></a> or
<a class="reference internal" href="#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a>:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Arguments</span> minus n m : <span class="nb">simpl</span> never.</span></span></span></pre></div></div>
<p>After that command an expression like <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">minus</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">)</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">)</span></span></code> is left
untouched by the tactics <a class="reference internal" href="#coq:tacn.cbn" title="cbn"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbn</span></code></a> and <a class="reference internal" href="#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a>.</p>
</li>
<li><p>A constant can be marked to be unfolded only if applied to enough
arguments. The number of arguments required can be specified using the
<code class="docutils literal notranslate"><span class="pre">/</span></code> symbol in the argument list of the <a class="reference internal" href="../language/gallina-extensions.html#coq:cmd.arguments-implicits" title="Arguments (implicits)"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Arguments</span></code></a> vernacular command.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">fcomp</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">f</span> (<span class="nv">g</span> : A -&gt; B) (<span class="nv">x</span> : A) : C := f (g x).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Arguments</span> fcomp {A B C} f g x /.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;f \o g&quot;</span> := (fcomp f g) (<span class="kn">at level</span> <span class="mi">50</span>).</span></span></span></pre></div></div>
<p>After that command the expression <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">f</span></span> <span class="operator"><span class="pre">\</span></span><span class="name"><span class="pre">o</span></span> <span class="name"><span class="pre">g</span></span><span class="operator"><span class="pre">)</span></span></code> is left untouched by
<a class="reference internal" href="#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a> while <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">((</span></span><span class="name"><span class="pre">f</span></span> <span class="operator"><span class="pre">\</span></span><span class="name"><span class="pre">o</span></span> <span class="name"><span class="pre">g</span></span><span class="operator"><span class="pre">)</span></span> <span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code> is reduced to <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">f</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">g</span></span> <span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">))</span></span></code>.
The same mechanism can be used to make a constant volatile, i.e.
always unfolded.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">volatile</span> := <span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Arguments</span> volatile / x.</span></span></span></pre></div></div>
</li>
<li><p>A constant can be marked to be unfolded only if an entire set of
arguments evaluates to a constructor. The <code class="docutils literal notranslate"><span class="pre">!</span></code> symbol can be used to mark
such arguments.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Arguments</span> minus !n !m.</span></span></span></pre></div></div>
<p>After that command, the expression <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">minus</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">)</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">)</span></span></code> is left untouched
by <a class="reference internal" href="#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a>, while <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">minus</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">))</span></span></code> is reduced to <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">minus</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">)</span></span></code>.</p>
</li>
<li><p>A special heuristic to determine if a constant has to be unfolded
can be activated with the following command:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Arguments</span> minus n m : <span class="nb">simpl</span> nomatch.</span></span></span></pre></div></div>
<p>The heuristic avoids to perform a simplification step that would expose a
match construct in head position. For example the expression
<code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">minus</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">))</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">))</span></span></code> is simplified to <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">minus</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">)</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">)</span></span></code>
even if an extra simplification is possible.</p>
</li>
</ul>
<p>In detail, the tactic <a class="reference internal" href="#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a> first applies <span class="math notranslate nohighlight">\(\beta\)</span><span class="math notranslate nohighlight">\(\iota\)</span>-reduction. Then, it
expands transparent constants and tries to reduce further using <span class="math notranslate nohighlight">\(\beta\)</span><span class="math notranslate nohighlight">\(\iota\)</span>-reduction.
But, when no <span class="math notranslate nohighlight">\(\iota\)</span> rule is applied after unfolding then
<span class="math notranslate nohighlight">\(\delta\)</span>-reductions are not applied. For instance trying to use <a class="reference internal" href="#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a> on
<code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">plus</span></span> <span class="name"><span class="pre">n</span></span> <span class="name"><span class="pre">O</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">n</span></span></code> changes nothing.</p>
<p>Notice that only transparent constants whose name can be reused in the
recursive calls are possibly unfolded by <a class="reference internal" href="#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a>. For instance a
constant defined by <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">plus'</span></span> <span class="operator"><span class="pre">:=</span></span> <span class="name"><span class="pre">plus</span></span></code> is possibly unfolded and reused in
the recursive calls, but a constant such as <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">succ</span></span> <span class="operator"><span class="pre">:=</span></span> <span class="name"><span class="pre">plus</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">O</span></span><span class="operator"><span class="pre">)</span></span></code> is
never unfolded. This is the main difference between <a class="reference internal" href="#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a> and <a class="reference internal" href="#coq:tacn.cbn" title="cbn"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbn</span></code></a>.
The tactic <a class="reference internal" href="#coq:tacn.cbn" title="cbn"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbn</span></code></a> reduces whenever it will be able to reuse it or not:
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">succ</span></span> <span class="name"><span class="pre">t</span></span></code> is reduced to <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">t</span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>cbn</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span> <span>]</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>cbn</span> <span>-</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span> <span>]</span></span></code></dt>
<dd><p>These are respectively synonyms of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cbn</span></span> <span><span class="pre">beta</span></span> <span><span class="pre">delta</span></span> <span><span class="pre">[</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">qualid</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">]</span></span> <span><span class="pre">iota</span></span> <span><span class="pre">zeta</span></span></span></code>
and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cbn</span></span> <span><span class="pre">beta</span></span> <span><span class="pre">delta</span></span> <span><span class="pre">-</span></span> <span><span class="pre">[</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">qualid</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">]</span></span> <span><span class="pre">iota</span></span> <span><span class="pre">zeta</span></span></span></code> (see <a class="reference internal" href="#coq:tacn.cbn" title="cbn"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbn</span></code></a>).</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simpl</span> <span class="hole">pattern</span></span></code></dt>
<dd><p>This applies <a class="reference internal" href="#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a> only to the subterms matching
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">pattern</span></span></span></code> in the current goal.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simpl</span> <span class="hole">pattern</span> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This applies <a class="reference internal" href="#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a> only to the <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">num</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> occurrences of the subterms
matching <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">pattern</span></span></span></code> in the current goal.</p>
<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Too</span> <span>few</span> <span>occurrences.</span></span></code></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simpl</span> <span class="hole">qualid</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simpl</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code></dt>
<dd><p>This applies <a class="reference internal" href="#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a> only to the applicative subterms whose head occurrence
is the unfoldable constant <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> (the constant can be referred to by
its notation using <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code> if such a notation exists).</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simpl</span> <span class="hole">qualid</span> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simpl</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This applies <a class="reference internal" href="#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a> only to the <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">num</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> applicative subterms whose
head occurrence is <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> (or <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code>).</p>
</dd></dl>

<dl class="coq flag">
<dt id="coq:flag.debug-rakam">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Debug</span> <span>RAKAM</span></span></code><a class="headerlink" href="#coq:flag.debug-rakam" title="Permalink to this definition">¶</a></dt>
<dd><p>This option makes <a class="reference internal" href="#coq:tacn.cbn" title="cbn"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbn</span></code></a> print various debugging information.
<code class="docutils literal notranslate"><span class="pre">RAKAM</span></code> is the Refolding Algebraic Krivine Abstract Machine.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.unfold">
<code class="sig-name descname"><span class="notation"><span>unfold</span> <span class="hole">qualid</span></span></code><a class="headerlink" href="#coq:tacn.unfold" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. The argument qualid must denote a
defined transparent constant or local definition (see
<a class="reference internal" href="../language/gallina-specification-language.html#gallina-definitions"><span class="std std-ref">Definitions</span></a> and
<a class="reference internal" href="vernacular-commands.html#vernac-controlling-the-reduction-strategies"><span class="std std-ref">Controlling the reduction strategies and the conversion algorithm</span></a>). The tactic
<a class="reference internal" href="#coq:tacn.unfold" title="unfold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unfold</span></code></a> applies the <span class="math notranslate nohighlight">\(\delta\)</span> rule to each occurrence
of the constant to which <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> refers in the current goal
and then replaces it with its <span class="math notranslate nohighlight">\(\beta\iota\zeta\)</span>-normal form.
Use the general reduction tactics if you want to avoid this final
reduction, for instance <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cbv</span></span> <span><span class="pre">delta</span></span> <span><span class="pre">[</span></span><span class="hole"><span class="pre">qualid</span></span><span><span class="pre">]</span></span></span></code>.</p>
<dl class="coq exn">
<dt id="coq:exn.cannot-coerce-qualid-to-an-evaluable-reference">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>coerce</span> <span class="hole">qualid</span> <span>to</span> <span>an</span> <span>evaluable</span> <span>reference.</span></span></code><a class="headerlink" href="#coq:exn.cannot-coerce-qualid-to-an-evaluable-reference" title="Permalink to this definition">¶</a></dt>
<dd><p>This error is frequent when trying to unfold something that has
defined as an inductive type (or constructor) and not as a
definition.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk5b" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="tactics-rst-chk5b"><span class="highlight"><span class="kn">Goal</span> <span class="mi">0</span> &lt;= <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt;= <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk5c" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="tactics-rst-chk5c"><span class="highlight"><span class="nb">unfold</span> le.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">Cannot coerce le to an evaluable reference.</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt;= <span class="mi">1</span></span></div></blockquote></div></div></small></span></pre></div></div>
<p>This error can also be raised if you are trying to unfold
something that has been marked as opaque.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input alectryon-failed"><span class="highlight"><span class="kn">Opaque</span> Nat.add.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk5d" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="tactics-rst-chk5d"><span class="highlight"><span class="kn">Goal</span> <span class="mi">1</span> + <span class="mi">0</span> = <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> + <span class="mi">0</span> = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk5e" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="tactics-rst-chk5e"><span class="highlight"><span class="nb">unfold</span> Nat.add.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">Cannot coerce Nat.add to an evaluable reference.</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> + <span class="mi">0</span> = <span class="mi">1</span></span></div></blockquote></div></div></small></span></pre></div></div>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>unfold</span> <span class="hole">qualid</span> <span>in</span> <span class="hole">goal_occurrences</span></span></code></dt>
<dd><p>Replaces <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> in hypothesis (or hypotheses) designated
by <code class="xref std std-token docutils literal notranslate"><span class="pre">goal_occurrences</span></code> with its definition and replaces
the hypothesis with its <span class="math notranslate nohighlight">\(\beta\)</span><span class="math notranslate nohighlight">\(\iota\)</span> normal form.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>unfold</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>Replaces <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">qualid</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></code> with their definitions and replaces
the current goal with its <span class="math notranslate nohighlight">\(\beta\)</span><span class="math notranslate nohighlight">\(\iota\)</span> normal
form.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>unfold</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span> <span>at</span> <span class="hole">occurrences</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>The list <code class="xref std std-token docutils literal notranslate"><span class="pre">occurrences</span></code> specify the occurrences of
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> to be unfolded. Occurrences are located from left
to right.</p>
<dl class="coq exn">
<dt id="coq:exn.bad-occurrence-number-of-qualid">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Bad</span> <span>occurrence</span> <span>number</span> <span>of</span> <span class="hole">qualid</span><span>.</span></span></code><a class="headerlink" href="#coq:exn.bad-occurrence-number-of-qualid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.qualid-does-not-occur">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">qualid</span> <span>does</span> <span>not</span> <span>occur.</span></span></code><a class="headerlink" href="#coq:exn.qualid-does-not-occur" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>unfold</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code> denotes the discriminating symbol of a notation
(e.g. &quot;+&quot;) or an expression defining a notation (e.g. <code class="docutils literal notranslate"><span class="pre">&quot;_</span> <span class="pre">+</span>
<span class="pre">_&quot;</span></code>), and this notation denotes an application whose head symbol
is an unfoldable constant, then the tactic unfolds it.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>unfold</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a><span>%</span><span class="hole">ident</span></span></code></dt>
<dd><p>This is variant of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">unfold</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code> where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code> gets
its interpretation from the scope bound to the delimiting key
<code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> instead of its default interpretation (see
<a class="reference internal" href="../user-extensions/syntax-extensions.html#localinterpretationrulesfornotations"><span class="std std-ref">Local interpretation rules for notations</span></a>).</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>unfold</span> <span class="repeat-wrapper"><span class="repeat"><span class="alternative"><span class="alternative-block"><span class="hole">qualid</span></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a><span class="repeat-wrapper"><span class="repeat"><span>%</span><span class="hole">ident</span></span><span class="notation-sup">?</span></span></span></span> <span class="repeat-wrapper"><span class="repeat"><span>at</span> <span class="hole">occurrences</span></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <span class="hole">goal_occurrences</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This is the most general form.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.fold">
<code class="sig-name descname"><span class="notation"><span>fold</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.fold" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. The term <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> is reduced using the
<a class="reference internal" href="#coq:tacn.red" title="red"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">red</span></code></a> tactic. Every occurrence of the resulting <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> in the goal is
then replaced by <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>. This tactic is particularly useful when a fixpoint
definition has been wrongfully unfolded, making the goal very hard to read.
On the other hand, when an unfolded function applied to its argument has been
reduced, the <a class="reference internal" href="#coq:tacn.fold" title="fold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fold</span></code></a> tactic won't do anything.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk5f" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk5f"><span class="highlight"><span class="kn">Goal</span> ~<span class="mi">0</span>=<span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt;&gt; <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk60" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk60"><span class="highlight"><span class="nb">unfold</span> not.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span> -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk61" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk61"><span class="highlight"><span class="kn">Fail</span> <span class="kp">progress</span> <span class="nb">fold</span> not.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
Failed to <span class="kp">progress</span>.</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span> -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk62" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk62"><span class="highlight"><span class="nb">pattern</span> (<span class="mi">0</span> = <span class="mi">0</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">P</span> : <span class="kt">Prop</span> =&gt; P -&gt; <span class="kt">False</span>) (<span class="mi">0</span> = <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk63" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk63"><span class="highlight"><span class="nb">fold</span> not.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt;&gt; <span class="mi">0</span></span></div></blockquote></div></div></small></span></pre></div></div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>fold</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">fold</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">;</span></span> <span><span class="pre">...</span></span> <span><span class="pre">;</span></span> <span><span class="pre">fold</span></span> <span class="hole"><span class="pre">term</span></span></span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.pattern">
<code class="sig-name descname"><span class="notation"><span>pattern</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>This command applies to any goal. The argument <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> must be a free
subterm of the current goal. The command pattern performs <span class="math notranslate nohighlight">\(\beta\)</span>-expansion
(the inverse of <span class="math notranslate nohighlight">\(\beta\)</span>-reduction) of the current goal (say <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code>) by</p>
<ul class="simple">
<li><p>replacing all occurrences of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> in <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> with a fresh variable</p></li>
<li><p>abstracting this variable</p></li>
<li><p>applying the abstracted goal to <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code></p></li>
</ul>
<p>For instance, if the current goal <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> is expressible as
<span class="math notranslate nohighlight">\(\varphi\)</span><code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code> where the notation captures all the instances of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code>
in <span class="math notranslate nohighlight">\(\varphi\)</span><code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code>, then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pattern</span></span> <span><span class="pre">t</span></span></span></code> transforms it into
<code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="keyword reserved"><span class="pre">fun</span></span> <span class="name variable"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">=&gt;</span></span></code> <span class="math notranslate nohighlight">\(\varphi\)</span><code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">))</span></span> <span class="name"><span class="pre">t</span></span></code>. This tactic can be used, for
instance, when the tactic <code class="docutils literal notranslate"><span class="pre">apply</span></code> fails on matching.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>pattern</span> <span class="hole">term</span> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Only the occurrences <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">num</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> are considered for
<span class="math notranslate nohighlight">\(\beta\)</span>-expansion. Occurrences are located from left to right.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>pattern</span> <span class="hole">term</span> <span>at</span> <span>-</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>All occurrences except the occurrences of indexes <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">num</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>
of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> are considered for <span class="math notranslate nohighlight">\(\beta\)</span>-expansion. Occurrences are located from
left to right.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>pattern</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>Starting from a goal <span class="math notranslate nohighlight">\(\varphi\)</span><code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">t</span></span></code><sub>1</sub> <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">t</span></span></code><sub>m</sub><code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">)</span></span></code>,
the tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pattern</span></span> <span><span class="pre">t</span></span></span></code><sub>1</sub><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">,</span></span> <span><span class="pre">...,</span></span> <span><span class="pre">t</span></span></span></code><sub>m</sub> generates the
equivalent goal
<code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="keyword reserved"><span class="pre">fun</span></span> <span class="operator"><span class="pre">(</span></span><span class="name variable"><span class="pre">x</span></span></code><sub>1</sub><code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">A</span></span></code><sub>1</sub><code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">...</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span></code><sub>m</sub> <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">A</span></span></code><sub>m</sub> <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">=&gt;</span></span></code><span class="math notranslate nohighlight">\(\varphi\)</span><code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span></code><sub>1</sub> <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">x</span></span></code><sub>m</sub> <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">))</span></span> <span class="name"><span class="pre">t</span></span></code><sub>1</sub> <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">t</span></span></code><sub>m</sub>.
If <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code><sub>i</sub> occurs in one of the generated types <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code><sub>j</sub> these
occurrences will also be considered and possibly abstracted.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>pattern</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">+</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>This behaves as above but processing only the occurrences <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">num</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> of
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> starting from <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>pattern</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>at</span> <span class="repeat-wrapper"><span class="repeat"><span>-</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>This is the most general syntax that combines the different variants.</p>
</dd></dl>

<div class="section" id="conversion-tactics-applied-to-hypotheses">
<h3>Conversion tactics applied to hypotheses<a class="headerlink" href="#conversion-tactics-applied-to-hypotheses" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span class="hole">tactic</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>Applies <code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code> (any of the conversion tactics listed in this
section) to the hypotheses <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
<p>If <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is a local definition, then <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> can be replaced by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">type</span></span> <span><span class="pre">of</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> to address not the body but the type of the local
definition.</p>
<p>Example: <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">unfold</span></span> <span><span class="pre">not</span></span> <span><span class="pre">in</span></span> <span><span class="pre">(type</span></span> <span><span class="pre">of</span></span> <span><span class="pre">H1)</span></span> <span><span class="pre">(type</span></span> <span><span class="pre">of</span></span> <span><span class="pre">H3)</span></span></span></code>.</p>
</dd></dl>

<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis:</span> <span class="hole">ident</span><span>.</span></span></code></dt>
<dd></dd></dl>

</div>
</div>
<div class="section" id="automation">
<span id="id10"></span><h2>Automation<a class="headerlink" href="#automation" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt id="coq:tacn.auto">
<code class="sig-name descname"><span class="notation"><span>auto</span></span></code><a class="headerlink" href="#coq:tacn.auto" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic implements a Prolog-like resolution procedure to solve the
current goal. It first tries to solve the goal using the <a class="reference internal" href="#coq:tacn.assumption" title="assumption"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assumption</span></code></a>
tactic, then it reduces the goal to an atomic one using <a class="reference internal" href="#coq:tacv.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> and
introduces the newly generated hypotheses as hints. Then it looks at
the list of tactics associated to the head symbol of the goal and
tries to apply one of them (starting from the tactics with lower
cost). This process is recursively applied to the generated subgoals.</p>
<p>By default, <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> only uses the hypotheses of the current goal and
the hints of the database named <code class="docutils literal notranslate"><span class="pre">core</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> uses a weaker version of <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> that is closer to
<a class="reference internal" href="#coq:tacv.simple-apply" title="simple apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simple</span> <span class="pre">apply</span></code></a> so it is expected that sometimes <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> will
fail even if applying manually one of the hints would succeed.</p>
</div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>auto</span> <span class="hole">num</span></span></code></dt>
<dd><p>Forces the search depth to be <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code>. The maximal search depth
is 5 by default.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>auto</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Uses the hint databases <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> in addition to the database <code class="docutils literal notranslate"><span class="pre">core</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use the fake database <code class="docutils literal notranslate"><span class="pre">nocore</span></code> if you want to <em>not</em> use the <code class="docutils literal notranslate"><span class="pre">core</span></code>
database.</p>
</div>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>auto</span> <span>with</span> <span>*</span></span></code></dt>
<dd><p>Uses all existing hint databases. Using this variant is highly discouraged
in finished scripts since it is both slower and less robust than the variant
where the required databases are explicitly listed.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#thehintsdatabasesforautoandeauto"><span class="std std-ref">The Hints Databases for auto and eauto</span></a> for the list of
pre-defined databases and the way to create or extend a database.</p>
</div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>auto</span> <span>using</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid<sub>i</sub></span></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>Uses lemmas <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span><sub><span class="pre">i</span></sub></span></span></code> in addition to hints. If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> is an
inductive type, it is the collection of its constructors which are added
as hints.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The hints passed through the <code class="docutils literal notranslate"><span class="pre">using</span></code> clause are used in the same
way as if they were passed through a hint database. Consequently,
they use a weaker version of <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">auto</span></span> <span><span class="pre">using</span></span> <span class="hole"><span class="pre">qualid</span></span></span></code>
may fail where <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <span class="hole"><span class="pre">qualid</span></span></span></code> succeeds.</p>
<p>Given that this can be seen as counter-intuitive, it could be useful
to have an option to use full-blown <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> for lemmas passed
through the <code class="docutils literal notranslate"><span class="pre">using</span></code> clause. Contributions welcome!</p>
</div>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>info</span><span>_</span><span>auto</span></span></code></dt>
<dd><p>Behaves like <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> but shows the tactics it uses to solve the goal. This
variant is very useful for getting a better understanding of automation, or
to know what lemmas/assumptions were used.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.debug-auto">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>debug</span> <span>auto</span></span></code><a class="headerlink" href="#coq:tacv.debug-auto" title="Permalink to this definition">¶</a></dt>
<dd><p>Behaves like <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> but shows the tactics it tries to solve the goal,
including failing paths.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>info</span><span>_</span></span><span class="notation-sup">?</span></span><span>auto</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>using</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This is the most general form, combining the various options.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.trivial">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>trivial</span></span></code><a class="headerlink" href="#coq:tacv.trivial" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic is a restriction of <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> that is not recursive
and tries only hints that cost <code class="docutils literal notranslate"><span class="pre">0</span></code>. Typically it solves trivial
equalities like <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">X</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">X</span></span></code>.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>trivial</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>trivial</span> <span>with</span> <span>*</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>trivial</span> <span>using</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dt id="coq:tacv.debug-trivial">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>debug</span> <span>trivial</span></span></code><a class="headerlink" href="#coq:tacv.debug-trivial" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacv.info-trivial">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>info</span><span>_</span><span>trivial</span></span></code><a class="headerlink" href="#coq:tacv.info-trivial" title="Permalink to this definition">¶</a></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>info</span><span>_</span></span><span class="notation-sup">?</span></span><span>trivial</span> <span class="repeat-wrapper"><span class="repeat"><span>using</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> and <a class="reference internal" href="#coq:tacv.trivial" title="trivial"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">trivial</span></code></a> either solve completely the goal or
else succeed without changing the goal. Use <code class="code highlight coq docutils literal notranslate"><span class="keyword pseudo"><span class="pre">solve</span></span> <span class="operator"><span class="pre">[</span></span> <span class="name builtin"><span class="pre">auto</span></span> <span class="operator"><span class="pre">]</span></span></code> and
<code class="code highlight coq docutils literal notranslate"><span class="keyword pseudo"><span class="pre">solve</span></span> <span class="operator"><span class="pre">[</span></span> <span class="name builtin"><span class="pre">trivial</span></span> <span class="operator"><span class="pre">]</span></span></code> if you would prefer these tactics to fail when
they do not manage to solve the goal.</p>
</div>
<dl class="coq flag">
<dt id="coq:flag.info-auto">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Info</span> <span>Auto</span></span></code><a class="headerlink" href="#coq:flag.info-auto" title="Permalink to this definition">¶</a></dt>
<dt id="coq:flag.debug-auto">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Debug</span> <span>Auto</span></span></code><a class="headerlink" href="#coq:flag.debug-auto" title="Permalink to this definition">¶</a></dt>
<dt id="coq:flag.info-trivial">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Info</span> <span>Trivial</span></span></code><a class="headerlink" href="#coq:flag.info-trivial" title="Permalink to this definition">¶</a></dt>
<dt id="coq:flag.debug-trivial">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Debug</span> <span>Trivial</span></span></code><a class="headerlink" href="#coq:flag.debug-trivial" title="Permalink to this definition">¶</a></dt>
<dd><p>These options enable printing of informative or debug information for
the <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> and <a class="reference internal" href="#coq:tacv.trivial" title="trivial"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">trivial</span></code></a> tactics.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.eauto">
<code class="sig-name descname"><span class="notation"><span>eauto</span></span></code><a class="headerlink" href="#coq:tacn.eauto" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic generalizes <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a>. While <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> does not try
resolution hints which would leave existential variables in the goal,
<a class="reference internal" href="#coq:tacn.eauto" title="eauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eauto</span></code></a> does try them (informally speaking, it internally uses a tactic
close to <a class="reference internal" href="#coq:tacv.simple-eapply" title="simple eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simple</span> <span class="pre">eapply</span></code></a> instead of a tactic close to <a class="reference internal" href="#coq:tacv.simple-apply" title="simple apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simple</span> <span class="pre">apply</span></code></a>
in the case of <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a>). As a consequence, <a class="reference internal" href="#coq:tacn.eauto" title="eauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eauto</span></code></a>
can solve such a goal:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> ex_intro : core.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk64" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk64"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">P</span>:nat -&gt; <span class="kt">Prop</span>, P <span class="mi">0</span> -&gt; <span class="kr">exists</span> <span class="nv">n</span>, P n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>, P <span class="mi">0</span> -&gt; <span class="kr">exists</span> <span class="nv">n</span> : nat, P n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eauto</span>.</span></span></span></pre></div><p>Note that <code class="docutils literal notranslate"><span class="pre">ex_intro</span></code> should be declared as a hint.</p>
</div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>info</span><span>_</span></span><span class="notation-sup">?</span></span><span>eauto</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>using</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>The various options for <a class="reference internal" href="#coq:tacn.eauto" title="eauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eauto</span></code></a> are the same as for <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a>.</p>
</dd></dl>

<p><a class="reference internal" href="#coq:tacn.eauto" title="eauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eauto</span></code></a> also obeys the following options:</p>
<dl class="coq flag">
<dt id="coq:flag.info-eauto">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Info</span> <span>Eauto</span></span></code><a class="headerlink" href="#coq:flag.info-eauto" title="Permalink to this definition">¶</a></dt>
<dt id="coq:flag.debug-eauto">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Debug</span> <span>Eauto</span></span></code><a class="headerlink" href="#coq:flag.debug-eauto" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#thehintsdatabasesforautoandeauto"><span class="std std-ref">The Hints Databases for auto and eauto</span></a></p>
</div>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.autounfold">
<code class="sig-name descname"><span class="notation"><span>autounfold</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn.autounfold" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic unfolds constants that were declared through a <a class="reference internal" href="#coq:cmdv.hint-unfold" title="Hint Unfold"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Unfold</span></code></a>
in the given databases.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>autounfold</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>in</span> <span class="hole">goal_occurrences</span></span></code></dt>
<dd><p>Performs the unfolding in the given clause (<code class="xref std std-token docutils literal notranslate"><span class="pre">goal_occurrences</span></code>).</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>autounfold</span> <span>with</span> <span>*</span></span></code></dt>
<dd><p>Uses the unfold hints declared in all the hint databases.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.autorewrite">
<code class="sig-name descname"><span class="notation"><span>autorewrite</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn.autorewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic carries out rewritings according to the rewriting rule
bases <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
<p>Each rewriting rule from the base <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is applied to the main subgoal until
it fails. Once all the rules have been processed, if the main subgoal has
progressed (e.g., if it is distinct from the initial main goal) then the rules
of this base are processed again. If the main subgoal has not progressed then
the next base is processed. For the bases, the behavior is exactly similar to
the processing of the rewriting rules.</p>
<p>The rewriting rule bases are built with the <a class="reference internal" href="#coq:cmd.hint-rewrite" title="Hint Rewrite"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Rewrite</span></code></a>
command.</p>
</dd></dl>

<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This tactic may loop if you build non terminating rewriting systems.</p>
</div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>autorewrite</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>using</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>Performs, in the same way, all the rewritings of the bases <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>
applying tactic to the main subgoal after each rewriting step.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>autorewrite</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>in</span> <span class="hole">qualid</span></span></code></dt>
<dd><p>Performs all the rewritings in hypothesis <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>autorewrite</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>in</span> <span class="hole">qualid</span> <span>using</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>Performs all the rewritings in hypothesis <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> applying <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code>
to the main subgoal after each rewriting step.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>autorewrite</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>in</span> <span class="hole">goal_occurrences</span></span></code></dt>
<dd><p>Performs all the rewriting in the clause <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">goal_occurrences</span></span></span></code>.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hintrewrite"><span class="std std-ref">Hint-Rewrite</span></a> for feeding the database of lemmas used by
<a class="reference internal" href="#coq:tacn.autorewrite" title="autorewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">autorewrite</span></code></a> and <a class="reference internal" href="#coq:tacn.autorewrite" title="autorewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">autorewrite</span></code></a> for examples showing the use of this tactic.</p>
</div>
<dl class="coq tacn">
<dt id="coq:tacn.easy">
<code class="sig-name descname"><span class="notation"><span>easy</span></span></code><a class="headerlink" href="#coq:tacn.easy" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic tries to solve the current goal by a number of standard closing steps.
In particular, it tries to close the current goal using the closing tactics
<a class="reference internal" href="#coq:tacv.trivial" title="trivial"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">trivial</span></code></a>, <a class="reference internal" href="#coq:tacn.reflexivity" title="reflexivity"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">reflexivity</span></code></a>, <a class="reference internal" href="#coq:tacn.symmetry" title="symmetry"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">symmetry</span></code></a>, <a class="reference internal" href="#coq:tacn.contradiction" title="contradiction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">contradiction</span></code></a>
and <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> of hypothesis.
If this fails, it tries introducing variables and splitting and-hypotheses,
using the closing tactics afterwards, and splitting the goal using
<a class="reference internal" href="#coq:tacv.split" title="split"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">split</span></code></a> and recursing.</p>
<p>This tactic solves goals that belong to many common classes; in particular, many cases of
unsatisfiable hypotheses, and simple equality goals are usually solved by this tactic.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.now">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>now</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:tacv.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Run <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> followed by <a class="reference internal" href="#coq:tacn.easy" title="easy"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">easy</span></code></a>. This is a notation for <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span><span><span class="pre">;</span></span> <span><span class="pre">easy</span></span></span></code>.</p>
</dd></dl>

</div>
<div class="section" id="controlling-automation">
<h2>Controlling automation<a class="headerlink" href="#controlling-automation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-hints-databases-for-auto-and-eauto">
<span id="thehintsdatabasesforautoandeauto"></span><h3>The hints databases for auto and eauto<a class="headerlink" href="#the-hints-databases-for-auto-and-eauto" title="Permalink to this headline">¶</a></h3>
<p>The hints for <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> and <a class="reference internal" href="#coq:tacn.eauto" title="eauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eauto</span></code></a> are stored in databases. Each database
maps head symbols to a list of hints.</p>
<dl class="coq cmd">
<dt id="coq:cmd.print-hint">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Print</span> <span>Hint</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:cmd.print-hint" title="Permalink to this definition">¶</a></dt>
<dd><p>Use this command
to display the hints associated to the head symbol <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>
(see <a class="reference internal" href="#printhint"><span class="std std-ref">Print Hint</span></a>). Each hint has a cost that is a nonnegative
integer, and an optional pattern. The hints with lower cost are tried first. A
hint is tried by <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> when the conclusion of the current goal matches its
pattern or when it has no pattern.</p>
</dd></dl>

<div class="section" id="creating-hint-databases">
<h4>Creating Hint databases<a class="headerlink" href="#creating-hint-databases" title="Permalink to this headline">¶</a></h4>
<p>One can optionally declare a hint database using the command
<a class="reference internal" href="#coq:cmd.create-hintdb" title="Create HintDb"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Create</span> <span class="pre">HintDb</span></code></a>. If a hint is added to an unknown database, it will be
automatically created.</p>
<dl class="coq cmd">
<dt id="coq:cmd.create-hintdb">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Create</span> <span>HintDb</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span>discriminated</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.create-hintdb" title="Permalink to this definition">¶</a></dt>
<dd><p>This command creates a new database named <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>. The database is
implemented by a Discrimination Tree (DT) that serves as an index of
all the lemmas. The DT can use transparency information to decide if a
constant should be indexed or not
(c.f. <a class="reference internal" href="#thehintsdatabasesforautoandeauto"><span class="std std-ref">The hints databases for auto and eauto</span></a>),
making the retrieval more efficient. The legacy implementation (the default one
for new databases) uses the DT only on goals without existentials (i.e., <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a>
goals), for non-Immediate hints and does not make use of transparency
hints, putting more work on the unification that is run after
retrieval (it keeps a list of the lemmas in case the DT is not used).
The new implementation enabled by the discriminated option makes use
of DTs in all cases and takes transparency information into account.
However, the order in which hints are retrieved from the DT may differ
from the order in which they were inserted, making this implementation
observationally different from the legacy one.</p>
</dd></dl>

<dl class="coq cmd">
<dt id="coq:cmd.hint">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <a class="reference internal" href="#grammar-token-hint_definition"><span class="hole">hint_definition</span></a> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.hint" title="Permalink to this definition">¶</a></dt>
<dd><p>The general command to add a hint to some databases <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.
The various possible <span class="inline-grammar-production"><span class="target" id="grammar-token-hint_definition"></span><code class="docutils literal notranslate"><span class="pre">hint_definition</span></code></span>s are given below.</p>
<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <a class="reference internal" href="#grammar-token-hint_definition"><span class="hole">hint_definition</span></a></span></code></dt>
<dd><p>No database name is given: the hint is registered in the <code class="docutils literal notranslate"><span class="pre">core</span></code> database.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 8.10.</span></p>
</div>
</dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Local</span> <span>Hint</span> <a class="reference internal" href="#grammar-token-hint_definition"><span class="hole">hint_definition</span></a> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This is used to declare hints that must not be exported to the other modules
that require and import the current module. Inside a section, the option
Local is useless since hints do not survive anyway to the closure of
sections.</p>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.hint-resolve">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Resolve</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat">| <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">pattern</span></span><span class="notation-sup">?</span></span></span><span class="notation-sup">?</span></span> <span>:</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:cmdv.hint-resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>This command adds <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simple</span></span> <span><span class="pre">apply</span></span> <span class="hole"><span class="pre">term</span></span></span></code> to the hint list with the head
symbol of the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>. The cost of that hint is the number of
subgoals generated by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simple</span></span> <span><span class="pre">apply</span></span> <span class="hole"><span class="pre">term</span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code> if specified. The
associated <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">pattern</span></span></span></code> is inferred from the conclusion of the type of
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> or the given <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">pattern</span></span></span></code> if specified. In case the inferred type
of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> does not start with a product the tactic added in the hint list
is <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">exact</span></span> <span class="hole"><span class="pre">term</span></span></span></code>. In case this type can however be reduced to a type
starting with a product, the tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simple</span></span> <span><span class="pre">apply</span></span> <span class="hole"><span class="pre">term</span></span></span></code> is also stored in
the hints list. If the inferred type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> contains a dependent
quantification on a variable which occurs only in the premisses of the type
and not in its conclusion, no instance could be inferred for the variable by
unification with the goal. In this case, the hint is added to the hint list
of <a class="reference internal" href="#coq:tacn.eauto" title="eauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eauto</span></code></a> instead of the hint list of auto and a warning is printed. A
typical example of a hint that is used only by <a class="reference internal" href="#coq:tacn.eauto" title="eauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eauto</span></code></a> is a transitivity
lemma.</p>
<dl class="coq exn">
<dt id="coq:exn.term-cannot-be-used-as-a-hint">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">term</span> <span>cannot</span> <span>be</span> <span>used</span> <span>as</span> <span>a</span> <span>hint</span></span></code><a class="headerlink" href="#coq:exn.term-cannot-be-used-as-a-hint" title="Permalink to this definition">¶</a></dt>
<dd><p>The head symbol of the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> is a bound variable
such that this tactic cannot be associated to a constant.</p>
</dd></dl>

</dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Resolve</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span></span> <span>:</span> <span class="hole">ident</span></span></code></dt>
<dd><p>Adds each <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Hint</span></span> <span><span class="pre">Resolve</span></span> <span class="hole"><span class="pre">term</span></span></span></code>.</p>
</dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Resolve</span> <span>-&gt;</span> <span class="hole">term</span> <span>:</span> <span class="hole">ident</span></span></code></dt>
<dd><p>Adds the left-to-right implication of an equivalence as a hint (informally
the hint will be used as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <span><span class="pre">&lt;-</span></span> <span class="hole"><span class="pre">term</span></span></span></code>, although as mentioned
before, the tactic actually used is a restricted version of
<a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>).</p>
</dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Resolve</span> <span>&lt;-</span> <span class="hole">term</span></span></code></dt>
<dd><p>Adds the right-to-left implication of an equivalence  as a hint.</p>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.hint-immediate">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Immediate</span> <span class="hole">term</span> <span>:</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:cmdv.hint-immediate" title="Permalink to this definition">¶</a></dt>
<dd><p>This command adds <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simple</span></span> <span><span class="pre">apply</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">;</span></span> <span><span class="pre">trivial</span></span></span></code> to the hint list associated
with the head symbol of the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> in the given database. This
tactic will fail if all the subgoals generated by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simple</span></span> <span><span class="pre">apply</span></span> <span class="hole"><span class="pre">term</span></span></span></code> are
not solved immediately by the <a class="reference internal" href="#coq:tacv.trivial" title="trivial"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">trivial</span></code></a> tactic (which only tries tactics
with cost 0).This command is useful for theorems such as the symmetry of
equality or <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">+</span></span><span class="literal number integer"><span class="pre">1</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">+</span></span><span class="literal number integer"><span class="pre">1</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">m</span></span></code> that we may like to introduce with a limited
use in order to avoid useless proof-search. The cost of this tactic (which
never generates subgoals) is always 1, so that it is not used by <a class="reference internal" href="#coq:tacv.trivial" title="trivial"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">trivial</span></code></a>
itself.</p>
</dd></dl>

<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">term</span> <span>cannot</span> <span>be</span> <span>used</span> <span>as</span> <span>a</span> <span>hint</span></span></code></dt>
<dd></dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Immediate</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span></span> <span>:</span> <span class="hole">ident</span></span></code></dt>
<dd><p>Adds each <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Hint</span></span> <span><span class="pre">Immediate</span></span> <span class="hole"><span class="pre">term</span></span></span></code>.</p>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.hint-constructors">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Constructors</span> <span class="hole">qualid</span> <span>:</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:cmdv.hint-constructors" title="Permalink to this definition">¶</a></dt>
<dd><p>If <code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code> is an inductive type, this command adds all its constructors as
hints of type <code class="docutils literal notranslate"><span class="pre">Resolve</span></code>. Then, when the conclusion of current goal has the form
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="hole"><span class="pre">qualid</span></span> <span><span class="pre">...)</span></span></span></code>, <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> will try to apply each constructor.</p>
<dl class="coq exn">
<dt id="coq:exn.qualid-is-not-an-inductive-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">qualid</span> <span>is</span> <span>not</span> <span>an</span> <span>inductive</span> <span>type</span></span></code><a class="headerlink" href="#coq:exn.qualid-is-not-an-inductive-type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Constructors</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span> <span>:</span> <span class="hole">ident</span></span></code></dt>
<dd><p>Extends the previous command for several inductive types.</p>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.hint-unfold">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Unfold</span> <span class="hole">qualid</span> <span>:</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:cmdv.hint-unfold" title="Permalink to this definition">¶</a></dt>
<dd><p>This adds the tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">unfold</span></span> <span class="hole"><span class="pre">qualid</span></span></span></code> to the hint list that will only be
used when the head constant of the goal is <code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code>.
Its cost is 4.</p>
</dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Unfold</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Extends the previous command for several defined constants.</p>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.hint-transparent">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Transparent</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span> <span>:</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:cmdv.hint-transparent" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.hint-opaque">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Opaque</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span> <span>:</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:cmdv.hint-opaque" title="Permalink to this definition">¶</a></dt>
<dd><p>This adds transparency hints to the database, making <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code>
transparent or opaque constants during resolution. This information is used
during unification of the goal with any lemma in the database and inside the
discrimination network to relax or constrain it in the case of discriminated
databases.</p>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.hint-variables">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Variables</span> <span class="alternative"><span class="alternative-block"><span>Transparent</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>Opaque</span></span></span> <span>:</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:cmdv.hint-variables" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.hint-constants">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Constants</span> <span class="alternative"><span class="alternative-block"><span>Transparent</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>Opaque</span></span></span> <span>:</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:cmdv.hint-constants" title="Permalink to this definition">¶</a></dt>
<dd><p>This sets the transparency flag used during unification of
hints in the database for all constants or all variables,
overwriting the existing settings of opacity. It is advised
to use this just after a <a class="reference internal" href="#coq:cmd.create-hintdb" title="Create HintDb"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Create</span> <span class="pre">HintDb</span></code></a> command.</p>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.hint-extern">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Extern</span> <span class="hole">num</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">pattern</span></span><span class="notation-sup">?</span></span> <span>=&gt;</span> <span class="hole">tactic</span> <span>:</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:cmdv.hint-extern" title="Permalink to this definition">¶</a></dt>
<dd><p>This hint type is to extend <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> with tactics other than <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> and
<a class="reference internal" href="#coq:tacn.unfold" title="unfold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unfold</span></code></a>. For that, we must specify a cost, an optional <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">pattern</span></span></span></code> and a
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> to execute.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Extern</span> <span class="mi">4</span> (~(_ = _)) =&gt; <span class="bp">discriminate</span> : core.</span></span></span></pre></div><p>Now, when the head of the goal is a disequality, <code class="docutils literal notranslate"><span class="pre">auto</span></code> will try
discriminate if it does not manage to solve the goal with hints with a
cost less than 4.</p>
</div>
<p>One can even use some sub-patterns of the pattern in
the tactic script. A sub-pattern is a question mark followed by an
identifier, like <code class="docutils literal notranslate"><span class="pre">?X1</span></code> or <code class="docutils literal notranslate"><span class="pre">?X2</span></code>. Here is an example:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> List.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Extern</span> <span class="mi">5</span> ({?X1 = ?X2} + {?X1 &lt;&gt; ?X2}) =&gt; <span class="nb">generalize</span>  X1, X2; <span class="bp">decide equality</span> : eqdec.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk65" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk65"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>:list (nat * nat), {a = b} + {a &lt;&gt; b}.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : list (nat * nat), {a = b} + {a &lt;&gt; b}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk66" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk66"><span class="highlight"><span class="kn">Info</span> <span class="mi">1</span> <span class="nb">auto with</span> eqdec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">&lt;ltac_plugin::<span class="nb">auto</span>@<span class="mi">0</span>&gt; eqdec</span></blockquote></div></div></small></span></pre></div></div>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.hint-cut">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Cut</span> <span class="hole">regexp</span> <span>:</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:cmdv.hint-cut" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>These hints currently only apply to typeclass proof search and the
<a class="reference internal" href="../addendum/type-classes.html#coq:tacn.typeclasses-eauto" title="typeclasses eauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">typeclasses</span> <span class="pre">eauto</span></code></a> tactic.</p>
</div>
<p>This command can be used to cut the proof-search tree according to a regular
expression matching paths to be cut. The grammar for regular expressions is
the following. Beware, there is no operator precedence during parsing, one can
check with <a class="reference internal" href="#coq:cmd.print-hintdb" title="Print HintDb"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Print</span> <span class="pre">HintDb</span></code></a> to verify the current cut expression:</p>
<pre>
<strong id="grammar-token-regexp-regexp"><span id="grammar-token-regexp"></span>regexp</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>          (hint or instance identifier)
            _             (any hint)
            <code class="xref docutils literal notranslate"><span class="pre">regexp</span></code> | <code class="xref docutils literal notranslate"><span class="pre">regexp</span></code> (disjunction)
            <code class="xref docutils literal notranslate"><span class="pre">regexp</span></code> <code class="xref docutils literal notranslate"><span class="pre">regexp</span></code>   (sequence)
            <code class="xref docutils literal notranslate"><span class="pre">regexp</span></code> *       (Kleene star)
            emp           (empty)
            eps           (epsilon)
            ( <code class="xref docutils literal notranslate"><span class="pre">regexp</span></code> )
</pre>
<p>The <code class="docutils literal notranslate"><span class="pre">emp</span></code> regexp does not match any search path while <code class="docutils literal notranslate"><span class="pre">eps</span></code>
matches the empty path. During proof search, the path of
successive successful hints on a search branch is recorded, as a
list of identifiers for the hints (note that <a class="reference internal" href="#coq:cmdv.hint-extern" title="Hint Extern"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Extern</span></code></a>’s do not have
an associated identifier).
Before applying any hint <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> the current path <code class="docutils literal notranslate"><span class="pre">p</span></code> extended with
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is matched against the current cut expression <code class="docutils literal notranslate"><span class="pre">c</span></code> associated to
the hint database. If matching succeeds, the hint is <em>not</em> applied. The
semantics of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Hint</span></span> <span><span class="pre">Cut</span></span> <span class="hole"><span class="pre">regexp</span></span></span></code> is to set the cut expression
to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">c</span></span> <span class="pre">|</span> <span><span class="pre">regexp</span></span></span></code>, the initial cut expression being <code class="docutils literal notranslate"><span class="pre">emp</span></code>.</p>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.hint-mode">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Mode</span> <span class="hole">qualid</span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span>+</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>!</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>-</span></span></span></span><span class="notation-sup">*</span></span> <span>:</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:cmdv.hint-mode" title="Permalink to this definition">¶</a></dt>
<dd><p>This sets an optional mode of use of the identifier <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code>. When
proof-search faces a goal that ends in an application of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> to
arguments <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span> <span><span class="pre">...</span></span> <span class="hole"><span class="pre">term</span></span></span></code>, the mode tells if the hints associated to
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> can be applied or not. A mode specification is a list of n <code class="docutils literal notranslate"><span class="pre">+</span></code>,
<code class="docutils literal notranslate"><span class="pre">!</span></code> or <code class="docutils literal notranslate"><span class="pre">-</span></code> items that specify if an argument of the identifier is to be
treated as an input (<code class="docutils literal notranslate"><span class="pre">+</span></code>), if its head only is an input (<code class="docutils literal notranslate"><span class="pre">!</span></code>) or an output
(<code class="docutils literal notranslate"><span class="pre">-</span></code>) of the identifier. For a mode to match a list of arguments, input
terms and input heads <em>must not</em> contain existential variables or be
existential variables respectively, while outputs can be any term. Multiple
modes can be declared for a single identifier, in that case only one mode
needs to match the arguments for the hints to be applied. The head of a term
is understood here as the applicative head, or the match or projection
scrutinee’s head, recursively, casts being ignored. <a class="reference internal" href="#coq:cmdv.hint-mode" title="Hint Mode"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Mode</span></code></a> is
especially useful for typeclasses, when one does not want to support default
instances and avoid ambiguity in general. Setting a parameter of a class as an
input forces proof-search to be driven by that index of the class, with <code class="docutils literal notranslate"><span class="pre">!</span></code>
giving more flexibility by allowing existentials to still appear deeper in the
index but not at its head.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>One can use a <a class="reference internal" href="#coq:cmdv.hint-extern" title="Hint Extern"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Extern</span></code></a> with no pattern to do
pattern matching on hypotheses using <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span> <span class="pre">with</span></code>
inside the tactic.</p></li>
<li><p>If you want to add hints such as <a class="reference internal" href="#coq:cmdv.hint-transparent" title="Hint Transparent"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Transparent</span></code></a>,
<a class="reference internal" href="#coq:cmdv.hint-cut" title="Hint Cut"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Cut</span></code></a>, or <a class="reference internal" href="#coq:cmdv.hint-mode" title="Hint Mode"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Mode</span></code></a>, for typeclass
resolution, do not forget to put them in the
<code class="docutils literal notranslate"><span class="pre">typeclass_instances</span></code> hint database.</p></li>
</ul>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="hint-databases-defined-in-the-coq-standard-library">
<h3>Hint databases defined in the Coq standard library<a class="headerlink" href="#hint-databases-defined-in-the-coq-standard-library" title="Permalink to this headline">¶</a></h3>
<p>Several hint databases are defined in the Coq standard library. The
actual content of a database is the collection of hints declared
to belong to this database in each of the various modules currently
loaded. Especially, requiring new modules may extend the database.
At Coq startup, only the core database is nonempty and can be used.</p>
<dl class="field-list simple">
<dt class="field-odd">core</dt>
<dd class="field-odd"><p>This special database is automatically used by <code class="docutils literal notranslate"><span class="pre">auto</span></code>, except when
pseudo-database <code class="docutils literal notranslate"><span class="pre">nocore</span></code> is given to <code class="docutils literal notranslate"><span class="pre">auto</span></code>. The core database
contains only basic lemmas about negation, conjunction, and so on.
Most of the hints in this database come from the Init and Logic directories.</p>
</dd>
<dt class="field-even">arith</dt>
<dd class="field-even"><p>This database contains all lemmas about Peano’s arithmetic proved in the
directories Init and Arith.</p>
</dd>
<dt class="field-odd">zarith</dt>
<dd class="field-odd"><p>contains lemmas about binary signed integers from the directories
theories/ZArith. When required, the module Omega also extends the
database zarith with a high-cost hint that calls <code class="docutils literal notranslate"><span class="pre">omega</span></code> on equations
and inequalities in <code class="docutils literal notranslate"><span class="pre">nat</span></code> or <code class="docutils literal notranslate"><span class="pre">Z</span></code>.</p>
</dd>
<dt class="field-even">bool</dt>
<dd class="field-even"><p>contains lemmas about booleans, mostly from directory theories/Bool.</p>
</dd>
<dt class="field-odd">datatypes</dt>
<dd class="field-odd"><p>is for lemmas about lists, streams and so on that are mainly proved
in the Lists subdirectory.</p>
</dd>
<dt class="field-even">sets</dt>
<dd class="field-even"><p>contains lemmas about sets and relations from the directories Sets and
Relations.</p>
</dd>
<dt class="field-odd">typeclass_instances</dt>
<dd class="field-odd"><p>contains all the typeclass instances declared in the
environment, including those used for <code class="docutils literal notranslate"><span class="pre">setoid_rewrite</span></code>,
from the Classes directory.</p>
</dd>
<dt class="field-even">fset</dt>
<dd class="field-even"><p>internal database for the implementation of the <code class="docutils literal notranslate"><span class="pre">FSets</span></code> library.</p>
</dd>
</dl>
<p>You are advised not to put your own hints in the core database, but
use one or several databases specific to your development.</p>
<span class="target" id="removehints"></span><dl class="coq cmd">
<dt id="coq:cmd.remove-hints">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Remove</span> <span>Hints</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.remove-hints" title="Permalink to this definition">¶</a></dt>
<dd><p>This command removes the hints associated to terms <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> in databases
<code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
</dd></dl>

<span class="target" id="printhint"></span><dl class="coq cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Print</span> <span>Hint</span></span></code></dt>
<dd><p>This command displays all hints that apply to the current goal. It
fails if no proof is being edited, while the two variants can be used
at every moment.</p>
</dd></dl>

<p><strong>Variants:</strong></p>
<dl class="coq cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Print</span> <span>Hint</span> <span class="hole">ident</span></span></code></dt>
<dd><p>This command displays only tactics associated with <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> in the hints
list. This is independent of the goal being edited, so this command will not
fail if no goal is being edited.</p>
</dd></dl>

<dl class="coq cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Print</span> <span>Hint</span> <span>*</span></span></code></dt>
<dd><p>This command displays all declared hints.</p>
</dd></dl>

<dl class="coq cmd">
<dt id="coq:cmd.print-hintdb">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Print</span> <span>HintDb</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:cmd.print-hintdb" title="Permalink to this definition">¶</a></dt>
<dd><p>This command displays all hints from database <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>.</p>
</dd></dl>

<span class="target" id="hintrewrite"></span><dl class="coq cmd">
<dt id="coq:cmd.hint-rewrite">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Rewrite</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.hint-rewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>This vernacular command adds the terms <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> (their types must be
equalities) in the rewriting bases <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> with the default orientation
(left to right). Notice that the rewriting bases are distinct from the <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a>
hint bases and that <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> does not take them into account.</p>
<p>This command is synchronous with the section mechanism (see <a class="reference internal" href="../language/gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>):
when closing a section, all aliases created by <code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Rewrite</span></code> in that
section are lost. Conversely, when loading a module, all <code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Rewrite</span></code>
declarations at the global level of that module are loaded.</p>
</dd></dl>

<p><strong>Variants:</strong></p>
<dl class="coq cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Rewrite</span> <span>-&gt;</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This is strictly equivalent to the command above (we only make explicit the
orientation which otherwise defaults to -&gt;).</p>
</dd></dl>

<dl class="coq cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Rewrite</span> <span>&lt;-</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Adds the rewriting rules <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> with a right-to-left orientation in
the bases <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
</dd></dl>

<dl class="coq cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>Rewrite</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span></span> <span>using</span> <span class="hole">tactic</span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>When the rewriting rules <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> in <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> will be used, the
tactic <code class="docutils literal notranslate"><span class="pre">tactic</span></code> will be applied to the generated subgoals, the main subgoal
excluded.</p>
</dd></dl>

<dl class="coq cmd">
<dt id="coq:cmd.print-rewrite-hintdb">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Print</span> <span>Rewrite</span> <span>HintDb</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:cmd.print-rewrite-hintdb" title="Permalink to this definition">¶</a></dt>
<dd><p>This command displays all rewrite hints contained in <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>.</p>
</dd></dl>

</div>
<div class="section" id="hint-locality">
<h3>Hint locality<a class="headerlink" href="#hint-locality" title="Permalink to this headline">¶</a></h3>
<p>Hints provided by the <code class="docutils literal notranslate"><span class="pre">Hint</span></code> commands are erased when closing a section.
Conversely, all hints of a module <code class="docutils literal notranslate"><span class="pre">A</span></code> that are not defined inside a
section (and not defined with option <code class="docutils literal notranslate"><span class="pre">Local</span></code>) become available when the
module <code class="docutils literal notranslate"><span class="pre">A</span></code> is imported (using e.g. <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">A.</span></code>).</p>
<p>As of today, hints only have a binary behavior regarding locality, as
described above: either they disappear at the end of a section scope,
or they remain global forever. This causes a scalability issue,
because hints coming from an unrelated part of the code may badly
influence another development. It can be mitigated to some extent
thanks to the <a class="reference internal" href="#coq:cmd.remove-hints" title="Remove Hints"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Remove</span> <span class="pre">Hints</span></code></a> command,
but this is a mere workaround and has some limitations (for instance, external
hints cannot be removed).</p>
<p>A proper way to fix this issue is to bind the hints to their module scope, as
for most of the other objects Coq uses. Hints should only be made available when
the module they are defined in is imported, not just required. It is very
difficult to change the historical behavior, as it would break a lot of scripts.
We propose a smooth transitional path by providing the <a class="reference internal" href="#coq:opt.loose-hint-behavior" title="Loose Hint Behavior"><code class="xref coq coq-opt docutils literal notranslate"><span class="pre">Loose</span> <span class="pre">Hint</span> <span class="pre">Behavior</span></code></a>
option which accepts three flags allowing for a fine-grained handling of
non-imported hints.</p>
<dl class="coq opt">
<dt id="coq:opt.loose-hint-behavior">
<em class="property"><span class="sigannot">Option</span></em> <code class="sig-name descname"><span class="notation"><span>Loose</span> <span>Hint</span> <span>Behavior</span> <span class="alternative"><span class="alternative-block"><span>&quot;Lax&quot;</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>&quot;Warn&quot;</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>&quot;Strict&quot;</span></span></span></span></code><a class="headerlink" href="#coq:opt.loose-hint-behavior" title="Permalink to this definition">¶</a></dt>
<dd><p>This option accepts three values, which control the behavior of hints w.r.t.
<a class="reference internal" href="../language/gallina-extensions.html#coq:cmd.import" title="Import"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Import</span></code></a>:</p>
<ul class="simple">
<li><p>&quot;Lax&quot;: this is the default, and corresponds to the historical behavior,
that is, hints defined outside of a section have a global scope.</p></li>
<li><p>&quot;Warn&quot;: outputs a warning when a non-imported hint is used. Note that this
is an over-approximation, because a hint may be triggered by a run that
will eventually fail and backtrack, resulting in the hint not being
actually useful for the proof.</p></li>
<li><p>&quot;Strict&quot;: changes the behavior of an unloaded hint to a immediate fail
tactic, allowing to emulate an import-scoped hint mechanism.</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="setting-implicit-automation-tactics">
<span id="tactics-implicit-automation"></span><h3>Setting implicit automation tactics<a class="headerlink" href="#setting-implicit-automation-tactics" title="Permalink to this headline">¶</a></h3>
<dl class="coq cmd">
<dt id="coq:cmd.proof-with">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Proof</span> <span>with</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:cmd.proof-with" title="Permalink to this definition">¶</a></dt>
<dd><p>This command may be used to start a proof. It defines a default tactic
to be used each time a tactic command <code class="docutils literal notranslate"><span class="pre">tactic</span></code><sub>1</sub> is ended by <code class="docutils literal notranslate"><span class="pre">...</span></code>.
In this case the tactic command typed by the user is equivalent to
<code class="docutils literal notranslate"><span class="pre">tactic</span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="pre">;tactic</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="proof-handling.html#coq:cmd.proof" title="Proof"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Proof</span></code></a> in <a class="reference internal" href="proof-handling.html#proof-editing-mode"><span class="std std-ref">Switching on/off the proof editing mode</span></a>.</p>
</div>
<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Proof</span> <span>with</span> <span class="hole">tactic</span> <span>using</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Combines in a single line <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">with</span></code> and <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code>, see <a class="reference internal" href="proof-handling.html#proof-editing-mode"><span class="std std-ref">Switching on/off the proof editing mode</span></a></p>
</dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Proof</span> <span>using</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>with</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>Combines in a single line <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">with</span></code> and <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code>, see <a class="reference internal" href="proof-handling.html#proof-editing-mode"><span class="std std-ref">Switching on/off the proof editing mode</span></a></p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="decision-procedures">
<span id="decisionprocedures"></span><h2>Decision procedures<a class="headerlink" href="#decision-procedures" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt id="coq:tacn.tauto">
<code class="sig-name descname"><span class="notation"><span>tauto</span></span></code><a class="headerlink" href="#coq:tacn.tauto" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic implements a decision procedure for intuitionistic propositional
calculus based on the contraction-free sequent calculi LJT* of Roy Dyckhoff
<a class="bibtex reference internal" href="../zebibliography.html#dyc92" id="id11">[Dyc92]</a>. Note that <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> succeeds on any instance of an
intuitionistic tautological proposition. <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> unfolds negations and
logical equivalence but does not unfold any other definition.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The following goal can be proved by <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> whereas <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> would
fail:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk67" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk67"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> (<span class="nv">x</span>:nat) (<span class="nv">P</span>:nat -&gt; <span class="kt">Prop</span>), x = <span class="mi">0</span> \/ P x -&gt; x &lt;&gt; <span class="mi">0</span> -&gt; P x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : nat) (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
x = <span class="mi">0</span> \/ P x -&gt; x &lt;&gt; <span class="mi">0</span> -&gt; P x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk68" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk68"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span> \/ P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;&gt; <span class="mi">0</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">tauto</span>.</span></span></span></pre></div></div>
<p>Moreover, if it has nothing else to do, <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> performs introductions.
Therefore, the use of <a class="reference internal" href="#coq:tacv.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> in the previous proof is unnecessary.
<a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> can for instance for:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk69" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk69"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> (<span class="nv">A</span>:<span class="kt">Prop</span>) (<span class="nv">P</span>:nat -&gt; <span class="kt">Prop</span>), A \/ (<span class="kr">forall</span> <span class="nv">x</span>:nat, ~ A -&gt; P x) -&gt; <span class="kr">forall</span> <span class="nv">x</span>:nat, ~ A -&gt; P x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Prop</span>) (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>),
A \/ (<span class="kr">forall</span> <span class="nv">x</span> : nat, ~ A -&gt; P x) -&gt;
<span class="kr">forall</span> <span class="nv">x</span> : nat, ~ A -&gt; P x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">tauto</span>.</span></span></span></pre></div></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In contrast, <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> cannot solve the following goal
<code class="code highlight coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Goal</span></span> <span class="keyword reserved"><span class="pre">forall</span></span> <span class="operator"><span class="pre">(</span></span><span class="name variable"><span class="pre">A</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">Prop</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name variable"><span class="pre">P</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="keyword type"><span class="pre">Prop</span></span><span class="operator"><span class="pre">),</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">\/</span></span> <span class="operator"><span class="pre">(</span></span><span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="operator"><span class="pre">~</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">-&gt;</span></span></code>
<code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="operator"><span class="pre">~</span></span> <span class="operator"><span class="pre">~</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">\/</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">).</span></span></code>
because <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="operator"><span class="pre">~</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">)</span></span></code> cannot be treated as atomic and
an instantiation of <code class="docutils literal notranslate"><span class="pre">x</span></code> is necessary.</p>
</div>
<dl class="coq tacv">
<dt id="coq:tacv.dtauto">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>dtauto</span></span></code><a class="headerlink" href="#coq:tacv.dtauto" title="Permalink to this definition">¶</a></dt>
<dd><p>While <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> recognizes inductively defined connectives isomorphic to
the standard connectives <code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">prod</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code>,
<code class="docutils literal notranslate"><span class="pre">Empty_set</span></code>, <code class="docutils literal notranslate"><span class="pre">unit</span></code>, <code class="docutils literal notranslate"><span class="pre">True</span></code>, <a class="reference internal" href="#coq:tacv.dtauto" title="dtauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dtauto</span></code></a> also recognizes all inductive
types with one constructor and no indices, i.e. record-style connectives.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.intuition">
<code class="sig-name descname"><span class="notation"><span>intuition</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:tacn.intuition" title="Permalink to this definition">¶</a></dt>
<dd><p>The tactic <a class="reference internal" href="#coq:tacn.intuition" title="intuition"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intuition</span></code></a> takes advantage of the search-tree built by the
decision procedure involved in the tactic <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a>. It uses this
information to generate a set of subgoals equivalent to the original one (but
simpler than it) and applies the tactic <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> to them <a class="bibtex reference internal" href="../zebibliography.html#mun94" id="id12">[Mun94]</a>. If
this tactic fails on some goals then <a class="reference internal" href="#coq:tacn.intuition" title="intuition"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intuition</span></code></a> fails. In fact,
<a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> is simply <code class="code highlight coq docutils literal notranslate"><span class="name builtin"><span class="pre">intuition</span></span> <span class="keyword pseudo"><span class="pre">fail</span></span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>For instance, the tactic <code class="code highlight coq docutils literal notranslate"><span class="name builtin"><span class="pre">intuition</span></span> <span class="name builtin"><span class="pre">auto</span></span></code> applied to the goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(forall (x:nat), P x) /\ B -&gt; (forall (y:nat), P y) /\ P O \/ B /\ P O
</pre></div>
</div>
<p>internally replaces it by the equivalent one:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(forall (x:nat), P x), B |- P O
</pre></div>
</div>
<p>and then uses <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> which completes the proof.</p>
</div>
</dd></dl>

<p>Originally due to César Muñoz, these tactics (<a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> and
<a class="reference internal" href="#coq:tacn.intuition" title="intuition"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intuition</span></code></a>) have been completely re-engineered by David Delahaye using
mainly the tactic language (see <a class="reference internal" href="ltac.html#ltac"><span class="std std-ref">The tactic language</span></a>). The code is
now much shorter and a significant increase in performance has been noticed.
The general behavior with respect to dependent types, unfolding and
introductions has slightly changed to get clearer semantics. This may lead to
some incompatibilities.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>intuition</span></span></code></dt>
<dd><p>Is equivalent to <code class="code highlight coq docutils literal notranslate"><span class="name builtin"><span class="pre">intuition</span></span> <span class="name builtin"><span class="pre">auto</span> <span class="pre">with</span></span> <span class="operator"><span class="pre">*</span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.dintuition">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>dintuition</span></span></code><a class="headerlink" href="#coq:tacv.dintuition" title="Permalink to this definition">¶</a></dt>
<dd><p>While <a class="reference internal" href="#coq:tacn.intuition" title="intuition"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intuition</span></code></a> recognizes inductively defined connectives
isomorphic to the standard connectives <code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">prod</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code>,
<code class="docutils literal notranslate"><span class="pre">Empty_set</span></code>, <code class="docutils literal notranslate"><span class="pre">unit</span></code>, <code class="docutils literal notranslate"><span class="pre">True</span></code>, <a class="reference internal" href="#coq:tacv.dintuition" title="dintuition"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dintuition</span></code></a> also recognizes all inductive
types with one constructor and no indices, i.e. record-style connectives.</p>
</dd></dl>

<dl class="coq flag">
<dt id="coq:flag.intuition-negation-unfolding">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Intuition</span> <span>Negation</span> <span>Unfolding</span></span></code><a class="headerlink" href="#coq:flag.intuition-negation-unfolding" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls whether <a class="reference internal" href="#coq:tacn.intuition" title="intuition"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intuition</span></code></a> unfolds inner negations which do not need
to be unfolded. This option is on by default.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.rtauto">
<code class="sig-name descname"><span class="notation"><span>rtauto</span></span></code><a class="headerlink" href="#coq:tacn.rtauto" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#coq:tacn.rtauto" title="rtauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rtauto</span></code></a> tactic solves propositional tautologies similarly to what
<a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> does. The main difference is that the proof term is built using a
reflection scheme applied to a sequent calculus proof of the goal.  The search
procedure is also implemented using a different technique.</p>
<p>Users should be aware that this difference may result in faster proof-search
but slower proof-checking, and <a class="reference internal" href="#coq:tacn.rtauto" title="rtauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rtauto</span></code></a> might not solve goals that
<a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> would be able to solve (e.g. goals involving universal
quantifiers).</p>
<p>Note that this tactic is only available after a <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">Rtauto</span></code>.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.firstorder">
<code class="sig-name descname"><span class="notation"><span>firstorder</span></span></code><a class="headerlink" href="#coq:tacn.firstorder" title="Permalink to this definition">¶</a></dt>
<dd><p>The tactic <a class="reference internal" href="#coq:tacn.firstorder" title="firstorder"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">firstorder</span></code></a> is an experimental extension of <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> to
first- order reasoning, written by Pierre Corbineau. It is not restricted to
usual logical connectives but instead may reason about any first-order class
inductive definition.</p>
</dd></dl>

<dl class="coq opt">
<dt id="coq:opt.firstorder-solver">
<em class="property"><span class="sigannot">Option</span></em> <code class="sig-name descname"><span class="notation"><span>Firstorder</span> <span>Solver</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:opt.firstorder-solver" title="Permalink to this definition">¶</a></dt>
<dd><p>The default tactic used by <a class="reference internal" href="#coq:tacn.firstorder" title="firstorder"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">firstorder</span></code></a> when no rule applies is
<code class="code highlight coq docutils literal notranslate"><span class="name builtin"><span class="pre">auto</span> <span class="pre">with</span></span> <span class="operator"><span class="pre">*</span></span></code>, it can be reset locally or globally using this option.</p>
<dl class="coq cmd">
<dt id="coq:cmd.print-firstorder-solver">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Print</span> <span>Firstorder</span> <span>Solver</span></span></code><a class="headerlink" href="#coq:cmd.print-firstorder-solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the default tactic used by <a class="reference internal" href="#coq:tacn.firstorder" title="firstorder"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">firstorder</span></code></a> when no rule applies.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>firstorder</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>Tries to solve the goal with <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> when no logical rule may apply.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>firstorder</span> <span>using</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 8.3: </span>Use the syntax below instead (with commas).</p>
</div>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>firstorder</span> <span>using</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>Adds lemmas <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">qualid</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></code> to the proof-search environment. If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code>
refers to an inductive type, it is the collection of its constructors which are
added to the proof-search environment.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>firstorder</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Adds lemmas from <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> hint bases <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> to the proof-search
environment.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>firstorder</span> <span class="hole">tactic</span> <span>using</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">qualid</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This combines the effects of the different variants of <a class="reference internal" href="#coq:tacn.firstorder" title="firstorder"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">firstorder</span></code></a>.</p>
</dd></dl>

<dl class="coq opt">
<dt id="coq:opt.firstorder-depth">
<em class="property"><span class="sigannot">Option</span></em> <code class="sig-name descname"><span class="notation"><span>Firstorder</span> <span>Depth</span> <span class="hole">num</span></span></code><a class="headerlink" href="#coq:opt.firstorder-depth" title="Permalink to this definition">¶</a></dt>
<dd><p>This option controls the proof-search depth bound.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.congruence">
<code class="sig-name descname"><span class="notation"><span>congruence</span></span></code><a class="headerlink" href="#coq:tacn.congruence" title="Permalink to this definition">¶</a></dt>
<dd><p>The tactic <a class="reference internal" href="#coq:tacn.congruence" title="congruence"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span></code></a>, by Pierre Corbineau, implements the standard
Nelson and Oppen congruence closure algorithm, which is a decision procedure
for ground equalities with uninterpreted symbols. It also includes
constructor theory (see <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> and <a class="reference internal" href="#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a>). If the goal
is a non-quantified equality, congruence tries to prove it with non-quantified
equalities in the context. Otherwise it tries to infer a discriminable equality
from those in the context. Alternatively, congruence tries to prove that a
hypothesis is equal to the goal or to the negation of another hypothesis.</p>
<p><a class="reference internal" href="#coq:tacn.congruence" title="congruence"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span></code></a> is also able to take advantage of hypotheses stating
quantified equalities, but you have to provide a bound for the number of extra
equalities generated that way. Please note that one of the sides of the
equality must contain all the quantified variables in order for congruence to
match against it.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk6a" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk6a"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">T</span> (<span class="nv">A</span>:<span class="kt">Type</span>) (<span class="nv">f</span>:A -&gt; A) (<span class="nv">g</span>: A -&gt; A -&gt; A) <span class="nv">a</span> <span class="nv">b</span>: a=(f a) -&gt; (g b (f a))=(f (f a)) -&gt; (g a b)=(f (g b a)) -&gt; (g a b)=a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; A -&gt; A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a = f a -&gt;
g b (f a) = f (f a) -&gt; g a b = f (g b a) -&gt; g a b = a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk6b" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk6b"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; A -&gt; A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = f a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">g b (f a) = f (f a)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">g a b = f (g b a)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">g a b = a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk6c" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk6c"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">inj</span> (<span class="nv">A</span>:<span class="kt">Type</span>) (<span class="nv">f</span>:A -&gt; A * A) (<span class="nv">a</span> <span class="nv">c</span> <span class="nv">d</span>: A) : f = pair a -&gt; Some (f c) = Some (f d) -&gt; c=d.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; A * A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">f = pair a -&gt; Some (f c) = Some (f d) -&gt; c = d</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk6d" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk6d"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; A * A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, c, d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">f = pair a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Some (f c) = Some (f d)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">c = d</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div></div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>congruence</span> <span class="hole">num</span></span></code></dt>
<dd><p>Tries to add at most <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code> instances of hypotheses stating quantified equalities
to the problem in order to solve it. A bigger value of <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code> does not make
success slower, only failure. You might consider adding some lemmas as
hypotheses using assert in order for <a class="reference internal" href="#coq:tacn.congruence" title="congruence"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span></code></a> to use them.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.congruence-with">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>congruence</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacv.congruence-with" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> to the pool of terms used by <a class="reference internal" href="#coq:tacn.congruence" title="congruence"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span></code></a>. This helps
in case you have partially applied constructors in your goal.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.i-dont-know-how-to-handle-dependent-equality">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>I</span> <span>don’t</span> <span>know</span> <span>how</span> <span>to</span> <span>handle</span> <span>dependent</span> <span>equality.</span></span></code><a class="headerlink" href="#coq:exn.i-dont-know-how-to-handle-dependent-equality" title="Permalink to this definition">¶</a></dt>
<dd><p>The decision procedure managed to find a proof of the goal or of a
discriminable equality but this proof could not be built in Coq because of
dependently-typed functions.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.goal-is-solvable-by-congruence-but-some-arguments-are-missing-try-congruence-with-term-term-replacing-metavariables-by-arbitrary-terms">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Goal</span> <span>is</span> <span>solvable</span> <span>by</span> <span>congruence</span> <span>but</span> <span>some</span> <span>arguments</span> <span>are</span> <span>missing.</span> <span>Try</span> <span>congruence</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">+</span></span><span>,</span> <span>replacing</span> <span>metavariables</span> <span>by</span> <span>arbitrary</span> <span>terms.</span></span></code><a class="headerlink" href="#coq:exn.goal-is-solvable-by-congruence-but-some-arguments-are-missing-try-congruence-with-term-term-replacing-metavariables-by-arbitrary-terms" title="Permalink to this definition">¶</a></dt>
<dd><p>The decision procedure could solve the goal with the provision that additional
arguments are supplied for some partially applied constructors. Any term of an
appropriate type will allow the tactic to successfully solve the goal. Those
additional arguments can be given to congruence by filling in the holes in the
terms given in the error message, using the <a class="reference internal" href="#coq:tacv.congruence-with" title="congruence with"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span> <span class="pre">with</span></code></a> variant described above.</p>
</dd></dl>

<dl class="coq flag">
<dt id="coq:flag.congruence-verbose">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Congruence</span> <span>Verbose</span></span></code><a class="headerlink" href="#coq:flag.congruence-verbose" title="Permalink to this definition">¶</a></dt>
<dd><p>This option makes <a class="reference internal" href="#coq:tacn.congruence" title="congruence"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span></code></a> print debug information.</p>
</dd></dl>

</div>
<div class="section" id="checking-properties-of-terms">
<h2>Checking properties of terms<a class="headerlink" href="#checking-properties-of-terms" title="Permalink to this headline">¶</a></h2>
<p>Each of the following tactics acts as the identity if the check
succeeds, and results in an error otherwise.</p>
<dl class="coq tacn">
<dt id="coq:tacn.constr-eq">
<code class="sig-name descname"><span class="notation"><span>constr</span><span>_</span><span>eq</span> <span class="hole">term</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.constr-eq" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic checks whether its arguments are equal modulo alpha
conversion, casts and universe constraints. It may unify universes.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.not-equal">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>equal.</span></span></code><a class="headerlink" href="#coq:exn.not-equal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.not-equal-due-to-universes">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>equal</span> <span>(due</span> <span>to</span> <span>universes).</span></span></code><a class="headerlink" href="#coq:exn.not-equal-due-to-universes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.constr-eq-strict">
<code class="sig-name descname"><span class="notation"><span>constr</span><span>_</span><span>eq</span><span>_</span><span>strict</span> <span class="hole">term</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.constr-eq-strict" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic checks whether its arguments are equal modulo alpha
conversion, casts and universe constraints. It does not add new
constraints.</p>
</dd></dl>

<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>equal.</span></span></code></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>equal</span> <span>(due</span> <span>to</span> <span>universes).</span></span></code></dt>
<dd></dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.unify">
<code class="sig-name descname"><span class="notation"><span>unify</span> <span class="hole">term</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.unify" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic checks whether its arguments are unifiable, potentially
instantiating existential variables.</p>
</dd></dl>

<dl class="coq exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Unable</span> <span>to</span> <span>unify</span> <span class="hole">term</span> <span>with</span> <span class="hole">term</span><span>.</span></span></code></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>unify</span> <span class="hole">term</span> <span class="hole">term</span> <span>with</span> <span class="hole">ident</span></span></code></dt>
<dd><p>Unification takes the transparency information defined in the hint database
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> into account (see <a class="reference internal" href="#thehintsdatabasesforautoandeauto"><span class="std std-ref">the hints databases for auto and eauto</span></a>).</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.is-evar">
<code class="sig-name descname"><span class="notation"><span>is</span><span>_</span><span>evar</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.is-evar" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic checks whether its argument is a current existential
variable. Existential variables are uninstantiated variables generated
by <a class="reference internal" href="#coq:tacv.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a> and some other tactics.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.not-an-evar">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>an</span> <span>evar.</span></span></code><a class="headerlink" href="#coq:exn.not-an-evar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.has-evar">
<code class="sig-name descname"><span class="notation"><span>has</span><span>_</span><span>evar</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.has-evar" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic checks whether its argument has an existential variable as
a subterm. Unlike context patterns combined with <code class="docutils literal notranslate"><span class="pre">is_evar</span></code>, this tactic
scans all subterms, including those under binders.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.no-evars">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>evars.</span></span></code><a class="headerlink" href="#coq:exn.no-evars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.is-var">
<code class="sig-name descname"><span class="notation"><span>is</span><span>_</span><span>var</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.is-var" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic checks whether its argument is a variable or hypothesis in
the current goal context or in the opened sections.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.not-a-variable-or-hypothesis">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>a</span> <span>variable</span> <span>or</span> <span>hypothesis.</span></span></code><a class="headerlink" href="#coq:exn.not-a-variable-or-hypothesis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="equality">
<span id="id13"></span><h2>Equality<a class="headerlink" href="#equality" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt id="coq:tacn.f-equal">
<code class="sig-name descname"><span class="notation"><span>f</span><span>_</span><span>equal</span></span></code><a class="headerlink" href="#coq:tacn.f-equal" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to a goal of the form <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">f</span></span> <span class="name"><span class="pre">a</span></span></code><sub>1</sub> <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">a</span></span></code><sub>n</sub>
<code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">f</span></span><span class="operator"><span class="pre">′</span></span><span class="name"><span class="pre">a</span></span><span class="operator"><span class="pre">′</span></span></code><sub>1</sub> <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">a</span></span><span class="operator"><span class="pre">′</span></span></code><sub>n</sub>.  Using <a class="reference internal" href="#coq:tacn.f-equal" title="f_equal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">f_equal</span></code></a> on such a goal
leads to subgoals <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">f</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">f</span></span><span class="operator"><span class="pre">′</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">a</span></span></code><sub>1</sub> = <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">a</span></span><span class="operator"><span class="pre">′</span></span></code><sub>1</sub> and so on up
to <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">a</span></span></code><sub>n</sub> <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">a</span></span><span class="operator"><span class="pre">′</span></span></code><sub>n</sub>. Amongst these subgoals, the simple ones
(e.g. provable by <a class="reference internal" href="#coq:tacn.reflexivity" title="reflexivity"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">reflexivity</span></code></a> or <a class="reference internal" href="#coq:tacn.congruence" title="congruence"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span></code></a>) are automatically
solved by <a class="reference internal" href="#coq:tacn.f-equal" title="f_equal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">f_equal</span></code></a>.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.reflexivity">
<code class="sig-name descname"><span class="notation"><span>reflexivity</span></span></code><a class="headerlink" href="#coq:tacn.reflexivity" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to a goal that has the form <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">u</span></span></code>. It checks that <code class="docutils literal notranslate"><span class="pre">t</span></code>
and <code class="docutils literal notranslate"><span class="pre">u</span></code> are convertible and then solves the goal. It is equivalent to
<code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">refl_equal</span></code>.</p>
<dl class="coq exn">
<dt id="coq:exn.the-conclusion-is-not-a-substitutive-equation">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>The</span> <span>conclusion</span> <span>is</span> <span>not</span> <span>a</span> <span>substitutive</span> <span>equation.</span></span></code><a class="headerlink" href="#coq:exn.the-conclusion-is-not-a-substitutive-equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.unable-to-unify-with">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Unable</span> <span>to</span> <span>unify</span> <span>...</span> <span>with</span> <span>...</span></span></code><a class="headerlink" href="#coq:exn.unable-to-unify-with" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.symmetry">
<code class="sig-name descname"><span class="notation"><span>symmetry</span></span></code><a class="headerlink" href="#coq:tacn.symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to a goal that has the form <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">u</span></span></code> and changes it into
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">u</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">t</span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>symmetry</span> <span>in</span> <span class="hole">ident</span></span></code></dt>
<dd><p>If the statement of the hypothesis ident has the form <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">u</span></span></code>, the tactic
changes it to <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">u</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">t</span></span></code>.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.transitivity">
<code class="sig-name descname"><span class="notation"><span>transitivity</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.transitivity" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to a goal that has the form <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">u</span></span></code> and transforms it
into the two subgoals <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">t=</span></span><span class="hole"><span class="pre">term</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span><span><span class="pre">=u</span></span></span></code>.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>etransitivity</span></span></code></dt>
<dd><p>This tactic behaves like <a class="reference internal" href="#coq:tacn.transitivity" title="transitivity"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">transitivity</span></code></a>, using a fresh evar instead of
a concrete <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="equality-and-inductive-sets">
<h2>Equality and inductive sets<a class="headerlink" href="#equality-and-inductive-sets" title="Permalink to this headline">¶</a></h2>
<p>We describe in this section some special purpose tactics dealing with
equality and inductive sets or types. These tactics use the
equality <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword reserved"><span class="pre">forall</span></span> <span class="operator"><span class="pre">(</span></span><span class="name variable"><span class="pre">A</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">Type</span></span><span class="operator"><span class="pre">),</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Prop</span></span></code>, simply written with the infix
symbol <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">=</span></span></code>.</p>
<dl class="coq tacn">
<dt id="coq:tacn.decide-equality">
<code class="sig-name descname"><span class="notation"><span>decide</span> <span>equality</span></span></code><a class="headerlink" href="#coq:tacn.decide-equality" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic solves a goal of the form <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">x</span></span> <span class="name variable"><span class="pre">y</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">R</span></span><span class="operator"><span class="pre">,</span></span> <span class="operator"><span class="pre">{</span></span><span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">}</span></span> <span class="operator"><span class="pre">+</span></span> <span class="operator"><span class="pre">{~</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">}</span></span></code>,
where <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">R</span></span></code> is an inductive type such that its constructors do not take
proofs or functions as arguments, nor objects in dependent types. It
solves goals of the form <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">{</span></span><span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">}</span></span> <span class="operator"><span class="pre">+</span></span> <span class="operator"><span class="pre">{~</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">}</span></span></code> as well.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.compare">
<code class="sig-name descname"><span class="notation"><span>compare</span> <span class="hole">term</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic compares two given objects <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> of an
inductive datatype. If <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">G</span></span></code> is the current goal, it leaves the sub-
goals <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span> <span><span class="pre">=</span></span><span class="hole"><span class="pre">term</span></span> <span><span class="pre">-&gt;</span></span> <span><span class="pre">G</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">~</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">-&gt;</span></span> <span><span class="pre">G</span></span></span></code>. The type of
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> must satisfy the same restrictions as in the
tactic <code class="docutils literal notranslate"><span class="pre">decide</span> <span class="pre">equality</span></code>.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.simplify-eq">
<code class="sig-name descname"><span class="notation"><span>simplify</span><span>_</span><span>eq</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.simplify-eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> be the proof of a statement of conclusion <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">term</span></span></span></code>.
If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> are structurally different (in the sense
described for the tactic <a class="reference internal" href="#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a>), then the tactic
<code class="docutils literal notranslate"><span class="pre">simplify_eq</span></code> behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">discriminate</span></span> <span class="hole"><span class="pre">term</span></span></span></code>, otherwise it behaves as
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">injection</span></span> <span class="hole"><span class="pre">term</span></span></span></code>.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If some quantified hypothesis of the goal is named <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code>,
then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simplify</span></span><span><span class="pre">_</span></span><span><span class="pre">eq</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> first introduces the hypothesis in the local
context using <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>.</p>
</div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simplify</span><span>_</span><span>eq</span> <span class="hole">num</span></span></code></dt>
<dd><p>This does the same thing as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">num</span></span></span></code> then
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simplify</span></span><span><span class="pre">_</span></span><span><span class="pre">eq</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> where <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is the identifier for the last
introduced hypothesis.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simplify</span><span>_</span><span>eq</span> <span class="hole">term</span> <span>with</span> <span class="hole">bindings_list</span></span></code></dt>
<dd><p>This does the same as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simplify</span></span><span><span class="pre">_</span></span><span><span class="pre">eq</span></span> <span class="hole"><span class="pre">term</span></span></span></code> but using the given bindings to
instantiate parameters or hypotheses of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.esimplify-eq">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>esimplify</span><span>_</span><span>eq</span> <span class="hole">num</span></span></code><a class="headerlink" href="#coq:tacv.esimplify-eq" title="Permalink to this definition">¶</a></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>esimplify</span><span>_</span><span>eq</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">bindings_list</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This works the same as <a class="reference internal" href="#coq:tacn.simplify-eq" title="simplify_eq"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simplify_eq</span></code></a> but if the type of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>, or the
type of the hypothesis referred to by <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code>, has uninstantiated
parameters, these parameters are left as existential variables.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>simplify</span><span>_</span><span>eq</span></span></code></dt>
<dd><p>If the current goal has form <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t1</span></span> <span class="operator"><span class="pre">&lt;&gt;</span></span> <span class="name"><span class="pre">t2</span></span></code>, it behaves as
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span> <span class="hole"><span class="pre">ident</span></span><span><span class="pre">;</span></span> <span><span class="pre">simplify</span></span><span><span class="pre">_</span></span><span><span class="pre">eq</span></span> <span class="hole"><span class="pre">ident</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.dependent-rewrite">
<code class="sig-name descname"><span class="notation"><span>dependent</span> <span>rewrite</span> <span>-&gt;</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacn.dependent-rewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies to any goal. If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> has type
<code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">existT</span></span> <span class="name"><span class="pre">B</span></span> <span class="name"><span class="pre">a</span></span> <span class="name"><span class="pre">b</span></span><span class="operator"><span class="pre">)=(</span></span><span class="name"><span class="pre">existT</span></span> <span class="name"><span class="pre">B</span></span> <span class="name"><span class="pre">a'</span></span> <span class="name"><span class="pre">b'</span></span><span class="operator"><span class="pre">)</span></span></code> in the local context (i.e. each
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> of the equality has a sigma type <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">{</span></span> <span class="name"><span class="pre">a</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">&amp;</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">B</span></span> <span class="name"><span class="pre">a</span></span><span class="operator"><span class="pre">)}</span></span></code>) this tactic
rewrites <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">a</span></span></code> into <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">a'</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">b</span></span></code> into <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">b'</span></span></code> in the current goal.
This tactic works even if <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> is also a sigma type. This kind of
equalities between dependent pairs may be derived by the
<a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> and <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> tactics.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.dependent-rewrite">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>dependent</span> <span>rewrite</span> <span>&lt;-</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacv.dependent-rewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Analogous to <a class="reference internal" href="#coq:tacn.dependent-rewrite" title="dependent rewrite -&gt;"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">rewrite</span> <span class="pre">-&gt;</span></code></a> but uses the equality from right to
left.</p>
</dd></dl>

</div>
<div class="section" id="inversion">
<h2>Inversion<a class="headerlink" href="#inversion" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt id="coq:tacn.functional-inversion">
<code class="sig-name descname"><span class="notation"><span>functional</span> <span>inversion</span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacn.functional-inversion" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#coq:tacn.functional-inversion" title="functional inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">functional</span> <span class="pre">inversion</span></code></a> is a tactic that performs inversion on hypothesis
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> of the form <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">term</span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">qualid</span></span><span>
</span><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> where <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> must have been defined using Function (see
<a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions"><span class="std std-ref">Advanced recursive functions</span></a>). Note that this tactic is only
available after a <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">FunInd</span></code>.</p>
<dl class="coq exn">
<dt id="coq:exn.hypothesis-ident-must-contain-at-least-one-function">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Hypothesis</span> <span class="hole">ident</span> <span>must</span> <span>contain</span> <span>at</span> <span>least</span> <span>one</span> <span>Function.</span></span></code><a class="headerlink" href="#coq:exn.hypothesis-ident-must-contain-at-least-one-function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.cannot-find-inversion-information-for-hypothesis-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>find</span> <span>inversion</span> <span>information</span> <span>for</span> <span>hypothesis</span> <span class="hole">ident</span><span>.</span></span></code><a class="headerlink" href="#coq:exn.cannot-find-inversion-information-for-hypothesis-ident" title="Permalink to this definition">¶</a></dt>
<dd><p>This error may be raised when some inversion lemma failed to be generated by
Function.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>functional</span> <span>inversion</span> <span class="hole">num</span></span></code></dt>
<dd><p>This does the same thing as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span class="hole"><span class="pre">num</span></span></span></code> followed by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">functional</span></span> <span><span class="pre">inversion</span></span> <span class="hole"><span class="pre">ident</span></span></span></code> where <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is the
identifier for the last introduced hypothesis.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>functional</span> <span>inversion</span> <span class="hole">ident</span> <span class="hole">qualid</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>functional</span> <span>inversion</span> <span class="hole">num</span> <span class="hole">qualid</span></span></code></dt>
<dd><p>If the hypothesis <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> (or <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code>) has a type of the form
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span><sub><span class="pre">1</span></sub></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span><sub><span class="pre">i</span></sub></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">=</span></span> <span class="hole"><span class="pre">qualid</span><sub><span class="pre">2</span></sub></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span><sub><span class="pre">j</span></sub></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> where
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span><sub><span class="pre">1</span></sub></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span><sub><span class="pre">2</span></sub></span></span></code> are valid candidates to
functional inversion, this variant allows choosing which <code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code>
is inverted.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="classical-tactics">
<h2>Classical tactics<a class="headerlink" href="#classical-tactics" title="Permalink to this headline">¶</a></h2>
<p>In order to ease the proving process, when the <code class="docutils literal notranslate"><span class="pre">Classical</span></code> module is
loaded, a few more tactics are available. Make sure to load the module
using the <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span></code> command.</p>
<dl class="coq tacn">
<dt id="coq:tacn.classical-left">
<code class="sig-name descname"><span class="notation"><span>classical</span><span>_</span><span>left</span></span></code><a class="headerlink" href="#coq:tacn.classical-left" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacn.classical-right">
<code class="sig-name descname"><span class="notation"><span>classical</span><span>_</span><span>right</span></span></code><a class="headerlink" href="#coq:tacn.classical-right" title="Permalink to this definition">¶</a></dt>
<dd><p>These tactics are the analog of <a class="reference internal" href="#coq:tacv.left" title="left"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">left</span></code></a> and <a class="reference internal" href="#coq:tacv.right" title="right"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">right</span></code></a>
but using classical logic. They can only be used for
disjunctions. Use <a class="reference internal" href="#coq:tacn.classical-left" title="classical_left"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">classical_left</span></code></a> to prove the left part of the
disjunction with the assumption that the negation of right part holds.
Use <a class="reference internal" href="#coq:tacn.classical-right" title="classical_right"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">classical_right</span></code></a> to prove the right part of the disjunction with
the assumption that the negation of left part holds.</p>
</dd></dl>

</div>
<div class="section" id="automating">
<span id="tactics-automating"></span><h2>Automating<a class="headerlink" href="#automating" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt id="coq:tacn.btauto">
<code class="sig-name descname"><span class="notation"><span>btauto</span></span></code><a class="headerlink" href="#coq:tacn.btauto" title="Permalink to this definition">¶</a></dt>
<dd><p>The tactic <a class="reference internal" href="#coq:tacn.btauto" title="btauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">btauto</span></code></a> implements a reflexive solver for boolean
tautologies. It solves goals of the form <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">u</span></span></code> where <code class="docutils literal notranslate"><span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">u</span></code> are
constructed over the following grammar:</p>
<pre id="btauto-grammar">
<strong id="grammar-token-sentence-btauto_term"><span id="grammar-token-btauto-term"></span>btauto_term</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>
                 true
                 false
                 orb <code class="xref docutils literal notranslate"><span class="pre">btauto_term</span></code> <code class="xref docutils literal notranslate"><span class="pre">btauto_term</span></code>
                 andb <code class="xref docutils literal notranslate"><span class="pre">btauto_term</span></code> <code class="xref docutils literal notranslate"><span class="pre">btauto_term</span></code>
                 xorb <code class="xref docutils literal notranslate"><span class="pre">btauto_term</span></code> <code class="xref docutils literal notranslate"><span class="pre">btauto_term</span></code>
                 negb <code class="xref docutils literal notranslate"><span class="pre">btauto_term</span></code>
                 if <code class="xref docutils literal notranslate"><span class="pre">btauto_term</span></code> then <code class="xref docutils literal notranslate"><span class="pre">btauto_term</span></code> else <code class="xref docutils literal notranslate"><span class="pre">btauto_term</span></code>
</pre>
<p>Whenever the formula supplied is not a tautology, it also provides a
counter-example.</p>
<p>Internally, it uses a system very similar to the one of the ring
tactic.</p>
<p>Note that this tactic is only available after a <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">Btauto</span></code>.</p>
<dl class="coq exn">
<dt id="coq:exn.cannot-recognize-a-boolean-equality">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>recognize</span> <span>a</span> <span>boolean</span> <span>equality.</span></span></code><a class="headerlink" href="#coq:exn.cannot-recognize-a-boolean-equality" title="Permalink to this definition">¶</a></dt>
<dd><p>The goal is not of the form <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">u</span></span></code>. Especially note that <a class="reference internal" href="#coq:tacn.btauto" title="btauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">btauto</span></code></a>
doesn't introduce variables into the context on its own.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.omega">
<code class="sig-name descname"><span class="notation"><span>omega</span></span></code><a class="headerlink" href="#coq:tacn.omega" title="Permalink to this definition">¶</a></dt>
<dd><p>The tactic <a class="reference internal" href="#coq:tacn.omega" title="omega"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">omega</span></code></a>, due to Pierre Crégut, is an automatic decision
procedure for Presburger arithmetic. It solves quantifier-free
formulas built with <code class="docutils literal notranslate"><span class="pre">~</span></code>, <code class="docutils literal notranslate"><span class="pre">\/</span></code>, <code class="docutils literal notranslate"><span class="pre">/\</span></code>, <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> on top of equalities,
inequalities and disequalities on both the type <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">nat</span></span></code> of natural numbers
and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">Z</span></span></code> of binary integers. This tactic must be loaded by the command
<code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">Omega</span></code>. See the additional documentation about omega
(see Chapter <a class="reference internal" href="../addendum/omega.html#omega"><span class="std std-ref">Omega: a solver for quantifier-free problems in Presburger Arithmetic</span></a>).</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.ring">
<code class="sig-name descname"><span class="notation"><span>ring</span></span></code><a class="headerlink" href="#coq:tacn.ring" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic solves equations upon polynomial expressions of a ring
(or semiring) structure. It proceeds by normalizing both hand sides
of the equation (w.r.t. associativity, commutativity and
distributivity, constant propagation) and comparing syntactically the
results.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.ring-simplify">
<code class="sig-name descname"><span class="notation"><span>ring</span><span>_</span><span>simplify</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:tacn.ring-simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic applies the normalization procedure described above to
the given terms. The tactic then replaces all occurrences of the terms
given in the conclusion of the goal by their normal forms. If no term
is given, then the conclusion should be an equation and both hand
sides are normalized.</p>
</dd></dl>

<p>See <a class="reference internal" href="../addendum/ring.html#theringandfieldtacticfamilies"><span class="std std-ref">The ring and field tactic families</span></a> for more information on
the tactic and how to declare new ring structures. All declared field structures
can be printed with the <code class="docutils literal notranslate"><span class="pre">Print</span> <span class="pre">Rings</span></code> command.</p>
<dl class="coq tacn">
<dt id="coq:tacn.field">
<code class="sig-name descname"><span class="notation"><span>field</span></span></code><a class="headerlink" href="#coq:tacn.field" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacn.field-simplify">
<code class="sig-name descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:tacn.field-simplify" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacn.field-simplify-eq">
<code class="sig-name descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span><span>_</span><span>eq</span></span></code><a class="headerlink" href="#coq:tacn.field-simplify-eq" title="Permalink to this definition">¶</a></dt>
<dd><p>The field tactic is built on the same ideas as ring: this is a
reflexive tactic that solves or simplifies equations in a field
structure. The main idea is to reduce a field expression (which is an
extension of ring expressions with the inverse and division
operations) to a fraction made of two polynomial expressions.</p>
<p>Tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">field</span></span></span></code> is used to solve subgoals, whereas <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">field</span></span><span><span class="pre">_</span></span><span><span class="pre">simplify</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>
replaces the provided terms by their reduced fraction.
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">field</span></span><span><span class="pre">_</span></span><span><span class="pre">simplify</span></span><span><span class="pre">_</span></span><span><span class="pre">eq</span></span></span></code> applies when the conclusion is an equation: it
simplifies both hand sides and multiplies so as to cancel
denominators. So it produces an equation without division nor inverse.</p>
<p>All of these 3 tactics may generate a subgoal in order to prove that
denominators are different from zero.</p>
<p>See <a class="reference internal" href="../addendum/ring.html#theringandfieldtacticfamilies"><span class="std std-ref">The ring and field tactic families</span></a> for more information on the tactic and how to
declare new field structures. All declared field structures can be
printed with the Print Fields command.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Reals.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk6e" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk6e"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>:R,
(x * y &gt; <span class="mi">0</span>)%R -&gt;
(x * (<span class="mi">1</span> / x + x / (x + y)))%R =
((- <span class="mi">1</span> / y) * y * (- x * (x / (x + y)) - <span class="mi">1</span>))%R.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : R,
(x * y &gt; <span class="mi">0</span>)%R -&gt;
(x * (<span class="mi">1</span> / x + x / (x + y)))%R =
(-<span class="mi">1</span> / y * y * (- x * (x / (x + y)) - <span class="mi">1</span>))%R</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk6f" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk6f"><span class="highlight"><span class="nb">intros</span>; <span class="bp">field</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(x * y &gt; <span class="mi">0</span>)%R</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(x + y)%R &lt;&gt; <span class="mi">0</span>%R /\ y &lt;&gt; <span class="mi">0</span>%R /\ x &lt;&gt; <span class="mi">0</span>%R</span></div></blockquote></div></div></small></span></pre></div></div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>File plugins/setoid_ring/RealField.v for an example of instantiation,
theory theories/Reals for many examples of use of field.</p>
</div>
</div>
<div class="section" id="non-logical-tactics">
<h2>Non-logical tactics<a class="headerlink" href="#non-logical-tactics" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt id="coq:tacn.cycle">
<code class="sig-name descname"><span class="notation"><span>cycle</span> <span class="hole">num</span></span></code><a class="headerlink" href="#coq:tacn.cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic puts the <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code> first goals at the end of the list of goals.
If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code> is negative, it will put the last <span class="math notranslate nohighlight">\(|num|\)</span> goals at the
beginning of the list.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk70" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk70"><span class="highlight"><span class="kn">Goal</span> P <span class="mi">1</span> /\ P <span class="mi">2</span> /\ P <span class="mi">3</span> /\ P <span class="mi">4</span> /\ P <span class="mi">5</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">1</span> /\ P <span class="mi">2</span> /\ P <span class="mi">3</span> /\ P <span class="mi">4</span> /\ P <span class="mi">5</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk71" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk71"><span class="highlight"><span class="kp">repeat</span> <span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">1</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk72" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk72"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">2</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk73" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk73"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">3</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk74" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk74"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">4</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk75" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk75"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">5</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk76" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk76"><span class="highlight"><span class="kp">all</span>: <span class="nb">cycle</span> <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">3</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk77" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk77"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">4</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk78" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk78"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">5</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk79" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk79"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">1</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk7a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk7a"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">2</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk7b" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk7b"><span class="highlight"><span class="kp">all</span>: <span class="nb">cycle</span> -<span class="mi">3</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">5</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk7c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk7c"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">1</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk7d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk7d"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">2</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk7e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk7e"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">3</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk7f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk7f"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">4</span></span></div></blockquote></div></div></div></small></span></pre></div></div>
<dl class="coq tacn">
<dt id="coq:tacn.swap">
<code class="sig-name descname"><span class="notation"><span>swap</span> <span class="hole">num</span> <span class="hole">num</span></span></code><a class="headerlink" href="#coq:tacn.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic switches the position of the goals of indices <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code> and
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code>. If either <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code> is negative then goals are
counted from the end of the focused goal list. Goals are indexed from 1,
there is no goal with position 0.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk80" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk80"><span class="highlight"><span class="kn">Goal</span> P <span class="mi">1</span> /\ P <span class="mi">2</span> /\ P <span class="mi">3</span> /\ P <span class="mi">4</span> /\ P <span class="mi">5</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">1</span> /\ P <span class="mi">2</span> /\ P <span class="mi">3</span> /\ P <span class="mi">4</span> /\ P <span class="mi">5</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk81" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk81"><span class="highlight"><span class="kp">repeat</span> <span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">1</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk82" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk82"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">2</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk83" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk83"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">3</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk84" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk84"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">4</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk85" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk85"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">5</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk86" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk86"><span class="highlight"><span class="kp">all</span>: <span class="nb">swap</span> <span class="mi">1</span> <span class="mi">3</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">3</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk87" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk87"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">2</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk88" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk88"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">1</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk89" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk89"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">4</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk8a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk8a"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">5</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk8b" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk8b"><span class="highlight"><span class="kp">all</span>: <span class="nb">swap</span> <span class="mi">1</span> -<span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">5</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk8c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk8c"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">2</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk8d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk8d"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">1</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk8e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk8e"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">4</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk8f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk8f"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">3</span></span></div></blockquote></div></div></div></small></span></pre></div></div>
<dl class="coq tacn">
<dt id="coq:tacn.revgoals">
<code class="sig-name descname"><span class="notation"><span>revgoals</span></span></code><a class="headerlink" href="#coq:tacn.revgoals" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactics reverses the list of the focused goals.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk90" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk90"><span class="highlight"><span class="kn">Goal</span> P <span class="mi">1</span> /\ P <span class="mi">2</span> /\ P <span class="mi">3</span> /\ P <span class="mi">4</span> /\ P <span class="mi">5</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">1</span> /\ P <span class="mi">2</span> /\ P <span class="mi">3</span> /\ P <span class="mi">4</span> /\ P <span class="mi">5</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk91" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk91"><span class="highlight"><span class="kp">repeat</span> <span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">1</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk92" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk92"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">2</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk93" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk93"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">3</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk94" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk94"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">4</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk95" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk95"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">5</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk96" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk96"><span class="highlight"><span class="kp">all</span>: <span class="nb">revgoals</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">5</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="tactics-rst-chk97" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk97"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">4</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk98" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk98"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">3</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk99" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk99"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">2</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="tactics-rst-chk9a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="tactics-rst-chk9a"><hr></label><div class="goal-conclusion"><span class="highlight">P <span class="mi">1</span></span></div></blockquote></div></div></div></small></span></pre></div></div>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.shelve">
<code class="sig-name descname"><span class="notation"><span>shelve</span></span></code><a class="headerlink" href="#coq:tacn.shelve" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic moves all goals under focus to a shelf. While on the
shelf, goals will not be focused on. They can be solved by
unification, or they can be called back into focus with the command
<a class="reference internal" href="#coq:cmd.unshelve" title="Unshelve"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Unshelve</span></code></a>.</p>
<dl class="coq tacv">
<dt id="coq:tacv.shelve-unifiable">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>shelve</span><span>_</span><span>unifiable</span></span></code><a class="headerlink" href="#coq:tacv.shelve-unifiable" title="Permalink to this definition">¶</a></dt>
<dd><p>Shelves only the goals under focus that are mentioned in other goals.
Goals that appear in the type of other goals can be solved by unification.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk9b" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk9b"><span class="highlight"><span class="kn">Goal</span> <span class="kr">exists</span> <span class="nv">n</span>, n=<span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">n</span> : nat, n = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk9c" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk9c"><span class="highlight"><span class="nb">refine</span> (ex_intro _ _ _).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">?<span class="kn">Goal</span> = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk9d" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk9d"><span class="highlight"><span class="kp">all</span>: <span class="nb">shelve_unifiable</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">?<span class="kn">Goal</span> = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span></span></pre></div></div>
</dd></dl>

</dd></dl>

<dl class="coq cmd">
<dt id="coq:cmd.unshelve">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Unshelve</span></span></code><a class="headerlink" href="#coq:cmd.unshelve" title="Permalink to this definition">¶</a></dt>
<dd><p>This command moves all the goals on the shelf (see <a class="reference internal" href="#coq:tacn.shelve" title="shelve"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">shelve</span></code></a>)
from the shelf into focus, by appending them to the end of the current
list of focused goals.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.unshelve">
<code class="sig-name descname"><span class="notation"><span>unshelve</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:tacn.unshelve" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code>, then unshelves existential variables added to the
shelf by the execution of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code>, prepending them to the current goal.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.give-up">
<code class="sig-name descname"><span class="notation"><span>give</span><span>_</span><span>up</span></span></code><a class="headerlink" href="#coq:tacn.give-up" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic removes the focused goals from the proof. They are not
solved, and cannot be solved later in the proof. As the goals are not
solved, the proof cannot be closed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">give_up</span></code> tactic can be used while editing a proof, to choose to
write the proof script in a non-sequential order.</p>
</dd></dl>

</div>
<div class="section" id="delaying-solving-unification-constraints">
<h2>Delaying solving unification constraints<a class="headerlink" href="#delaying-solving-unification-constraints" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt id="coq:tacn.solve-constraints">
<code class="sig-name descname"><span class="notation"><span>solve</span><span>_</span><span>constraints</span></span></code><a class="headerlink" href="#coq:tacn.solve-constraints" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq flag">
<dt id="coq:flag.solve-unification-constraints">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Solve</span> <span>Unification</span> <span>Constraints</span></span></code><a class="headerlink" href="#coq:flag.solve-unification-constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, after each tactic application, postponed typechecking unification
problems are resolved using heuristics. Unsetting this flag disables this
behavior, allowing tactics to leave unification constraints unsolved. Use the
<a class="reference internal" href="#coq:tacn.solve-constraints" title="solve_constraints"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">solve_constraints</span></code></a> tactic at any point to solve the constraints.</p>
</dd></dl>

</div>
<div class="section" id="proof-maintenance">
<h2>Proof maintenance<a class="headerlink" href="#proof-maintenance" title="Permalink to this headline">¶</a></h2>
<p><em>Experimental.</em>  Many tactics, such as <a class="reference internal" href="#coq:tacv.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a>, can automatically generate names, such
as &quot;H0&quot; or &quot;H1&quot; for a new hypothesis introduced from a goal.  Subsequent proof steps
may explicitly refer to these names.  However, future versions of Coq may not assign
names exactly the same way, which could cause the proof to fail because the
new names don't match the explicit references in the proof.</p>
<p>The following &quot;Mangle Names&quot; settings let users find all the
places where proofs rely on automatically generated names, which can
then be named explicitly to avoid any incompatibility.  These
settings cause Coq to generate different names, producing errors for
references to automatically generated names.</p>
<dl class="coq flag">
<dt id="coq:flag.mangle-names">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Mangle</span> <span>Names</span></span></code><a class="headerlink" href="#coq:flag.mangle-names" title="Permalink to this definition">¶</a></dt>
<dd><p>When set, generated names use the prefix specified in the following
option instead of the default prefix.</p>
</dd></dl>

<dl class="coq opt">
<dt id="coq:opt.mangle-names-prefix">
<em class="property"><span class="sigannot">Option</span></em> <code class="sig-name descname"><span class="notation"><span>Mangle</span> <span>Names</span> <span>Prefix</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code><a class="headerlink" href="#coq:opt.mangle-names-prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the prefix to use when generating names.</p>
</dd></dl>

</div>
<div class="section" id="performance-oriented-tactic-variants">
<h2>Performance-oriented tactic variants<a class="headerlink" href="#performance-oriented-tactic-variants" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt id="coq:tacn.change-no-check">
<code class="sig-name descname"><span class="notation"><span>change</span><span>_</span><span>no</span><span>_</span><span>check</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.change-no-check" title="Permalink to this definition">¶</a></dt>
<dd><p>For advanced usage. Similar to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">change</span></span> <span class="hole"><span class="pre">term</span></span></span></code>, but as an optimization,
it skips checking that <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> is convertible to the goal.</p>
<p>Recall that the Coq kernel typechecks proofs again when they are concluded to
ensure safety. Hence, using <a class="reference internal" href="#coq:tacn.change" title="change"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change</span></code></a> checks convertibility twice
overall, while <a class="reference internal" href="#coq:tacn.change-no-check" title="change_no_check"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change_no_check</span></code></a> can produce ill-typed terms,
but checks convertibility only once.
Hence, <a class="reference internal" href="#coq:tacn.change-no-check" title="change_no_check"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change_no_check</span></code></a> can be useful to speed up certain proof
scripts, especially if one knows by construction that the argument is
indeed convertible to the goal.</p>
<p>In the following example, <a class="reference internal" href="#coq:tacn.change-no-check" title="change_no_check"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change_no_check</span></code></a> replaces <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">False</span></span></code> by
<code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">True</span></span></code>, but <code class="code highlight coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Qed</span></span></code> then rejects the proof, ensuring consistency.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk9e" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk9e"><span class="highlight"><span class="kn">Goal</span> <span class="kt">False</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chk9f" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chk9f"><span class="highlight"><span class="nb">change_no_check</span> <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">exact</span> I.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chka0" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chka0"><span class="highlight"><span class="kn">Fail</span> <span class="kn">Qed</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
The term <span class="s2">&quot;I&quot;</span> has type <span class="s2">&quot;True&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type <span class="s2">&quot;False&quot;</span>.</span></blockquote></div></div></small></span></pre></div></div>
<p><a class="reference internal" href="#coq:tacn.change-no-check" title="change_no_check"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change_no_check</span></code></a> supports all of <code class="docutils literal notranslate"><span class="pre">change</span></code>'s variants.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>change</span><span>_</span><span>no</span><span>_</span><span>check</span> <span class="hole">term</span> <span>with</span> <span class="hole">term</span><span>’</span></span></code></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>change</span><span>_</span><span>no</span><span>_</span><span>check</span> <span class="hole">term</span> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">+</span></span> <span>with</span> <span class="hole">term</span><span>’</span></span></code></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>change</span><span>_</span><span>no</span><span>_</span><span>check</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span>at</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span>with</span> <span class="hole">term</span></span><span class="notation-sup">?</span></span> <span>in</span> <span class="hole">ident</span></span></code></dt>
<dd><div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chka1" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chka1"><span class="highlight"><span class="kn">Goal</span> <span class="kt">True</span> -&gt; <span class="kt">False</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span> -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chka2" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chka2"><span class="highlight"><span class="nb">intro</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">True</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chka3" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chka3"><span class="highlight"><span class="nb">change_no_check</span> <span class="kt">False</span> <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">False</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">exact</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chka4" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chka4"><span class="highlight"><span class="kn">Fail</span> <span class="kn">Qed</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
The term <span class="s2">&quot;fun H : True =&gt; H&quot;</span> has type <span class="s2">&quot;True -&gt; True&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type <span class="s2">&quot;True -&gt; False&quot;</span>.</span></blockquote></div></div></small></span></pre></div></div>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.convert-concl-no-check">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>convert</span><span>_</span><span>concl</span><span>_</span><span>no</span><span>_</span><span>check</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacv.convert-concl-no-check" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated old name for <a class="reference internal" href="#coq:tacn.change-no-check" title="change_no_check"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change_no_check</span></code></a>. Does not support any of its
variants.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.exact-no-check">
<code class="sig-name descname"><span class="notation"><span>exact</span><span>_</span><span>no</span><span>_</span><span>check</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.exact-no-check" title="Permalink to this definition">¶</a></dt>
<dd><p>For advanced usage. Similar to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">exact</span></span> <span class="hole"><span class="pre">term</span></span></span></code>, but as an optimization,
it skips checking that <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code> has the goal's type, relying on the kernel
check instead. See <a class="reference internal" href="#coq:tacn.change-no-check" title="change_no_check"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change_no_check</span></code></a> for more explanations.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chka5" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chka5"><span class="highlight"><span class="kn">Goal</span> <span class="kt">False</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">exact_no_check</span> I.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chka6" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chka6"><span class="highlight"><span class="kn">Fail</span> <span class="kn">Qed</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
The term <span class="s2">&quot;I&quot;</span> has type <span class="s2">&quot;True&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type <span class="s2">&quot;False&quot;</span>.</span></blockquote></div></div></small></span></pre></div></div>
<dl class="coq tacv">
<dt id="coq:tacv.vm-cast-no-check">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>vm</span><span>_</span><span>cast</span><span>_</span><span>no</span><span>_</span><span>check</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacv.vm-cast-no-check" title="Permalink to this definition">¶</a></dt>
<dd><p>For advanced usage. Similar to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">exact</span></span><span><span class="pre">_</span></span><span><span class="pre">no</span></span><span><span class="pre">_</span></span><span><span class="pre">check</span></span> <span class="hole"><span class="pre">term</span></span></span></code>, but additionally
instructs the kernel to use <a class="reference internal" href="#coq:tacv.vm-compute" title="vm_compute"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">vm_compute</span></code></a> to compare the
goal's type with the <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>'s type.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chka7" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chka7"><span class="highlight"><span class="kn">Goal</span> <span class="kt">False</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">vm_cast_no_check</span> I.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chka8" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chka8"><span class="highlight"><span class="kn">Fail</span> <span class="kn">Qed</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
The term <span class="s2">&quot;I&quot;</span> has type <span class="s2">&quot;True&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type <span class="s2">&quot;False&quot;</span>.</span></blockquote></div></div></small></span></pre></div></div>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.native-cast-no-check">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>native</span><span>_</span><span>cast</span><span>_</span><span>no</span><span>_</span><span>check</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacv.native-cast-no-check" title="Permalink to this definition">¶</a></dt>
<dd><p>for advanced usage. similar to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">exact</span></span><span><span class="pre">_</span></span><span><span class="pre">no</span></span><span><span class="pre">_</span></span><span><span class="pre">check</span></span> <span class="hole"><span class="pre">term</span></span></span></code>, but additionally
instructs the kernel to use <a class="reference internal" href="#coq:tacv.native-compute" title="native_compute"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">native_compute</span></code></a> to compare the goal's
type with the <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span></span></code>'s type.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chka9" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chka9"><span class="highlight"><span class="kn">Goal</span> <span class="kt">False</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">native_cast_no_check</span> I.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="tactics-rst-chkaa" style="display: none" type="checkbox"><label class="coq-input" for="tactics-rst-chkaa"><span class="highlight"><span class="kn">Fail</span> <span class="kn">Qed</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
Dynlink error: implementation mismatch on Nativelib</span></blockquote></div></div></small></span></pre></div></div>
</dd></dl>

</dd></dl>

<dl class="footnote brackets">
<dt class="label" id="id14"><span class="brackets"><a class="fn-backref" href="#id3">1</a></span></dt>
<dd><p>Actually, only the second subgoal will be generated since the
other one can be automatically checked.</p>
</dd>
<dt class="label" id="id15"><span class="brackets"><a class="fn-backref" href="#id4">2</a></span></dt>
<dd><p>This corresponds to the cut rule of sequent calculus.</p>
</dd>
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id7">3</a></span></dt>
<dd><p>Reminder: opaque constants will not be expanded by δ reductions.</p>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ltac.html" class="btn btn-neutral float-right" title="The tactic language" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="proof-handling.html" class="btn btn-neutral float-left" title="Proof handling" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>