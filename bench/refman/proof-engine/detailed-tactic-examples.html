

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Detailed examples of tactics &mdash; Coq 8.10.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/notations.js"></script>
        <script src="../_static/alectryon.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
  <link rel="stylesheet" href="../_static/alectryon.css" type="text/css" />
  <link rel="stylesheet" href="../_static/tango_subtle.css" type="text/css" />
  <link rel="stylesheet" href="../_static/tango_subtle.min.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The SSReflect proof language" href="ssreflect-proof-language.html" />
    <link rel="prev" title="The tactic language" href="ltac.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.10.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Indexes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">Preamble</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction and Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">Early history of Coq</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../history.html#historical-roots">Historical roots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-1-to-5">Versions 1 to 5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-1">Version 1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-2">Version 2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-3">Version 3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-4">Version 4</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-5">Version 5</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-6">Versions 6</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-1">Version 6.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-2">Version 6.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-3">Version 6.3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-7">Versions 7</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-0-and-7-1">Details of changes in 7.0 and 7.1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#main-novelties">Main novelties</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-2">Details of changes in 7.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-3">Details of changes in 7.3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#changes-in-7-3-1">Changes in 7.3.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-4">Details of changes in 7.4</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changes.html">Recent changes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-10">Version 8.10</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#other-changes-in-8-10-beta1">Other changes in 8.10+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-beta2">Changes in 8.10+beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-beta3">Changes in 8.10+beta3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-0">Changes in 8.10.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-1">Changes in 8.10.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-2">Changes in 8.10.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-9">Version 8.9</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id147">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-9-beta1">Details of changes in 8.9+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-8-0">Changes in 8.8.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-8-1">Changes in 8.8.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-8">Version 8.8</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id149">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-beta1">Details of changes in 8.8+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-0">Details of changes in 8.8.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-1">Details of changes in 8.8.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-2">Details of changes in 8.8.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-7">Version 8.7</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id150">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#potential-compatibility-issues">Potential compatibility issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta1">Details of changes in 8.7+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta2">Details of changes in 8.7+beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-0">Details of changes in 8.7.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-1">Details of changes in 8.7.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-2">Details of changes in 8.7.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-6">Version 8.6</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id151">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#potential-sources-of-incompatibilities">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6beta1">Details of changes in 8.6beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6">Details of changes in 8.6</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6-1">Details of changes in 8.6.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-5">Version 8.5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id152">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id153">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta1">Details of changes in 8.5beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta2">Details of changes in 8.5beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta3">Details of changes in 8.5beta3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5">Details of changes in 8.5</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl1">Details of changes in 8.5pl1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl2">Details of changes in 8.5pl2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl3">Details of changes in 8.5pl3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-4">Version 8.4</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id154">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id156">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta">Details of changes in 8.4beta</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta2">Details of changes in 8.4beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4">Details of changes in 8.4</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-3">Version 8.3</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id157">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-2">Version 8.2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id158">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id159">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-1">Version 8.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id160">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1beta">Details of changes in 8.1beta</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1gamma">Details of changes in 8.1gamma</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1">Details of changes in 8.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-0">Version 8.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id161">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-old-syntax">Details of changes in 8.0beta old syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-new-syntax">Details of changes in 8.0beta new syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0">Details of changes in 8.0</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">The language</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-specification-language.html">The Gallina specification language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#about-the-grammars-in-the-manual">About the grammars in the manual</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#lexical-conventions">Lexical conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#terms">Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#syntax-of-terms">Syntax of terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#types">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#qualified-identifiers-and-simple-identifiers">Qualified identifiers and simple identifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#numerals">Numerals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#binders">Binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#abstractions">Abstractions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#products">Products</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#applications">Applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#type-cast">Type cast</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#inferable-subterms">Inferable subterms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#let-in-definitions">Let-in definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#definition-by-case-analysis">Definition by case analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#recursive-functions">Recursive functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#the-vernacular">The Vernacular</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#assumptions">Assumptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#inductive-definitions">Inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#simple-inductive-types">Simple inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#simple-annotated-inductive-types">Simple annotated inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#parameterized-inductive-types">Parameterized inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#variants">Variants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#mutually-defined-inductive-types">Mutually defined inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#co-inductive-types">Co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#definition-of-recursive-functions">Definition of recursive functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#definition-of-functions-by-recursion-over-inductive-objects">Definition of functions by recursion over inductive objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#definitions-of-recursive-objects-in-co-inductive-types">Definitions of recursive objects in co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#assertions-and-proofs">Assertions and proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#attributes">Attributes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#record-types">Record types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#primitive-projections">Primitive Projections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#primitive-record-types">Primitive Record Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#compatibility-projections-and-match">Compatibility Projections and <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">match</span></span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#variants-and-extensions-of-match">Variants and extensions of <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">match</span></span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#multiple-and-nested-pattern-matching">Multiple and nested pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#pattern-matching-on-boolean-values-the-if-expression">Pattern-matching on boolean values: the if expression</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#irrefutable-patterns-the-destructuring-let-variants">Irrefutable patterns: the destructuring let variants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#first-destructuring-let-syntax">First destructuring let syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#second-destructuring-let-syntax">Second destructuring let syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-pretty-printing-of-match-expressions">Controlling pretty-printing of match expressions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-nested-patterns">Printing nested patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#factorization-of-clauses-with-same-right-hand-side">Factorization of clauses with same right-hand side</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#use-of-a-default-clause">Use of a default clause</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-of-wildcard-patterns">Printing of wildcard patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-of-the-elimination-predicate">Printing of the elimination predicate</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-matching-on-irrefutable-patterns">Printing matching on irrefutable patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-matching-on-booleans">Printing matching on booleans</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions">Advanced recursive functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#section-mechanism">Section mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#module-system">Module system</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#reserved-commands-inside-an-interactive-module">Reserved commands inside an interactive module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#reserved-commands-inside-an-interactive-module-type">Reserved commands inside an interactive module type:</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#libraries-and-qualified-names">Libraries and qualified names</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#names-of-libraries">Names of libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#qualified-names">Qualified names</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#libraries-and-filesystem">Libraries and filesystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#implicit-arguments">Implicit arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#the-different-kinds-of-implicit-arguments">The different kinds of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function">Implicit arguments inferable from the knowledge of other arguments of a function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#implicit-arguments-inferable-by-resolution">Implicit arguments inferable by resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#maximal-or-non-maximal-insertion-of-implicit-arguments">Maximal or non maximal insertion of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#casual-use-of-implicit-arguments">Casual use of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#declaration-of-implicit-arguments">Declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#implicit-argument-binders">Implicit Argument Binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#declaring-implicit-arguments">Declaring Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#automatic-declaration-of-implicit-arguments">Automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#mode-for-automatic-declaration-of-implicit-arguments">Mode for automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-strict-implicit-arguments">Controlling strict implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-contextual-implicit-arguments">Controlling contextual implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-reversible-pattern-implicit-arguments">Controlling reversible-pattern implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments">Controlling the insertion of implicit arguments not followed by explicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#explicit-applications">Explicit applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#renaming-implicit-arguments">Renaming implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#displaying-what-the-implicit-arguments-are">Displaying what the implicit arguments are</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#explicit-displaying-of-implicit-arguments-for-pretty-printing">Explicit displaying of implicit arguments for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#interaction-with-subtyping">Interaction with subtyping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#deactivation-of-implicit-arguments-for-parsing">Deactivation of implicit arguments for parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#canonical-structures">Canonical structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#implicit-types-of-variables">Implicit types of variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#implicit-generalization">Implicit generalization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#coercions">Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#printing-constructions-in-full">Printing constructions in full</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#printing-universes">Printing universes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#existential-variables">Existential variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#explicit-displaying-of-existential-instances-for-pretty-printing">Explicit displaying of existential instances for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#solving-existential-variables-using-tactics">Solving existential variables using tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#primitive-integers">Primitive Integers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/coq-library.html">The <span class="smallcaps">Coq</span> library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html#the-basic-library">The basic library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#notations">Notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#logic">Logic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#propositional-connectives">Propositional Connectives</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#quantifiers">Quantifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#equality">Equality</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#lemmas">Lemmas</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#datatypes">Datatypes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#programming">Programming</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#specification">Specification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#basic-arithmetics">Basic Arithmetics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#well-founded-recursion">Well-founded recursion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#accessing-the-type-level">Accessing the Type level</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#tactics">Tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html#the-standard-library">The standard library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#survey">Survey</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#peanos-arithmetic-nat">Peano’s arithmetic (nat)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#notations-for-integer-arithmetics">Notations for integer arithmetics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#real-numbers-library">Real numbers library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#notations-for-real-numbers">Notations for real numbers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#some-tactics-for-real-numbers">Some tactics for real numbers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#list-library">List library</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html#users-contributions">Users’ contributions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/cic.html">Calculus of Inductive Constructions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#the-terms">The terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#terms">Terms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#typing-rules">Typing rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#conversion-rules">Conversion rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#reduction">β-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#iota-reduction">ι-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#delta-reduction">δ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#zeta-reduction">ζ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#expansion">η-expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#proof-irrelevance">Proof Irrelevance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#convertibility">Convertibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#subtyping-rules">Subtyping rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#inductive-definitions">Inductive Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#types-of-inductive-objects">Types of inductive objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#well-formed-inductive-definitions">Well-formed inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#arity-of-a-given-sort">Arity of a given sort</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#arity">Arity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#type-of-constructor">Type of constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#positivity-condition">Positivity Condition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#strict-positivity">Strict positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#nested-positivity">Nested Positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#correctness-rules">Correctness rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#template-polymorphism">Template polymorphism</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#destructors">Destructors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#the-match-with-end-construction">The match ... with ... end construction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#fixpoint-definitions">Fixpoint definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#id29">Typing rule</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#reduction-rule">Reduction rule</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#admissible-rules-for-global-environments">Admissible rules for global environments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#co-inductive-types">Co-inductive types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#the-calculus-of-inductive-constructions-with-impredicative-set">The Calculus of Inductive Constructions with impredicative Set</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/module-system.html">The Module System</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/module-system.html#modules-and-module-types">Modules and module types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/module-system.html#typing-modules">Typing Modules</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">The proof engine</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="vernacular-commands.html">Vernacular commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#displaying">Displaying</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#flags-options-and-tables">Flags, Options and Tables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#scope-qualifiers-for-set-and-unset">Scope qualifiers for <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Set</span></code> and <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Unset</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#requests-to-the-environment">Requests to the environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#printing-flags">Printing flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#loading-files">Loading files</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#compiled-files">Compiled files</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#loadpath">Loadpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#backtracking">Backtracking</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#quitting-and-debugging">Quitting and debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#controlling-display">Controlling display</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#controlling-the-reduction-strategies-and-the-conversion-algorithm">Controlling the reduction strategies and the conversion algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#controlling-the-locality-of-commands">Controlling the locality of commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#internal-registration-commands">Internal registration commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#exposing-constants-to-ocaml-libraries">Exposing constants to OCaml libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#inlining-hints-for-the-fast-reduction-machines">Inlining hints for the fast reduction machines</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#registering-primitive-operations">Registering primitive operations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="proof-handling.html">Proof handling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#switching-on-off-the-proof-editing-mode">Switching on/off the proof editing mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#proof-using-options">Proof using options</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#name-a-set-of-section-hypotheses-for-proof-using">Name a set of section hypotheses for <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#navigation-in-the-proof-tree">Navigation in the proof tree</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#bullets">Bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#set-bullet-behavior">Set Bullet Behavior</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#requesting-information">Requesting information</a></li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#showing-differences-between-proof-steps">Showing differences between proof steps</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#how-to-enable-diffs">How to enable diffs</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#how-diffs-are-calculated">How diffs are calculated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#controlling-the-effect-of-proof-editing-commands">Controlling the effect of proof editing commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#controlling-memory-usage">Controlling memory usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">Tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#common-elements-of-tactics">Common elements of tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#invocation-of-tactics">Invocation of tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#bindings-list">Bindings list</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#occurrence-sets-and-occurrence-clauses">Occurrence sets and occurrence clauses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#applying-theorems">Applying theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#managing-the-local-context">Managing the local context</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#controlling-the-proof-flow">Controlling the proof flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#case-analysis-and-induction">Case analysis and induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#rewriting-expressions">Rewriting expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#performing-computations">Performing computations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#conversion-tactics-applied-to-hypotheses">Conversion tactics applied to hypotheses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#automation">Automation</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#controlling-automation">Controlling automation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#the-hints-databases-for-auto-and-eauto">The hints databases for auto and eauto</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tactics.html#creating-hint-databases">Creating Hint databases</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#hint-databases-defined-in-the-coq-standard-library">Hint databases defined in the Coq standard library</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#hint-locality">Hint locality</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#setting-implicit-automation-tactics">Setting implicit automation tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#decision-procedures">Decision procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#checking-properties-of-terms">Checking properties of terms</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#equality">Equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#equality-and-inductive-sets">Equality and inductive sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#inversion">Inversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#classical-tactics">Classical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#automating">Automating</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#non-logical-tactics">Non-logical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#delaying-solving-unification-constraints">Delaying solving unification constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#proof-maintenance">Proof maintenance</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#performance-oriented-tactic-variants">Performance-oriented tactic variants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ltac.html">The tactic language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ltac.html#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="ltac.html#semantics">Semantics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#sequence">Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#local-application-of-tactics">Local application of tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#goal-selectors">Goal selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#for-loop">For loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#repeat-loop">Repeat loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#error-catching">Error catching</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#detecting-progress">Detecting progress</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#backtracking-branching">Backtracking branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#first-tactic-to-work">First tactic to work</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#left-biased-branching">Left-biased branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#generalized-biased-branching">Generalized biased branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#soft-cut">Soft cut</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#checking-the-successes">Checking the successes</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#checking-the-failure">Checking the failure</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#checking-the-success">Checking the success</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#solving">Solving</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#identity">Identity</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#failing">Failing</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#timeout">Timeout</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#timing-a-tactic">Timing a tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#timing-a-tactic-that-evaluates-to-a-term">Timing a tactic that evaluates to a term</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#local-definitions">Local definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#application">Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#function-construction">Function construction</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#pattern-matching-on-terms">Pattern matching on terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#pattern-matching-on-goals">Pattern matching on goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#filling-a-term-context">Filling a term context</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#generating-fresh-hypothesis-names">Generating fresh hypothesis names</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#computing-in-a-constr">Computing in a constr</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#recovering-the-type-of-a-term">Recovering the type of a term</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#manipulating-untyped-terms">Manipulating untyped terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#counting-the-goals">Counting the goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#testing-boolean-expressions">Testing boolean expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#proving-a-subgoal-as-a-separate-lemma">Proving a subgoal as a separate lemma</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ltac.html#tactic-toplevel-definitions">Tactic toplevel definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#defining-ltac-functions">Defining <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#printing-ltac-tactics">Printing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ltac.html#examples-of-using-ltac">Examples of using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub></a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#proof-that-the-natural-numbers-have-at-least-two-elements">Proof that the natural numbers have at least two elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#proving-that-a-list-is-a-permutation-of-a-second-list">Proving that a list is a permutation of a second list</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#deciding-intuitionistic-propositional-logic">Deciding intuitionistic propositional logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#deciding-type-isomorphisms">Deciding type isomorphisms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ltac.html#debugging-ltac-tactics">Debugging <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#backtraces">Backtraces</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#info-trace">Info trace</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#interactive-debugger">Interactive debugger</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#profiling-ltac-tactics">Profiling <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#run-time-optimization-tactic">Run-time optimization tactic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Detailed examples of tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#dependent-induction">dependent induction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-larger-example">A larger example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#autorewrite">autorewrite</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#usage">Usage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#getting-started">Getting started</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#compatibility-issues">Compatibility issues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#gallina-extensions"><span class="smallcaps">Gallina</span> extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#pattern-assignment">Pattern assignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#pattern-conditional">Pattern conditional</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#parametric-polymorphism">Parametric polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#anonymous-arguments">Anonymous arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#wildcards">Wildcards</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#abbreviations">Abbreviations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#matching">Matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#occurrence-selection">Occurrence selection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#basic-localization">Basic localization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#basic-tactics">Basic tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#bookkeeping">Bookkeeping</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#the-defective-tactics">The defective tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-move-tactic">The move tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-case-tactic">The case tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-elim-tactic">The elim tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-apply-tactic">The apply tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#discharge">Discharge</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#clear-rules">Clear rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#matching-for-apply-and-exact">Matching for apply and exact</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-abstract-tactic">The abstract tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#introduction-in-the-context">Introduction in the context</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#simplification-items">Simplification items</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#views">Views</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#clear-switch">Clear switch</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#branching-and-destructuring">Branching and destructuring</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#block-introduction">Block introduction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#generation-of-equations">Generation of equations</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#type-families">Type families</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#control-flow">Control flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#indentation-and-bullets">Indentation and bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#terminators">Terminators</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#selectors">Selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#iteration">Iteration</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#localization">Localization</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#structure">Structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-have-tactic">The have tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#generating-let-in-context-entries-with-have">Generating let in context entries with have</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-have-tactic-and-typeclass-resolution">The have tactic and typeclass resolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#variants-the-suff-and-wlog-tactics">Variants: the suff and wlog tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#rewriting">Rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#an-extended-rewrite-tactic">An extended rewrite tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#remarks-and-examples">Remarks and examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#rewrite-redex-selection">Rewrite redex selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#chained-rewrite-steps">Chained rewrite steps</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#explicit-redex-switches-are-matched-first">Explicit redex switches are matched first</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#occurrence-switches-and-redex-switches">Occurrence switches and redex switches</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#occurrence-selection-and-repetition">Occurrence selection and repetition</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#multi-rule-rewriting">Multi-rule rewriting</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#wildcards-vs-abstractions">Wildcards vs abstractions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#when-ssr-rewrite-fails-on-standard-coq-licit-rewrite">When <span class="smallcaps">SSReflect</span> rewrite fails on standard <span class="smallcaps">Coq</span> licit rewrite</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#existential-metavariables-and-rewriting">Existential metavariables and rewriting</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#rewriting-under-binders">Rewriting under binders</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-under-tactic">The under tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#interactive-mode">Interactive mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#one-liner-mode">One-liner mode</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#locking-unlocking">Locking, unlocking</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#congruence">Congruence</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#contextual-patterns">Contextual patterns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#matching-contextual-patterns">Matching contextual patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#examples">Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#contextual-pattern-in-set-and-the-tactical">Contextual pattern in set and the : tactical</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#contextual-patterns-in-rewrite">Contextual patterns in rewrite</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#patterns-for-recurrent-contexts">Patterns for recurrent contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#views-and-reflection">Views and reflection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-eliminations">Interpreting eliminations</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-assumptions">Interpreting assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#specializing-assumptions">Specializing assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-goals">Interpreting goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#boolean-reflection">Boolean reflection</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#the-reflect-predicate">The reflect predicate</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#general-mechanism-for-interpreting-goals-and-assumptions">General mechanism for interpreting goals and assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#id13">Specializing assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#id14">Interpreting assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-equivalences">Interpreting equivalences</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#declaring-new-hint-views">Declaring new Hint Views</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#multiple-views">Multiple views</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#ssr-searching-tool"><span class="smallcaps">SSReflect</span> searching tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#synopsis-and-index">Synopsis and Index</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#parameters">Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#items-and-switches">Items and switches</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#tacticals">Tacticals</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#commands">Commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#settings">Settings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">User extensions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations">Notations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#basic-notations">Basic notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#precedences-and-associativity">Precedences and associativity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#complex-notations">Complex notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simple-factorization-rules">Simple factorization rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-symbolic-notations">Displaying symbolic notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-infix-command">The Infix command</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#reserving-notations">Reserving notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simultaneous-definition-of-terms-and-notations">Simultaneous definition of terms and notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-notations">Displaying information about notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#locating-notations">Locating notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-and-binders">Notations and binders</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-identifiers">Binders bound in the notation and parsed as identifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-patterns">Binders bound in the notation and parsed as patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-terms">Binders bound in the notation and parsed as terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-not-bound-in-the-notation">Binders not bound in the notation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns">Notations with recursive patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns-involving-binders">Notations with recursive patterns involving binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#predefined-entries">Predefined entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#custom-entries">Custom entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#summary">Summary</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#syntax-of-notations">Syntax of notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#persistence-of-notations">Persistence of notations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes">Interpretation scopes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#global-interpretation-rules-for-notations">Global interpretation rules for notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-interpretation-rules-for-notations">Local interpretation rules for notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-opening-of-an-interpretation-scope">Local opening of an interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binding-arguments-of-a-constant-to-an-interpretation-scope">Binding arguments of a constant to an interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binding-types-of-arguments-to-an-interpretation-scope">Binding types of arguments to an interpretation scope</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-type-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">type_scope</span></code> interpretation scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-function-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">function_scope</span></code> interpretation scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes-used-in-the-standard-library-of-coq">Interpretation scopes used in the standard library of Coq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-scopes">Displaying information about scopes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#numeral-notations">Numeral notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#string-notations">String notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#tactic-notations">Tactic Notations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-induction-principles-with-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#automatic-declaration-of-schemes">Automatic declaration of schemes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#combined-scheme">Combined Scheme</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-induction-principles-with-functional-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Functional</span></code> <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-inversion-principles-with-derive-inversion">Generation of inversion principles with <code class="docutils literal notranslate"><span class="pre">Derive</span></code> <code class="docutils literal notranslate"><span class="pre">Inversion</span></code></a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Practical tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#interactive-use-coqtop">Interactive use (coqtop)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#batch-compilation-coqc">Batch compilation (coqc)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#customization-at-launch-time">Customization at launch time</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-resource-file">By resource file</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-environment-variables">By environment variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-command-line-options">By command line options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-libraries-checker-coqchk">Compiled libraries checker (coqchk)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#using-coq-as-a-library">Using Coq as a library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project">Building a <span class="smallcaps">Coq</span> project</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-coq-makefile">Building a <span class="smallcaps">Coq</span> project with coq_makefile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#coqmakefile-local">CoqMakefile.local</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#timing-targets-and-performance-testing">Timing targets and performance testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#reusing-extending-the-generated-makefile">Reusing/extending the generated Makefile</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#building-a-subset-of-the-targets-with-j">Building a subset of the targets with <code class="docutils literal notranslate"><span class="pre">-j</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-dune">Building a <span class="smallcaps">Coq</span> project with Dune</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#computing-module-dependencies">Computing Module dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#documenting-coq-files-with-coqdoc">Documenting <span class="smallcaps">Coq</span> files with coqdoc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#principles">Principles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#coq-material-inside-documentation"><span class="smallcaps">Coq</span> material inside documentation.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#pretty-printing">Pretty-printing.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#sections">Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#lists">Lists.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#rules">Rules.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#emphasis">Emphasis.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#escaping-to-latex-and-html">Escaping to <span class="smallcaps">LaTeX</span> and HTML.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#verbatim">Verbatim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#hyperlinks">Hyperlinks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#hiding-showing-parts-of-the-source">Hiding / Showing parts of the source.</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#the-coqdoc-latex-style-file">The coqdoc <span class="smallcaps">LaTeX</span> style file</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#embedded-coq-phrases-inside-latex-documents">Embedded Coq phrases inside <span class="smallcaps">LaTeX</span> documents</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#man-pages">Man pages</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#managing-files-and-buffers-basic-editing">Managing files and buffers, basic editing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#interactive-navigation-into-coq-scripts">Interactive navigation into Coq scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#proof-folding">Proof folding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#vernacular-commands-templates">Vernacular commands, templates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#queries">Queries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#compilation">Compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#customizations">Customizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#using-unicode-symbols">Using Unicode symbols</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#displaying-unicode-symbols">Displaying Unicode symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#bindings-for-input-of-unicode-symbols">Bindings for input of Unicode symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#adding-custom-bindings">Adding custom bindings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#character-encoding-for-saved-files">Character encoding for saved files</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Addendum</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extended-pattern-matching.html">Extended pattern matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#patterns">Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#multiple-patterns">Multiple patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#aliasing-subpatterns">Aliasing subpatterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#nested-patterns">Nested patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#disjunctive-patterns">Disjunctive patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#about-patterns-of-parametric-types">About patterns of parametric types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#parameters-in-patterns">Parameters in patterns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#implicit-arguments-in-patterns">Implicit arguments in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#matching-objects-of-dependent-types">Matching objects of dependent types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#understanding-dependencies-in-patterns">Understanding dependencies in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#when-the-elimination-predicate-must-be-provided">When the elimination predicate must be provided</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#dependent-pattern-matching">Dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#multiple-dependent-pattern-matching">Multiple dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#patterns-in-in">Patterns in <code class="docutils literal notranslate"><span class="pre">in</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#using-pattern-matching-to-write-proofs">Using pattern matching to write proofs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#pattern-matching-on-inductive-objects-involving-local-definitions">Pattern-matching on inductive objects involving local definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#pattern-matching-and-coercions">Pattern-matching and coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#when-does-the-expansion-strategy-fail">When does the expansion strategy fail?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#general-presentation">General Presentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions">Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#identity-coercions">Identity Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#inheritance-graph">Inheritance Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#declaring-coercions">Declaring Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#displaying-available-coercions">Displaying Available Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#activating-the-printing-of-coercions">Activating the Printing of Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#classes-as-records">Classes as Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-sections">Coercions and Sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-modules">Coercions and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-at-function-application">Coercion at function application</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-to-a-type">Coercion to a type</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-to-a-function">Coercion to a function</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/canonical-structures.html">Canonical Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/canonical-structures.html#notation-overloading">Notation overloading</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/canonical-structures.html#derived-canonical-structures">Derived Canonical Structures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/canonical-structures.html#hierarchy-of-structures">Hierarchy of structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/canonical-structures.html#compact-declaration-of-canonical-structures">Compact declaration of Canonical Structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/type-classes.html">Typeclasses</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#class-and-instance-declarations">Class and Instance declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#binding-classes">Binding classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#parameterized-instances">Parameterized Instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#sections-and-contexts">Sections and contexts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#building-hierarchies">Building hierarchies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#superclasses">Superclasses</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#substructures">Substructures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#summary-of-the-commands">Summary of the commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-transparent-typeclasses-opaque">Typeclasses Transparent, Typeclasses Opaque</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#settings">Settings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-eauto">Typeclasses eauto <code class="docutils literal notranslate"><span class="pre">:=</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#description-of-omega">Description of <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#arithmetical-goals-recognized-by-omega">Arithmetical goals recognized by <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#messages-from-omega">Messages from <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#using-omega">Using <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#options">Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#technical-data">Technical data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#overview-of-the-tactic">Overview of the tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#overview-of-the-omega-decision-procedure">Overview of the OMEGA decision procedure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#bugs">Bugs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#short-description-of-the-tactics">Short description of the tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#positivstellensatz-refutations"><em>Positivstellensatz</em> refutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#lra-a-decision-procedure-for-linear-real-and-rational-arithmetic"><code class="docutils literal notranslate"><span class="pre">lra</span></code>: a decision procedure for linear real and rational arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#lia-a-tactic-for-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">lia</span></code>: a tactic for linear integer arithmetic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#high-level-view-of-lia">High level view of <code class="docutils literal notranslate"><span class="pre">lia</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#cutting-plane-proofs">Cutting plane proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#case-split">Case split</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#nra-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">nra</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#nia-a-proof-procedure-for-non-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">nia</span></code>: a proof procedure for non-linear integer arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#psatz-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">psatz</span></code>: a proof procedure for non-linear arithmetic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#generating-ml-code">Generating ML Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#extraction-options">Extraction Options</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#setting-the-target-language">Setting the target language</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#inlining-and-optimizations">Inlining and optimizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extra-elimination-of-useless-arguments">Extra elimination of useless arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#realizing-axioms">Realizing axioms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#realizing-inductive-types">Realizing inductive types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#avoiding-conflicts-with-existing-filenames">Avoiding conflicts with existing filenames</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#additional-settings">Additional settings</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#differences-between-coq-and-ml-type-systems">Differences between <span class="smallcaps">Coq</span> and ML type systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#some-examples">Some examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#a-detailed-example-euclidean-division">A detailed example: Euclidean division</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extraction-s-horror-museum">Extraction's horror museum</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#users-contributions">Users' Contributions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/program.html">Program</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#elaborating-programs">Elaborating programs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#syntactic-control-over-equalities">Syntactic control over equalities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-definition">Program Definition</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-fixpoint">Program Fixpoint</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-lemma">Program Lemma</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#solving-obligations">Solving obligations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#frequently-asked-questions">Frequently Asked Questions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/ring.html">The ring and field tactic families</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#what-does-this-tactic-do">What does this tactic do?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#the-variables-map">The variables map</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#is-it-automatic">Is it automatic?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#concrete-usage-in-coq">Concrete usage in Coq</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#adding-a-ring-structure">Adding a ring structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#how-does-it-work">How does it work?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#dealing-with-fields">Dealing with fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#adding-a-new-field-structure">Adding a new field structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#history-of-ring">History of ring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#discussion">Discussion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: tactics for proving equalities in integral domains</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/nsatz.html#more-about-nsatz">More about <code class="docutils literal notranslate"><span class="pre">nsatz</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#introduction-to-generalized-rewriting">Introduction to generalized rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#relations-and-morphisms">Relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#adding-new-relations-and-morphisms">Adding new relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-non-reflexive-relations">Rewriting and non reflexive relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-non-symmetric-relations">Rewriting and non symmetric relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-in-ambiguous-setoid-contexts">Rewriting in ambiguous setoid contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#commands-and-tactics">Commands and tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#first-class-setoids-and-morphisms">First class setoids and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#tactics-enabled-on-user-provided-relations">Tactics enabled on user provided relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#printing-relations-and-morphisms">Printing relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#deprecated-syntax-and-backward-incompatibilities">Deprecated syntax and backward incompatibilities</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#extensions">Extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#subrelations">Subrelations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#constant-unfolding">Constant unfolding</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#strategies-for-rewriting">Strategies for rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#usage">Usage</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-annotations">Proof annotations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#automatic-suggestion-of-proof-annotations">Automatic suggestion of proof annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-blocks-and-error-resilience">Proof blocks and error resilience</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#caveats">Caveats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#interactive-mode">Interactive mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#id2">Caveats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#batch-mode">Batch mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#limiting-the-number-of-parallel-workers">Limiting the number of parallel workers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Miscellaneous extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/miscellaneous-extensions.html#program-derivation">Program derivation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#general-presentation">General Presentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-monomorphic">Polymorphic, Monomorphic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulative-noncumulative">Cumulative, NonCumulative</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#an-example-of-a-proof-using-cumulativity">An example of a proof using cumulativity</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulativity-weak-constraints">Cumulativity Weak Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#global-and-local-universes">Global and local universes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#conversion-and-unification">Conversion and unification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#minimization">Minimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#explicit-universes">Explicit Universes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-definitions">Polymorphic definitions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/sprop.html">SProp (proof irrelevant propositions)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#basic-constructs">Basic constructs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#encodings-for-strict-propositions">Encodings for strict propositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#issues-with-non-cumulativity">Issues with non-cumulativity</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Detailed examples of tactics</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/proof-engine/detailed-tactic-examples.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="detailed-examples-of-tactics">
<span id="detailedexamplesoftactics"></span><h1>Detailed examples of tactics<a class="headerlink" href="#detailed-examples-of-tactics" title="Permalink to this headline">¶</a></h1>
<p>This chapter presents detailed examples of certain tactics, to
illustrate their behavior.</p>
<div class="section" id="dependent-induction">
<span id="id1"></span><h2>dependent induction<a class="headerlink" href="#dependent-induction" title="Permalink to this headline">¶</a></h2>
<p>The tactics <code class="docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code> and <code class="docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">destruction</span></code> are another
solution for inverting inductive predicate instances and potentially
doing induction at the same time. It is based on the <code class="docutils literal notranslate"><span class="pre">BasicElim</span></code> tactic
of Conor McBride which works by abstracting each argument of an
inductive instance by a variable and constraining it by equalities
afterwards. This way, the usual induction and destruct tactics can be
applied to the abstracted instance and after simplification of the
equalities we get the expected goals.</p>
<p>The abstracting tactic is called generalize_eqs and it takes as
argument a hypothesis to generalize. It uses the JMeq datatype
defined in Coq.Logic.JMeq, hence we need to require it before. For
example, revisiting the first example of the inversion documentation:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Coq.Logic.JMeq.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">Le</span> : nat -&gt; nat -&gt; <span class="kt">Set</span> :=
     | LeO : <span class="kr">forall</span> <span class="nv">n</span>:nat, Le <span class="mi">0</span> n
     | LeS : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>:nat, Le n m -&gt; Le (S n) (S m).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">P</span> : nat -&gt; nat -&gt; <span class="kt">Prop</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chk0" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk0"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>:nat, Le (S n) m -&gt; P n m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, Le (S n) m -&gt; P n m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chk1" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk1"><span class="highlight"><span class="nb">intros</span> n m H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Le (S n) m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P n m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chk2" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk2"><span class="highlight">generalize_eqs H. <span class="c">(*. unfold *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, gen_x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Le gen_x m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">gen_x = S n -&gt; P n m</span></div></blockquote></div></div></small></span></pre></div><p>The index <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">n</span></code> gets abstracted by a variable here, but a corresponding
equality is added under the abstract instance so that no information
is actually lost. The goal is now almost amenable to do induction or
case analysis. One should indeed first move <code class="docutils literal notranslate"><span class="pre">n</span></code> into the goal to
strengthen it before doing induction, or <code class="docutils literal notranslate"><span class="pre">n</span></code> will be fixed in the
inductive hypotheses (this does not matter for case analysis). As a
rule of thumb, all the variables that appear inside constructors in
the indices of the hypothesis should be generalized. This is exactly
what the <code class="docutils literal notranslate"><span class="pre">generalize_eqs_vars</span></code> variant does:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="detailed-tactic-examples-rst-chk3" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk3"><span class="highlight">generalize_eqs_vars H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m, gen_x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Le gen_x m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">gen_x = S n -&gt; P n m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="detailed-tactic-examples-rst-chk4" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk4"><span class="highlight"><span class="nb">induction</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = S n -&gt; P n n0</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk5" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n0, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Le n0 m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHLe</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n0 = S n -&gt; P n m</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk5"><hr></label><div class="goal-conclusion"><span class="highlight">S n0 = S n -&gt; P n (S m)</span></div></blockquote></div></div></div></small></span></pre></div><p>As the hypothesis itself did not appear in the goal, we did not need
to use an heterogeneous equality to relate the new hypothesis to the
old one (which just disappeared here). However, the tactic works just
as well in this case, e.g.:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">Q</span> : <span class="kr">forall</span> (<span class="nv">n</span> <span class="nv">m</span> : nat), Le n m -&gt; <span class="kt">Prop</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chk6" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk6"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> (<span class="nv">p</span> : Le (S n) m), Q (S n) m p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> <span class="nv">m</span> : nat) (<span class="nv">p</span> : Le (S n) m), Q (S n) m p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="detailed-tactic-examples-rst-chk7" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk7"><span class="highlight"><span class="nb">intros</span> n m p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Le (S n) m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Q (S n) m p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="detailed-tactic-examples-rst-chk8" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk8"><span class="highlight">generalize_eqs_vars p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, gen_x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Le gen_x m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">p0</span> : Le (S n) m),
gen_x = S n -&gt; p ~= p0 -&gt; Q (S n) m p0</span></div></blockquote></div></div></small></span></pre></div><p>One drawback of this approach is that in the branches one will have to
substitute the equalities back into the instance to get the right
assumptions. Sometimes injection of constructors will also be needed
to recover the needed equalities. Also, some subgoals should be
directly solved because of inconsistent contexts arising from the
constraints on indexes. The nice thing is that we can make a tactic
based on discriminate, injection and variants of substitution to
automatically do such simplifications (which may involve the axiom K).
This is what the <code class="docutils literal notranslate"><span class="pre">simplify_dep_elim</span></code> tactic from <code class="docutils literal notranslate"><span class="pre">Coq.Program.Equality</span></code>
does. For example, we might simplify the previous goals considerably:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="detailed-tactic-examples-rst-chk9" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk9"><span class="highlight"><span class="nb">induction</span> p ; simplify_dep_elim.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Le n m</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHp</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">n0</span> : nat) (<span class="nv">p0</span> : Le (S n0) m),
n = S n0 -&gt; p ~= p0 -&gt; Q (S n0) m p0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Q (S n) (S m) (LeS n m p)</span></div></blockquote></div></div></small></span></pre></div><p>The higher-order tactic <code class="docutils literal notranslate"><span class="pre">do_depind</span></code> defined in <code class="docutils literal notranslate"><span class="pre">Coq.Program.Equality</span></code>
takes a tactic and combines the building blocks we have seen with it:
generalizing by equalities calling the given tactic with the
generalized induction hypothesis as argument and cleaning the subgoals
with respect to equalities. Its most important instantiations
are <code class="docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code> and <code class="docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">destruction</span></code> that do induction or
simply case analysis on the generalized hypothesis. For example we can
redo what we’ve done manually with dependent destruction:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chka" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chka"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">ex</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>:nat, Le (S n) m -&gt; P n m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, Le (S n) m -&gt; P n m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chkb" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chkb"><span class="highlight"><span class="nb">intros</span> n m H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Le (S n) m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P n m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="detailed-tactic-examples-rst-chkc" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chkc"><span class="highlight"><span class="nb">dependent destruction</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Le n m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P n (S m)</span></div></blockquote></div></div></small></span></pre></div><p>This gives essentially the same result as inversion. Now if the
destructed hypothesis actually appeared in the goal, the tactic would
still be able to invert it, contrary to dependent inversion. Consider
the following example on vectors:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Set Implicit Arguments</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">A</span> : <span class="kt">Set</span>.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">vector</span> : nat -&gt; <span class="kt">Type</span> :=
         | vnil : vector <span class="mi">0</span>
         | vcons : A -&gt; <span class="kr">forall</span> <span class="nv">n</span>, vector n -&gt; vector (S n).</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chkd" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chkd"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">n</span>, <span class="kr">forall</span> <span class="nv">v</span> : vector (S n),
         <span class="kr">exists</span> <span class="nv">v&#39;</span> : vector n, <span class="kr">exists</span> <span class="nv">a</span> : A, v = vcons a v&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">v</span> : vector (S n)),
<span class="kr">exists</span> (<span class="nv">v&#39;</span> : vector n) (<span class="nv">a</span> : A), v = vcons a v&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chke" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chke"><span class="highlight"><span class="nb">intros</span> n v.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">vector (S n)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> (<span class="nv">v&#39;</span> : vector n) (<span class="nv">a</span> : A), v = vcons a v&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="detailed-tactic-examples-rst-chkf" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chkf"><span class="highlight"><span class="nb">dependent destruction</span> v.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">vector n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> (<span class="nv">v&#39;</span> : vector n) (<span class="nv">a0</span> : A),
  vcons a v = vcons a0 v&#39;</span></div></blockquote></div></div></small></span></pre></div><p>In this case, the <code class="docutils literal notranslate"><span class="pre">v</span></code> variable can be replaced in the goal by the
generalized hypothesis only when it has a type of the form <code class="docutils literal notranslate"><span class="pre">vector</span> <span class="pre">(S</span> <span class="pre">n)</span></code>,
that is only in the second case of the destruct. The first one is
dismissed because <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">n</span> <span class="pre">&lt;&gt;</span> <span class="pre">0</span></code>.</p>
<div class="section" id="a-larger-example">
<h3>A larger example<a class="headerlink" href="#a-larger-example" title="Permalink to this headline">¶</a></h3>
<p>Let’s see how the technique works with induction on inductive
predicates on a real example. We will develop an example application
to the theory of simply-typed lambda-calculus formalized in a
dependently-typed style:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">type</span> : <span class="kt">Type</span> :=
         | base : type
         | arrow : type -&gt; type -&gt; type.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot; t --&gt; t&#39; &quot;</span> := (arrow t t&#39;) (<span class="kn">at level</span> <span class="mi">20</span>, t&#39; <span class="kn">at next level</span>).</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">ctx</span> : <span class="kt">Type</span> :=
         | empty : ctx
         | snoc : ctx -&gt; type -&gt; ctx.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot; G , tau &quot;</span> := (snoc G tau) (<span class="kn">at level</span> <span class="mi">20</span>, tau <span class="kn">at next level</span>).</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">conc</span> (<span class="nv">G</span> <span class="nv">D</span> : ctx) : ctx :=
         <span class="kr">match</span> D <span class="kr">with</span>
         | empty =&gt; G
         | snoc D&#39; x =&gt; snoc (conc G D&#39;) x
         <span class="kr">end</span>.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot; G ; D &quot;</span> := (conc G D) (<span class="kn">at level</span> <span class="mi">20</span>).</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">term</span> : ctx -&gt; type -&gt; <span class="kt">Type</span> :=
         | ax : <span class="kr">forall</span> <span class="nv">G</span> <span class="nv">tau</span>, term (G, tau) tau
         | weak : <span class="kr">forall</span> <span class="nv">G</span> <span class="nv">tau</span>,
                    term G tau -&gt; <span class="kr">forall</span> <span class="nv">tau&#39;</span>, term (G, tau&#39;) tau
         | abs : <span class="kr">forall</span> <span class="nv">G</span> <span class="nv">tau</span> <span class="nv">tau&#39;</span>,
                   term (G , tau) tau&#39; -&gt; term G (tau --&gt; tau&#39;)
         | app : <span class="kr">forall</span> <span class="nv">G</span> <span class="nv">tau</span> <span class="nv">tau&#39;</span>,
                   term G (tau --&gt; tau&#39;) -&gt; term G tau -&gt; term G tau&#39;.</span></span></span></pre></div><p>We have defined types and contexts which are snoc-lists of types. We
also have a <code class="docutils literal notranslate"><span class="pre">conc</span></code> operation that concatenates two contexts. The <code class="docutils literal notranslate"><span class="pre">term</span></code>
datatype represents in fact the possible typing derivations of the
calculus, which are isomorphic to the well-typed terms, hence the
name. A term is either an application of:</p>
<ul class="simple">
<li><p>the axiom rule to type a reference to the first variable in a
context</p></li>
<li><p>the weakening rule to type an object in a larger context</p></li>
<li><p>the abstraction or lambda rule to type a function</p></li>
<li><p>the application to type an application of a function to an argument</p></li>
</ul>
<p>Once we have this datatype we want to do proofs on it, like weakening:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chk10" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk10"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">weakening</span> : <span class="kr">forall</span> <span class="nv">G</span> <span class="nv">D</span> <span class="nv">tau</span>, term (G ; D) tau -&gt;
                  <span class="kr">forall</span> <span class="nv">tau&#39;</span>, term (G , tau&#39; ; D) tau.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">G</span> <span class="nv">D</span> : ctx) (<span class="nv">tau</span> : type),
term (G; D) tau -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;</span> : type, term ((G, tau&#39;); D) tau</span></div></blockquote></div></div></small></span></pre></div><p>The problem here is that we can’t just use induction on the typing
derivation because it will forget about the <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">;</span> <span class="pre">D</span></code> constraint appearing
in the instance. A solution would be to rewrite the goal as:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chk11" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk11"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">weakening&#39;</span> : <span class="kr">forall</span> <span class="nv">G&#39;</span> <span class="nv">tau</span>, term G&#39; tau -&gt;
                   <span class="kr">forall</span> <span class="nv">G</span> <span class="nv">D</span>, (G ; D) = G&#39; -&gt;
                   <span class="kr">forall</span> <span class="nv">tau&#39;</span>, term (G, tau&#39; ; D) tau.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">G&#39;</span> : ctx) (<span class="nv">tau</span> : type),
term G&#39; tau -&gt;
<span class="kr">forall</span> <span class="nv">G</span> <span class="nv">D</span> : ctx,
G; D = G&#39; -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;</span> : type, term ((G, tau&#39;); D) tau</span></div></blockquote></div></div></small></span></pre></div><p>With this proper separation of the index from the instance and the
right induction loading (putting <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">D</span></code> after the inducted-on
hypothesis), the proof will go through, but it is a very tedious
process. One is also forced to make a wrapper lemma to get back the
more natural statement. The <code class="docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code> tactic alleviates this
trouble by doing all of this plumbing of generalizing and substituting
back automatically. Indeed we can simply write:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Coq.Program.Tactics.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Coq.Program.Equality.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chk12" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk12"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">weakening</span> : <span class="kr">forall</span> <span class="nv">G</span> <span class="nv">D</span> <span class="nv">tau</span>, term (G ; D) tau -&gt;
                  <span class="kr">forall</span> <span class="nv">tau&#39;</span>, term (G , tau&#39; ; D) tau.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">G</span> <span class="nv">D</span> : ctx) (<span class="nv">tau</span> : type),
term (G; D) tau -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;</span> : type, term ((G, tau&#39;); D) tau</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chk13" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk13"><span class="highlight"><span class="kn">Proof with</span> <span class="nb">simpl</span> <span class="kr">in</span> *; simpl_depind; <span class="nb">auto</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">G</span> <span class="nv">D</span> : ctx) (<span class="nv">tau</span> : type),
term (G; D) tau -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;</span> : type, term ((G, tau&#39;); D) tau</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chk14" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk14"><span class="highlight"><span class="nb">intros</span> G D tau H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) tau</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">tau&#39;</span> : type, term ((G, tau&#39;); D) tau</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="detailed-tactic-examples-rst-chk15" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk15"><span class="highlight"><span class="nb">dependent induction</span> H <span class="nb">generalizing</span> G D; <span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">G0, tau = G; D</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;); D) tau</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk16" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term G0 tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G1</span> <span class="nv">D0</span> : ctx,
G0 = G1; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G1, tau&#39;1); D0) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">G0, tau&#39; = G; D</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk16"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) tau</span></div></blockquote><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk17" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term ((G; D), tau) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
(G; D), tau = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk17"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) (tau --&gt; tau&#39;)</span></div></blockquote><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk18" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk18"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) tau&#39;</span></div></blockquote></div></div></div></small></span></pre></div><p>This call to dependent induction has an additional arguments which is
a list of variables appearing in the instance that should be
generalized in the goal, so that they can vary in the induction
hypotheses. By default, all variables appearing inside constructors
(except in a parameter position) of the instantiated hypothesis will
be generalized automatically but one can always give the list
explicitly.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">simpl_depind</span></code> tactic includes an automatic tactic that tries to
simplify equalities appearing at the beginning of induction
hypotheses, generally using trivial applications of <code class="docutils literal notranslate"><span class="pre">reflexivity</span></code>. In
cases where the equality is not between constructor forms though, one
must help the automation by giving some arguments, using the
<code class="docutils literal notranslate"><span class="pre">specialize</span></code> tactic for example.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chk19" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk19"><span class="highlight"><span class="nb">destruct</span> D...</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G0, tau), tau&#39;) tau</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk1a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">t, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk1a"><hr></label><div class="goal-conclusion"><span class="highlight">term (((G, tau&#39;); D), t) t</span></div></blockquote><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk1b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term G0 tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G1</span> <span class="nv">D0</span> : ctx,
G0 = G1; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G1, tau&#39;1); D0) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">G0, tau&#39; = G; D</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk1b"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) tau</span></div></blockquote><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk1c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term ((G; D), tau) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
(G; D), tau = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk1c"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) (tau --&gt; tau&#39;)</span></div></blockquote><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk1d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk1d"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) tau&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk1e"><span class="highlight"><span class="nb">apply</span> weak; <span class="nb">apply</span> ax.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">t, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">term (((G, tau&#39;); D), t) t</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk1f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term G0 tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G1</span> <span class="nv">D0</span> : ctx,
G0 = G1; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G1, tau&#39;1); D0) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">G0, tau&#39; = G; D</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk1f"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) tau</span></div></blockquote><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk20" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term ((G; D), tau) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
(G; D), tau = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk20"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) (tau --&gt; tau&#39;)</span></div></blockquote><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk21" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk21"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) tau&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chk22" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk22"><span class="highlight"><span class="nb">apply</span> ax.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term G0 tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G1</span> <span class="nv">D0</span> : ctx,
G0 = G1; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G1, tau&#39;1); D0) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">G0, tau&#39; = G; D</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) tau</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk23" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term ((G; D), tau) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
(G; D), tau = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk23"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) (tau --&gt; tau&#39;)</span></div></blockquote><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk24" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk24"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) tau&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="detailed-tactic-examples-rst-chk25" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk25"><span class="highlight"><span class="nb">destruct</span> D...</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term G0 tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G</span> <span class="nv">D</span> : ctx,
G0 = G; D -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type, term ((G, tau&#39;1); D) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G0, tau&#39;), tau&#39;0) tau</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk26" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">tau</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;</span> : type, term ((G0, tau&#39;); D0) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">t, tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk26"><hr></label><div class="goal-conclusion"><span class="highlight">term (((G, tau&#39;0); D), t) tau</span></div></blockquote><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk27" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term ((G; D), tau) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
(G; D), tau = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk27"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) (tau --&gt; tau&#39;)</span></div></blockquote><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk28" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk28"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) tau&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="detailed-tactic-examples-rst-chk29" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk29"><span class="highlight"><span class="nb">specialize</span> (IHterm G0 empty eq_refl).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term G0 tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); empty) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G0, tau&#39;), tau&#39;0) tau</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk2a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">tau</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;</span> : type, term ((G0, tau&#39;); D0) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">t, tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk2a"><hr></label><div class="goal-conclusion"><span class="highlight">term (((G, tau&#39;0); D), t) tau</span></div></blockquote><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk2b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term ((G; D), tau) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
(G; D), tau = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk2b"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) (tau --&gt; tau&#39;)</span></div></blockquote><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk2c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk2c"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) tau&#39;</span></div></blockquote></div></div></div></small></span></pre></div><p>Once the induction hypothesis has been narrowed to the right equality,
it can be used directly.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="detailed-tactic-examples-rst-chk2d" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk2d"><span class="highlight"><span class="nb">apply</span> weak, IHterm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">tau</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;</span> : type, term ((G0, tau&#39;); D0) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">t, tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">term (((G, tau&#39;0); D), t) tau</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk2e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term ((G; D), tau) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
(G; D), tau = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk2e"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) (tau --&gt; tau&#39;)</span></div></blockquote><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk2f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk2f"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) tau&#39;</span></div></blockquote></div></div></div></small></span></pre></div><p>Now concluding this subgoal is easy.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="detailed-tactic-examples-rst-chk30" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk30"><span class="highlight"><span class="nb">constructor</span>; <span class="nb">apply</span> IHterm; <span class="bp">reflexivity</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term ((G; D), tau) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
(G; D), tau = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) (tau --&gt; tau&#39;)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="detailed-tactic-examples-rst-chk31" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G, D</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ctx</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau, tau'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">term (G; D) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) (tau --&gt; tau&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHterm2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">G0</span> <span class="nv">D0</span> : ctx,
G; D = G0; D0 -&gt;
<span class="kr">forall</span> <span class="nv">tau&#39;1</span> : type,
term ((G0, tau&#39;1); D0) tau</span></span></span></div><div class="goal-hyp"><span class="hyp-names">tau'0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">type</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="detailed-tactic-examples-rst-chk31"><hr></label><div class="goal-conclusion"><span class="highlight">term ((G, tau&#39;0); D) tau&#39;</span></div></blockquote></div></div></div></small></span></pre></div><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The <a class="reference internal" href="tactics.html#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.case" title="case"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">case</span></code></a>, and <a class="reference internal" href="tactics.html#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> tactics.</p>
</div>
</div>
</div>
<div class="section" id="autorewrite">
<h2>autorewrite<a class="headerlink" href="#autorewrite" title="Permalink to this headline">¶</a></h2>
<p>Here are two examples of <code class="docutils literal notranslate"><span class="pre">autorewrite</span></code> use. The first one ( <em>Ackermann
function</em>) shows actually a quite basic use where there is no
conditional rewriting. The second one ( <em>Mac Carthy function</em>)
involves conditional rewritings and shows how to deal with them using
the optional tactic of the <code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Rewrite</span></code> command.</p>
<div class="admonition note">
<p class="admonition-title">Example: Ackermann function</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Arith.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">Ack</span> : nat -&gt; nat -&gt; nat.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">Ack0</span> : <span class="kr">forall</span> <span class="nv">m</span>:nat, Ack <span class="mi">0</span> m = S m.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">Ack1</span> : <span class="kr">forall</span> <span class="nv">n</span>:nat, Ack (S n) <span class="mi">0</span> = Ack n <span class="mi">1</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">Ack2</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>:nat, Ack (S n) (S m) = Ack n (Ack (S n) m).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Rewrite</span> Ack0 Ack1 Ack2 : base0.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="detailed-tactic-examples-rst-chk32" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk32"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">ResAck0</span> : Ack <span class="mi">3</span> <span class="mi">2</span> = <span class="mi">29</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Ack <span class="mi">3</span> <span class="mi">2</span> = <span class="mi">29</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">autorewrite with</span> base0 <span class="nb">using</span> <span class="kp">try</span> <span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div></div>
<div class="admonition note">
<p class="admonition-title">Example: MacCarthy function</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Omega.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">g</span> : nat -&gt; nat -&gt; nat.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">g0</span> : <span class="kr">forall</span> <span class="nv">m</span>:nat, g <span class="mi">0</span> m = m.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">g1</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>:nat, (n &gt; <span class="mi">0</span>) -&gt; (m &gt; <span class="mi">100</span>) -&gt; g n m = g (pred n) (m - <span class="mi">10</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">g2</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span>:nat, (n &gt; <span class="mi">0</span>) -&gt; (m &lt;= <span class="mi">100</span>) -&gt; g n m = g (S n) (m + <span class="mi">11</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Rewrite</span> g0 g1 g2 <span class="nb">using</span> <span class="bp">omega</span> : base1.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="detailed-tactic-examples-rst-chk33" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk33"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">Resg0</span> : g <span class="mi">1</span> <span class="mi">110</span> = <span class="mi">100</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">g <span class="mi">1</span> <span class="mi">110</span> = <span class="mi">100</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">autorewrite with</span> base1 <span class="nb">using</span> <span class="bp">reflexivity</span> || <span class="nb">simpl</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="detailed-tactic-examples-rst-chk34" style="display: none" type="checkbox"><label class="coq-input" for="detailed-tactic-examples-rst-chk34"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">Resg1</span> : g <span class="mi">1</span> <span class="mi">95</span> = <span class="mi">91</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">g <span class="mi">1</span> <span class="mi">95</span> = <span class="mi">91</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">autorewrite with</span> base1 <span class="nb">using</span> <span class="bp">reflexivity</span> || <span class="nb">simpl</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ssreflect-proof-language.html" class="btn btn-neutral float-right" title="The SSReflect proof language" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ltac.html" class="btn btn-neutral float-left" title="The tactic language" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>