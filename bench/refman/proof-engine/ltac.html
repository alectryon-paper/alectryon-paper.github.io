

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The tactic language &mdash; Coq 8.10.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/notations.js"></script>
        <script src="../_static/alectryon.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
  <link rel="stylesheet" href="../_static/alectryon.css" type="text/css" />
  <link rel="stylesheet" href="../_static/tango_subtle.css" type="text/css" />
  <link rel="stylesheet" href="../_static/tango_subtle.min.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Detailed examples of tactics" href="detailed-tactic-examples.html" />
    <link rel="prev" title="Tactics" href="tactics.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.10.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Indexes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">Preamble</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction and Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">Early history of Coq</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../history.html#historical-roots">Historical roots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-1-to-5">Versions 1 to 5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-1">Version 1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-2">Version 2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-3">Version 3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-4">Version 4</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-5">Version 5</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-6">Versions 6</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-1">Version 6.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-2">Version 6.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-3">Version 6.3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-7">Versions 7</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-0-and-7-1">Details of changes in 7.0 and 7.1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#main-novelties">Main novelties</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-2">Details of changes in 7.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-3">Details of changes in 7.3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#changes-in-7-3-1">Changes in 7.3.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-4">Details of changes in 7.4</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changes.html">Recent changes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-10">Version 8.10</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#other-changes-in-8-10-beta1">Other changes in 8.10+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-beta2">Changes in 8.10+beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-beta3">Changes in 8.10+beta3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-0">Changes in 8.10.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-1">Changes in 8.10.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-2">Changes in 8.10.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-9">Version 8.9</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id147">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-9-beta1">Details of changes in 8.9+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-8-0">Changes in 8.8.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-8-1">Changes in 8.8.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-8">Version 8.8</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id149">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-beta1">Details of changes in 8.8+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-0">Details of changes in 8.8.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-1">Details of changes in 8.8.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-2">Details of changes in 8.8.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-7">Version 8.7</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id150">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#potential-compatibility-issues">Potential compatibility issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta1">Details of changes in 8.7+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta2">Details of changes in 8.7+beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-0">Details of changes in 8.7.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-1">Details of changes in 8.7.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-2">Details of changes in 8.7.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-6">Version 8.6</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id151">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#potential-sources-of-incompatibilities">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6beta1">Details of changes in 8.6beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6">Details of changes in 8.6</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6-1">Details of changes in 8.6.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-5">Version 8.5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id152">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id153">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta1">Details of changes in 8.5beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta2">Details of changes in 8.5beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta3">Details of changes in 8.5beta3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5">Details of changes in 8.5</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl1">Details of changes in 8.5pl1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl2">Details of changes in 8.5pl2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl3">Details of changes in 8.5pl3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-4">Version 8.4</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id154">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id156">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta">Details of changes in 8.4beta</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta2">Details of changes in 8.4beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4">Details of changes in 8.4</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-3">Version 8.3</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id157">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-2">Version 8.2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id158">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id159">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-1">Version 8.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id160">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1beta">Details of changes in 8.1beta</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1gamma">Details of changes in 8.1gamma</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1">Details of changes in 8.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-0">Version 8.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id161">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-old-syntax">Details of changes in 8.0beta old syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-new-syntax">Details of changes in 8.0beta new syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0">Details of changes in 8.0</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">The language</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-specification-language.html">The Gallina specification language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#about-the-grammars-in-the-manual">About the grammars in the manual</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#lexical-conventions">Lexical conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#terms">Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#syntax-of-terms">Syntax of terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#types">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#qualified-identifiers-and-simple-identifiers">Qualified identifiers and simple identifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#numerals">Numerals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#binders">Binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#abstractions">Abstractions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#products">Products</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#applications">Applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#type-cast">Type cast</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#inferable-subterms">Inferable subterms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#let-in-definitions">Let-in definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#definition-by-case-analysis">Definition by case analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#recursive-functions">Recursive functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#the-vernacular">The Vernacular</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#assumptions">Assumptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#inductive-definitions">Inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#simple-inductive-types">Simple inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#simple-annotated-inductive-types">Simple annotated inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#parameterized-inductive-types">Parameterized inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#variants">Variants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#mutually-defined-inductive-types">Mutually defined inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#co-inductive-types">Co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#definition-of-recursive-functions">Definition of recursive functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#definition-of-functions-by-recursion-over-inductive-objects">Definition of functions by recursion over inductive objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#definitions-of-recursive-objects-in-co-inductive-types">Definitions of recursive objects in co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#assertions-and-proofs">Assertions and proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#attributes">Attributes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#record-types">Record types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#primitive-projections">Primitive Projections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#primitive-record-types">Primitive Record Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#compatibility-projections-and-match">Compatibility Projections and <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">match</span></span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#variants-and-extensions-of-match">Variants and extensions of <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">match</span></span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#multiple-and-nested-pattern-matching">Multiple and nested pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#pattern-matching-on-boolean-values-the-if-expression">Pattern-matching on boolean values: the if expression</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#irrefutable-patterns-the-destructuring-let-variants">Irrefutable patterns: the destructuring let variants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#first-destructuring-let-syntax">First destructuring let syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#second-destructuring-let-syntax">Second destructuring let syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-pretty-printing-of-match-expressions">Controlling pretty-printing of match expressions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-nested-patterns">Printing nested patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#factorization-of-clauses-with-same-right-hand-side">Factorization of clauses with same right-hand side</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#use-of-a-default-clause">Use of a default clause</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-of-wildcard-patterns">Printing of wildcard patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-of-the-elimination-predicate">Printing of the elimination predicate</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-matching-on-irrefutable-patterns">Printing matching on irrefutable patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-matching-on-booleans">Printing matching on booleans</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions">Advanced recursive functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#section-mechanism">Section mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#module-system">Module system</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#reserved-commands-inside-an-interactive-module">Reserved commands inside an interactive module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#reserved-commands-inside-an-interactive-module-type">Reserved commands inside an interactive module type:</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#libraries-and-qualified-names">Libraries and qualified names</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#names-of-libraries">Names of libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#qualified-names">Qualified names</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#libraries-and-filesystem">Libraries and filesystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#implicit-arguments">Implicit arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#the-different-kinds-of-implicit-arguments">The different kinds of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function">Implicit arguments inferable from the knowledge of other arguments of a function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#implicit-arguments-inferable-by-resolution">Implicit arguments inferable by resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#maximal-or-non-maximal-insertion-of-implicit-arguments">Maximal or non maximal insertion of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#casual-use-of-implicit-arguments">Casual use of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#declaration-of-implicit-arguments">Declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#implicit-argument-binders">Implicit Argument Binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#declaring-implicit-arguments">Declaring Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#automatic-declaration-of-implicit-arguments">Automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#mode-for-automatic-declaration-of-implicit-arguments">Mode for automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-strict-implicit-arguments">Controlling strict implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-contextual-implicit-arguments">Controlling contextual implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-reversible-pattern-implicit-arguments">Controlling reversible-pattern implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments">Controlling the insertion of implicit arguments not followed by explicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#explicit-applications">Explicit applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#renaming-implicit-arguments">Renaming implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#displaying-what-the-implicit-arguments-are">Displaying what the implicit arguments are</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#explicit-displaying-of-implicit-arguments-for-pretty-printing">Explicit displaying of implicit arguments for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#interaction-with-subtyping">Interaction with subtyping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#deactivation-of-implicit-arguments-for-parsing">Deactivation of implicit arguments for parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#canonical-structures">Canonical structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#implicit-types-of-variables">Implicit types of variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#implicit-generalization">Implicit generalization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#coercions">Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#printing-constructions-in-full">Printing constructions in full</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#printing-universes">Printing universes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#existential-variables">Existential variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#explicit-displaying-of-existential-instances-for-pretty-printing">Explicit displaying of existential instances for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#solving-existential-variables-using-tactics">Solving existential variables using tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#primitive-integers">Primitive Integers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/coq-library.html">The <span class="smallcaps">Coq</span> library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html#the-basic-library">The basic library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#notations">Notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#logic">Logic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#propositional-connectives">Propositional Connectives</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#quantifiers">Quantifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#equality">Equality</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#lemmas">Lemmas</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#datatypes">Datatypes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#programming">Programming</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#specification">Specification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#basic-arithmetics">Basic Arithmetics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#well-founded-recursion">Well-founded recursion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#accessing-the-type-level">Accessing the Type level</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#tactics">Tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html#the-standard-library">The standard library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#survey">Survey</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#peanos-arithmetic-nat">Peano’s arithmetic (nat)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#notations-for-integer-arithmetics">Notations for integer arithmetics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#real-numbers-library">Real numbers library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#notations-for-real-numbers">Notations for real numbers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#some-tactics-for-real-numbers">Some tactics for real numbers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#list-library">List library</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html#users-contributions">Users’ contributions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/cic.html">Calculus of Inductive Constructions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#the-terms">The terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#terms">Terms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#typing-rules">Typing rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#conversion-rules">Conversion rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#reduction">β-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#iota-reduction">ι-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#delta-reduction">δ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#zeta-reduction">ζ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#expansion">η-expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#proof-irrelevance">Proof Irrelevance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#convertibility">Convertibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#subtyping-rules">Subtyping rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#inductive-definitions">Inductive Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#types-of-inductive-objects">Types of inductive objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#well-formed-inductive-definitions">Well-formed inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#arity-of-a-given-sort">Arity of a given sort</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#arity">Arity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#type-of-constructor">Type of constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#positivity-condition">Positivity Condition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#strict-positivity">Strict positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#nested-positivity">Nested Positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#correctness-rules">Correctness rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#template-polymorphism">Template polymorphism</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#destructors">Destructors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#the-match-with-end-construction">The match ... with ... end construction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#fixpoint-definitions">Fixpoint definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#id29">Typing rule</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#reduction-rule">Reduction rule</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#admissible-rules-for-global-environments">Admissible rules for global environments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#co-inductive-types">Co-inductive types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#the-calculus-of-inductive-constructions-with-impredicative-set">The Calculus of Inductive Constructions with impredicative Set</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/module-system.html">The Module System</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/module-system.html#modules-and-module-types">Modules and module types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/module-system.html#typing-modules">Typing Modules</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">The proof engine</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="vernacular-commands.html">Vernacular commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#displaying">Displaying</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#flags-options-and-tables">Flags, Options and Tables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#scope-qualifiers-for-set-and-unset">Scope qualifiers for <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Set</span></code> and <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Unset</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#requests-to-the-environment">Requests to the environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#printing-flags">Printing flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#loading-files">Loading files</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#compiled-files">Compiled files</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#loadpath">Loadpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#backtracking">Backtracking</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#quitting-and-debugging">Quitting and debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#controlling-display">Controlling display</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#controlling-the-reduction-strategies-and-the-conversion-algorithm">Controlling the reduction strategies and the conversion algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#controlling-the-locality-of-commands">Controlling the locality of commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#internal-registration-commands">Internal registration commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#exposing-constants-to-ocaml-libraries">Exposing constants to OCaml libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#inlining-hints-for-the-fast-reduction-machines">Inlining hints for the fast reduction machines</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#registering-primitive-operations">Registering primitive operations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="proof-handling.html">Proof handling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#switching-on-off-the-proof-editing-mode">Switching on/off the proof editing mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#proof-using-options">Proof using options</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#name-a-set-of-section-hypotheses-for-proof-using">Name a set of section hypotheses for <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#navigation-in-the-proof-tree">Navigation in the proof tree</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#bullets">Bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#set-bullet-behavior">Set Bullet Behavior</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#requesting-information">Requesting information</a></li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#showing-differences-between-proof-steps">Showing differences between proof steps</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#how-to-enable-diffs">How to enable diffs</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#how-diffs-are-calculated">How diffs are calculated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#controlling-the-effect-of-proof-editing-commands">Controlling the effect of proof editing commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#controlling-memory-usage">Controlling memory usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">Tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#common-elements-of-tactics">Common elements of tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#invocation-of-tactics">Invocation of tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#bindings-list">Bindings list</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#occurrence-sets-and-occurrence-clauses">Occurrence sets and occurrence clauses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#applying-theorems">Applying theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#managing-the-local-context">Managing the local context</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#controlling-the-proof-flow">Controlling the proof flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#case-analysis-and-induction">Case analysis and induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#rewriting-expressions">Rewriting expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#performing-computations">Performing computations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#conversion-tactics-applied-to-hypotheses">Conversion tactics applied to hypotheses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#automation">Automation</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#controlling-automation">Controlling automation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#the-hints-databases-for-auto-and-eauto">The hints databases for auto and eauto</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tactics.html#creating-hint-databases">Creating Hint databases</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#hint-databases-defined-in-the-coq-standard-library">Hint databases defined in the Coq standard library</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#hint-locality">Hint locality</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#setting-implicit-automation-tactics">Setting implicit automation tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#decision-procedures">Decision procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#checking-properties-of-terms">Checking properties of terms</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#equality">Equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#equality-and-inductive-sets">Equality and inductive sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#inversion">Inversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#classical-tactics">Classical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#automating">Automating</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#non-logical-tactics">Non-logical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#delaying-solving-unification-constraints">Delaying solving unification constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#proof-maintenance">Proof maintenance</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#performance-oriented-tactic-variants">Performance-oriented tactic variants</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">The tactic language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="#semantics">Semantics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sequence">Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="#local-application-of-tactics">Local application of tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#goal-selectors">Goal selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#for-loop">For loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="#repeat-loop">Repeat loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="#error-catching">Error catching</a></li>
<li class="toctree-l3"><a class="reference internal" href="#detecting-progress">Detecting progress</a></li>
<li class="toctree-l3"><a class="reference internal" href="#backtracking-branching">Backtracking branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="#first-tactic-to-work">First tactic to work</a></li>
<li class="toctree-l3"><a class="reference internal" href="#left-biased-branching">Left-biased branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generalized-biased-branching">Generalized biased branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="#soft-cut">Soft cut</a></li>
<li class="toctree-l3"><a class="reference internal" href="#checking-the-successes">Checking the successes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#checking-the-failure">Checking the failure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#checking-the-success">Checking the success</a></li>
<li class="toctree-l3"><a class="reference internal" href="#solving">Solving</a></li>
<li class="toctree-l3"><a class="reference internal" href="#identity">Identity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#failing">Failing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#timeout">Timeout</a></li>
<li class="toctree-l3"><a class="reference internal" href="#timing-a-tactic">Timing a tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#timing-a-tactic-that-evaluates-to-a-term">Timing a tactic that evaluates to a term</a></li>
<li class="toctree-l3"><a class="reference internal" href="#local-definitions">Local definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#application">Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-construction">Function construction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pattern-matching-on-terms">Pattern matching on terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pattern-matching-on-goals">Pattern matching on goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#filling-a-term-context">Filling a term context</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generating-fresh-hypothesis-names">Generating fresh hypothesis names</a></li>
<li class="toctree-l3"><a class="reference internal" href="#computing-in-a-constr">Computing in a constr</a></li>
<li class="toctree-l3"><a class="reference internal" href="#recovering-the-type-of-a-term">Recovering the type of a term</a></li>
<li class="toctree-l3"><a class="reference internal" href="#manipulating-untyped-terms">Manipulating untyped terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#counting-the-goals">Counting the goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing-boolean-expressions">Testing boolean expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#proving-a-subgoal-as-a-separate-lemma">Proving a subgoal as a separate lemma</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tactic-toplevel-definitions">Tactic toplevel definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#defining-ltac-functions">Defining <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#printing-ltac-tactics">Printing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#examples-of-using-ltac">Examples of using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#proof-that-the-natural-numbers-have-at-least-two-elements">Proof that the natural numbers have at least two elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#proving-that-a-list-is-a-permutation-of-a-second-list">Proving that a list is a permutation of a second list</a></li>
<li class="toctree-l3"><a class="reference internal" href="#deciding-intuitionistic-propositional-logic">Deciding intuitionistic propositional logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#deciding-type-isomorphisms">Deciding type isomorphisms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#debugging-ltac-tactics">Debugging <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#backtraces">Backtraces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#info-trace">Info trace</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interactive-debugger">Interactive debugger</a></li>
<li class="toctree-l3"><a class="reference internal" href="#profiling-ltac-tactics">Profiling <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#run-time-optimization-tactic">Run-time optimization tactic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="detailed-tactic-examples.html">Detailed examples of tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="detailed-tactic-examples.html#dependent-induction">dependent induction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="detailed-tactic-examples.html#a-larger-example">A larger example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="detailed-tactic-examples.html#autorewrite">autorewrite</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#usage">Usage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#getting-started">Getting started</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#compatibility-issues">Compatibility issues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#gallina-extensions"><span class="smallcaps">Gallina</span> extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#pattern-assignment">Pattern assignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#pattern-conditional">Pattern conditional</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#parametric-polymorphism">Parametric polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#anonymous-arguments">Anonymous arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#wildcards">Wildcards</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#abbreviations">Abbreviations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#matching">Matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#occurrence-selection">Occurrence selection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#basic-localization">Basic localization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#basic-tactics">Basic tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#bookkeeping">Bookkeeping</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#the-defective-tactics">The defective tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-move-tactic">The move tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-case-tactic">The case tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-elim-tactic">The elim tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-apply-tactic">The apply tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#discharge">Discharge</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#clear-rules">Clear rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#matching-for-apply-and-exact">Matching for apply and exact</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-abstract-tactic">The abstract tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#introduction-in-the-context">Introduction in the context</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#simplification-items">Simplification items</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#views">Views</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#clear-switch">Clear switch</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#branching-and-destructuring">Branching and destructuring</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#block-introduction">Block introduction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#generation-of-equations">Generation of equations</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#type-families">Type families</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#control-flow">Control flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#indentation-and-bullets">Indentation and bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#terminators">Terminators</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#selectors">Selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#iteration">Iteration</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#localization">Localization</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#structure">Structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-have-tactic">The have tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#generating-let-in-context-entries-with-have">Generating let in context entries with have</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-have-tactic-and-typeclass-resolution">The have tactic and typeclass resolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#variants-the-suff-and-wlog-tactics">Variants: the suff and wlog tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#rewriting">Rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#an-extended-rewrite-tactic">An extended rewrite tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#remarks-and-examples">Remarks and examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#rewrite-redex-selection">Rewrite redex selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#chained-rewrite-steps">Chained rewrite steps</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#explicit-redex-switches-are-matched-first">Explicit redex switches are matched first</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#occurrence-switches-and-redex-switches">Occurrence switches and redex switches</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#occurrence-selection-and-repetition">Occurrence selection and repetition</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#multi-rule-rewriting">Multi-rule rewriting</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#wildcards-vs-abstractions">Wildcards vs abstractions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#when-ssr-rewrite-fails-on-standard-coq-licit-rewrite">When <span class="smallcaps">SSReflect</span> rewrite fails on standard <span class="smallcaps">Coq</span> licit rewrite</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#existential-metavariables-and-rewriting">Existential metavariables and rewriting</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#rewriting-under-binders">Rewriting under binders</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-under-tactic">The under tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#interactive-mode">Interactive mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#one-liner-mode">One-liner mode</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#locking-unlocking">Locking, unlocking</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#congruence">Congruence</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#contextual-patterns">Contextual patterns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#matching-contextual-patterns">Matching contextual patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#examples">Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#contextual-pattern-in-set-and-the-tactical">Contextual pattern in set and the : tactical</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#contextual-patterns-in-rewrite">Contextual patterns in rewrite</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#patterns-for-recurrent-contexts">Patterns for recurrent contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#views-and-reflection">Views and reflection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-eliminations">Interpreting eliminations</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-assumptions">Interpreting assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#specializing-assumptions">Specializing assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-goals">Interpreting goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#boolean-reflection">Boolean reflection</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#the-reflect-predicate">The reflect predicate</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#general-mechanism-for-interpreting-goals-and-assumptions">General mechanism for interpreting goals and assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#id13">Specializing assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#id14">Interpreting assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-equivalences">Interpreting equivalences</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#declaring-new-hint-views">Declaring new Hint Views</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#multiple-views">Multiple views</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#ssr-searching-tool"><span class="smallcaps">SSReflect</span> searching tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html#synopsis-and-index">Synopsis and Index</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#parameters">Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#items-and-switches">Items and switches</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#tacticals">Tacticals</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#commands">Commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#settings">Settings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">User extensions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations">Notations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#basic-notations">Basic notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#precedences-and-associativity">Precedences and associativity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#complex-notations">Complex notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simple-factorization-rules">Simple factorization rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-symbolic-notations">Displaying symbolic notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-infix-command">The Infix command</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#reserving-notations">Reserving notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simultaneous-definition-of-terms-and-notations">Simultaneous definition of terms and notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-notations">Displaying information about notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#locating-notations">Locating notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-and-binders">Notations and binders</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-identifiers">Binders bound in the notation and parsed as identifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-patterns">Binders bound in the notation and parsed as patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-terms">Binders bound in the notation and parsed as terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-not-bound-in-the-notation">Binders not bound in the notation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns">Notations with recursive patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns-involving-binders">Notations with recursive patterns involving binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#predefined-entries">Predefined entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#custom-entries">Custom entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#summary">Summary</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#syntax-of-notations">Syntax of notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#persistence-of-notations">Persistence of notations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes">Interpretation scopes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#global-interpretation-rules-for-notations">Global interpretation rules for notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-interpretation-rules-for-notations">Local interpretation rules for notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-opening-of-an-interpretation-scope">Local opening of an interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binding-arguments-of-a-constant-to-an-interpretation-scope">Binding arguments of a constant to an interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binding-types-of-arguments-to-an-interpretation-scope">Binding types of arguments to an interpretation scope</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-type-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">type_scope</span></code> interpretation scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-function-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">function_scope</span></code> interpretation scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes-used-in-the-standard-library-of-coq">Interpretation scopes used in the standard library of Coq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-scopes">Displaying information about scopes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#numeral-notations">Numeral notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#string-notations">String notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#tactic-notations">Tactic Notations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-induction-principles-with-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#automatic-declaration-of-schemes">Automatic declaration of schemes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#combined-scheme">Combined Scheme</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-induction-principles-with-functional-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Functional</span></code> <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-inversion-principles-with-derive-inversion">Generation of inversion principles with <code class="docutils literal notranslate"><span class="pre">Derive</span></code> <code class="docutils literal notranslate"><span class="pre">Inversion</span></code></a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Practical tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#interactive-use-coqtop">Interactive use (coqtop)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#batch-compilation-coqc">Batch compilation (coqc)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#customization-at-launch-time">Customization at launch time</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-resource-file">By resource file</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-environment-variables">By environment variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-command-line-options">By command line options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-libraries-checker-coqchk">Compiled libraries checker (coqchk)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#using-coq-as-a-library">Using Coq as a library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project">Building a <span class="smallcaps">Coq</span> project</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-coq-makefile">Building a <span class="smallcaps">Coq</span> project with coq_makefile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#coqmakefile-local">CoqMakefile.local</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#timing-targets-and-performance-testing">Timing targets and performance testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#reusing-extending-the-generated-makefile">Reusing/extending the generated Makefile</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#building-a-subset-of-the-targets-with-j">Building a subset of the targets with <code class="docutils literal notranslate"><span class="pre">-j</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-dune">Building a <span class="smallcaps">Coq</span> project with Dune</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#computing-module-dependencies">Computing Module dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#documenting-coq-files-with-coqdoc">Documenting <span class="smallcaps">Coq</span> files with coqdoc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#principles">Principles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#coq-material-inside-documentation"><span class="smallcaps">Coq</span> material inside documentation.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#pretty-printing">Pretty-printing.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#sections">Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#lists">Lists.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#rules">Rules.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#emphasis">Emphasis.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#escaping-to-latex-and-html">Escaping to <span class="smallcaps">LaTeX</span> and HTML.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#verbatim">Verbatim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#hyperlinks">Hyperlinks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#hiding-showing-parts-of-the-source">Hiding / Showing parts of the source.</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#the-coqdoc-latex-style-file">The coqdoc <span class="smallcaps">LaTeX</span> style file</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#embedded-coq-phrases-inside-latex-documents">Embedded Coq phrases inside <span class="smallcaps">LaTeX</span> documents</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#man-pages">Man pages</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#managing-files-and-buffers-basic-editing">Managing files and buffers, basic editing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#interactive-navigation-into-coq-scripts">Interactive navigation into Coq scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#proof-folding">Proof folding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#vernacular-commands-templates">Vernacular commands, templates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#queries">Queries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#compilation">Compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#customizations">Customizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#using-unicode-symbols">Using Unicode symbols</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#displaying-unicode-symbols">Displaying Unicode symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#bindings-for-input-of-unicode-symbols">Bindings for input of Unicode symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#adding-custom-bindings">Adding custom bindings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#character-encoding-for-saved-files">Character encoding for saved files</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Addendum</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extended-pattern-matching.html">Extended pattern matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#patterns">Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#multiple-patterns">Multiple patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#aliasing-subpatterns">Aliasing subpatterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#nested-patterns">Nested patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#disjunctive-patterns">Disjunctive patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#about-patterns-of-parametric-types">About patterns of parametric types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#parameters-in-patterns">Parameters in patterns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#implicit-arguments-in-patterns">Implicit arguments in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#matching-objects-of-dependent-types">Matching objects of dependent types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#understanding-dependencies-in-patterns">Understanding dependencies in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#when-the-elimination-predicate-must-be-provided">When the elimination predicate must be provided</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#dependent-pattern-matching">Dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#multiple-dependent-pattern-matching">Multiple dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#patterns-in-in">Patterns in <code class="docutils literal notranslate"><span class="pre">in</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#using-pattern-matching-to-write-proofs">Using pattern matching to write proofs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#pattern-matching-on-inductive-objects-involving-local-definitions">Pattern-matching on inductive objects involving local definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#pattern-matching-and-coercions">Pattern-matching and coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#when-does-the-expansion-strategy-fail">When does the expansion strategy fail?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#general-presentation">General Presentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions">Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#identity-coercions">Identity Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#inheritance-graph">Inheritance Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#declaring-coercions">Declaring Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#displaying-available-coercions">Displaying Available Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#activating-the-printing-of-coercions">Activating the Printing of Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#classes-as-records">Classes as Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-sections">Coercions and Sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-modules">Coercions and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-at-function-application">Coercion at function application</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-to-a-type">Coercion to a type</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-to-a-function">Coercion to a function</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/canonical-structures.html">Canonical Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/canonical-structures.html#notation-overloading">Notation overloading</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/canonical-structures.html#derived-canonical-structures">Derived Canonical Structures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/canonical-structures.html#hierarchy-of-structures">Hierarchy of structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/canonical-structures.html#compact-declaration-of-canonical-structures">Compact declaration of Canonical Structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/type-classes.html">Typeclasses</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#class-and-instance-declarations">Class and Instance declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#binding-classes">Binding classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#parameterized-instances">Parameterized Instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#sections-and-contexts">Sections and contexts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#building-hierarchies">Building hierarchies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#superclasses">Superclasses</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#substructures">Substructures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#summary-of-the-commands">Summary of the commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-transparent-typeclasses-opaque">Typeclasses Transparent, Typeclasses Opaque</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#settings">Settings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-eauto">Typeclasses eauto <code class="docutils literal notranslate"><span class="pre">:=</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#description-of-omega">Description of <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#arithmetical-goals-recognized-by-omega">Arithmetical goals recognized by <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#messages-from-omega">Messages from <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#using-omega">Using <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#options">Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#technical-data">Technical data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#overview-of-the-tactic">Overview of the tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#overview-of-the-omega-decision-procedure">Overview of the OMEGA decision procedure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#bugs">Bugs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#short-description-of-the-tactics">Short description of the tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#positivstellensatz-refutations"><em>Positivstellensatz</em> refutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#lra-a-decision-procedure-for-linear-real-and-rational-arithmetic"><code class="docutils literal notranslate"><span class="pre">lra</span></code>: a decision procedure for linear real and rational arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#lia-a-tactic-for-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">lia</span></code>: a tactic for linear integer arithmetic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#high-level-view-of-lia">High level view of <code class="docutils literal notranslate"><span class="pre">lia</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#cutting-plane-proofs">Cutting plane proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#case-split">Case split</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#nra-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">nra</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#nia-a-proof-procedure-for-non-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">nia</span></code>: a proof procedure for non-linear integer arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#psatz-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">psatz</span></code>: a proof procedure for non-linear arithmetic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#generating-ml-code">Generating ML Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#extraction-options">Extraction Options</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#setting-the-target-language">Setting the target language</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#inlining-and-optimizations">Inlining and optimizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extra-elimination-of-useless-arguments">Extra elimination of useless arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#realizing-axioms">Realizing axioms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#realizing-inductive-types">Realizing inductive types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#avoiding-conflicts-with-existing-filenames">Avoiding conflicts with existing filenames</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#additional-settings">Additional settings</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#differences-between-coq-and-ml-type-systems">Differences between <span class="smallcaps">Coq</span> and ML type systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#some-examples">Some examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#a-detailed-example-euclidean-division">A detailed example: Euclidean division</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extraction-s-horror-museum">Extraction's horror museum</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#users-contributions">Users' Contributions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/program.html">Program</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#elaborating-programs">Elaborating programs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#syntactic-control-over-equalities">Syntactic control over equalities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-definition">Program Definition</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-fixpoint">Program Fixpoint</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-lemma">Program Lemma</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#solving-obligations">Solving obligations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#frequently-asked-questions">Frequently Asked Questions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/ring.html">The ring and field tactic families</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#what-does-this-tactic-do">What does this tactic do?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#the-variables-map">The variables map</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#is-it-automatic">Is it automatic?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#concrete-usage-in-coq">Concrete usage in Coq</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#adding-a-ring-structure">Adding a ring structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#how-does-it-work">How does it work?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#dealing-with-fields">Dealing with fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#adding-a-new-field-structure">Adding a new field structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#history-of-ring">History of ring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#discussion">Discussion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: tactics for proving equalities in integral domains</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/nsatz.html#more-about-nsatz">More about <code class="docutils literal notranslate"><span class="pre">nsatz</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#introduction-to-generalized-rewriting">Introduction to generalized rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#relations-and-morphisms">Relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#adding-new-relations-and-morphisms">Adding new relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-non-reflexive-relations">Rewriting and non reflexive relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-non-symmetric-relations">Rewriting and non symmetric relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-in-ambiguous-setoid-contexts">Rewriting in ambiguous setoid contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#commands-and-tactics">Commands and tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#first-class-setoids-and-morphisms">First class setoids and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#tactics-enabled-on-user-provided-relations">Tactics enabled on user provided relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#printing-relations-and-morphisms">Printing relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#deprecated-syntax-and-backward-incompatibilities">Deprecated syntax and backward incompatibilities</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#extensions">Extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#subrelations">Subrelations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#constant-unfolding">Constant unfolding</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#strategies-for-rewriting">Strategies for rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#usage">Usage</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-annotations">Proof annotations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#automatic-suggestion-of-proof-annotations">Automatic suggestion of proof annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-blocks-and-error-resilience">Proof blocks and error resilience</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#caveats">Caveats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#interactive-mode">Interactive mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#id2">Caveats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#batch-mode">Batch mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#limiting-the-number-of-parallel-workers">Limiting the number of parallel workers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Miscellaneous extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/miscellaneous-extensions.html#program-derivation">Program derivation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#general-presentation">General Presentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-monomorphic">Polymorphic, Monomorphic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulative-noncumulative">Cumulative, NonCumulative</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#an-example-of-a-proof-using-cumulativity">An example of a proof using cumulativity</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulativity-weak-constraints">Cumulativity Weak Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#global-and-local-universes">Global and local universes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#conversion-and-unification">Conversion and unification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#minimization">Minimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#explicit-universes">Explicit Universes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-definitions">Polymorphic definitions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/sprop.html">SProp (proof irrelevant propositions)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#basic-constructs">Basic constructs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#encodings-for-strict-propositions">Encodings for strict propositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#issues-with-non-cumulativity">Issues with non-cumulativity</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>The tactic language</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/proof-engine/ltac.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="the-tactic-language">
<span id="ltac"></span><h1>The tactic language<a class="headerlink" href="#the-tactic-language" title="Permalink to this headline">¶</a></h1>
<p>This chapter documents the tactic language <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub>.</p>
<p>We start by giving the syntax, and next, we present the informal
semantics. To learn more about the language and
especially about its foundations, please refer to <a class="bibtex reference internal" href="../zebibliography.html#del00" id="id1">[Del00]</a>.</p>
<div class="admonition note">
<p class="admonition-title">Example: Basic tactic macros</p>
<p>Here are some examples of simple tactic macros that the
language lets you write.</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Ltac</span> <span class="nf">reduce_and_try_to_solve</span> <span class="o">:=</span> <span class="nb">simpl</span><span class="o">;</span> <span class="nb">intros</span><span class="o">;</span> <span class="nb">auto</span><span class="o">.</span>

<span class="kn">Ltac</span> <span class="nf">destruct_bool_and_rewrite</span> <span class="n">b</span> <span class="n">H1</span> <span class="n">H2</span> <span class="o">:=</span>
  <span class="nb">destruct</span> <span class="n">b</span><span class="o">;</span> <span class="o">[</span> <span class="nb">rewrite</span> <span class="n">H1</span><span class="o">;</span> <span class="nb">eauto</span> <span class="o">|</span> <span class="nb">rewrite</span> <span class="n">H2</span><span class="o">;</span> <span class="nb">eauto</span> <span class="o">].</span>
</pre></div>
</div>
<p>See Section <a class="reference internal" href="#ltac-examples"><span class="std std-ref">Examples of using Ltac</span></a> for more advanced examples.</p>
</div>
<div class="section" id="syntax">
<span id="ltac-syntax"></span><h2>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h2>
<p>The syntax of the tactic language is given below. See Chapter
<a class="reference internal" href="../language/gallina-specification-language.html#gallinaspecificationlanguage"><span class="std std-ref">The Gallina specification language</span></a> for a description of the BNF metasyntax used
in these grammar rules. Various already defined entries will be used in this
chapter: entries <a class="reference internal" href="ssreflect-proof-language.html#grammar-token-natural"><code class="xref std std-token docutils literal notranslate"><span class="pre">natural</span></code></a>, <code class="xref std std-token docutils literal notranslate"><span class="pre">integer</span></code>, <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>,
<code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code>, <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>, <a class="reference internal" href="#grammar-token-cpattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">cpattern</span></code></a> and <code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code>
represent respectively the natural and integer numbers, the authorized
identificators and qualified names, Coq terms and patterns and all the atomic
tactics described in Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>.</p>
<p>The syntax of <span class="inline-grammar-production"><span class="target" id="grammar-token-cpattern"></span><code class="docutils literal notranslate"><span class="pre">cpattern</span></code></span> is
the same as that of terms, but it is extended with pattern matching
metavariables. In <a class="reference internal" href="#grammar-token-cpattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">cpattern</span></code></a>, a pattern matching metavariable is
represented with the syntax <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">?</span></span><span class="hole"><span class="pre">ident</span></span></span></code>. The
notation <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">_</span></span></code> can also be used to denote metavariable whose instance is
irrelevant. In the notation <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">?</span></span><span class="hole"><span class="pre">ident</span></span></span></code>, the identifier allows us to keep
instantiations and to make constraints whereas <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">_</span></span></code> shows that we are not
interested in what will be matched. On the right hand side of pattern matching
clauses, the named metavariables are used without the question mark prefix. There
is also a special notation for second-order pattern matching problems: in an
applicative pattern of the form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">%</span></span><span><span class="pre">&#64;</span></span><span><span class="pre">?</span></span><span class="hole"><span class="pre">ident</span></span> <span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span> <span><span class="pre">…</span></span> <span class="hole"><span class="pre">ident</span><sub><span class="pre">n</span></sub></span></span></code>,
the variable <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> matches any complex expression with (possible)
dependencies in the variables <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">i</span></sub></span></span></code> and returns a functional term
of the form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">fun</span></span> <span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span> <span><span class="pre">…</span></span> <span><span class="pre">ident</span><sub><span class="pre">n</span></sub></span> <span><span class="pre">=&gt;</span></span> <span class="hole"><span class="pre">term</span></span></span></code>.</p>
<p>The main entry of the grammar is <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code>. This language is used in proof
mode but it can also be used in toplevel definitions as shown below.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li><p>The infix tacticals  <code class="docutils literal notranslate"><span class="pre">…</span> <span class="pre">||</span> <span class="pre">…</span></code> ,  <code class="docutils literal notranslate"><span class="pre">…</span> <span class="pre">+</span> <span class="pre">…</span></code> , and  <code class="docutils literal notranslate"><span class="pre">…</span> <span class="pre">;</span> <span class="pre">…</span></code>  are associative.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>If you want that <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">2</span></sub></span><span><span class="pre">;</span></span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">3</span></sub></span></span></code> be fully run on the first
subgoal generated by <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span></span></code>, before running on the other
subgoals, then you should not write
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span><span><span class="pre">;</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">tactic</span><sub><span class="pre">2</span></sub></span><span><span class="pre">;</span></span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">3</span></sub></span><span><span class="pre">)</span></span></span></code> but rather
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span><span><span class="pre">;</span></span> <span><span class="pre">[&gt;</span></span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">2</span></sub></span><span><span class="pre">;</span></span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">3</span></sub></span> <span><span class="pre">..</span></span> <span><span class="pre">]</span></span></span></code>.</p>
</div>
</li>
<li><p>In <code class="xref std std-token docutils literal notranslate"><span class="pre">tacarg</span></code>, there is an overlap between <code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code> as a
direct tactic argument and <code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code> as a particular case of
<code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>. The resolution is done by first looking for a reference
of the tactic language and if it fails, for a reference to a term.
To force the resolution as a reference of the tactic language, use the
form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">ltac:(</span></span><span class="hole"><span class="pre">qualid</span></span><span><span class="pre">)</span></span></span></code>. To force the resolution as a reference to a
term, use the syntax <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="hole"><span class="pre">qualid</span></span><span><span class="pre">)</span></span></span></code>.</p></li>
<li><p>As shown by the figure, tactical  <code class="docutils literal notranslate"><span class="pre">…</span> <span class="pre">||</span> <span class="pre">…</span></code>  binds more than the prefix
tacticals <a class="reference internal" href="#coq:tacn.try" title="try"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">try</span></code></a>, <a class="reference internal" href="#coq:tacn.repeat" title="repeat"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">repeat</span></code></a>, <a class="reference internal" href="#coq:tacn.do" title="do"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">do</span></code></a> and <a class="reference internal" href="#coq:tacn.abstract" title="abstract"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">abstract</span></code></a>
which themselves bind more than the postfix tactical  <code class="docutils literal notranslate"><span class="pre">…</span> <span class="pre">;[</span> <span class="pre">…</span> <span class="pre">]</span></code>
which binds at the same level as  <code class="docutils literal notranslate"><span class="pre">…</span> <span class="pre">;</span> <span class="pre">…</span></code> .</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">try</span></span> <span><span class="pre">repeat</span></span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span> <span class="pre">|</span><span class="pre">|</span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">2</span></sub></span><span><span class="pre">;</span></span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">3</span></sub></span><span><span class="pre">;</span></span> <span><span class="pre">[</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">tactic</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">|</span></span></span> <span><span class="pre">];</span></span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">4</span></sub></span></span></code></p>
<p>is understood as:</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">((try</span></span> <span><span class="pre">(repeat</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span> <span class="pre">|</span><span class="pre">|</span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">2</span></sub></span><span><span class="pre">));</span></span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">3</span></sub></span><span><span class="pre">);</span></span> <span><span class="pre">[</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">tactic</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">|</span></span></span> <span><span class="pre">]);</span></span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">4</span></sub></span></span></code></p>
</div>
</li>
</ul>
</div>
<pre>
<strong id="grammar-token-coq-ltac_expr"><span id="grammar-token-ltac-expr"></span>ltac_expr        </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code> ; <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code>
                       [&gt; <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code> | ... | <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code> ]
                       <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code> ; [ <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code> | ... | <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code> ]
                       <code class="xref docutils literal notranslate"><span class="pre">ltac_expr3</span></code>
<strong id="grammar-token-coq-ltac_expr3"><span id="grammar-token-ltac-expr3"></span>ltac_expr3       </strong> ::=  do (<code class="xref docutils literal notranslate"><span class="pre">natural</span></code> | <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>) <code class="xref docutils literal notranslate"><span class="pre">ltac_expr3</span></code>
                       progress <code class="xref docutils literal notranslate"><span class="pre">ltac_expr3</span></code>
                       repeat <code class="xref docutils literal notranslate"><span class="pre">ltac_expr3</span></code>
                       try <code class="xref docutils literal notranslate"><span class="pre">ltac_expr3</span></code>
                       once <code class="xref docutils literal notranslate"><span class="pre">ltac_expr3</span></code>
                       exactly_once <code class="xref docutils literal notranslate"><span class="pre">ltac_expr3</span></code>
                       timeout (<code class="xref docutils literal notranslate"><span class="pre">natural</span></code> | <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>) <code class="xref docutils literal notranslate"><span class="pre">ltac_expr3</span></code>
                       time [<code class="xref docutils literal notranslate"><span class="pre">string</span></code>] <code class="xref docutils literal notranslate"><span class="pre">ltac_expr3</span></code>
                       only <code class="xref docutils literal notranslate"><span class="pre">selector</span></code>: <code class="xref docutils literal notranslate"><span class="pre">ltac_expr3</span></code>
                       <code class="xref docutils literal notranslate"><span class="pre">ltac_expr2</span></code>
<strong id="grammar-token-coq-ltac_expr2"><span id="grammar-token-ltac-expr2"></span>ltac_expr2       </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">ltac_expr1</span></code> || <code class="xref docutils literal notranslate"><span class="pre">ltac_expr3</span></code>
                       <code class="xref docutils literal notranslate"><span class="pre">ltac_expr1</span></code> + <code class="xref docutils literal notranslate"><span class="pre">ltac_expr3</span></code>
                       tryif <code class="xref docutils literal notranslate"><span class="pre">ltac_expr1</span></code> then <code class="xref docutils literal notranslate"><span class="pre">ltac_expr1</span></code> else <code class="xref docutils literal notranslate"><span class="pre">ltac_expr1</span></code>
                       <code class="xref docutils literal notranslate"><span class="pre">ltac_expr1</span></code>
<strong id="grammar-token-coq-ltac_expr1"><span id="grammar-token-ltac-expr1"></span>ltac_expr1       </strong> ::=  fun <code class="xref docutils literal notranslate"><span class="pre">name</span></code> ... <code class="xref docutils literal notranslate"><span class="pre">name</span></code> =&gt; <code class="xref docutils literal notranslate"><span class="pre">atom</span></code>
                       let [rec] <code class="xref docutils literal notranslate"><span class="pre">let_clause</span></code> with ... with <code class="xref docutils literal notranslate"><span class="pre">let_clause</span></code> in <code class="xref docutils literal notranslate"><span class="pre">atom</span></code>
                       match goal with <code class="xref docutils literal notranslate"><span class="pre">context_rule</span></code> | ... | <code class="xref docutils literal notranslate"><span class="pre">context_rule</span></code> end
                       match reverse goal with <code class="xref docutils literal notranslate"><span class="pre">context_rule</span></code> | ... | <code class="xref docutils literal notranslate"><span class="pre">context_rule</span></code> end
                       match <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code> with <code class="xref docutils literal notranslate"><span class="pre">match_rule</span></code> | ... | <code class="xref docutils literal notranslate"><span class="pre">match_rule</span></code> end
                       lazymatch goal with <code class="xref docutils literal notranslate"><span class="pre">context_rule</span></code> | ... | <code class="xref docutils literal notranslate"><span class="pre">context_rule</span></code> end
                       lazymatch reverse goal with <code class="xref docutils literal notranslate"><span class="pre">context_rule</span></code> | ... | <code class="xref docutils literal notranslate"><span class="pre">context_rule</span></code> end
                       lazymatch <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code> with <code class="xref docutils literal notranslate"><span class="pre">match_rule</span></code> | ... | <code class="xref docutils literal notranslate"><span class="pre">match_rule</span></code> end
                       multimatch goal with <code class="xref docutils literal notranslate"><span class="pre">context_rule</span></code> | ... | <code class="xref docutils literal notranslate"><span class="pre">context_rule</span></code> end
                       multimatch reverse goal with <code class="xref docutils literal notranslate"><span class="pre">context_rule</span></code> | ... | <code class="xref docutils literal notranslate"><span class="pre">context_rule</span></code> end
                       multimatch <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code> with <code class="xref docutils literal notranslate"><span class="pre">match_rule</span></code> | ... | <code class="xref docutils literal notranslate"><span class="pre">match_rule</span></code> end
                       abstract <code class="xref docutils literal notranslate"><span class="pre">atom</span></code>
                       abstract <code class="xref docutils literal notranslate"><span class="pre">atom</span></code> using <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>
                       first [ <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code> | ... | <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code> ]
                       solve [ <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code> | ... | <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code> ]
                       idtac [ <code class="xref docutils literal notranslate"><span class="pre">message_token</span></code> ... <code class="xref docutils literal notranslate"><span class="pre">message_token</span></code>]
                       fail [<code class="xref docutils literal notranslate"><span class="pre">natural</span></code>] [<code class="xref docutils literal notranslate"><span class="pre">message_token</span></code> ... <code class="xref docutils literal notranslate"><span class="pre">message_token</span></code>]
                       gfail [<code class="xref docutils literal notranslate"><span class="pre">natural</span></code>] [<code class="xref docutils literal notranslate"><span class="pre">message_token</span></code> ... <code class="xref docutils literal notranslate"><span class="pre">message_token</span></code>]
                       fresh [ <code class="xref docutils literal notranslate"><span class="pre">component</span></code> … <code class="xref docutils literal notranslate"><span class="pre">component</span></code> ]
                       context <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> [<code class="xref docutils literal notranslate"><span class="pre">term</span></code>]
                       eval <code class="xref docutils literal notranslate"><span class="pre">redexpr</span></code> in <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                       type of <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                       constr : <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                       uconstr : <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                       type_term <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                       numgoals
                       guard <code class="xref docutils literal notranslate"><span class="pre">test</span></code>
                       assert_fails <code class="xref docutils literal notranslate"><span class="pre">ltac_expr3</span></code>
                       assert_succeeds <code class="xref docutils literal notranslate"><span class="pre">ltac_expr3</span></code>
                       <code class="xref docutils literal notranslate"><span class="pre">tactic</span></code>
                       <code class="xref docutils literal notranslate"><span class="pre">qualid</span></code> <code class="xref docutils literal notranslate"><span class="pre">tacarg</span></code> ... <code class="xref docutils literal notranslate"><span class="pre">tacarg</span></code>
                       <code class="xref docutils literal notranslate"><span class="pre">atom</span></code>
<strong id="grammar-token-coq-atom"><span id="grammar-token-atom"></span>atom             </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">qualid</span></code>
                       ()
                       <code class="xref docutils literal notranslate"><span class="pre">integer</span></code>
                       ( <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code> )
<strong id="grammar-token-coq-component"><span id="grammar-token-component"></span>component        </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">string</span></code> | <code class="xref docutils literal notranslate"><span class="pre">qualid</span></code>
<strong id="grammar-token-coq-message_token"><span id="grammar-token-message-token"></span>message_token    </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">string</span></code> | <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> | <code class="xref docutils literal notranslate"><span class="pre">integer</span></code>
<strong id="grammar-token-coq-tacarg"><span id="grammar-token-tacarg"></span>tacarg           </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">qualid</span></code>
                       ()
                       ltac : <code class="xref docutils literal notranslate"><span class="pre">atom</span></code>
                       <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
<strong id="grammar-token-coq-let_clause"><span id="grammar-token-let-clause"></span>let_clause       </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> [<code class="xref docutils literal notranslate"><span class="pre">name</span></code> ... <code class="xref docutils literal notranslate"><span class="pre">name</span></code>] := <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code>
<strong id="grammar-token-coq-context_rule"><span id="grammar-token-context-rule"></span>context_rule     </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">context_hyp</span></code>, ..., <code class="xref docutils literal notranslate"><span class="pre">context_hyp</span></code> |- <code class="xref docutils literal notranslate"><span class="pre">cpattern</span></code> =&gt; <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code>
                       <code class="xref docutils literal notranslate"><span class="pre">cpattern</span></code> =&gt; <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code>
                       |- <code class="xref docutils literal notranslate"><span class="pre">cpattern</span></code> =&gt; <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code>
                       _ =&gt; <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code>
<strong id="grammar-token-coq-context_hyp"><span id="grammar-token-context-hyp"></span>context_hyp      </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">name</span></code> : <code class="xref docutils literal notranslate"><span class="pre">cpattern</span></code>
                       <code class="xref docutils literal notranslate"><span class="pre">name</span></code> := <code class="xref docutils literal notranslate"><span class="pre">cpattern</span></code> [: <code class="xref docutils literal notranslate"><span class="pre">cpattern</span></code>]
<strong id="grammar-token-coq-match_rule"><span id="grammar-token-match-rule"></span>match_rule       </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">cpattern</span></code> =&gt; <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code>
                       context [<code class="xref docutils literal notranslate"><span class="pre">ident</span></code>] [ <code class="xref docutils literal notranslate"><span class="pre">cpattern</span></code> ] =&gt; <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code>
                       _ =&gt; <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code>
<strong id="grammar-token-coq-test"><span id="grammar-token-test"></span>test             </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">integer</span></code> = <code class="xref docutils literal notranslate"><span class="pre">integer</span></code>
                       <code class="xref docutils literal notranslate"><span class="pre">integer</span></code> (&lt; | &lt;= | &gt; | &gt;=) <code class="xref docutils literal notranslate"><span class="pre">integer</span></code>
<strong id="grammar-token-coq-selector"><span id="grammar-token-selector"></span>selector         </strong> ::=  [<code class="xref docutils literal notranslate"><span class="pre">ident</span></code>]
                       <code class="xref docutils literal notranslate"><span class="pre">integer</span></code>
                       (<code class="xref docutils literal notranslate"><span class="pre">integer</span></code> | <code class="xref docutils literal notranslate"><span class="pre">integer</span></code> - <code class="xref docutils literal notranslate"><span class="pre">integer</span></code>), ..., (<code class="xref docutils literal notranslate"><span class="pre">integer</span></code> | <code class="xref docutils literal notranslate"><span class="pre">integer</span></code> - <code class="xref docutils literal notranslate"><span class="pre">integer</span></code>)
<strong id="grammar-token-coq-toplevel_selector"><span id="grammar-token-toplevel-selector"></span>toplevel_selector</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">selector</span></code>
                       all
                       par
                       !
</pre>
<pre>
<strong id="grammar-token-coq-top"><span id="grammar-token-top"></span>top     </strong> ::=  [Local] Ltac <code class="xref docutils literal notranslate"><span class="pre">ltac_def</span></code> with ... with <code class="xref docutils literal notranslate"><span class="pre">ltac_def</span></code>
<strong id="grammar-token-coq-ltac_def"><span id="grammar-token-ltac-def"></span>ltac_def</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> [<code class="xref docutils literal notranslate"><span class="pre">ident</span></code> ... <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>] := <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code>
              <code class="xref docutils literal notranslate"><span class="pre">qualid</span></code> [<code class="xref docutils literal notranslate"><span class="pre">ident</span></code> ... <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>] ::= <code class="xref docutils literal notranslate"><span class="pre">ltac_expr</span></code>
</pre>
</div>
<div class="section" id="semantics">
<span id="ltac-semantics"></span><h2>Semantics<a class="headerlink" href="#semantics" title="Permalink to this headline">¶</a></h2>
<p>Tactic expressions can only be applied in the context of a proof. The
evaluation yields either a term, an integer or a tactic. Intermediate
results can be terms or integers but the final result must be a tactic
which is then applied to the focused goals.</p>
<p>There is a special case for <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span></code> expressions of which the clauses
evaluate to tactics. Such expressions can only be used as end result of
a tactic expression (never as argument of a non-recursive local
definition or of an application).</p>
<p>The rest of this section explains the semantics of every construction of
<code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub>.</p>
<div class="section" id="sequence">
<h3>Sequence<a class="headerlink" href="#sequence" title="Permalink to this headline">¶</a></h3>
<p>A sequence is an expression of the following form:</p>
<dl class="coq tacn">
<dt id="coq:tacn.ltac-seq">
<code class="sig-name descname"><span class="notation"><span class="hole">ltac_expr<sub>1</sub></span> <span>;</span> <span class="hole">ltac_expr<sub>2</sub></span></span></code><a class="headerlink" href="#coq:tacn.ltac-seq" title="Permalink to this definition">¶</a></dt>
<dd><p>The expression <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span></span></code> is evaluated to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code>, which must be
a tactic value. The tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code> is applied to the current goal,
possibly producing more goals. Then <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">2</span></sub></span></span></code> is evaluated to
produce <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">2</span></sub></span></span></code>, which must be a tactic value. The tactic
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">2</span></sub></span></span></code> is applied to all the goals produced by the prior
application. Sequence is associative.</p>
</dd></dl>

</div>
<div class="section" id="local-application-of-tactics">
<h3>Local application of tactics<a class="headerlink" href="#local-application-of-tactics" title="Permalink to this headline">¶</a></h3>
<p>Different tactics can be applied to the different goals using the
following form:</p>
<dl class="coq tacn">
<dt id="coq:tacn.dispatch">
<code class="sig-name descname"><span class="notation"><span>[&gt;</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ltac_expr</span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span><span>]</span></span></code><a class="headerlink" href="#coq:tacn.dispatch" title="Permalink to this definition">¶</a></dt>
<dd><p>The expressions <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">i</span></sub></span></span></code> are evaluated to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">i</span></sub></span></span></code>, for
i = 1, ..., n and all have to be tactics. The <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">i</span></sub></span></span></code> is applied to the
i-th goal, for i = 1, ..., n. It fails if the number of focused goals is not
exactly n.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If no tactic is given for the i-th goal, it behaves as if the tactic idtac
were given. For instance, <code class="docutils literal notranslate"><span class="pre">[&gt;</span> <span class="pre">|</span> <span class="pre">auto]</span></code> is a shortcut for <code class="docutils literal notranslate"><span class="pre">[&gt;</span> <span class="pre">idtac</span> <span class="pre">|</span> <span class="pre">auto</span>
<span class="pre">]</span></code>.</p>
</div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>[&gt;</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ltac_expr<sub>i</sub></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> | <span class="hole">ltac_expr</span> <span>..</span> | <span class="repeat-wrapper"><span class="repeat"><span class="hole">ltac_expr<sub>j</sub></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span><span>]</span></span></code></dt>
<dd><p>In this variant, <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> is used for each goal coming after those
covered by the list of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">i</span></sub></span></span></code> but before those covered by the
list of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">j</span></sub></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>[&gt;</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ltac_expr</span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> | <span>..</span> | <span class="repeat-wrapper"><span class="repeat"><span class="hole">ltac_expr</span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span><span>]</span></span></code></dt>
<dd><p>In this variant, idtac is used for the goals not covered by the two lists of
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>[&gt;</span> <span class="hole">ltac_expr</span> <span>..</span> <span>]</span></span></code></dt>
<dd><p>In this variant, the tactic <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> is applied independently to each of
the goals, rather than globally. In particular, if there are no goals, the
tactic is not run at all. A tactic which expects multiple goals, such as
<code class="docutils literal notranslate"><span class="pre">swap</span></code>, would act as if a single goal is focused.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">ltac_expr<sub>0</sub></span> <span>;</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><span class="hole">ltac_expr<sub>i</sub></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span><span>]</span></span></code></dt>
<dd><p>This variant of local tactic application is paired with a sequence. In this
variant, there must be as many <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">i</span></sub></span></span></code> as goals generated
by the application of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">0</span></sub></span></span></code> to each of the individual goals
independently. All the above variants work in this form too.
Formally, <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span> <span><span class="pre">;</span></span> <span><span class="pre">[</span></span> <span><span class="pre">...</span></span> <span><span class="pre">]</span></span></span></code> is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[&gt;</span></span> <span class="hole"><span class="pre">ltac_expr</span></span> <span><span class="pre">;</span></span> <span><span class="pre">[&gt;</span></span> <span><span class="pre">...</span></span> <span><span class="pre">]</span></span> <span><span class="pre">..</span></span> <span><span class="pre">]</span></span></span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="goal-selectors">
<span id="id2"></span><h3>Goal selectors<a class="headerlink" href="#goal-selectors" title="Permalink to this headline">¶</a></h3>
<p>We can restrict the application of a tactic to a subset of the currently
focused goals with:</p>
<dl class="coq tacn">
<dt id="coq:tacn.goal-selector">
<code class="sig-name descname"><span class="notation"><span class="hole">toplevel_selector</span> <span>:</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacn.goal-selector" title="Permalink to this definition">¶</a></dt>
<dd><p>We can also use selectors as a tactical, which allows to use them nested
in a tactic expression, by using the keyword <code class="docutils literal notranslate"><span class="pre">only</span></code>:</p>
<dl class="coq tacv">
<dt id="coq:tacv.only">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>only</span> <span class="hole">selector</span> <span>:</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacv.only" title="Permalink to this definition">¶</a></dt>
<dd><p>When selecting several goals, the tactic <code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code> is applied globally to all
selected goals.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>[</span><span class="hole">ident</span><span>]</span> <span>:</span> <span class="hole">ltac_expr</span></span></code></dt>
<dd><p>In this variant, <code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code> is applied locally to a goal previously named
by the user (see <a class="reference internal" href="../language/gallina-extensions.html#existential-variables"><span class="std std-ref">Existential variables</span></a>).</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">num</span> <span>:</span> <span class="hole">ltac_expr</span></span></code></dt>
<dd><p>In this variant, <code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code> is applied locally to the <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code>-th goal.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span><span>-</span><span class="hole">num</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>:</span> <span class="hole">ltac_expr</span></span></code></dt>
<dd><p>In this variant, <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> is applied globally to the subset of goals
described by the given ranges. You can write a single <code class="docutils literal notranslate"><span class="pre">n</span></code> as a shortcut
for <code class="docutils literal notranslate"><span class="pre">n-n</span></code> when specifying multiple ranges.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.all">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>all:</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacv.all" title="Permalink to this definition">¶</a></dt>
<dd><p>In this variant, <code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code> is applied to all focused goals. <code class="docutils literal notranslate"><span class="pre">all:</span></code> can only
be used at the toplevel of a tactic expression.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>!:</span> <span class="hole">ltac_expr</span></span></code></dt>
<dd><p>In this variant, if exactly one goal is focused, <code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code> is
applied to it. Otherwise the tactic fails. <code class="docutils literal notranslate"><span class="pre">!:</span></code> can only be
used at the toplevel of a tactic expression.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.par">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>par:</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacv.par" title="Permalink to this definition">¶</a></dt>
<dd><p>In this variant, <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> is applied to all focused goals in parallel.
The number of workers can be controlled via the command line option
<code class="docutils literal notranslate"><span class="pre">-async-proofs-tac-j</span></code> taking as argument the desired number of workers.
Limitations: <code class="docutils literal notranslate"><span class="pre">par:</span></code> only works on goals containing no existential
variables and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> must either solve the goal completely or do
nothing (i.e. it cannot make some progress). <code class="docutils literal notranslate"><span class="pre">par:</span></code> can only be used at
the toplevel of a tactic expression.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.no-such-goal-goal-selector">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>such</span> <span>goal.</span></span></code><a class="headerlink" href="#coq:exn.no-such-goal-goal-selector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="for-loop">
<h3>For loop<a class="headerlink" href="#for-loop" title="Permalink to this headline">¶</a></h3>
<p>There is a for loop that repeats a tactic <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code> times:</p>
<dl class="coq tacn">
<dt id="coq:tacn.do">
<code class="sig-name descname"><span class="notation"><span>do</span> <span class="hole">num</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacn.do" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> is evaluated to <code class="docutils literal notranslate"><span class="pre">v</span></code> which must be a tactic value. This tactic
value <code class="docutils literal notranslate"><span class="pre">v</span></code> is applied <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code> times. Supposing <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code> &gt; 1, after the
first application of <code class="docutils literal notranslate"><span class="pre">v</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code> is applied, at least once, to the generated
subgoals and so on. It fails if the application of <code class="docutils literal notranslate"><span class="pre">v</span></code> fails before the num
applications have been completed.</p>
</dd></dl>

</div>
<div class="section" id="repeat-loop">
<h3>Repeat loop<a class="headerlink" href="#repeat-loop" title="Permalink to this headline">¶</a></h3>
<p>We have a repeat loop with:</p>
<dl class="coq tacn">
<dt id="coq:tacn.repeat">
<code class="sig-name descname"><span class="notation"><span>repeat</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacn.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> is evaluated to <code class="docutils literal notranslate"><span class="pre">v</span></code>. If <code class="docutils literal notranslate"><span class="pre">v</span></code> denotes a tactic, this tactic is
applied to each focused goal independently. If the application succeeds, the
tactic is applied recursively to all the generated subgoals until it eventually
fails. The recursion stops in a subgoal when the tactic has failed <em>to make
progress</em>. The tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">repeat</span></span> <span class="hole"><span class="pre">ltac_expr</span></span></span></code> itself never fails.</p>
</dd></dl>

</div>
<div class="section" id="error-catching">
<h3>Error catching<a class="headerlink" href="#error-catching" title="Permalink to this headline">¶</a></h3>
<p>We can catch the tactic errors with:</p>
<dl class="coq tacn">
<dt id="coq:tacn.try">
<code class="sig-name descname"><span class="notation"><span>try</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacn.try" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> is evaluated to <code class="docutils literal notranslate"><span class="pre">v</span></code> which must be a tactic value. The tactic
value <code class="docutils literal notranslate"><span class="pre">v</span></code> is applied to each focused goal independently. If the application of
<code class="docutils literal notranslate"><span class="pre">v</span></code> fails in a goal, it catches the error and leaves the goal unchanged. If the
level of the exception is positive, then the exception is re-raised with its
level decremented.</p>
</dd></dl>

</div>
<div class="section" id="detecting-progress">
<h3>Detecting progress<a class="headerlink" href="#detecting-progress" title="Permalink to this headline">¶</a></h3>
<p>We can check if a tactic made progress with:</p>
<dl class="coq tacn">
<dt id="coq:tacn.progress">
<code class="sig-name descname"><span class="notation"><span>progress</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacn.progress" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> is evaluated to v which must be a tactic value. The tactic value <code class="docutils literal notranslate"><span class="pre">v</span></code>
is applied to each focused subgoal independently. If the application of <code class="docutils literal notranslate"><span class="pre">v</span></code>
to one of the focused subgoal produced subgoals equal to the initial
goals (up to syntactical equality), then an error of level 0 is raised.</p>
<dl class="coq exn">
<dt id="coq:exn.failed-to-progress">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Failed</span> <span>to</span> <span>progress.</span></span></code><a class="headerlink" href="#coq:exn.failed-to-progress" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="backtracking-branching">
<h3>Backtracking branching<a class="headerlink" href="#backtracking-branching" title="Permalink to this headline">¶</a></h3>
<p>We can branch with the following structure:</p>
<dl class="coq tacn">
<dt id="coq:tacn.backtracking-branching">
<code class="sig-name descname"><span class="notation"><span class="hole">ltac_expr<sub>1</sub></span> <span>+</span> <span class="hole">ltac_expr<sub>2</sub></span></span></code><a class="headerlink" href="#coq:tacn.backtracking-branching" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">2</span></sub></span></span></code> are evaluated respectively to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code> and
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">2</span></sub></span></span></code> which must be tactic values. The tactic value <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code> is applied to
each focused goal independently and if it fails or a later tactic fails, then
the proof backtracks to the current goal and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">2</span></sub></span></span></code> is applied.</p>
<p>Tactics can be seen as having several successes. When a tactic fails it
asks for more successes of the prior tactics.
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span> <span><span class="pre">+</span></span> <span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">2</span></sub></span></span></code> has all the successes of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code> followed by all the
successes of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">2</span></sub></span></span></code>. Algebraically,
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span> <span><span class="pre">+</span></span> <span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">2</span></sub></span><span><span class="pre">);</span></span> <span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">3</span></sub></span> <span><span class="pre">=</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span><span><span class="pre">;</span></span> <span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">3</span></sub></span><span><span class="pre">)</span></span> <span><span class="pre">+</span></span> <span><span class="pre">(</span></span><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">2</span></sub></span><span><span class="pre">;</span></span> <span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">3</span></sub></span><span><span class="pre">)</span></span></span></code>.</p>
<p>Branching is left-associative.</p>
</dd></dl>

</div>
<div class="section" id="first-tactic-to-work">
<h3>First tactic to work<a class="headerlink" href="#first-tactic-to-work" title="Permalink to this headline">¶</a></h3>
<p>Backtracking branching may be too expensive. In this case we may
restrict to a local, left biased, branching and consider the first
tactic to work (i.e. which does not fail) among a panel of tactics:</p>
<dl class="coq tacn">
<dt id="coq:tacn.first">
<code class="sig-name descname"><span class="notation"><span>first</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><span class="hole">ltac_expr</span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span><span>]</span></span></code><a class="headerlink" href="#coq:tacn.first" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">i</span></sub></span></span></code> are evaluated to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">i</span></sub></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">i</span></sub></span></span></code> must be
tactic values for i = 1, ..., n. Supposing n &gt; 1,
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">first</span></span> <span><span class="pre">[</span></span><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span> <span class="pre">|</span> <span><span class="pre">...</span></span> <span class="pre">|</span> <span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">n</span></sub></span><span><span class="pre">]</span></span></span></code> applies <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code> in each
focused goal independently and stops if it succeeds; otherwise it
tries to apply <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">2</span></sub></span></span></code> and so on. It fails when there is no
applicable tactic. In other words,
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">first</span></span> <span><span class="pre">[</span></span><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span> <span class="pre">|</span> <span><span class="pre">...</span></span> <span class="pre">|</span> <span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">n</span></sub></span><span><span class="pre">]</span></span></span></code> behaves, in each goal, as the first
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">i</span></sub></span></span></code> to have <em>at least</em> one success.</p>
<dl class="coq exn">
<dt id="coq:exn.no-applicable-tactic">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>applicable</span> <span>tactic.</span></span></code><a class="headerlink" href="#coq:exn.no-applicable-tactic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>first</span> <span class="hole">ltac_expr</span></span></code></dt>
<dd><p>This is an <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> alias that gives a primitive access to the first
tactical as an <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> definition without going through a parsing rule. It
expects to be given a list of tactics through a <code class="docutils literal notranslate"><span class="pre">Tactic</span> <span class="pre">Notation</span></code>,
allowing to write notations of the following form:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;foo&quot;</span> tactic_list(tacs) := <span class="kp">first</span> tacs.</span></span></span></pre></div></div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="left-biased-branching">
<h3>Left-biased branching<a class="headerlink" href="#left-biased-branching" title="Permalink to this headline">¶</a></h3>
<p>Yet another way of branching without backtracking is the following
structure:</p>
<dl class="coq tacn">
<dt id="coq:tacn.left-biased-branching">
<code class="sig-name descname"><span class="notation"><span class="hole">ltac_expr<sub>1</sub></span> || <span class="hole">ltac_expr<sub>2</sub></span></span></code><a class="headerlink" href="#coq:tacn.left-biased-branching" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">2</span></sub></span></span></code> are evaluated respectively to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code> and
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">2</span></sub></span></span></code> which must be tactic values. The tactic value <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code> is
applied in each subgoal independently and if it fails <em>to progress</em> then
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">2</span></sub></span></span></code> is applied. <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span> <span class="pre">|</span><span class="pre">|</span> <span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">2</span></sub></span></span></code> is
equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">first</span></span> <span><span class="pre">[</span></span> <span><span class="pre">progress</span></span> <span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span> <span class="pre">|</span> <span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">2</span></sub></span> <span><span class="pre">]</span></span></span></code> (except that
if it fails, it fails like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">2</span></sub></span></span></code>). Branching is left-associative.</p>
</dd></dl>

</div>
<div class="section" id="generalized-biased-branching">
<h3>Generalized biased branching<a class="headerlink" href="#generalized-biased-branching" title="Permalink to this headline">¶</a></h3>
<p>The tactic</p>
<dl class="coq tacn">
<dt id="coq:tacn.tryif">
<code class="sig-name descname"><span class="notation"><span>tryif</span> <span class="hole">ltac_expr<sub>1</sub></span> <span>then</span> <span class="hole">ltac_expr<sub>2</sub></span> <span>else</span> <span class="hole">ltac_expr<sub>3</sub></span></span></code><a class="headerlink" href="#coq:tacn.tryif" title="Permalink to this definition">¶</a></dt>
<dd><p>is a generalization of the biased-branching tactics above. The
expression <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span></span></code> is evaluated to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code>, which is then
applied to each subgoal independently. For each goal where <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code>
succeeds at least once, <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">2</span></sub></span></span></code> is evaluated to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">2</span></sub></span></span></code> which
is then applied collectively to the generated subgoals. The <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">2</span></sub></span></span></code>
tactic can trigger backtracking points in <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code>: where <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code>
succeeds at least once,
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">tryif</span></span> <span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span> <span><span class="pre">then</span></span> <span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">2</span></sub></span> <span><span class="pre">else</span></span> <span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">3</span></sub></span></span></code> is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span><span><span class="pre">;</span></span> <span><span class="pre">v</span><sub><span class="pre">2</span></sub></span></span></code>. In each of the goals where <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code> does not succeed at least
once, <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">3</span></sub></span></span></code> is evaluated in <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">3</span></sub></span></span></code> which is is then applied to the
goal.</p>
</dd></dl>

</div>
<div class="section" id="soft-cut">
<h3>Soft cut<a class="headerlink" href="#soft-cut" title="Permalink to this headline">¶</a></h3>
<p>Another way of restricting backtracking is to restrict a tactic to a
single success <em>a posteriori</em>:</p>
<dl class="coq tacn">
<dt id="coq:tacn.once">
<code class="sig-name descname"><span class="notation"><span>once</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacn.once" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> is evaluated to <code class="docutils literal notranslate"><span class="pre">v</span></code> which must be a tactic value. The tactic value
<code class="docutils literal notranslate"><span class="pre">v</span></code> is applied but only its first success is used. If <code class="docutils literal notranslate"><span class="pre">v</span></code> fails,
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">once</span></span> <span class="hole"><span class="pre">ltac_expr</span></span></span></code> fails like <code class="docutils literal notranslate"><span class="pre">v</span></code>. If <code class="docutils literal notranslate"><span class="pre">v</span></code> has at least one success,
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">once</span></span> <span class="hole"><span class="pre">ltac_expr</span></span></span></code> succeeds once, but cannot produce more successes.</p>
</dd></dl>

</div>
<div class="section" id="checking-the-successes">
<h3>Checking the successes<a class="headerlink" href="#checking-the-successes" title="Permalink to this headline">¶</a></h3>
<p>Coq provides an experimental way to check that a tactic has <em>exactly
one</em> success:</p>
<dl class="coq tacn">
<dt id="coq:tacn.exactly-once">
<code class="sig-name descname"><span class="notation"><span>exactly</span><span>_</span><span>once</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacn.exactly-once" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> is evaluated to <code class="docutils literal notranslate"><span class="pre">v</span></code> which must be a tactic value. The tactic value
<code class="docutils literal notranslate"><span class="pre">v</span></code> is applied if it has at most one success. If <code class="docutils literal notranslate"><span class="pre">v</span></code> fails,
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">exactly</span></span><span><span class="pre">_</span></span><span><span class="pre">once</span></span> <span class="hole"><span class="pre">ltac_expr</span></span></span></code> fails like <code class="docutils literal notranslate"><span class="pre">v</span></code>. If <code class="docutils literal notranslate"><span class="pre">v</span></code> has a exactly one success,
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">exactly</span></span><span><span class="pre">_</span></span><span><span class="pre">once</span></span> <span class="hole"><span class="pre">ltac_expr</span></span></span></code> succeeds like <code class="docutils literal notranslate"><span class="pre">v</span></code>. If <code class="docutils literal notranslate"><span class="pre">v</span></code> has two or more
successes, <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">exactly</span></span><span><span class="pre">_</span></span><span><span class="pre">once</span></span> <span class="hole"><span class="pre">ltac_expr</span></span></span></code> fails.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The experimental status of this tactic pertains to the fact if <code class="docutils literal notranslate"><span class="pre">v</span></code>
performs side effects, they may occur in an unpredictable way. Indeed,
normally <code class="docutils literal notranslate"><span class="pre">v</span></code> would only be executed up to the first success until
backtracking is needed, however exactly_once needs to look ahead to see
whether a second success exists, and may run further effects
immediately.</p>
</div>
<dl class="coq exn">
<dt id="coq:exn.this-tactic-has-more-than-one-success">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>This</span> <span>tactic</span> <span>has</span> <span>more</span> <span>than</span> <span>one</span> <span>success.</span></span></code><a class="headerlink" href="#coq:exn.this-tactic-has-more-than-one-success" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="checking-the-failure">
<h3>Checking the failure<a class="headerlink" href="#checking-the-failure" title="Permalink to this headline">¶</a></h3>
<p>Coq provides a derived tactic to check that a tactic <em>fails</em>:</p>
<dl class="coq tacn">
<dt id="coq:tacn.assert-fails">
<code class="sig-name descname"><span class="notation"><span>assert</span><span>_</span><span>fails</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacn.assert-fails" title="Permalink to this definition">¶</a></dt>
<dd><p>This behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">tryif</span></span> <span class="hole"><span class="pre">ltac_expr</span></span> <span><span class="pre">then</span></span> <span><span class="pre">fail</span></span> <span><span class="pre">0</span></span> <span><span class="pre">tac</span></span> <span><span class="pre">&quot;succeeds&quot;</span></span> <span><span class="pre">else</span></span> <span><span class="pre">idtac</span></span></span></code>.</p>
</dd></dl>

</div>
<div class="section" id="checking-the-success">
<h3>Checking the success<a class="headerlink" href="#checking-the-success" title="Permalink to this headline">¶</a></h3>
<p>Coq provides a derived tactic to check that a tactic has <em>at least one</em>
success:</p>
<dl class="coq tacn">
<dt id="coq:tacn.assert-succeeds">
<code class="sig-name descname"><span class="notation"><span>assert</span><span>_</span><span>succeeds</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacn.assert-succeeds" title="Permalink to this definition">¶</a></dt>
<dd><p>This behaves like
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">tryif</span></span> <span><span class="pre">(assert</span></span><span><span class="pre">_</span></span><span><span class="pre">fails</span></span> <span><span class="pre">tac)</span></span> <span><span class="pre">then</span></span> <span><span class="pre">fail</span></span> <span><span class="pre">0</span></span> <span><span class="pre">tac</span></span> <span><span class="pre">&quot;fails&quot;</span></span> <span><span class="pre">else</span></span> <span><span class="pre">idtac</span></span></span></code>.</p>
</dd></dl>

</div>
<div class="section" id="solving">
<h3>Solving<a class="headerlink" href="#solving" title="Permalink to this headline">¶</a></h3>
<p>We may consider the first to solve (i.e. which generates no subgoal)
among a panel of tactics:</p>
<dl class="coq tacn">
<dt id="coq:tacn.solve">
<code class="sig-name descname"><span class="notation"><span>solve</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><span class="hole">ltac_expr</span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span><span>]</span></span></code><a class="headerlink" href="#coq:tacn.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">i</span></sub></span></span></code> are evaluated to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">i</span></sub></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">i</span></sub></span></span></code> must be
tactic values, for i = 1, ..., n. Supposing n &gt; 1,
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">solve</span></span> <span><span class="pre">[</span></span><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span> <span class="pre">|</span> <span><span class="pre">...</span></span> <span class="pre">|</span> <span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">n</span></sub></span><span><span class="pre">]</span></span></span></code> applies <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code> to
each goal independently and stops if it succeeds; otherwise it tries to
apply <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">2</span></sub></span></span></code> and so on. It fails if there is no solving tactic.</p>
<dl class="coq exn">
<dt id="coq:exn.cannot-solve-the-goal">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>solve</span> <span>the</span> <span>goal.</span></span></code><a class="headerlink" href="#coq:exn.cannot-solve-the-goal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>solve</span> <span class="hole">ltac_expr</span></span></code></dt>
<dd><p>This is an <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> alias that gives a primitive access to the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">solve:</span></span></span></code>
tactical. See the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">first</span></span></span></code> tactical for more information.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="identity">
<h3>Identity<a class="headerlink" href="#identity" title="Permalink to this headline">¶</a></h3>
<p>The constant <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">idtac</span></span></span></code> is the identity tactic: it leaves any goal unchanged but
it appears in the proof script.</p>
<dl class="coq tacn">
<dt id="coq:tacn.idtac">
<code class="sig-name descname"><span class="notation"><span>idtac</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">message_token</span></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:tacn.idtac" title="Permalink to this definition">¶</a></dt>
<dd><p>This prints the given tokens. Strings and integers are printed
literally. If a (term) variable is given, its contents are printed.</p>
</dd></dl>

</div>
<div class="section" id="failing">
<h3>Failing<a class="headerlink" href="#failing" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.fail">
<code class="sig-name descname"><span class="notation"><span>fail</span></span></code><a class="headerlink" href="#coq:tacn.fail" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the always-failing tactic: it does not solve any
goal. It is useful for defining other tacticals since it can be caught by
<a class="reference internal" href="#coq:tacn.try" title="try"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">try</span></code></a>, <a class="reference internal" href="#coq:tacn.repeat" title="repeat"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">repeat</span></code></a>, <a class="reference internal" href="#coq:tacn.match-goal" title="match goal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span></code></a>, or the branching tacticals.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>fail</span> <span class="hole">num</span></span></code></dt>
<dd><p>The number is the failure level. If no level is specified, it defaults to 0.
The level is used by <a class="reference internal" href="#coq:tacn.try" title="try"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">try</span></code></a>, <a class="reference internal" href="#coq:tacn.repeat" title="repeat"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">repeat</span></code></a>, <a class="reference internal" href="#coq:tacn.match-goal" title="match goal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span></code></a> and the branching
tacticals. If 0, it makes <a class="reference internal" href="#coq:tacn.match-goal" title="match goal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span></code></a> consider the next clause
(backtracking). If nonzero, the current <a class="reference internal" href="#coq:tacn.match-goal" title="match goal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span></code></a> block, <a class="reference internal" href="#coq:tacn.try" title="try"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">try</span></code></a>,
<a class="reference internal" href="#coq:tacn.repeat" title="repeat"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">repeat</span></code></a>, or branching command is aborted and the level is decremented. In
the case of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">+</span></span></span></code>, a nonzero level skips the first backtrack point, even if
the call to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">fail</span></span> <span class="hole"><span class="pre">num</span></span></span></code> is not enclosed in a <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">+</span></span></span></code> command,
respecting the algebraic identity.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>fail</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">message_token</span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>The given tokens are used for printing the failure message.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>fail</span> <span class="hole">num</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">message_token</span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This is a combination of the previous variants.</p>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.gfail">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>gfail</span></span></code><a class="headerlink" href="#coq:tacv.gfail" title="Permalink to this definition">¶</a></dt>
<dd><p>This variant fails even when used after <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">;</span></span></span></code> and there are no goals left.
Similarly, <code class="docutils literal notranslate"><span class="pre">gfail</span></code> fails even when used after <code class="docutils literal notranslate"><span class="pre">all:</span></code> and there are no
goals left. See the example for clarification.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>gfail</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">message_token</span></span><span class="notation-sup">*</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>gfail</span> <span class="hole">num</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">message_token</span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>These variants fail with an error message or an error level even if
there are no goals left. Be careful however if Coq terms have to be
printed as part of the failure: term construction always forces the
tactic into the goals, meaning that if there are no goals when it is
evaluated, a tactic call like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <span><span class="pre">x</span></span> <span><span class="pre">:=</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">fail</span></span> <span><span class="pre">0</span></span> <span><span class="pre">x</span></span></span></code> will succeed.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.tactic-failure-message-level-num">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Tactic</span> <span>Failure</span> <span>message</span> <span>(level</span> <span class="hole">num</span><span>).</span></span></code><a class="headerlink" href="#coq:exn.tactic-failure-message-level-num" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.no-such-goal-fail">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>such</span> <span>goal.</span></span></code><a class="headerlink" href="#coq:exn.no-such-goal-fail" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk0" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk0"><span class="highlight"><span class="kn">Goal</span> <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk1" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk2" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk2"><span class="highlight"><span class="kp">fail</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">Tactic failure.</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input alectryon-failed"><span class="highlight"><span class="kn">Abort</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk3" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk3"><span class="highlight"><span class="kn">Goal</span> <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk4" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk4"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input alectryon-failed"><span class="highlight"><span class="nb">trivial</span>; <span class="kp">fail</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input alectryon-failed"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk5" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk5"><span class="highlight"><span class="kn">Goal</span> <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk6" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input alectryon-failed"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk7" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk7"><span class="highlight"><span class="kp">fail</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">No such goal.</span></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input alectryon-failed"><span class="highlight"><span class="kn">Abort</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk8" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk8"><span class="highlight"><span class="kn">Goal</span> <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk9" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input alectryon-failed"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input alectryon-failed"><span class="highlight"><span class="kp">all</span>: <span class="kp">fail</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input alectryon-failed"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chka" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chka"><span class="highlight"><span class="kn">Goal</span> <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chkb" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chkb"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chkc" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chkc"><span class="highlight"><span class="kp">gfail</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">Tactic failure.</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input alectryon-failed"><span class="highlight"><span class="kn">Abort</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chkd" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chkd"><span class="highlight"><span class="kn">Goal</span> <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chke" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chke"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chkf" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chkf"><span class="highlight"><span class="nb">trivial</span>; <span class="kp">gfail</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">Tactic failure.</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input alectryon-failed"><span class="highlight"><span class="kn">Abort</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk10" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk10"><span class="highlight"><span class="kn">Goal</span> <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk11" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk11"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input alectryon-failed"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk12" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk12"><span class="highlight"><span class="kp">gfail</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">No such goal.</span></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input alectryon-failed"><span class="highlight"><span class="kn">Abort</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk13" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk13"><span class="highlight"><span class="kn">Goal</span> <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk14" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk14"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input alectryon-failed"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk15" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ltac-rst-chk15"><span class="highlight"><span class="kp">all</span>: <span class="kp">gfail</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">Tactic failure.</span></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input alectryon-failed"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre></div></div>
</dd></dl>

</div>
<div class="section" id="timeout">
<h3>Timeout<a class="headerlink" href="#timeout" title="Permalink to this headline">¶</a></h3>
<p>We can force a tactic to stop if it has not finished after a certain
amount of time:</p>
<dl class="coq tacn">
<dt id="coq:tacn.timeout">
<code class="sig-name descname"><span class="notation"><span>timeout</span> <span class="hole">num</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacn.timeout" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> is evaluated to <code class="docutils literal notranslate"><span class="pre">v</span></code> which must be a tactic value. The tactic value
<code class="docutils literal notranslate"><span class="pre">v</span></code> is applied normally, except that it is interrupted after <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code> seconds
if it is still running. In this case the outcome is a failure.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>For the moment, timeout is based on elapsed time in seconds,
which is very machine-dependent: a script that works on a quick machine
may fail on a slow one. The converse is even possible if you combine a
timeout with some other tacticals. This tactical is hence proposed only
for convenience during debugging or other development phases, we strongly
advise you to not leave any timeout in final scripts. Note also that
this tactical isn’t available on the native Windows port of Coq.</p>
</div>
</dd></dl>

</div>
<div class="section" id="timing-a-tactic">
<h3>Timing a tactic<a class="headerlink" href="#timing-a-tactic" title="Permalink to this headline">¶</a></h3>
<p>A tactic execution can be timed:</p>
<dl class="coq tacn">
<dt id="coq:tacn.time">
<code class="sig-name descname"><span class="notation"><span>time</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacn.time" title="Permalink to this definition">¶</a></dt>
<dd><p>evaluates <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> and displays the running time of the tactic expression, whether it
fails or succeeds. In case of several successes, the time for each successive
run is displayed. Time is in seconds and is machine-dependent. The <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code>
argument is optional. When provided, it is used to identify this particular
occurrence of time.</p>
</dd></dl>

</div>
<div class="section" id="timing-a-tactic-that-evaluates-to-a-term">
<h3>Timing a tactic that evaluates to a term<a class="headerlink" href="#timing-a-tactic-that-evaluates-to-a-term" title="Permalink to this headline">¶</a></h3>
<p>Tactic expressions that produce terms can be timed with the experimental
tactic</p>
<dl class="coq tacn">
<dt id="coq:tacn.time-constr">
<code class="sig-name descname"><span class="notation"><span>time</span><span>_</span><span>constr</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacn.time-constr" title="Permalink to this definition">¶</a></dt>
<dd><p>which evaluates <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span> <span><span class="pre">()</span></span></span></code> and displays the time the tactic expression
evaluated, assuming successful evaluation. Time is in seconds and is
machine-dependent.</p>
<p>This tactic currently does not support nesting, and will report times
based on the innermost execution. This is due to the fact that it is
implemented using the following internal tactics:</p>
<dl class="coq tacn">
<dt id="coq:tacn.restart-timer">
<code class="sig-name descname"><span class="notation"><span>restart</span><span>_</span><span>timer</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code><a class="headerlink" href="#coq:tacn.restart-timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset a timer</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.finish-timing">
<code class="sig-name descname"><span class="notation"><span>finish</span><span>_</span><span>timing</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a><span>)</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code><a class="headerlink" href="#coq:tacn.finish-timing" title="Permalink to this definition">¶</a></dt>
<dd><p>Display an optionally named timer. The parenthesized string argument
is also optional, and determines the label associated with the timer
for printing.</p>
</dd></dl>

<p>By copying the definition of <a class="reference internal" href="#coq:tacn.time-constr" title="time_constr"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">time_constr</span></code></a> from the standard library,
users can achieve support for a fixed pattern of nesting by passing
different <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><code class="xref std std-token docutils literal notranslate"><span class="pre">string</span></code></a> parameters to <a class="reference internal" href="#coq:tacn.restart-timer" title="restart_timer"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">restart_timer</span></code></a> and
<a class="reference internal" href="#coq:tacn.finish-timing" title="finish_timing"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">finish_timing</span></code></a> at each level of nesting.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">time_constr1</span> tac :=
  <span class="kr">let</span> <span class="nv">eval_early</span> := <span class="kr">match goal with</span> _ =&gt; <span class="nb">restart_timer</span> <span class="s2">&quot;(depth 1)&quot;</span> <span class="kr">end</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">ret</span> := tac () <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">eval_early</span> := <span class="kr">match goal with</span> _ =&gt; <span class="nb">finish_timing</span> ( <span class="s2">&quot;Tactic evaluation&quot;</span> ) <span class="s2">&quot;(depth 1)&quot;</span> <span class="kr">end</span> <span class="kr">in</span>
  ret.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk16" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk16"><span class="highlight"><span class="kn">Goal</span> <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk17" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk17"><span class="highlight"><span class="kr">let</span> <span class="nv">v</span> := <span class="nb">time_constr</span>
       <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt;
               <span class="kr">let</span> <span class="nv">x</span> := time_constr1 <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="kp">constr</span>:(<span class="mi">10</span> * <span class="mi">10</span>)) <span class="kr">in</span>
               <span class="kr">let</span> <span class="nv">y</span> := time_constr1 <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="kp">eval</span> <span class="nb">compute</span> <span class="kr">in</span> x) <span class="kr">in</span>
               y) <span class="kr">in</span>
  <span class="nb">pose</span> v.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">Tactic evaluation (depth <span class="mi">1</span>) ran <span class="kr">for</span> <span class="mi">0</span>. secs (<span class="mi">0</span>.u,<span class="mi">0</span>.s)</span></blockquote><blockquote class="coq-response"><span class="highlight">Tactic evaluation (depth <span class="mi">1</span>) ran <span class="kr">for</span> <span class="mi">0</span>. secs (<span class="mi">0</span>.u,<span class="mi">0</span>.s)</span></blockquote><blockquote class="coq-response"><span class="highlight">Tactic evaluation ran <span class="kr">for</span> <span class="mi">0</span>. secs (<span class="mi">0</span>.u,<span class="mi">0</span>.s)</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="mi">100</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div></div>
</dd></dl>

</div>
<div class="section" id="local-definitions">
<h3>Local definitions<a class="headerlink" href="#local-definitions" title="Permalink to this headline">¶</a></h3>
<p>Local definitions can be done as follows:</p>
<dl class="coq tacn">
<dt id="coq:tacn.let">
<code class="sig-name descname"><span class="notation"><span>let</span> <span class="hole">ident<sub>1</sub></span> <span>:=</span> <span class="hole">ltac_expr<sub>1</sub></span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">ident<sub>i</sub></span> <span>:=</span> <span class="hole">ltac_expr<sub>i</sub></span></span><span class="notation-sup">*</span></span> <span>in</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacn.let" title="Permalink to this definition">¶</a></dt>
<dd><p>each <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">i</span></sub></span></span></code> is evaluated to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">i</span></sub></span></span></code>, then, <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> is evaluated
by substituting <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">i</span></sub></span></span></code> to each occurrence of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">i</span></sub></span></span></code>, for
i = 1, ..., n. There are no dependencies between the <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">i</span></sub></span></span></code> and the
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">i</span></sub></span></span></code>.</p>
<p>Local definitions can be made recursive by using <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <span><span class="pre">rec</span></span></span></code> instead of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span></span></code>.
In this latter case, the definitions are evaluated lazily so that the rec
keyword can be used also in non-recursive cases so as to avoid the eager
evaluation of local definitions.</p>
</dd></dl>

</div>
<div class="section" id="application">
<h3>Application<a class="headerlink" href="#application" title="Permalink to this headline">¶</a></h3>
<p>An application is an expression of the following form:</p>
<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span class="hole">qualid</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">tacarg</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>The reference <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> must be bound to some defined tactic definition
expecting at least as many arguments as the provided <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">tacarg</span></span></span></code>. The
expressions <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">i</span></sub></span></span></code> are evaluated to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">i</span></sub></span></span></code>, for i = 1, ..., n.</p>
</dd></dl>

</div>
<div class="section" id="function-construction">
<h3>Function construction<a class="headerlink" href="#function-construction" title="Permalink to this headline">¶</a></h3>
<p>A parameterized tactic can be built anonymously (without resorting to
local definitions) with:</p>
<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>fun</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>=&gt;</span> <span class="hole">ltac_expr</span></span></code></dt>
<dd><p>Indeed, local definitions of functions are a syntactic sugar for binding
a <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">fun</span></span></span></code> tactic to an identifier.</p>
</dd></dl>

</div>
<div class="section" id="pattern-matching-on-terms">
<h3>Pattern matching on terms<a class="headerlink" href="#pattern-matching-on-terms" title="Permalink to this headline">¶</a></h3>
<p>We can carry out pattern matching on terms with:</p>
<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>match</span> <span class="hole">ltac_expr</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-cpattern"><span class="hole">cpattern<sub>i</sub></span></a> <span>=&gt;</span> <span class="hole">ltac_expr<sub>i</sub></span></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span>end</span></span></code></dt>
<dd><p>The expression <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> is evaluated and should yield a term which is
matched against <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cpattern</span><sub><span class="pre">1</span></sub></span></span></code>. The matching is non-linear: if a
metavariable occurs more than once, it should match the same expression
every time. It is first-order except on the variables of the form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">&#64;</span></span><span><span class="pre">?id</span></span></span></code>
that occur in head position of an application. For these variables, the
matching is second-order and returns a functional term.</p>
<p>Alternatively, when a metavariable of the form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">?id</span></span></span></code> occurs under binders,
say <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">x</span><sub><span class="pre">1</span></sub></span><span><span class="pre">,</span></span> <span><span class="pre">…,</span></span> <span><span class="pre">x</span><sub><span class="pre">n</span></sub></span></span></code> and the expression matches, the
metavariable is instantiated by a term which can then be used in any
context which also binds the variables <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">x</span><sub><span class="pre">1</span></sub></span><span><span class="pre">,</span></span> <span><span class="pre">…,</span></span> <span><span class="pre">x</span><sub><span class="pre">n</span></sub></span></span></code> with
same types. This provides with a primitive form of matching under
context which does not require manipulating a functional term.</p>
<p>If the matching with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-cpattern"><span class="hole"><span class="pre">cpattern</span><sub><span class="pre">1</span></sub></span></a></span></code> succeeds, then <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span></span></code> is
evaluated into some value by substituting the pattern matching
instantiations to the metavariables. If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span></span></code> evaluates to a
tactic and the match expression is in position to be applied to a goal
(e.g. it is not bound to a variable by a <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <span><span class="pre">in</span></span></span></code>), then this tactic is
applied. If the tactic succeeds, the list of resulting subgoals is the
result of the match expression. If <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span></span></code> does not evaluate to a
tactic or if the match expression is not in position to be applied to a
goal, then the result of the evaluation of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span></span></code> is the result
of the match expression.</p>
<p>If the matching with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-cpattern"><span class="hole"><span class="pre">cpattern</span><sub><span class="pre">1</span></sub></span></a></span></code> fails, or if it succeeds but the
evaluation of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span></span></code> fails, or if the evaluation of
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span></span></code> succeeds but returns a tactic in execution position whose
execution fails, then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cpattern</span><sub><span class="pre">2</span></sub></span></span></code> is used and so on. The pattern
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">_</span></span></span></code> matches any term and shadows all remaining patterns if any. If all
clauses fail (in particular, there is no pattern <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">_</span></span></span></code>) then a
no-matching-clause error is raised.</p>
<p>Failures in subsequent tactics do not cause backtracking to select new
branches or inside the right-hand side of the selected branch even if it
has backtracking points.</p>
<dl class="coq exn">
<dt id="coq:exn.no-matching-clauses-for-match">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>matching</span> <span>clauses</span> <span>for</span> <span>match.</span></span></code><a class="headerlink" href="#coq:exn.no-matching-clauses-for-match" title="Permalink to this definition">¶</a></dt>
<dd><p>No pattern can be used and, in particular, there is no <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">_</span></span></span></code> pattern.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.argument-of-match-does-not-evaluate-to-a-term">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Argument</span> <span>of</span> <span>match</span> <span>does</span> <span>not</span> <span>evaluate</span> <span>to</span> <span>a</span> <span>term.</span></span></code><a class="headerlink" href="#coq:exn.argument-of-match-does-not-evaluate-to-a-term" title="Permalink to this definition">¶</a></dt>
<dd><p>This happens when <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> does not denote a term.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>multimatch</span> <span class="hole">ltac_expr</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-cpattern"><span class="hole">cpattern<sub>i</sub></span></a> <span>=&gt;</span> <span class="hole">ltac_expr<sub>i</sub></span></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span>end</span></span></code></dt>
<dd><p>Using multimatch instead of match will allow subsequent tactics to
backtrack into a right-hand side tactic which has backtracking points
left and trigger the selection of a new matching branch when all the
backtracking points of the right-hand side have been consumed.</p>
<p>The syntax <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">match</span></span> <span><span class="pre">…</span></span></span></code> is, in fact, a shorthand for <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">once</span></span> <span><span class="pre">multimatch</span></span> <span><span class="pre">…</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>lazymatch</span> <span class="hole">ltac_expr</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-cpattern"><span class="hole">cpattern<sub>i</sub></span></a> <span>=&gt;</span> <span class="hole">ltac_expr<sub>i</sub></span></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span>end</span></span></code></dt>
<dd><p>Using lazymatch instead of match will perform the same pattern
matching procedure but will commit to the first matching branch
rather than trying a new matching if the right-hand side fails. If
the right-hand side of the selected branch is a tactic with
backtracking points, then subsequent failures cause this tactic to
backtrack.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>context</span> <span class="hole">ident</span> <span>[</span><a class="reference internal" href="#grammar-token-cpattern"><span class="hole">cpattern</span></a><span>]</span></span></code></dt>
<dd><p>This special form of patterns matches any term with a subterm matching
cpattern. If there is a match, the optional <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> is assigned the &quot;matched
context&quot;, i.e. the initial term where the matched subterm is replaced by a
hole. The example below will show how to use such term contexts.</p>
<p>If the evaluation of the right-hand-side of a valid match fails, the next
matching subterm is tried. If no further subterm matches, the next clause
is tried. Matching subterms are considered top-bottom and from left to
right (with respect to the raw printing obtained by setting option
<a class="reference internal" href="../language/gallina-extensions.html#coq:flag.printing-all" title="Printing All"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">All</span></code></a>).</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">f</span> x :=
  <span class="kr">match</span> x <span class="kr">with</span>
    <span class="kp">context</span> f [S ?X] =&gt;
    <span class="kp">idtac</span> X;                    <span class="c">(* To display the evaluation order *)</span>
    <span class="nb">assert</span> (p := eq_refl <span class="mi">1</span> : X=<span class="mi">1</span>);    <span class="c">(* To filter the case X=1 *)</span>
    <span class="kr">let</span> <span class="nv">x</span>:= <span class="kp">context</span> f[O] <span class="kr">in</span> <span class="nb">assert</span> (x=O) <span class="c">(* To observe the context *)</span>
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk18" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk18"><span class="highlight"><span class="kn">Goal</span> <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk19" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk19"><span class="highlight">f (<span class="mi">3</span>+<span class="mi">4</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight"><span class="mi">2</span></span></blockquote><blockquote class="coq-response"><span class="highlight"><span class="mi">1</span></span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">1</span> = <span class="mi">1</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> + <span class="mi">4</span> = <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ltac-rst-chk1a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">1</span> = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">1</span> + <span class="mi">4</span> = <span class="mi">0</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk1a"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></div></small></span></pre></div></div>
</dd></dl>

</div>
<div class="section" id="pattern-matching-on-goals">
<span id="ltac-match-goal"></span><h3>Pattern matching on goals<a class="headerlink" href="#pattern-matching-on-goals" title="Permalink to this headline">¶</a></h3>
<p>We can perform pattern matching on goals using the following expression:</p>
<dl class="coq tacn">
<dt id="coq:tacn.match-goal">
<code class="sig-name descname"><span class="notation"><span>match</span> <span>goal</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span class="hole">context_hyp</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> |<span>-</span> <a class="reference internal" href="#grammar-token-cpattern"><span class="hole">cpattern</span></a> <span>=&gt;</span> <span class="hole">ltac_expr</span></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> | <span>_</span> <span>=&gt;</span> <span class="hole">ltac_expr</span> <span>end</span></span></code><a class="headerlink" href="#coq:tacn.match-goal" title="Permalink to this definition">¶</a></dt>
<dd><p>If each hypothesis pattern <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">hyp</span></span></span></code><sub>1,i</sub>, with i = 1, ..., m<sub>1</sub> is
matched (non-linear first-order unification) by a hypothesis of the
goal and if <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cpattern</span></span><span><span class="pre">_</span></span><span><span class="pre">1</span></span></span></code> is matched by the conclusion of the goal,
then <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span></span></code> is evaluated to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code> by substituting the
pattern matching to the metavariables and the real hypothesis names
bound to the possible hypothesis names occurring in the hypothesis
patterns. If <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span><sub><span class="pre">1</span></sub></span></span></code> is a tactic value, then it is applied to the
goal. If this application fails, then another combination of hypotheses
is tried with the same proof context pattern. If there is no other
combination of hypotheses then the second proof context pattern is tried
and so on. If the next to last proof context pattern fails then
the last <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code> is evaluated to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">v</span></span></span></code> is
applied. Note also that matching against subterms (using the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">context</span>
</span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">[</span></span> <a class="reference internal" href="#grammar-token-cpattern"><span class="hole"><span class="pre">cpattern</span></span></a> <span><span class="pre">]</span></span></span></code>) is available and is also subject to yielding several
matchings.</p>
<p>Failures in subsequent tactics do not cause backtracking to select new
branches or combinations of hypotheses, or inside the right-hand side of
the selected branch even if it has backtracking points.</p>
<dl class="coq exn">
<dt id="coq:exn.no-matching-clauses-for-match-goal">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>matching</span> <span>clauses</span> <span>for</span> <span>match</span> <span>goal.</span></span></code><a class="headerlink" href="#coq:exn.no-matching-clauses-for-match-goal" title="Permalink to this definition">¶</a></dt>
<dd><p>No clause succeeds, i.e. all matching patterns, if any, fail at the
application of the right-hand-side.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is important to know that each hypothesis of the goal can be matched
by at most one hypothesis pattern. The order of matching is the
following: hypothesis patterns are examined from right to left
(i.e. hyp<sub>i,m</sub><sub>i`</sub> before hyp<sub>i,1</sub>). For each
hypothesis pattern, the goal hypotheses are matched in order (newest
first), but it possible to reverse this order (oldest first)
with the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">match</span></span> <span><span class="pre">reverse</span></span> <span><span class="pre">goal</span></span> <span><span class="pre">with</span></span></span></code> variant.</p>
</div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>multimatch</span> <span>goal</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span class="hole">context_hyp</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> |<span>-</span> <a class="reference internal" href="#grammar-token-cpattern"><span class="hole">cpattern</span></a> <span>=&gt;</span> <span class="hole">ltac_expr</span></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> | <span>_</span> <span>=&gt;</span> <span class="hole">ltac_expr</span> <span>end</span></span></code></dt>
<dd><p>Using <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">multimatch</span></span></span></code> instead of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">match</span></span></span></code> will allow subsequent tactics
to backtrack into a right-hand side tactic which has backtracking points
left and trigger the selection of a new matching branch or combination of
hypotheses when all the backtracking points of the right-hand side have
been consumed.</p>
<p>The syntax <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">match</span></span> <span><span class="pre">[reverse]</span></span> <span><span class="pre">goal</span></span> <span><span class="pre">…</span></span></span></code> is, in fact, a shorthand for
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">once</span></span> <span><span class="pre">multimatch</span></span> <span><span class="pre">[reverse]</span></span> <span><span class="pre">goal</span></span> <span><span class="pre">…</span></span></span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>lazymatch</span> <span>goal</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span class="hole">context_hyp</span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> |<span>-</span> <a class="reference internal" href="#grammar-token-cpattern"><span class="hole">cpattern</span></a> <span>=&gt;</span> <span class="hole">ltac_expr</span></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> | <span>_</span> <span>=&gt;</span> <span class="hole">ltac_expr</span> <span>end</span></span></code></dt>
<dd><p>Using lazymatch instead of match will perform the same pattern matching
procedure but will commit to the first matching branch with the first
matching combination of hypotheses rather than trying a new matching if
the right-hand side fails. If the right-hand side of the selected branch
is a tactic with backtracking points, then subsequent failures cause
this tactic to backtrack.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="filling-a-term-context">
<h3>Filling a term context<a class="headerlink" href="#filling-a-term-context" title="Permalink to this headline">¶</a></h3>
<p>The following expression is not a tactic in the sense that it does not
produce subgoals but generates a term to be used in tactic expressions:</p>
<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>context</span> <span class="hole">ident</span> <span>[</span><span class="hole">ltac_expr</span><span>]</span></span></code></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> must denote a context variable bound by a context pattern of a
match expression. This expression evaluates replaces the hole of the
value of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span></span></code> by the value of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac_expr</span></span></span></code>.</p>
<dl class="coq exn">
<dt id="coq:exn.not-a-context-variable">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Not</span> <span>a</span> <span>context</span> <span>variable.</span></span></code><a class="headerlink" href="#coq:exn.not-a-context-variable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.unbound-context-identifier-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Unbound</span> <span>context</span> <span>identifier</span> <span class="hole">ident</span><span>.</span></span></code><a class="headerlink" href="#coq:exn.unbound-context-identifier-ident" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="generating-fresh-hypothesis-names">
<h3>Generating fresh hypothesis names<a class="headerlink" href="#generating-fresh-hypothesis-names" title="Permalink to this headline">¶</a></h3>
<p>Tactics sometimes have to generate new names for hypothesis. Letting the
system decide a name with the intro tactic is not so good since it is
very awkward to retrieve the name the system gave. The following
expression returns an identifier:</p>
<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>fresh</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">component</span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>It evaluates to an identifier unbound in the goal. This fresh identifier
is obtained by concatenating the value of the <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">component</span></span></span></code>s (each of them
is, either a <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span></span></code> which has to refer to a (unqualified) name, or
directly a name denoted by a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code>).</p>
<p>If the resulting name is already used, it is padded with a number so that it
becomes fresh. If no component is given, the name is a fresh derivative of
the name <code class="docutils literal notranslate"><span class="pre">H</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="computing-in-a-constr">
<h3>Computing in a constr<a class="headerlink" href="#computing-in-a-constr" title="Permalink to this headline">¶</a></h3>
<p>Evaluation of a term can be performed with:</p>
<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>eval</span> <span class="hole">redexpr</span> <span>in</span> <span class="hole">term</span></span></code></dt>
<dd><p>where <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">redexpr</span></span></span></code> is a reduction tactic among <a class="reference internal" href="tactics.html#coq:tacn.red" title="red"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">red</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.hnf" title="hnf"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">hnf</span></code></a>,
<a class="reference internal" href="tactics.html#coq:tacv.compute" title="compute"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">compute</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.cbv" title="cbv"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbv</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.lazy" title="lazy"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">lazy</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.unfold" title="unfold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unfold</span></code></a>,
<a class="reference internal" href="tactics.html#coq:tacn.fold" title="fold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fold</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.pattern" title="pattern"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pattern</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="recovering-the-type-of-a-term">
<h3>Recovering the type of a term<a class="headerlink" href="#recovering-the-type-of-a-term" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>type</span> <span>of</span> <span class="hole">term</span></span></code></dt>
<dd><p>This tactic returns the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="manipulating-untyped-terms">
<h3>Manipulating untyped terms<a class="headerlink" href="#manipulating-untyped-terms" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>uconstr</span> <span>:</span> <span class="hole">term</span></span></code></dt>
<dd><p>The terms built in <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> are well-typed by default. It may not be
appropriate for building large terms using a recursive <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> function: the
term has to be entirely type checked at each step, resulting in potentially
very slow behavior. It is possible to build untyped terms using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> with
the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">uconstr</span></span> <span><span class="pre">:</span></span> <span class="hole"><span class="pre">term</span></span></span></code> syntax.</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>type</span><span>_</span><span>term</span> <span class="hole">term</span></span></code></dt>
<dd><p>An untyped term, in <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub>, can contain references to hypotheses or to
<code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> variables containing typed or untyped terms. An untyped term can be
type checked using the function type_term whose argument is parsed as an
untyped term and returns a well-typed term which can be used in tactics.</p>
</dd></dl>

<p>Untyped terms built using <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">uconstr</span></span> <span><span class="pre">:</span></span></span></code> can also be used as arguments to the
<a class="reference internal" href="tactics.html#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> tactic. In that case the untyped term is type
checked against the conclusion of the goal, and the holes which are not solved
by the typing procedure are turned into new subgoals.</p>
</div>
<div class="section" id="counting-the-goals">
<h3>Counting the goals<a class="headerlink" href="#counting-the-goals" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>numgoals</span></span></code></dt>
<dd><p>The number of goals under focus can be recovered using the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">numgoals</span></span></span></code>
function. Combined with the guard command below, it can be used to
branch over the number of goals produced by previous tactics.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">pr_numgoals</span> := <span class="kr">let</span> <span class="nv">n</span> := <span class="kp">numgoals</span> <span class="kr">in</span> <span class="kp">idtac</span> <span class="s2">&quot;There are&quot;</span> n <span class="s2">&quot;goals&quot;</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk1b"><span class="highlight"><span class="kn">Goal</span> <span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk1c"><span class="highlight"><span class="nb">split</span>;[|<span class="nb">split</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ltac-rst-chk1d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk1d"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk1e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk1e"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk1f"><span class="highlight"><span class="kp">all</span>:pr_numgoals.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">There are <span class="mi">3</span> goals</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ltac-rst-chk20" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk20"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk21" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk21"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></div></small></span></pre></div></div>
</dd></dl>

</div>
<div class="section" id="testing-boolean-expressions">
<h3>Testing boolean expressions<a class="headerlink" href="#testing-boolean-expressions" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.guard">
<code class="sig-name descname"><span class="notation"><span>guard</span> <span class="hole">test</span></span></code><a class="headerlink" href="#coq:tacn.guard" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#coq:tacn.guard" title="guard"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">guard</span></code></a> tactic tests a boolean expression, and fails if the expression
evaluates to false. If the expression evaluates to true, it succeeds
without affecting the proof.</p>
<p>The accepted tests are simple integer comparisons.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk22" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk22"><span class="highlight"><span class="kn">Goal</span> <span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk23" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk23"><span class="highlight"><span class="nb">split</span>;[|<span class="nb">split</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ltac-rst-chk24" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk24"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk25" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk25"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk26" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk26"><span class="highlight"><span class="kp">all</span>:<span class="kr">let</span> <span class="nv">n</span>:= <span class="kp">numgoals</span> <span class="kr">in</span> <span class="kp">guard</span> n&lt;<span class="mi">4</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ltac-rst-chk27" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk27"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk28" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk28"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk29" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk29"><span class="highlight"><span class="kn">Fail</span> <span class="kp">all</span>:<span class="kr">let</span> <span class="nv">n</span>:= <span class="kp">numgoals</span> <span class="kr">in</span> <span class="kp">guard</span> n=<span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
Condition not satisfied: <span class="mi">3</span>=<span class="mi">2</span></span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ltac-rst-chk2a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk2a"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk2b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk2b"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></div></small></span></pre></div></div>
<dl class="coq exn">
<dt id="coq:exn.condition-not-satisfied">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Condition</span> <span>not</span> <span>satisfied.</span></span></code><a class="headerlink" href="#coq:exn.condition-not-satisfied" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="proving-a-subgoal-as-a-separate-lemma">
<h3>Proving a subgoal as a separate lemma<a class="headerlink" href="#proving-a-subgoal-as-a-separate-lemma" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.abstract">
<code class="sig-name descname"><span class="notation"><span>abstract</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacn.abstract" title="Permalink to this definition">¶</a></dt>
<dd><p>From the outside, <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">abstract</span></span> <span class="hole"><span class="pre">ltac_expr</span></span></span></code> is the same as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">solve</span></span> <span class="hole"><span class="pre">ltac_expr</span></span></span></code>.
Internally it saves an auxiliary lemma called <code class="docutils literal notranslate"><span class="pre">ident_subproofn</span></code> where
<code class="docutils literal notranslate"><span class="pre">ident</span></code> is the name of the current goal and <code class="docutils literal notranslate"><span class="pre">n</span></code> is chosen so that this is
a fresh name. Such an auxiliary lemma is inlined in the final proof term.</p>
<p>This tactical is useful with tactics such as <a class="reference internal" href="tactics.html#coq:tacn.omega" title="omega"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">omega</span></code></a> or
<a class="reference internal" href="tactics.html#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a> that generate huge proof terms. With that tool the user
can avoid the explosion at time of the Save command without having to cut
manually the proof in smaller lemmas.</p>
<p>It may be useful to generate lemmas minimal w.r.t. the assumptions they
depend on. This can be obtained thanks to the option below.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The abstract tactic, while very useful, still has some known
limitations, see <a class="reference external" href="https://github.com/coq/coq/issues/9146">https://github.com/coq/coq/issues/9146</a> for more
details. Thus we recommend using it caution in some
&quot;non-standard&quot; contexts. In particular, <code class="docutils literal notranslate"><span class="pre">abstract</span></code> won't
properly work when used inside quotations <code class="docutils literal notranslate"><span class="pre">ltac:(...)</span></code>, or
if used as part of typeclass resolution, it may produce wrong
terms when in universe polymorphic mode.</p>
</div>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>abstract</span> <span class="hole">ltac_expr</span> <span>using</span> <span class="hole">ident</span></span></code></dt>
<dd><p>Give explicitly the name of the auxiliary lemma.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Use this feature at your own risk; explicitly named and reused subterms
don’t play well with asynchronous proofs.</p>
</div>
</dd></dl>

<dl class="coq tacv">
<dt id="coq:tacv.transparent-abstract">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>transparent</span><span>_</span><span>abstract</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:tacv.transparent-abstract" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the subproof in a transparent lemma rather than an opaque one.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Use this feature at your own risk; building computationally relevant
terms with tactics is fragile.</p>
</div>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>transparent</span><span>_</span><span>abstract</span> <span class="hole">ltac_expr</span> <span>using</span> <span class="hole">ident</span></span></code></dt>
<dd><p>Give explicitly the name of the auxiliary transparent lemma.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Use this feature at your own risk; building computationally relevant terms
with tactics is fragile, and explicitly named and reused subterms
don’t play well with asynchronous proofs.</p>
</div>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.proof-is-not-complete-abstract">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Proof</span> <span>is</span> <span>not</span> <span>complete.</span></span></code><a class="headerlink" href="#coq:exn.proof-is-not-complete-abstract" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="tactic-toplevel-definitions">
<h2>Tactic toplevel definitions<a class="headerlink" href="#tactic-toplevel-definitions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="defining-ltac-functions">
<h3>Defining <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> functions<a class="headerlink" href="#defining-ltac-functions" title="Permalink to this headline">¶</a></h3>
<p>Basically, <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> toplevel definitions are made as follows:</p>
<dl class="coq cmd">
<dt id="coq:cmd.ltac">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Ltac</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">*</span></span> <span>:=</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:cmd.ltac" title="Permalink to this definition">¶</a></dt>
<dd><p>This defines a new <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> function that can be used in any tactic
script or new <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> toplevel definition.</p>
<p>If preceded by the keyword <code class="docutils literal notranslate"><span class="pre">Local</span></code>, the tactic definition will not be
exported outside the current module.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The preceding definition can equivalently be written:</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Ltac</span></span> <span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span><span class="pre">fun</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">=&gt;</span></span> <span class="hole"><span class="pre">ltac_expr</span></span></span></code></p>
</div>
<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Ltac</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">*</span></span></span><span class="notation-sup">*</span></span> <span>:=</span> <span class="hole">ltac_expr</span></span></code></dt>
<dd><p>This syntax allows recursive and mutual recursive function definitions.</p>
</dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Ltac</span> <span class="hole">qualid</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">*</span></span> <span>::=</span> <span class="hole">ltac_expr</span></span></code></dt>
<dd><p>This syntax <em>redefines</em> an existing user-defined tactic.</p>
<p>A previous definition of qualid must exist in the environment. The new
definition will always be used instead of the old one and it goes across
module boundaries.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="printing-ltac-tactics">
<h3>Printing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics<a class="headerlink" href="#printing-ltac-tactics" title="Permalink to this headline">¶</a></h3>
<dl class="coq cmd">
<dt id="coq:cmd.print-ltac">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Print</span> <span>Ltac</span> <span class="hole">qualid</span></span></code><a class="headerlink" href="#coq:cmd.print-ltac" title="Permalink to this definition">¶</a></dt>
<dd><p>Defined <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> functions can be displayed using this command.</p>
</dd></dl>

<dl class="coq cmd">
<dt id="coq:cmd.print-ltac-signatures">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Print</span> <span>Ltac</span> <span>Signatures</span></span></code><a class="headerlink" href="#coq:cmd.print-ltac-signatures" title="Permalink to this definition">¶</a></dt>
<dd><p>This command displays a list of all user-defined tactics, with their arguments.</p>
</dd></dl>

</div>
</div>
<div class="section" id="examples-of-using-ltac">
<span id="ltac-examples"></span><h2>Examples of using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub><a class="headerlink" href="#examples-of-using-ltac" title="Permalink to this headline">¶</a></h2>
<div class="section" id="proof-that-the-natural-numbers-have-at-least-two-elements">
<h3>Proof that the natural numbers have at least two elements<a class="headerlink" href="#proof-that-the-natural-numbers-have-at-least-two-elements" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Example: Proof that the natural numbers have at least two elements</p>
<p>The first example shows how to use pattern matching over the proof
context to prove that natural numbers have at least two
elements. This can be done as follows:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk2c" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk2c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">card_nat</span> :
  ~ <span class="kr">exists</span> <span class="nv">x</span> <span class="nv">y</span> : nat, <span class="kr">forall</span> <span class="nv">z</span>:nat, x = z \/ y = z.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ (<span class="kr">exists</span> <span class="nv">x</span> <span class="nv">y</span> : nat, <span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk2d" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk2d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ (<span class="kr">exists</span> <span class="nv">x</span> <span class="nv">y</span> : nat, <span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk2e"><span class="highlight"><span class="nb">intros</span> (x &amp; y &amp; Hz).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk2f" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk2f"><span class="highlight"><span class="nb">destruct</span> (Hz <span class="mi">0</span>), (Hz <span class="mi">1</span>), (Hz <span class="mi">2</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">2</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ltac-rst-chk30" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">2</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk30"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk31" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">2</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk31"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk32" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">2</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk32"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk33" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">2</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk33"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk34" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">2</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk34"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk35" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">2</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk35"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk36" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">2</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk36"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></div></small></span></pre></div><p>At this point, the <a class="reference internal" href="tactics.html#coq:tacn.congruence" title="congruence"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span></code></a> tactic would finish the job:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kp">all</span>: <span class="bp">congruence</span>.</span></span></span></pre></div><p>But for the purpose of the example, let's craft our own custom
tactic to solve this:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk37" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk37"><span class="highlight"><span class="kp">all</span>: <span class="kr">match goal with</span>
     | _ : ?a = ?b, _ : ?a = ?c |- _ =&gt; <span class="nb">assert</span> (b = c) <span class="bp">by</span> <span class="bp">now</span> <span class="nb">transitivity</span> a
     <span class="kr">end</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">1</span> = <span class="mi">2</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ltac-rst-chk38" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = <span class="mi">1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk38"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk39" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = <span class="mi">2</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk39"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk3a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">1</span> = <span class="mi">2</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk3a"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk3b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">1</span> = <span class="mi">2</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk3b"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk3c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = <span class="mi">2</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk3c"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk3d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = <span class="mi">1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk3d"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ltac-rst-chk3e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hz</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, x = z \/ y = z</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">1</span> = <span class="mi">2</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ltac-rst-chk3e"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kp">all</span>: <span class="bp">discriminate</span>.</span></span></span></pre></div><p>Notice that all the (very similar) cases coming from the three
eliminations (with three distinct natural numbers) are successfully
solved by a <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span></code> structure and, in particular, with only one
pattern (use of non-linear matching).</p>
</div>
</div>
<div class="section" id="proving-that-a-list-is-a-permutation-of-a-second-list">
<h3>Proving that a list is a permutation of a second list<a class="headerlink" href="#proving-that-a-list-is-a-permutation-of-a-second-list" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Example: Proving that a list is a permutation of a second list</p>
<p>Let's first define the permutation predicate:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">Sort</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">A</span> : <span class="kt">Set</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">perm</span> : list A -&gt; list A -&gt; <span class="kt">Prop</span> :=
  | perm_refl : <span class="kr">forall</span> <span class="nv">l</span>, perm l l
  | perm_cons : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">l0</span> <span class="nv">l1</span>, perm l0 l1 -&gt; perm (a :: l0) (a :: l1)
  | perm_append : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">l</span>, perm (a :: l) (l ++ a :: nil)
  | perm_trans : <span class="kr">forall</span> <span class="nv">l0</span> <span class="nv">l1</span> <span class="nv">l2</span>, perm l0 l1 -&gt; perm l1 l2 -&gt; perm l0 l2.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Sort</span>.</span></span></span></pre></div><p>Next we define an auxiliary tactic <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">perm_aux</span></span></code> which takes an
argument used to control the recursion depth. This tactic works as
follows: If the lists are identical (i.e. convertible), it
completes the proof. Otherwise, if the lists have identical heads,
it looks at their tails.  Finally, if the lists have different
heads, it rotates the first list by putting its head at the end.</p>
<p>Every time we perform a rotation, we decrement <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>. When <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>
drops down to <code class="code highlight coq docutils literal notranslate"><span class="literal number integer"><span class="pre">1</span></span></code>, we stop performing rotations and we fail.
The idea is to give the length of the list as the initial value of
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>. This way of counting the number of rotations will avoid
going back to a head that had been considered before.</p>
<p>From Section <a class="reference internal" href="#ltac-syntax"><span class="std std-ref">Syntax</span></a> we know that Ltac has a primitive
notion of integers, but they are only used as arguments for
primitive tactics and we cannot make computations with them. Thus,
instead, we use Coq's natural number type <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">nat</span></span></code>.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">perm_aux</span> n :=
  <span class="kr">match goal with</span>
  | |- (perm _ ?l ?l) =&gt; <span class="nb">apply</span> perm_refl
  | |- (perm _ (?a :: ?l1) (?a :: ?l2)) =&gt;
     <span class="kr">let</span> <span class="nv">newn</span> := <span class="kp">eval</span> <span class="nb">compute</span> <span class="kr">in</span> (length l1) <span class="kr">in</span>
         (<span class="nb">apply</span> perm_cons; perm_aux newn)
  | |- (perm ?A (?a :: ?l1) ?l2) =&gt;
     <span class="kr">match</span> <span class="kp">eval</span> <span class="nb">compute</span> <span class="kr">in</span> n <span class="kr">with</span>
     | <span class="mi">1</span> =&gt; <span class="kp">fail</span>
     | _ =&gt;
         <span class="kr">let</span> <span class="nv">l1&#39;</span> := <span class="kp">constr</span>:(l1 ++ a :: nil) <span class="kr">in</span>
         (<span class="nb">apply</span> (perm_trans A (a :: l1) l1&#39; l2);
         [ <span class="nb">apply</span> perm_append | <span class="nb">compute</span>; perm_aux (pred n) ])
     <span class="kr">end</span>
  <span class="kr">end</span>.</span></span></span></pre></div><p>The main tactic is <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">solve_perm</span></span></code>. It computes the lengths of the
two lists and uses them as arguments to call <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">perm_aux</span></span></code> if the
lengths are equal. (If they aren't, the lists cannot be
permutations of each other.)</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">solve_perm</span> :=
  <span class="kr">match goal with</span>
  | |- (perm _ ?l1 ?l2) =&gt;
     <span class="kr">match</span> <span class="kp">eval</span> <span class="nb">compute</span> <span class="kr">in</span> (length l1 = length l2) <span class="kr">with</span>
     | (?n = ?n) =&gt; perm_aux n
     <span class="kr">end</span>
  <span class="kr">end</span>.</span></span></span></pre></div><p>And now, here is how we can use the tactic <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">solve_perm</span></span></code>:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk3f" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">perm nat (<span class="mi">1</span> :: <span class="mi">2</span> :: <span class="mi">3</span> :: nil) (<span class="mi">3</span> :: <span class="mi">2</span> :: <span class="mi">1</span> :: nil)</span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight">solve_perm.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk40" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">perm nat
  (<span class="mi">0</span>
   :: <span class="mi">1</span> :: <span class="mi">2</span> :: <span class="mi">3</span> :: <span class="mi">4</span> :: <span class="mi">5</span> :: <span class="mi">6</span> :: <span class="mi">7</span> :: <span class="mi">8</span> :: <span class="mi">9</span> :: nil)
  (<span class="mi">0</span>
   :: <span class="mi">2</span> :: <span class="mi">4</span> :: <span class="mi">6</span> :: <span class="mi">8</span> :: <span class="mi">9</span> :: <span class="mi">7</span> :: <span class="mi">5</span> :: <span class="mi">3</span> :: <span class="mi">1</span> :: nil)</span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight">solve_perm.</span></span></span></pre></div></div>
</div>
<div class="section" id="deciding-intuitionistic-propositional-logic">
<h3>Deciding intuitionistic propositional logic<a class="headerlink" href="#deciding-intuitionistic-propositional-logic" title="Permalink to this headline">¶</a></h3>
<p>Pattern matching on goals allows powerful backtracking when returning tactic
values. An interesting application is the problem of deciding intuitionistic
propositional logic. Considering the contraction-free sequent calculi LJT* of
Roy Dyckhoff <a class="bibtex reference internal" href="../zebibliography.html#dyc92" id="id3">[Dyc92]</a>, it is quite natural to code such a tactic using the
tactic language as shown below.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">basic</span> :=
<span class="kr">match goal with</span>
    | |- <span class="kt">True</span> =&gt; <span class="nb">trivial</span>
    | _ : <span class="kt">False</span> |- _ =&gt; <span class="bp">contradiction</span>
    | _ : ?A |- ?A =&gt; <span class="bp">assumption</span>
<span class="kr">end</span>.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simplify</span> :=
<span class="kp">repeat</span> (<span class="nb">intros</span>;
    <span class="kr">match goal with</span>
        | H : ~ _ |- _ =&gt; <span class="nb">red</span> <span class="kr">in</span> H
        | H : _ /\ _ |- _ =&gt;
            <span class="nb">elim</span> H; <span class="kp">do</span> <span class="mi">2</span> <span class="nb">intro</span>; <span class="nb">clear</span> H
        | H : _ \/ _ |- _ =&gt;
            <span class="nb">elim</span> H; <span class="nb">intro</span>; <span class="nb">clear</span> H
        | H : ?A /\ ?B -&gt; ?C |- _ =&gt;
            <span class="nb">cut</span> (A -&gt; B -&gt; C);
                [ <span class="nb">intro</span> | <span class="nb">intros</span>; <span class="nb">apply</span> H; <span class="nb">split</span>; <span class="bp">assumption</span> ]
        | H: ?A \/ ?B -&gt; ?C |- _ =&gt;
            <span class="nb">cut</span> (B -&gt; C);
                [ <span class="nb">cut</span> (A -&gt; C);
                    [ <span class="nb">intros</span>; <span class="nb">clear</span> H
                    | <span class="nb">intro</span>; <span class="nb">apply</span> H; <span class="nb">left</span>; <span class="bp">assumption</span> ]
                | <span class="nb">intro</span>; <span class="nb">apply</span> H; <span class="nb">right</span>; <span class="bp">assumption</span> ]
        | H0 : ?A -&gt; ?B, H1 : ?A |- _ =&gt;
            <span class="nb">cut</span> B; [ <span class="nb">intro</span>; <span class="nb">clear</span> H0 | <span class="nb">apply</span> H0; <span class="bp">assumption</span> ]
        | |- _ /\ _ =&gt; <span class="nb">split</span>
        | |- ~ _ =&gt; <span class="nb">red</span>
    <span class="kr">end</span>).</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">my_tauto</span> :=
  simplify; basic ||
  <span class="kr">match goal with</span>
      | H : (?A -&gt; ?B) -&gt; ?C |- _ =&gt;
          <span class="nb">cut</span> (B -&gt; C);
              [ <span class="nb">intro</span>; <span class="nb">cut</span> (A -&gt; B);
                  [ <span class="nb">intro</span>; <span class="nb">cut</span> C;
                      [ <span class="nb">intro</span>; <span class="nb">clear</span> H | <span class="nb">apply</span> H; <span class="bp">assumption</span> ]
                  | <span class="nb">clear</span> H ]
              | <span class="nb">intro</span>; <span class="nb">apply</span> H; <span class="nb">intro</span>; <span class="bp">assumption</span> ]; my_tauto
      | H : ~ ?A -&gt; ?B |- _ =&gt;
          <span class="nb">cut</span> (<span class="kt">False</span> -&gt; B);
              [ <span class="nb">intro</span>; <span class="nb">cut</span> (A -&gt; <span class="kt">False</span>);
                  [ <span class="nb">intro</span>; <span class="nb">cut</span> B;
                      [ <span class="nb">intro</span>; <span class="nb">clear</span> H | <span class="nb">apply</span> H; <span class="bp">assumption</span> ]
                  | <span class="nb">clear</span> H ]
              | <span class="nb">intro</span>; <span class="nb">apply</span> H; <span class="nb">red</span>; <span class="nb">intro</span>; <span class="bp">assumption</span> ]; my_tauto
      | |- _ \/ _ =&gt; (<span class="nb">left</span>; my_tauto) || (<span class="nb">right</span>; my_tauto)
  <span class="kr">end</span>.</span></span></span></pre></div><p>The tactic <code class="docutils literal notranslate"><span class="pre">basic</span></code> tries to reason using simple rules involving truth, falsity
and available assumptions. The tactic <code class="docutils literal notranslate"><span class="pre">simplify</span></code> applies all the reversible
rules of Dyckhoff’s system. Finally, the tactic <code class="docutils literal notranslate"><span class="pre">my_tauto</span></code> (the main
tactic to be called) simplifies with <code class="docutils literal notranslate"><span class="pre">simplify</span></code>, tries to conclude with
<code class="docutils literal notranslate"><span class="pre">basic</span></code> and tries several paths using the backtracking rules (one of the
four Dyckhoff’s rules for the left implication to get rid of the contraction
and the right <code class="docutils literal notranslate"><span class="pre">or</span></code>).</p>
<p>Having defined <code class="docutils literal notranslate"><span class="pre">my_tauto</span></code>, we can prove tautologies like these:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk41" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk41"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">my_tauto_ex1</span> :
  <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Prop</span>, A /\ B -&gt; A \/ B.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Prop</span>, A /\ B -&gt; A \/ B</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk42" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk42"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Prop</span>, A /\ B -&gt; A \/ B</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">my_tauto.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk43" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk43"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">my_tauto_ex2</span> :
  <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Prop</span>, (~ ~ B -&gt; B) -&gt; (A -&gt; B) -&gt; ~ ~ A -&gt; B.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Prop</span>,
(~ ~ B -&gt; B) -&gt; (A -&gt; B) -&gt; ~ ~ A -&gt; B</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk44" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk44"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Prop</span>,
(~ ~ B -&gt; B) -&gt; (A -&gt; B) -&gt; ~ ~ A -&gt; B</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">my_tauto.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div></div>
<div class="section" id="deciding-type-isomorphisms">
<h3>Deciding type isomorphisms<a class="headerlink" href="#deciding-type-isomorphisms" title="Permalink to this headline">¶</a></h3>
<p>A trickier problem is to decide equalities between types modulo
isomorphisms. Here, we choose to use the isomorphisms of the simply
typed λ-calculus with Cartesian product and unit type (see, for
example, <a class="bibtex reference internal" href="../zebibliography.html#rc95" id="id4">[dC95]</a>). The axioms of this λ-calculus are given below.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Open Scope</span> type_scope.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">Iso_axioms</span>.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variables</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Set</span>.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">Com</span> : A * B = B * A.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">Ass</span> : A * (B * C) = A * B * C.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">Cur</span> : (A * B -&gt; C) = (A -&gt; B -&gt; C).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">Dis</span> : (A -&gt; B * C) = (A -&gt; B) * (A -&gt; C).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">P_unit</span> : A * unit = A.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">AR_unit</span> : (A -&gt; unit) = unit.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">AL_unit</span> : (unit -&gt; A) = A.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk45" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk45"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">Cons</span> : B = C -&gt; A * B = A * C.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Set</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">B = C -&gt; A * B = A * C</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk46" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk46"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Set</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">B = C -&gt; A * B = A * C</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intro</span> Heq; <span class="nb">rewrite</span> Heq; <span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Iso_axioms</span>.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simplify_type</span> ty :=
<span class="kr">match</span> ty <span class="kr">with</span>
    | ?A * ?B * ?C =&gt;
        <span class="nb">rewrite</span> &lt;- (Ass A B C); <span class="kp">try</span> simplify_type_eq
    | ?A * ?B -&gt; ?C =&gt;
        <span class="nb">rewrite</span> (Cur A B C); <span class="kp">try</span> simplify_type_eq
    | ?A -&gt; ?B * ?C =&gt;
        <span class="nb">rewrite</span> (Dis A B C); <span class="kp">try</span> simplify_type_eq
    | ?A * unit =&gt;
        <span class="nb">rewrite</span> (P_unit A); <span class="kp">try</span> simplify_type_eq
    | unit * ?B =&gt;
        <span class="nb">rewrite</span> (Com unit B); <span class="kp">try</span> simplify_type_eq
    | ?A -&gt; unit =&gt;
        <span class="nb">rewrite</span> (AR_unit A); <span class="kp">try</span> simplify_type_eq
    | unit -&gt; ?B =&gt;
        <span class="nb">rewrite</span> (AL_unit B); <span class="kp">try</span> simplify_type_eq
    | ?A * ?B =&gt;
        (simplify_type A; <span class="kp">try</span> simplify_type_eq) ||
        (simplify_type B; <span class="kp">try</span> simplify_type_eq)
    | ?A -&gt; ?B =&gt;
        (simplify_type A; <span class="kp">try</span> simplify_type_eq) ||
        (simplify_type B; <span class="kp">try</span> simplify_type_eq)
<span class="kr">end</span>
<span class="kr">with</span> simplify_type_eq :=
<span class="kr">match goal with</span>
    | |- ?A = ?B =&gt; <span class="kp">try</span> simplify_type A; <span class="kp">try</span> simplify_type B
<span class="kr">end</span>.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">len</span> trm :=
<span class="kr">match</span> trm <span class="kr">with</span>
    | _ * ?B =&gt; <span class="kr">let</span> <span class="nv">succ</span> := len B <span class="kr">in</span> <span class="kp">constr</span>:(S succ)
    | _ =&gt; <span class="kp">constr</span>:(<span class="mi">1</span>)
<span class="kr">end</span>.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">assoc</span> := <span class="kp">repeat</span> <span class="nb">rewrite</span> &lt;- Ass.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">solve_type_eq</span> n :=
<span class="kr">match goal with</span>
    | |- ?A = ?A =&gt; <span class="bp">reflexivity</span>
    | |- ?A * ?B = ?A * ?C =&gt;
        <span class="nb">apply</span> Cons; <span class="kr">let</span> <span class="nv">newn</span> := len B <span class="kr">in</span> solve_type_eq newn
    | |- ?A * ?B = ?C =&gt;
        <span class="kr">match</span> <span class="kp">eval</span> <span class="nb">compute</span> <span class="kr">in</span> n <span class="kr">with</span>
            | <span class="mi">1</span> =&gt; <span class="kp">fail</span>
            | _ =&gt;
                <span class="nb">pattern</span> (A * B) <span class="nb">at</span> <span class="mi">1</span>; <span class="nb">rewrite</span> Com; assoc; solve_type_eq (pred n)
        <span class="kr">end</span>
<span class="kr">end</span>.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">compare_structure</span> :=
<span class="kr">match goal with</span>
    | |- ?A = ?B =&gt;
        <span class="kr">let</span> <span class="nv">l1</span> := len A
        <span class="kr">with</span> l2 := len B <span class="kr">in</span>
            <span class="kr">match</span> <span class="kp">eval</span> <span class="nb">compute</span> <span class="kr">in</span> (l1 = l2) <span class="kr">with</span>
                | ?n = ?n =&gt; solve_type_eq n
            <span class="kr">end</span>
<span class="kr">end</span>.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">solve_iso</span> := simplify_type_eq; compare_structure.</span></span></span></pre></div><p>The tactic to judge equalities modulo this axiomatization is shown above.
The algorithm is quite simple. First types are simplified using axioms that
can be oriented (this is done by <code class="docutils literal notranslate"><span class="pre">simplify_type</span></code> and <code class="docutils literal notranslate"><span class="pre">simplify_type_eq</span></code>).
The normal forms are sequences of Cartesian products without a Cartesian product
in the left component. These normal forms are then compared modulo permutation
of the components by the tactic <code class="docutils literal notranslate"><span class="pre">compare_structure</span></code>. If they have the same
length, the tactic <code class="docutils literal notranslate"><span class="pre">solve_type_eq</span></code> attempts to prove that the types are equal.
The main tactic that puts all these components together is <code class="docutils literal notranslate"><span class="pre">solve_iso</span></code>.</p>
<p>Here are examples of what can be solved by <code class="docutils literal notranslate"><span class="pre">solve_iso</span></code>.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk47" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk47"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">solve_iso_ex1</span> :
  <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Set</span>, A * unit * B = B * (unit * A).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Set</span>, A * unit * B = B * (unit * A)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk48" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk48"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Set</span>, A * unit * B = B * (unit * A)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span>; solve_iso.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk49" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk49"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">solve_iso_ex2</span> :
  <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Set</span>,
    (A * unit -&gt; B * (C * unit)) =
    (A * unit -&gt; (C -&gt; unit) * C) * (unit -&gt; A -&gt; B).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Set</span>,
(A * unit -&gt; B * (C * unit)) =
(A * unit -&gt; (C -&gt; unit) * C) * (unit -&gt; A -&gt; B)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk4a" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk4a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Set</span>,
(A * unit -&gt; B * (C * unit)) =
(A * unit -&gt; (C -&gt; unit) * C) * (unit -&gt; A -&gt; B)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span>; solve_iso.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div></div>
</div>
<div class="section" id="debugging-ltac-tactics">
<h2>Debugging <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics<a class="headerlink" href="#debugging-ltac-tactics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="backtraces">
<h3>Backtraces<a class="headerlink" href="#backtraces" title="Permalink to this headline">¶</a></h3>
<dl class="coq flag">
<dt id="coq:flag.ltac-backtrace">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Ltac</span> <span>Backtrace</span></span></code><a class="headerlink" href="#coq:flag.ltac-backtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Setting this flag displays a backtrace on Ltac failures that can be useful
to find out what went wrong. It is disabled by default for performance
reasons.</p>
</dd></dl>

</div>
<div class="section" id="info-trace">
<h3>Info trace<a class="headerlink" href="#info-trace" title="Permalink to this headline">¶</a></h3>
<dl class="coq cmd">
<dt id="coq:cmd.info">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Info</span> <span class="hole">num</span> <span class="hole">ltac_expr</span></span></code><a class="headerlink" href="#coq:cmd.info" title="Permalink to this definition">¶</a></dt>
<dd><p>This command can be used to print the trace of the path eventually taken by an
<code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> script. That is, the list of executed tactics, discarding
all the branches which have failed. To that end the <a class="reference internal" href="#coq:cmd.info" title="Info"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Info</span></code></a> command can be
used with the following syntax.</p>
<p>The number <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">num</span></span></span></code> is the unfolding level of tactics in the trace. At level
0, the trace contains a sequence of tactics in the actual script, at level 1,
the trace will be the concatenation of the traces of these tactics, etc…</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">t</span> x := <span class="kr">exists</span> <span class="nv">x</span>; <span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk4b" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk4b"><span class="highlight"><span class="kn">Goal</span> <span class="kr">exists</span> <span class="nv">n</span>, n=<span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">n</span> : nat, n = <span class="mi">0</span></span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk4c" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk4c"><span class="highlight"><span class="kn">Info</span> <span class="mi">0</span> t <span class="mi">1</span>||t <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight"><span class="kr">exists</span>  <span class="nv">with</span> <span class="mi">0</span>;&lt;ltac_plugin::<span class="bp">reflexivity</span>@<span class="mi">0</span>&gt;</span></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk4d" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk4d"><span class="highlight"><span class="kn">Undo</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">n</span> : nat, n = <span class="mi">0</span></span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk4e" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk4e"><span class="highlight"><span class="kn">Info</span> <span class="mi">1</span> t <span class="mi">1</span>||t <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">&lt;ltac_plugin::<span class="kr">exists</span>@<span class="mi">1</span>&gt;  <span class="kr">with</span>
 <span class="mi">0</span>;<span class="nb">simple refine</span> ?X12;&lt;unknown&gt;</span></blockquote></div></div></small></span></pre></div></div>
<p>The trace produced by <a class="reference internal" href="#coq:cmd.info" title="Info"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Info</span></code></a> tries its best to be a reparsable
<code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> script, but this goal is not achievable in all generality.
So some of the output traces will contain oddities.</p>
<p>As an additional help for debugging, the trace produced by <a class="reference internal" href="#coq:cmd.info" title="Info"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Info</span></code></a> contains
(in comments) the messages produced by the <a class="reference internal" href="#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a> tactical at the right
position in the script. In particular, the calls to idtac in branches which failed are
not printed.</p>
<dl class="coq opt">
<dt id="coq:opt.info-level">
<em class="property"><span class="sigannot">Option</span></em> <code class="sig-name descname"><span class="notation"><span>Info</span> <span>Level</span> <span class="hole">num</span></span></code><a class="headerlink" href="#coq:opt.info-level" title="Permalink to this definition">¶</a></dt>
<dd><p>This option is an alternative to the <a class="reference internal" href="#coq:cmd.info" title="Info"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Info</span></code></a> command.</p>
<p>This will automatically print the same trace as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Info</span></span> <span class="hole"><span class="pre">num</span></span></span></code> at each
tactic call. The unfolding level can be overridden by a call to the
<a class="reference internal" href="#coq:cmd.info" title="Info"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Info</span></code></a> command.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="interactive-debugger">
<h3>Interactive debugger<a class="headerlink" href="#interactive-debugger" title="Permalink to this headline">¶</a></h3>
<dl class="coq flag">
<dt id="coq:flag.ltac-debug">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Ltac</span> <span>Debug</span></span></code><a class="headerlink" href="#coq:flag.ltac-debug" title="Permalink to this definition">¶</a></dt>
<dd><p>This option governs the step-by-step debugger that comes with the <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> interpreter.</p>
</dd></dl>

<p>When the debugger is activated, it stops at every step of the evaluation of
the current <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> expression and prints information on what it is doing.
The debugger stops, prompting for a command which can be one of the
following:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 73%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>simple newline:</p></td>
<td><p>go to the next step</p></td>
</tr>
<tr class="row-even"><td><p>h:</p></td>
<td><p>get help</p></td>
</tr>
<tr class="row-odd"><td><p>x:</p></td>
<td><p>exit current evaluation</p></td>
</tr>
<tr class="row-even"><td><p>s:</p></td>
<td><p>continue current evaluation without stopping</p></td>
</tr>
<tr class="row-odd"><td><p>r n:</p></td>
<td><p>advance n steps further</p></td>
</tr>
<tr class="row-even"><td><p>r string:</p></td>
<td><p>advance up to the next call to “idtac string”</p></td>
</tr>
</tbody>
</table>
<dl class="coq exn">
<dt id="coq:exn.debug-mode-not-available-in-the-ide">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Debug</span> <span>mode</span> <span>not</span> <span>available</span> <span>in</span> <span>the</span> <span>IDE</span></span></code><a class="headerlink" href="#coq:exn.debug-mode-not-available-in-the-ide" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>A non-interactive mode for the debugger is available via the option:</p>
<dl class="coq flag">
<dt id="coq:flag.ltac-batch-debug">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Ltac</span> <span>Batch</span> <span>Debug</span></span></code><a class="headerlink" href="#coq:flag.ltac-batch-debug" title="Permalink to this definition">¶</a></dt>
<dd><p>This option has the effect of presenting a newline at every prompt, when
the debugger is on. The debug log thus created, which does not require
user input to generate when this option is set, can then be run through
external tools such as diff.</p>
</dd></dl>

</div>
<div class="section" id="profiling-ltac-tactics">
<h3>Profiling <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics<a class="headerlink" href="#profiling-ltac-tactics" title="Permalink to this headline">¶</a></h3>
<p>It is possible to measure the time spent in invocations of primitive
tactics as well as tactics defined in <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> and their inner
invocations. The primary use is the development of complex tactics,
which can sometimes be so slow as to impede interactive usage. The
reasons for the performance degradation can be intricate, like a slowly
performing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> match or a sub-tactic whose performance only
degrades in certain situations. The profiler generates a call tree and
indicates the time spent in a tactic depending on its calling context. Thus
it allows to locate the part of a tactic definition that contains the
performance issue.</p>
<dl class="coq flag">
<dt id="coq:flag.ltac-profiling">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Ltac</span> <span>Profiling</span></span></code><a class="headerlink" href="#coq:flag.ltac-profiling" title="Permalink to this definition">¶</a></dt>
<dd><p>This option enables and disables the profiler.</p>
</dd></dl>

<dl class="coq cmd">
<dt id="coq:cmd.show-ltac-profile">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Show</span> <span>Ltac</span> <span>Profile</span></span></code><a class="headerlink" href="#coq:cmd.show-ltac-profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the profile</p>
<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Show</span> <span>Ltac</span> <span>Profile</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code></dt>
<dd><p>Prints a profile for all tactics that start with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code>. Append a period
(.) to the string if you only want exactly that name.</p>
</dd></dl>

</dd></dl>

<dl class="coq cmd">
<dt id="coq:cmd.reset-ltac-profile">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Reset</span> <span>Ltac</span> <span>Profile</span></span></code><a class="headerlink" href="#coq:cmd.reset-ltac-profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the profile, that is, deletes all accumulated information.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Backtracking across a <a class="reference internal" href="#coq:cmd.reset-ltac-profile" title="Reset Ltac Profile"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Reset</span> <span class="pre">Ltac</span> <span class="pre">Profile</span></code></a> will not restore the information.</p>
</div>
</dd></dl>

<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Coq.<span class="bp">omega</span>.Omega.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">mytauto</span> := <span class="bp">tauto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">tac</span> := <span class="nb">intros</span>; <span class="kp">repeat</span> <span class="nb">split</span>; <span class="bp">omega</span> || mytauto.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">max</span> x y := (x + (y - x)) (<span class="kn">only parsing</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk4f" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk4f"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> <span class="nv">E</span> <span class="nv">F</span> <span class="nv">G</span> <span class="nv">H</span> <span class="nv">I</span> <span class="nv">J</span> <span class="nv">K</span> <span class="nv">L</span> <span class="nv">M</span> <span class="nv">N</span> <span class="nv">O</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> <span class="nv">S</span> <span class="nv">T</span> <span class="nv">U</span> <span class="nv">V</span> <span class="nv">W</span> <span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>,
    max x (max y z) = max (max x y) z /\ max x (max y z) = max (max x y) z
    /\
    (A /\ B /\ C /\ D /\ E /\ F /\ G /\ H /\ I /\ J /\ K /\ L /\ M /\
     N /\ O /\ P /\ Q /\ R /\ S /\ T /\ U /\ V /\ W /\ X /\ Y /\ Z
     -&gt;
     Z /\ Y /\ X /\ W /\ V /\ U /\ T /\ S /\ R /\ Q /\ P /\ O /\ N /\
     M /\ L /\ K /\ J /\ I /\ H /\ G /\ F /\ E /\ D /\ C /\ B /\ A).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : nat)
  (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> <span class="nv">E</span> <span class="nv">F</span> <span class="nv">G</span> <span class="nv">H</span> <span class="nv">I</span> <span class="nv">J</span> <span class="nv">K</span> <span class="nv">L</span> <span class="nv">M</span> <span class="nv">N</span> <span class="nv">O</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> <span class="nv">S</span> <span class="nv">T</span> <span class="nv">U</span> <span class="nv">V</span> <span class="nv">W</span> <span class="nv">X</span> <span class="nv">Y</span>
   <span class="nv">Z</span> : <span class="kt">Prop</span>),
x + (y + (z - y) - x) =
x + (y - x) + (z - (x + (y - x))) /\
x + (y + (z - y) - x) =
x + (y - x) + (z - (x + (y - x))) /\
(A /\
 B /\
 C /\
 D /\
 E /\
 F /\
 G /\
 H /\
 I /\
 J /\
 K /\
 L /\
 M /\ N /\ O /\ P /\ Q /\ R /\ S /\ T /\ U /\ V /\ ... -&gt;
 Z /\
 Y /\
 X /\
 W /\
 V /\
 U /\
 T /\
 S /\
 R /\
 Q /\
 P /\
 O /\
 N /\ M /\ L /\ K /\ J /\ I /\ H /\ G /\ F /\ E /\ ...)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="ltac-rst-chk50" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk50"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : nat)
  (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> <span class="nv">E</span> <span class="nv">F</span> <span class="nv">G</span> <span class="nv">H</span> <span class="nv">I</span> <span class="nv">J</span> <span class="nv">K</span> <span class="nv">L</span> <span class="nv">M</span> <span class="nv">N</span> <span class="nv">O</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> <span class="nv">S</span> <span class="nv">T</span> <span class="nv">U</span> <span class="nv">V</span> <span class="nv">W</span> <span class="nv">X</span> <span class="nv">Y</span>
   <span class="nv">Z</span> : <span class="kt">Prop</span>),
x + (y + (z - y) - x) =
x + (y - x) + (z - (x + (y - x))) /\
x + (y + (z - y) - x) =
x + (y - x) + (z - (x + (y - x))) /\
(A /\
 B /\
 C /\
 D /\
 E /\
 F /\
 G /\
 H /\
 I /\
 J /\
 K /\
 L /\
 M /\ N /\ O /\ P /\ Q /\ R /\ S /\ T /\ U /\ V /\ ... -&gt;
 Z /\
 Y /\
 X /\
 W /\
 V /\
 U /\
 T /\
 S /\
 R /\
 Q /\
 P /\
 O /\
 N /\ M /\ L /\ K /\ J /\ I /\ H /\ G /\ F /\ E /\ ...)</span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk51" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk51"><span class="highlight"><span class="kn">Set Ltac Profiling</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : nat)
  (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> <span class="nv">E</span> <span class="nv">F</span> <span class="nv">G</span> <span class="nv">H</span> <span class="nv">I</span> <span class="nv">J</span> <span class="nv">K</span> <span class="nv">L</span> <span class="nv">M</span> <span class="nv">N</span> <span class="nv">O</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> <span class="nv">S</span> <span class="nv">T</span> <span class="nv">U</span> <span class="nv">V</span> <span class="nv">W</span> <span class="nv">X</span> <span class="nv">Y</span>
   <span class="nv">Z</span> : <span class="kt">Prop</span>),
x + (y + (z - y) - x) =
x + (y - x) + (z - (x + (y - x))) /\
x + (y + (z - y) - x) =
x + (y - x) + (z - (x + (y - x))) /\
(A /\
 B /\
 C /\
 D /\
 E /\
 F /\
 G /\
 H /\
 I /\
 J /\
 K /\
 L /\
 M /\ N /\ O /\ P /\ Q /\ R /\ S /\ T /\ U /\ V /\ ... -&gt;
 Z /\
 Y /\
 X /\
 W /\
 V /\
 U /\
 T /\
 S /\
 R /\
 Q /\
 P /\
 O /\
 N /\ M /\ L /\ K /\ J /\ I /\ H /\ G /\ F /\ E /\ ...)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ltac-rst-chk52" style="display: none" type="checkbox"><label class="coq-input" for="ltac-rst-chk52"><span class="highlight">tac.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">Anomaly
<span class="s2">&quot;&quot;</span>Assert_failure sertop/sertop_util.ml:<span class="mi">189</span>:<span class="mi">26</span><span class="s2">&quot;.&quot;</span>
Please report <span class="nb">at</span> http://coq.inria.fr/bugs/.</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Show Ltac Profile</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Show Ltac Profile</span> <span class="s2">&quot;omega&quot;</span>.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Unset Ltac Profiling</span>.</span></span></span></pre></div><dl class="coq tacn">
<dt id="coq:tacn.start-ltac-profiling">
<code class="sig-name descname"><span class="notation"><span>start</span> <span>ltac</span> <span>profiling</span></span></code><a class="headerlink" href="#coq:tacn.start-ltac-profiling" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves like <a class="reference internal" href="#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a> but enables the profiler.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.stop-ltac-profiling">
<code class="sig-name descname"><span class="notation"><span>stop</span> <span>ltac</span> <span>profiling</span></span></code><a class="headerlink" href="#coq:tacn.stop-ltac-profiling" title="Permalink to this definition">¶</a></dt>
<dd><p>Similarly to <a class="reference internal" href="#coq:tacn.start-ltac-profiling" title="start ltac profiling"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">start</span> <span class="pre">ltac</span> <span class="pre">profiling</span></code></a>, this tactic behaves like
<a class="reference internal" href="#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a>. Together, they allow you to exclude parts of a proof script
from profiling.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.reset-ltac-profile">
<code class="sig-name descname"><span class="notation"><span>reset</span> <span>ltac</span> <span>profile</span></span></code><a class="headerlink" href="#coq:tacn.reset-ltac-profile" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves like the corresponding vernacular command
and allow displaying and resetting the profile from tactic scripts for
benchmarking purposes.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.show-ltac-profile">
<code class="sig-name descname"><span class="notation"><span>show</span> <span>ltac</span> <span>profile</span></span></code><a class="headerlink" href="#coq:tacn.show-ltac-profile" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves like the corresponding vernacular command
and allow displaying and resetting the profile from tactic scripts for
benchmarking purposes.</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>show</span> <span>ltac</span> <span>profile</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code></dt>
<dd><p>This tactic behaves like the corresponding vernacular command
and allow displaying and resetting the profile from tactic scripts for
benchmarking purposes.</p>
</dd></dl>

<p>You can also pass the <code class="docutils literal notranslate"><span class="pre">-profile-ltac</span></code> command line option to <code class="docutils literal notranslate"><span class="pre">coqc</span></code>, which
turns the <a class="reference internal" href="#coq:flag.ltac-profiling" title="Ltac Profiling"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Ltac</span> <span class="pre">Profiling</span></code></a> option on at the beginning of each document,
and performs a <a class="reference internal" href="#coq:cmd.show-ltac-profile" title="Show Ltac Profile"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Show</span> <span class="pre">Ltac</span> <span class="pre">Profile</span></code></a> at the end.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that the profiler currently does not handle backtracking into
multi-success tactics, and issues a warning to this effect in many cases
when such backtracking occurs.</p>
</div>
</div>
<div class="section" id="run-time-optimization-tactic">
<h3>Run-time optimization tactic<a class="headerlink" href="#run-time-optimization-tactic" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.optimize-heap">
<code class="sig-name descname"><span class="notation"><span>optimize</span><span>_</span><span>heap</span></span></code><a class="headerlink" href="#coq:tacn.optimize-heap" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">idtac</span></span></span></code>, except that running it compacts the
heap in the OCaml run-time system. It is analogous to the Vernacular
command <a class="reference internal" href="proof-handling.html#coq:cmd.optimize-heap" title="Optimize Heap"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Optimize</span> <span class="pre">Heap</span></code></a>.</p>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="detailed-tactic-examples.html" class="btn btn-neutral float-right" title="Detailed examples of tactics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="tactics.html" class="btn btn-neutral float-left" title="Tactics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>