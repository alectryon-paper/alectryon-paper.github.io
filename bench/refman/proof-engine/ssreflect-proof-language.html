

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The SSReflect proof language &mdash; Coq 8.10.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/notations.js"></script>
        <script src="../_static/alectryon.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
  <link rel="stylesheet" href="../_static/alectryon.css" type="text/css" />
  <link rel="stylesheet" href="../_static/tango_subtle.css" type="text/css" />
  <link rel="stylesheet" href="../_static/tango_subtle.min.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Syntax extensions and interpretation scopes" href="../user-extensions/syntax-extensions.html" />
    <link rel="prev" title="Detailed examples of tactics" href="detailed-tactic-examples.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.10.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Indexes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">Preamble</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction and Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">Early history of Coq</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../history.html#historical-roots">Historical roots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-1-to-5">Versions 1 to 5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-1">Version 1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-2">Version 2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-3">Version 3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-4">Version 4</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-5">Version 5</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-6">Versions 6</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-1">Version 6.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-2">Version 6.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-3">Version 6.3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-7">Versions 7</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-0-and-7-1">Details of changes in 7.0 and 7.1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#main-novelties">Main novelties</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-2">Details of changes in 7.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-3">Details of changes in 7.3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#changes-in-7-3-1">Changes in 7.3.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-4">Details of changes in 7.4</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changes.html">Recent changes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-10">Version 8.10</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#other-changes-in-8-10-beta1">Other changes in 8.10+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-beta2">Changes in 8.10+beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-beta3">Changes in 8.10+beta3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-0">Changes in 8.10.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-1">Changes in 8.10.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-2">Changes in 8.10.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-9">Version 8.9</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id147">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-9-beta1">Details of changes in 8.9+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-8-0">Changes in 8.8.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-8-1">Changes in 8.8.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-8">Version 8.8</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id149">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-beta1">Details of changes in 8.8+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-0">Details of changes in 8.8.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-1">Details of changes in 8.8.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-2">Details of changes in 8.8.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-7">Version 8.7</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id150">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#potential-compatibility-issues">Potential compatibility issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta1">Details of changes in 8.7+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta2">Details of changes in 8.7+beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-0">Details of changes in 8.7.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-1">Details of changes in 8.7.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-2">Details of changes in 8.7.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-6">Version 8.6</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id151">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#potential-sources-of-incompatibilities">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6beta1">Details of changes in 8.6beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6">Details of changes in 8.6</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6-1">Details of changes in 8.6.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-5">Version 8.5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id152">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id153">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta1">Details of changes in 8.5beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta2">Details of changes in 8.5beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta3">Details of changes in 8.5beta3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5">Details of changes in 8.5</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl1">Details of changes in 8.5pl1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl2">Details of changes in 8.5pl2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl3">Details of changes in 8.5pl3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-4">Version 8.4</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id154">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id156">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta">Details of changes in 8.4beta</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta2">Details of changes in 8.4beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4">Details of changes in 8.4</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-3">Version 8.3</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id157">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-2">Version 8.2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id158">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id159">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-1">Version 8.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id160">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1beta">Details of changes in 8.1beta</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1gamma">Details of changes in 8.1gamma</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1">Details of changes in 8.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-0">Version 8.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id161">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-old-syntax">Details of changes in 8.0beta old syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-new-syntax">Details of changes in 8.0beta new syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0">Details of changes in 8.0</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">The language</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-specification-language.html">The Gallina specification language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#about-the-grammars-in-the-manual">About the grammars in the manual</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#lexical-conventions">Lexical conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#terms">Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#syntax-of-terms">Syntax of terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#types">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#qualified-identifiers-and-simple-identifiers">Qualified identifiers and simple identifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#numerals">Numerals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#binders">Binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#abstractions">Abstractions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#products">Products</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#applications">Applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#type-cast">Type cast</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#inferable-subterms">Inferable subterms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#let-in-definitions">Let-in definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#definition-by-case-analysis">Definition by case analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#recursive-functions">Recursive functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-specification-language.html#the-vernacular">The Vernacular</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#assumptions">Assumptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#inductive-definitions">Inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#simple-inductive-types">Simple inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#simple-annotated-inductive-types">Simple annotated inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#parameterized-inductive-types">Parameterized inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#variants">Variants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#mutually-defined-inductive-types">Mutually defined inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#co-inductive-types">Co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#definition-of-recursive-functions">Definition of recursive functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#definition-of-functions-by-recursion-over-inductive-objects">Definition of functions by recursion over inductive objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-specification-language.html#definitions-of-recursive-objects-in-co-inductive-types">Definitions of recursive objects in co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#assertions-and-proofs">Assertions and proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-specification-language.html#attributes">Attributes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#record-types">Record types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#primitive-projections">Primitive Projections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#primitive-record-types">Primitive Record Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#compatibility-projections-and-match">Compatibility Projections and <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">match</span></span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#variants-and-extensions-of-match">Variants and extensions of <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">match</span></span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#multiple-and-nested-pattern-matching">Multiple and nested pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#pattern-matching-on-boolean-values-the-if-expression">Pattern-matching on boolean values: the if expression</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#irrefutable-patterns-the-destructuring-let-variants">Irrefutable patterns: the destructuring let variants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#first-destructuring-let-syntax">First destructuring let syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#second-destructuring-let-syntax">Second destructuring let syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-pretty-printing-of-match-expressions">Controlling pretty-printing of match expressions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-nested-patterns">Printing nested patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#factorization-of-clauses-with-same-right-hand-side">Factorization of clauses with same right-hand side</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#use-of-a-default-clause">Use of a default clause</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-of-wildcard-patterns">Printing of wildcard patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-of-the-elimination-predicate">Printing of the elimination predicate</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-matching-on-irrefutable-patterns">Printing matching on irrefutable patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#printing-matching-on-booleans">Printing matching on booleans</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions">Advanced recursive functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#section-mechanism">Section mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#module-system">Module system</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#reserved-commands-inside-an-interactive-module">Reserved commands inside an interactive module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#reserved-commands-inside-an-interactive-module-type">Reserved commands inside an interactive module type:</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#libraries-and-qualified-names">Libraries and qualified names</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#names-of-libraries">Names of libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#qualified-names">Qualified names</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#libraries-and-filesystem">Libraries and filesystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#implicit-arguments">Implicit arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#the-different-kinds-of-implicit-arguments">The different kinds of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function">Implicit arguments inferable from the knowledge of other arguments of a function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#implicit-arguments-inferable-by-resolution">Implicit arguments inferable by resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#maximal-or-non-maximal-insertion-of-implicit-arguments">Maximal or non maximal insertion of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#casual-use-of-implicit-arguments">Casual use of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#declaration-of-implicit-arguments">Declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#implicit-argument-binders">Implicit Argument Binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/gallina-extensions.html#declaring-implicit-arguments">Declaring Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#automatic-declaration-of-implicit-arguments">Automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#mode-for-automatic-declaration-of-implicit-arguments">Mode for automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-strict-implicit-arguments">Controlling strict implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-contextual-implicit-arguments">Controlling contextual implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-reversible-pattern-implicit-arguments">Controlling reversible-pattern implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments">Controlling the insertion of implicit arguments not followed by explicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#explicit-applications">Explicit applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#renaming-implicit-arguments">Renaming implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#displaying-what-the-implicit-arguments-are">Displaying what the implicit arguments are</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#explicit-displaying-of-implicit-arguments-for-pretty-printing">Explicit displaying of implicit arguments for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#interaction-with-subtyping">Interaction with subtyping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#deactivation-of-implicit-arguments-for-parsing">Deactivation of implicit arguments for parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#canonical-structures">Canonical structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#implicit-types-of-variables">Implicit types of variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#implicit-generalization">Implicit generalization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#coercions">Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#printing-constructions-in-full">Printing constructions in full</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#printing-universes">Printing universes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#existential-variables">Existential variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#explicit-displaying-of-existential-instances-for-pretty-printing">Explicit displaying of existential instances for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/gallina-extensions.html#solving-existential-variables-using-tactics">Solving existential variables using tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/gallina-extensions.html#primitive-integers">Primitive Integers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/coq-library.html">The <span class="smallcaps">Coq</span> library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html#the-basic-library">The basic library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#notations">Notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#logic">Logic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#propositional-connectives">Propositional Connectives</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#quantifiers">Quantifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#equality">Equality</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#lemmas">Lemmas</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#datatypes">Datatypes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#programming">Programming</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#specification">Specification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#basic-arithmetics">Basic Arithmetics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#well-founded-recursion">Well-founded recursion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#accessing-the-type-level">Accessing the Type level</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#tactics">Tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html#the-standard-library">The standard library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#survey">Survey</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#peanos-arithmetic-nat">Peano’s arithmetic (nat)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#notations-for-integer-arithmetics">Notations for integer arithmetics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#real-numbers-library">Real numbers library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#notations-for-real-numbers">Notations for real numbers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#some-tactics-for-real-numbers">Some tactics for real numbers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#list-library">List library</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html#users-contributions">Users’ contributions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/cic.html">Calculus of Inductive Constructions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#the-terms">The terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#terms">Terms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#typing-rules">Typing rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#conversion-rules">Conversion rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#reduction">β-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#iota-reduction">ι-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#delta-reduction">δ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#zeta-reduction">ζ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#expansion">η-expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#proof-irrelevance">Proof Irrelevance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#convertibility">Convertibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#subtyping-rules">Subtyping rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#inductive-definitions">Inductive Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#types-of-inductive-objects">Types of inductive objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#well-formed-inductive-definitions">Well-formed inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#arity-of-a-given-sort">Arity of a given sort</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#arity">Arity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#type-of-constructor">Type of constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#positivity-condition">Positivity Condition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#strict-positivity">Strict positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#nested-positivity">Nested Positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#correctness-rules">Correctness rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#template-polymorphism">Template polymorphism</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#destructors">Destructors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#the-match-with-end-construction">The match ... with ... end construction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#fixpoint-definitions">Fixpoint definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#id29">Typing rule</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/cic.html#reduction-rule">Reduction rule</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#admissible-rules-for-global-environments">Admissible rules for global environments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#co-inductive-types">Co-inductive types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html#the-calculus-of-inductive-constructions-with-impredicative-set">The Calculus of Inductive Constructions with impredicative Set</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/module-system.html">The Module System</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/module-system.html#modules-and-module-types">Modules and module types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/module-system.html#typing-modules">Typing Modules</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">The proof engine</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="vernacular-commands.html">Vernacular commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#displaying">Displaying</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#flags-options-and-tables">Flags, Options and Tables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#scope-qualifiers-for-set-and-unset">Scope qualifiers for <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Set</span></code> and <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Unset</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#requests-to-the-environment">Requests to the environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#printing-flags">Printing flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#loading-files">Loading files</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#compiled-files">Compiled files</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#loadpath">Loadpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#backtracking">Backtracking</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#quitting-and-debugging">Quitting and debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#controlling-display">Controlling display</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#controlling-the-reduction-strategies-and-the-conversion-algorithm">Controlling the reduction strategies and the conversion algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#controlling-the-locality-of-commands">Controlling the locality of commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html#internal-registration-commands">Internal registration commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#exposing-constants-to-ocaml-libraries">Exposing constants to OCaml libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#inlining-hints-for-the-fast-reduction-machines">Inlining hints for the fast reduction machines</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#registering-primitive-operations">Registering primitive operations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="proof-handling.html">Proof handling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#switching-on-off-the-proof-editing-mode">Switching on/off the proof editing mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#proof-using-options">Proof using options</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#name-a-set-of-section-hypotheses-for-proof-using">Name a set of section hypotheses for <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#navigation-in-the-proof-tree">Navigation in the proof tree</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#bullets">Bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#set-bullet-behavior">Set Bullet Behavior</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#requesting-information">Requesting information</a></li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#showing-differences-between-proof-steps">Showing differences between proof steps</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#how-to-enable-diffs">How to enable diffs</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-handling.html#how-diffs-are-calculated">How diffs are calculated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#controlling-the-effect-of-proof-editing-commands">Controlling the effect of proof editing commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="proof-handling.html#controlling-memory-usage">Controlling memory usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">Tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#common-elements-of-tactics">Common elements of tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#invocation-of-tactics">Invocation of tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#bindings-list">Bindings list</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#occurrence-sets-and-occurrence-clauses">Occurrence sets and occurrence clauses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#applying-theorems">Applying theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#managing-the-local-context">Managing the local context</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#controlling-the-proof-flow">Controlling the proof flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#case-analysis-and-induction">Case analysis and induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#rewriting-expressions">Rewriting expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#performing-computations">Performing computations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#conversion-tactics-applied-to-hypotheses">Conversion tactics applied to hypotheses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#automation">Automation</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#controlling-automation">Controlling automation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#the-hints-databases-for-auto-and-eauto">The hints databases for auto and eauto</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tactics.html#creating-hint-databases">Creating Hint databases</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#hint-databases-defined-in-the-coq-standard-library">Hint databases defined in the Coq standard library</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#hint-locality">Hint locality</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#setting-implicit-automation-tactics">Setting implicit automation tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#decision-procedures">Decision procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#checking-properties-of-terms">Checking properties of terms</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#equality">Equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#equality-and-inductive-sets">Equality and inductive sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#inversion">Inversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#classical-tactics">Classical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#automating">Automating</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#non-logical-tactics">Non-logical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#delaying-solving-unification-constraints">Delaying solving unification constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#proof-maintenance">Proof maintenance</a></li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html#performance-oriented-tactic-variants">Performance-oriented tactic variants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ltac.html">The tactic language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ltac.html#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="ltac.html#semantics">Semantics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#sequence">Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#local-application-of-tactics">Local application of tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#goal-selectors">Goal selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#for-loop">For loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#repeat-loop">Repeat loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#error-catching">Error catching</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#detecting-progress">Detecting progress</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#backtracking-branching">Backtracking branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#first-tactic-to-work">First tactic to work</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#left-biased-branching">Left-biased branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#generalized-biased-branching">Generalized biased branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#soft-cut">Soft cut</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#checking-the-successes">Checking the successes</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#checking-the-failure">Checking the failure</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#checking-the-success">Checking the success</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#solving">Solving</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#identity">Identity</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#failing">Failing</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#timeout">Timeout</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#timing-a-tactic">Timing a tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#timing-a-tactic-that-evaluates-to-a-term">Timing a tactic that evaluates to a term</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#local-definitions">Local definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#application">Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#function-construction">Function construction</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#pattern-matching-on-terms">Pattern matching on terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#pattern-matching-on-goals">Pattern matching on goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#filling-a-term-context">Filling a term context</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#generating-fresh-hypothesis-names">Generating fresh hypothesis names</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#computing-in-a-constr">Computing in a constr</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#recovering-the-type-of-a-term">Recovering the type of a term</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#manipulating-untyped-terms">Manipulating untyped terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#counting-the-goals">Counting the goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#testing-boolean-expressions">Testing boolean expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#proving-a-subgoal-as-a-separate-lemma">Proving a subgoal as a separate lemma</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ltac.html#tactic-toplevel-definitions">Tactic toplevel definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#defining-ltac-functions">Defining <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#printing-ltac-tactics">Printing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ltac.html#examples-of-using-ltac">Examples of using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub></a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#proof-that-the-natural-numbers-have-at-least-two-elements">Proof that the natural numbers have at least two elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#proving-that-a-list-is-a-permutation-of-a-second-list">Proving that a list is a permutation of a second list</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#deciding-intuitionistic-propositional-logic">Deciding intuitionistic propositional logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#deciding-type-isomorphisms">Deciding type isomorphisms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ltac.html#debugging-ltac-tactics">Debugging <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#backtraces">Backtraces</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#info-trace">Info trace</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#interactive-debugger">Interactive debugger</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#profiling-ltac-tactics">Profiling <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#run-time-optimization-tactic">Run-time optimization tactic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="detailed-tactic-examples.html">Detailed examples of tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="detailed-tactic-examples.html#dependent-induction">dependent induction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="detailed-tactic-examples.html#a-larger-example">A larger example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="detailed-tactic-examples.html#autorewrite">autorewrite</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">The <span class="smallcaps">SSReflect</span> proof language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#usage">Usage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#getting-started">Getting started</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compatibility-issues">Compatibility issues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#gallina-extensions"><span class="smallcaps">Gallina</span> extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pattern-assignment">Pattern assignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pattern-conditional">Pattern conditional</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parametric-polymorphism">Parametric polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#anonymous-arguments">Anonymous arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wildcards">Wildcards</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#abbreviations">Abbreviations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#matching">Matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="#occurrence-selection">Occurrence selection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#basic-localization">Basic localization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#basic-tactics">Basic tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#bookkeeping">Bookkeeping</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-defective-tactics">The defective tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-move-tactic">The move tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-case-tactic">The case tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-elim-tactic">The elim tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-apply-tactic">The apply tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#discharge">Discharge</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#clear-rules">Clear rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#matching-for-apply-and-exact">Matching for apply and exact</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-abstract-tactic">The abstract tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#introduction-in-the-context">Introduction in the context</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simplification-items">Simplification items</a></li>
<li class="toctree-l4"><a class="reference internal" href="#views">Views</a></li>
<li class="toctree-l4"><a class="reference internal" href="#intro-patterns">Intro patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#clear-switch">Clear switch</a></li>
<li class="toctree-l4"><a class="reference internal" href="#branching-and-destructuring">Branching and destructuring</a></li>
<li class="toctree-l4"><a class="reference internal" href="#block-introduction">Block introduction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#generation-of-equations">Generation of equations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-families">Type families</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#control-flow">Control flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#indentation-and-bullets">Indentation and bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#terminators">Terminators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#selectors">Selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iteration">Iteration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#localization">Localization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#structure">Structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-have-tactic">The have tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generating-let-in-context-entries-with-have">Generating let in context entries with have</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-have-tactic-and-typeclass-resolution">The have tactic and typeclass resolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variants-the-suff-and-wlog-tactics">Variants: the suff and wlog tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rewriting">Rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#an-extended-rewrite-tactic">An extended rewrite tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#remarks-and-examples">Remarks and examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rewrite-redex-selection">Rewrite redex selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#chained-rewrite-steps">Chained rewrite steps</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-redex-switches-are-matched-first">Explicit redex switches are matched first</a></li>
<li class="toctree-l4"><a class="reference internal" href="#occurrence-switches-and-redex-switches">Occurrence switches and redex switches</a></li>
<li class="toctree-l4"><a class="reference internal" href="#occurrence-selection-and-repetition">Occurrence selection and repetition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multi-rule-rewriting">Multi-rule rewriting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wildcards-vs-abstractions">Wildcards vs abstractions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#when-ssr-rewrite-fails-on-standard-coq-licit-rewrite">When <span class="smallcaps">SSReflect</span> rewrite fails on standard <span class="smallcaps">Coq</span> licit rewrite</a></li>
<li class="toctree-l4"><a class="reference internal" href="#existential-metavariables-and-rewriting">Existential metavariables and rewriting</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rewriting-under-binders">Rewriting under binders</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-under-tactic">The under tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interactive-mode">Interactive mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="#one-liner-mode">One-liner mode</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#locking-unlocking">Locking, unlocking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#congruence">Congruence</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#contextual-patterns">Contextual patterns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#matching-contextual-patterns">Matching contextual patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#contextual-pattern-in-set-and-the-tactical">Contextual pattern in set and the : tactical</a></li>
<li class="toctree-l4"><a class="reference internal" href="#contextual-patterns-in-rewrite">Contextual patterns in rewrite</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#patterns-for-recurrent-contexts">Patterns for recurrent contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#views-and-reflection">Views and reflection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#interpreting-eliminations">Interpreting eliminations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interpreting-assumptions">Interpreting assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#specializing-assumptions">Specializing assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interpreting-goals">Interpreting goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolean-reflection">Boolean reflection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-reflect-predicate">The reflect predicate</a></li>
<li class="toctree-l3"><a class="reference internal" href="#general-mechanism-for-interpreting-goals-and-assumptions">General mechanism for interpreting goals and assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id13">Specializing assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">Interpreting assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interpreting-equivalences">Interpreting equivalences</a></li>
<li class="toctree-l3"><a class="reference internal" href="#declaring-new-hint-views">Declaring new Hint Views</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-views">Multiple views</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ssr-searching-tool"><span class="smallcaps">SSReflect</span> searching tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synopsis-and-index">Synopsis and Index</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#parameters">Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#items-and-switches">Items and switches</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tacticals">Tacticals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#commands">Commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="#settings">Settings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">User extensions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations">Notations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#basic-notations">Basic notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#precedences-and-associativity">Precedences and associativity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#complex-notations">Complex notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simple-factorization-rules">Simple factorization rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-symbolic-notations">Displaying symbolic notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-infix-command">The Infix command</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#reserving-notations">Reserving notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simultaneous-definition-of-terms-and-notations">Simultaneous definition of terms and notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-notations">Displaying information about notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#locating-notations">Locating notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-and-binders">Notations and binders</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-identifiers">Binders bound in the notation and parsed as identifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-patterns">Binders bound in the notation and parsed as patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-terms">Binders bound in the notation and parsed as terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-not-bound-in-the-notation">Binders not bound in the notation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns">Notations with recursive patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns-involving-binders">Notations with recursive patterns involving binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#predefined-entries">Predefined entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#custom-entries">Custom entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#summary">Summary</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#syntax-of-notations">Syntax of notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#persistence-of-notations">Persistence of notations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes">Interpretation scopes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#global-interpretation-rules-for-notations">Global interpretation rules for notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-interpretation-rules-for-notations">Local interpretation rules for notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-opening-of-an-interpretation-scope">Local opening of an interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binding-arguments-of-a-constant-to-an-interpretation-scope">Binding arguments of a constant to an interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binding-types-of-arguments-to-an-interpretation-scope">Binding types of arguments to an interpretation scope</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-type-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">type_scope</span></code> interpretation scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-function-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">function_scope</span></code> interpretation scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes-used-in-the-standard-library-of-coq">Interpretation scopes used in the standard library of Coq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-scopes">Displaying information about scopes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#numeral-notations">Numeral notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#string-notations">String notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#tactic-notations">Tactic Notations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-induction-principles-with-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#automatic-declaration-of-schemes">Automatic declaration of schemes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#combined-scheme">Combined Scheme</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-induction-principles-with-functional-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Functional</span></code> <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-inversion-principles-with-derive-inversion">Generation of inversion principles with <code class="docutils literal notranslate"><span class="pre">Derive</span></code> <code class="docutils literal notranslate"><span class="pre">Inversion</span></code></a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Practical tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#interactive-use-coqtop">Interactive use (coqtop)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#batch-compilation-coqc">Batch compilation (coqc)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#customization-at-launch-time">Customization at launch time</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-resource-file">By resource file</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-environment-variables">By environment variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-command-line-options">By command line options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-libraries-checker-coqchk">Compiled libraries checker (coqchk)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#using-coq-as-a-library">Using Coq as a library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project">Building a <span class="smallcaps">Coq</span> project</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-coq-makefile">Building a <span class="smallcaps">Coq</span> project with coq_makefile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#coqmakefile-local">CoqMakefile.local</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#timing-targets-and-performance-testing">Timing targets and performance testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#reusing-extending-the-generated-makefile">Reusing/extending the generated Makefile</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#building-a-subset-of-the-targets-with-j">Building a subset of the targets with <code class="docutils literal notranslate"><span class="pre">-j</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-dune">Building a <span class="smallcaps">Coq</span> project with Dune</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#computing-module-dependencies">Computing Module dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#documenting-coq-files-with-coqdoc">Documenting <span class="smallcaps">Coq</span> files with coqdoc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#principles">Principles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#coq-material-inside-documentation"><span class="smallcaps">Coq</span> material inside documentation.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#pretty-printing">Pretty-printing.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#sections">Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#lists">Lists.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#rules">Rules.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#emphasis">Emphasis.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#escaping-to-latex-and-html">Escaping to <span class="smallcaps">LaTeX</span> and HTML.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#verbatim">Verbatim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#hyperlinks">Hyperlinks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#hiding-showing-parts-of-the-source">Hiding / Showing parts of the source.</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#the-coqdoc-latex-style-file">The coqdoc <span class="smallcaps">LaTeX</span> style file</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#embedded-coq-phrases-inside-latex-documents">Embedded Coq phrases inside <span class="smallcaps">LaTeX</span> documents</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#man-pages">Man pages</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#managing-files-and-buffers-basic-editing">Managing files and buffers, basic editing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#interactive-navigation-into-coq-scripts">Interactive navigation into Coq scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#proof-folding">Proof folding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#vernacular-commands-templates">Vernacular commands, templates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#queries">Queries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#compilation">Compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#customizations">Customizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#using-unicode-symbols">Using Unicode symbols</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#displaying-unicode-symbols">Displaying Unicode symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#bindings-for-input-of-unicode-symbols">Bindings for input of Unicode symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#adding-custom-bindings">Adding custom bindings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#character-encoding-for-saved-files">Character encoding for saved files</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Addendum</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extended-pattern-matching.html">Extended pattern matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#patterns">Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#multiple-patterns">Multiple patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#aliasing-subpatterns">Aliasing subpatterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#nested-patterns">Nested patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#disjunctive-patterns">Disjunctive patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#about-patterns-of-parametric-types">About patterns of parametric types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#parameters-in-patterns">Parameters in patterns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#implicit-arguments-in-patterns">Implicit arguments in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#matching-objects-of-dependent-types">Matching objects of dependent types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#understanding-dependencies-in-patterns">Understanding dependencies in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#when-the-elimination-predicate-must-be-provided">When the elimination predicate must be provided</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#dependent-pattern-matching">Dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#multiple-dependent-pattern-matching">Multiple dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#patterns-in-in">Patterns in <code class="docutils literal notranslate"><span class="pre">in</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#using-pattern-matching-to-write-proofs">Using pattern matching to write proofs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#pattern-matching-on-inductive-objects-involving-local-definitions">Pattern-matching on inductive objects involving local definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#pattern-matching-and-coercions">Pattern-matching and coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#when-does-the-expansion-strategy-fail">When does the expansion strategy fail?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#general-presentation">General Presentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions">Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#identity-coercions">Identity Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#inheritance-graph">Inheritance Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#declaring-coercions">Declaring Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#displaying-available-coercions">Displaying Available Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#activating-the-printing-of-coercions">Activating the Printing of Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#classes-as-records">Classes as Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-sections">Coercions and Sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-modules">Coercions and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-at-function-application">Coercion at function application</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-to-a-type">Coercion to a type</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-to-a-function">Coercion to a function</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/canonical-structures.html">Canonical Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/canonical-structures.html#notation-overloading">Notation overloading</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/canonical-structures.html#derived-canonical-structures">Derived Canonical Structures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/canonical-structures.html#hierarchy-of-structures">Hierarchy of structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/canonical-structures.html#compact-declaration-of-canonical-structures">Compact declaration of Canonical Structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/type-classes.html">Typeclasses</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#class-and-instance-declarations">Class and Instance declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#binding-classes">Binding classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#parameterized-instances">Parameterized Instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#sections-and-contexts">Sections and contexts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#building-hierarchies">Building hierarchies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#superclasses">Superclasses</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#substructures">Substructures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#summary-of-the-commands">Summary of the commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-transparent-typeclasses-opaque">Typeclasses Transparent, Typeclasses Opaque</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#settings">Settings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-eauto">Typeclasses eauto <code class="docutils literal notranslate"><span class="pre">:=</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#description-of-omega">Description of <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#arithmetical-goals-recognized-by-omega">Arithmetical goals recognized by <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#messages-from-omega">Messages from <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#using-omega">Using <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#options">Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#technical-data">Technical data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#overview-of-the-tactic">Overview of the tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#overview-of-the-omega-decision-procedure">Overview of the OMEGA decision procedure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#bugs">Bugs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#short-description-of-the-tactics">Short description of the tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#positivstellensatz-refutations"><em>Positivstellensatz</em> refutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#lra-a-decision-procedure-for-linear-real-and-rational-arithmetic"><code class="docutils literal notranslate"><span class="pre">lra</span></code>: a decision procedure for linear real and rational arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#lia-a-tactic-for-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">lia</span></code>: a tactic for linear integer arithmetic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#high-level-view-of-lia">High level view of <code class="docutils literal notranslate"><span class="pre">lia</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#cutting-plane-proofs">Cutting plane proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#case-split">Case split</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#nra-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">nra</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#nia-a-proof-procedure-for-non-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">nia</span></code>: a proof procedure for non-linear integer arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#psatz-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">psatz</span></code>: a proof procedure for non-linear arithmetic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#generating-ml-code">Generating ML Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#extraction-options">Extraction Options</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#setting-the-target-language">Setting the target language</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#inlining-and-optimizations">Inlining and optimizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extra-elimination-of-useless-arguments">Extra elimination of useless arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#realizing-axioms">Realizing axioms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#realizing-inductive-types">Realizing inductive types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#avoiding-conflicts-with-existing-filenames">Avoiding conflicts with existing filenames</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#additional-settings">Additional settings</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#differences-between-coq-and-ml-type-systems">Differences between <span class="smallcaps">Coq</span> and ML type systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#some-examples">Some examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#a-detailed-example-euclidean-division">A detailed example: Euclidean division</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extraction-s-horror-museum">Extraction's horror museum</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#users-contributions">Users' Contributions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/program.html">Program</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#elaborating-programs">Elaborating programs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#syntactic-control-over-equalities">Syntactic control over equalities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-definition">Program Definition</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-fixpoint">Program Fixpoint</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-lemma">Program Lemma</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#solving-obligations">Solving obligations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#frequently-asked-questions">Frequently Asked Questions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/ring.html">The ring and field tactic families</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#what-does-this-tactic-do">What does this tactic do?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#the-variables-map">The variables map</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#is-it-automatic">Is it automatic?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#concrete-usage-in-coq">Concrete usage in Coq</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#adding-a-ring-structure">Adding a ring structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#how-does-it-work">How does it work?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#dealing-with-fields">Dealing with fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#adding-a-new-field-structure">Adding a new field structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#history-of-ring">History of ring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#discussion">Discussion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: tactics for proving equalities in integral domains</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/nsatz.html#more-about-nsatz">More about <code class="docutils literal notranslate"><span class="pre">nsatz</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#introduction-to-generalized-rewriting">Introduction to generalized rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#relations-and-morphisms">Relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#adding-new-relations-and-morphisms">Adding new relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-non-reflexive-relations">Rewriting and non reflexive relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-non-symmetric-relations">Rewriting and non symmetric relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-in-ambiguous-setoid-contexts">Rewriting in ambiguous setoid contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#commands-and-tactics">Commands and tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#first-class-setoids-and-morphisms">First class setoids and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#tactics-enabled-on-user-provided-relations">Tactics enabled on user provided relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#printing-relations-and-morphisms">Printing relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#deprecated-syntax-and-backward-incompatibilities">Deprecated syntax and backward incompatibilities</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#extensions">Extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#subrelations">Subrelations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#constant-unfolding">Constant unfolding</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#strategies-for-rewriting">Strategies for rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#usage">Usage</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-annotations">Proof annotations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#automatic-suggestion-of-proof-annotations">Automatic suggestion of proof annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-blocks-and-error-resilience">Proof blocks and error resilience</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#caveats">Caveats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#interactive-mode">Interactive mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#id2">Caveats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#batch-mode">Batch mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#limiting-the-number-of-parallel-workers">Limiting the number of parallel workers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Miscellaneous extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/miscellaneous-extensions.html#program-derivation">Program derivation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#general-presentation">General Presentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-monomorphic">Polymorphic, Monomorphic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulative-noncumulative">Cumulative, NonCumulative</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#an-example-of-a-proof-using-cumulativity">An example of a proof using cumulativity</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulativity-weak-constraints">Cumulativity Weak Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#global-and-local-universes">Global and local universes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#conversion-and-unification">Conversion and unification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#minimization">Minimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#explicit-universes">Explicit Universes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-definitions">Polymorphic definitions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/sprop.html">SProp (proof irrelevant propositions)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#basic-constructs">Basic constructs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#encodings-for-strict-propositions">Encodings for strict propositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#issues-with-non-cumulativity">Issues with non-cumulativity</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>The <span class="smallcaps">SSReflect</span> proof language</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/proof-engine/ssreflect-proof-language.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="the-ssr-proof-language">
<span id="thessreflectprooflanguage"></span><h1>The <span class="smallcaps">SSReflect</span> proof language<a class="headerlink" href="#the-ssr-proof-language" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p>Georges Gonthier, Assia Mahboubi, Enrico Tassi</p>
</dd>
</dl>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This chapter describes a set of tactics known as <span class="smallcaps">SSReflect</span> originally
designed to provide support for the so-called <em>small scale reflection</em>
proof methodology. Despite the original purpose this set of tactic is
of general interest and is available in <span class="smallcaps">Coq</span> starting from version 8.7.</p>
<p><span class="smallcaps">SSReflect</span> was developed independently of the tactics described in
Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>. Indeed the scope of the tactics part of <span class="smallcaps">SSReflect</span> largely
overlaps with the standard set of tactics. Eventually the overlap will
be reduced in future releases of <span class="smallcaps">Coq</span>.</p>
<p>Proofs written in <span class="smallcaps">SSReflect</span> typically look quite different from the
ones written using only tactics as per Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>. We try to
summarise here the most “visible” ones in order to help the reader
already accustomed to the tactics described in Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a> to read
this chapter.</p>
<p>The first difference between the tactics described in this chapter and the
tactics described in Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a> is the way hypotheses are managed
(we call this <em>bookkeeping</em>). In Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a> the most common
approach is to avoid moving explicitly hypotheses back and forth between the
context and the conclusion of the goal. On the contrary in <span class="smallcaps">SSReflect</span> all
bookkeeping is performed on the conclusion of the goal, using for that
purpose a couple of syntactic constructions behaving similar to tacticals
(and often named as such in this chapter). The <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical moves hypotheses
from the context to the conclusion, while <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> moves hypotheses from the
conclusion to the context, and <code class="docutils literal notranslate"><span class="pre">in</span></code> moves back and forth a hypothesis from the
context to the conclusion for the time of applying an action to it.</p>
<p>While naming hypotheses is commonly done by means of an <code class="docutils literal notranslate"><span class="pre">as</span></code> clause in the
basic model of Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>, it is here to <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> that this task is
devoted. Tactics frequently leave new assumptions in the conclusion, and are
often followed by <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> to explicitly name them. While generalizing the
goal is normally not explicitly needed in Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>, it is an
explicit operation performed by <code class="docutils literal notranslate"><span class="pre">:</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#bookkeeping-ssr"><span class="std std-ref">Bookkeeping</span></a></p>
</div>
<p>Beside the difference of bookkeeping model, this chapter includes
specific tactics which have no explicit counterpart in Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>
such as tactics to mix forward steps and generalizations as
<a class="reference internal" href="#coq:tacn.generally-have" title="generally have"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">generally</span> <span class="pre">have</span></code></a> or <a class="reference internal" href="#coq:tacn.without-loss" title="without loss"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">without</span> <span class="pre">loss</span></code></a>.</p>
<p><span class="smallcaps">SSReflect</span> adopts the point of view that rewriting, definition
expansion and partial evaluation participate all to a same concept of
rewriting a goal in a larger sense. As such, all these functionalities
are provided by the <a class="reference internal" href="#coq:tacn.rewrite-ssreflect" title="rewrite (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> tactic.</p>
<p><span class="smallcaps">SSReflect</span> includes a little language of patterns to select subterms in
tactics or tacticals where it matters. Its most notable application is
in the <a class="reference internal" href="#coq:tacn.rewrite-ssreflect" title="rewrite (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> tactic, where patterns are
used to specify where the rewriting step has to take place.</p>
<p>Finally, <span class="smallcaps">SSReflect</span> supports so-called reflection steps, typically
allowing to switch back and forth between the computational view and
logical view of a concept.</p>
<p>To conclude it is worth mentioning that <span class="smallcaps">SSReflect</span> tactics can be mixed
with non <span class="smallcaps">SSReflect</span> tactics in the same proof, or in the same Ltac
expression. The few exceptions to this statement are described in
section <a class="reference internal" href="#compatibility-issues-ssr"><span class="std std-ref">Compatibility issues</span></a>.</p>
<div class="section" id="acknowledgments">
<h3>Acknowledgments<a class="headerlink" href="#acknowledgments" title="Permalink to this headline">¶</a></h3>
<p>The authors would like to thank Frédéric Blanqui, François Pottier and
Laurence Rideau for their comments and suggestions.</p>
</div>
</div>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<div class="section" id="getting-started">
<h3>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h3>
<p>To be available, the tactics presented in this manual need the
following minimal set of libraries to be loaded: <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code>,
<code class="docutils literal notranslate"><span class="pre">ssrfun.v</span></code> and <code class="docutils literal notranslate"><span class="pre">ssrbool.v</span></code>.
Moreover, these tactics come with a methodology
specific to the authors of <span class="smallcaps">SSReflect</span> and which requires a few options
to be set in a different way than in their default way. All in all,
this corresponds to working in the following context:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> ssreflect ssrfun ssrbool.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Set Implicit Arguments</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Unset Strict Implicit</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Unset Printing Implicit Defensive</span>.</span></span></span></pre></div><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../language/gallina-extensions.html#coq:flag.implicit-arguments" title="Implicit Arguments"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Implicit</span> <span class="pre">Arguments</span></code></a>, <a class="reference internal" href="../language/gallina-extensions.html#coq:flag.strict-implicit" title="Strict Implicit"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Strict</span> <span class="pre">Implicit</span></code></a>,
<a class="reference internal" href="../language/gallina-extensions.html#coq:flag.printing-implicit-defensive" title="Printing Implicit Defensive"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">Implicit</span> <span class="pre">Defensive</span></code></a></p>
</div>
</div>
<div class="section" id="compatibility-issues">
<span id="compatibility-issues-ssr"></span><h3>Compatibility issues<a class="headerlink" href="#compatibility-issues" title="Permalink to this headline">¶</a></h3>
<p>Requiring the above modules creates an environment which is mostly
compatible with the rest of <span class="smallcaps">Coq</span>, up to a few discrepancies:</p>
<ul>
<li><p>New keywords (<code class="docutils literal notranslate"><span class="pre">is</span></code>) might clash with variable, constant, tactic or
tactical names, or with quasi-keywords in tactic or vernacular
notations.</p></li>
<li><p>New tactic(al)s names (<a class="reference internal" href="#coq:tacn.last" title="last"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">last</span></code></a>, <a class="reference internal" href="#coq:tacn.done" title="done"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">done</span></code></a>, <a class="reference internal" href="#coq:tacn.have" title="have"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">have</span></code></a>, <a class="reference internal" href="#coq:tacn.suffices" title="suffices"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">suffices</span></code></a>,
<a class="reference internal" href="#coq:tacn.suff" title="suff"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">suff</span></code></a>, <a class="reference internal" href="#coq:tacn.without-loss" title="without loss"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">without</span> <span class="pre">loss</span></code></a>, <a class="reference internal" href="#coq:tacn.wlog" title="wlog"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">wlog</span></code></a>, <a class="reference internal" href="#coq:tacn.congr" title="congr"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congr</span></code></a>, <a class="reference internal" href="#coq:tacn.unlock" title="unlock"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unlock</span></code></a>)
might clash with user tactic names.</p></li>
<li><p>Identifiers with both leading and trailing <code class="docutils literal notranslate"><span class="pre">_</span></code>, such as <code class="docutils literal notranslate"><span class="pre">_x_</span></code>, are
reserved by <span class="smallcaps">SSReflect</span> and cannot appear in scripts.</p></li>
<li><p>The extensions to the <a class="reference internal" href="tactics.html#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> tactic are partly incompatible with those
available in current versions of <span class="smallcaps">Coq</span>; in particular: <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">..</span> <span class="pre">in</span>
<span class="pre">(type</span> <span class="pre">of</span> <span class="pre">k)</span></code> or <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">..</span> <span class="pre">in</span> <span class="pre">*</span></code> or any other variant of <a class="reference internal" href="tactics.html#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a>
will not work, and the <span class="smallcaps">SSReflect</span> syntax and semantics for occurrence selection
and rule chaining is different. Use an explicit rewrite direction
(<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">&lt;-</span> <span class="pre">…</span></code> or <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">-&gt;</span> <span class="pre">…</span></code>) to access the <span class="smallcaps">Coq</span> rewrite tactic.</p></li>
<li><p>New symbols (<code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">//=</span></code>) might clash with adjacent
existing symbols.
This can be avoided by inserting white spaces.</p></li>
<li><p>New constant and theorem names might clash with the user theory.
This can be avoided by not importing all of <span class="smallcaps">SSReflect</span>:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require</span> ssreflect.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Import</span> ssreflect.SsrSyntax.</span></span></span></pre></div><p>Note that the full
syntax of <span class="smallcaps">SSReflect</span>’s rewrite and reserved identifiers are enabled
only if the ssreflect module has been required and if <code class="docutils literal notranslate"><span class="pre">SsrSyntax</span></code> has
been imported. Thus a file that requires (without importing) <code class="docutils literal notranslate"><span class="pre">ssreflect</span></code>
and imports <code class="docutils literal notranslate"><span class="pre">SsrSyntax</span></code>, can be required and imported without
automatically enabling <span class="smallcaps">SSReflect</span>’s extended rewrite syntax and
reserved identifiers.</p>
</li>
<li><p>Some user notations (in particular, defining an infix <code class="docutils literal notranslate"><span class="pre">;</span></code>) might
interfere with the &quot;open term&quot;, parenthesis free, syntax of tactics
such as have, set and pose.</p></li>
<li><p>The generalization of if statements to non-Boolean conditions is turned off
by <span class="smallcaps">SSReflect</span>, because it is mostly subsumed by Coercion to <code class="docutils literal notranslate"><span class="pre">bool</span></code> of the
<code class="docutils literal notranslate"><span class="pre">sumXXX</span></code> types (declared in <code class="docutils literal notranslate"><span class="pre">ssrfun.v</span></code>) and the
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">if</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">is</span></span> <span class="hole"><span class="pre">pattern</span></span> <span><span class="pre">then</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">else</span></span> <span class="hole"><span class="pre">term</span></span></span></code> construct
(see <a class="reference internal" href="#pattern-conditional-ssr"><span class="std std-ref">Pattern conditional</span></a>).  To use the
generalized form, turn off the <span class="smallcaps">SSReflect</span> Boolean <code class="docutils literal notranslate"><span class="pre">if</span></code> notation using the command:
<code class="docutils literal notranslate"><span class="pre">Close</span> <span class="pre">Scope</span> <span class="pre">boolean_if_scope</span></code>.</p></li>
<li><p>The following flags can be unset to make <span class="smallcaps">SSReflect</span> more compatible with
parts of Coq:</p></li>
</ul>
<dl class="coq flag">
<dt id="coq:flag.ssrrewrite">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>SsrRewrite</span></span></code><a class="headerlink" href="#coq:flag.ssrrewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls whether the incompatible rewrite syntax is enabled (the default).
Disabling the flag makes the syntax compatible with other parts of Coq.</p>
</dd></dl>

<dl class="coq flag">
<dt id="coq:flag.ssridents">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>SsrIdents</span></span></code><a class="headerlink" href="#coq:flag.ssridents" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls whether tactics can refer to <span class="smallcaps">SSReflect</span>-generated variables that are
in the form _xxx_.  Scripts with explicit references to such variables
are fragile; they are prone to failure if the proof is later modified or
if the details of variable name generation change in future releases of Coq.</p>
<p>The default is on, which gives an error message when the user tries to
create such identifiers.  Disabling the flag generates a warning instead,
increasing compatibility with other parts of Coq.</p>
</dd></dl>

</div>
</div>
<div class="section" id="gallina-extensions">
<h2><span class="smallcaps">Gallina</span> extensions<a class="headerlink" href="#gallina-extensions" title="Permalink to this headline">¶</a></h2>
<p>Small-scale reflection makes an extensive use of the programming
subset of <span class="smallcaps">Gallina</span>, <span class="smallcaps">Coq</span>’s logical specification language. This subset
is quite suited to the description of functions on representations,
because it closely follows the well-established design of the ML
programming language. The <span class="smallcaps">SSReflect</span> extension provides three additions
to <span class="smallcaps">Gallina</span>, for pattern assignment, pattern testing, and polymorphism;
these mitigate minor but annoying discrepancies between <span class="smallcaps">Gallina</span> and
ML.</p>
<div class="section" id="pattern-assignment">
<h3>Pattern assignment<a class="headerlink" href="#pattern-assignment" title="Permalink to this headline">¶</a></h3>
<p>The <span class="smallcaps">SSReflect</span> extension provides the following construct for
irrefutable pattern matching, that is, destructuring assignment:</p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">+=</span> </code><span class="notation"><span>let:</span> <span class="hole">pattern</span> <span>:=</span> <span class="hole">term</span> <span>in</span> <span class="hole">term</span></span></code></dt>
<dd></dd></dl>

<p>Note the colon <code class="docutils literal notranslate"><span class="pre">:</span></code> after the <code class="docutils literal notranslate"><span class="pre">let</span></code> keyword, which avoids any ambiguity
with a function definition or <span class="smallcaps">Coq</span>’s basic destructuring let. The let:
construct differs from the latter in that</p>
<ul class="simple">
<li><p>The pattern can be nested (deep pattern matching), in particular,
this allows expression of the form:</p></li>
</ul>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="o">:</span> <span class="n">exist</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="n">p_xy</span> <span class="o">:=</span> <span class="n">Hp</span> <span class="kr">in</span> <span class="o">…</span> <span class="o">.</span>
</pre></div>
</div>
<ul>
<li><p>The destructured constructor is explicitly given in the pattern, and
is used for type inference.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">f</span> <span class="nv">u</span> := <span class="kr">let</span>: (m, n) := u <span class="kr">in</span> m + n.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk0" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk0"><span class="highlight"><span class="kn">Check</span> f.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">f
     : nat * nat -&gt; nat</span></blockquote></div></div></small></span></pre></div><p>Using <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">let</span></span><span class="operator"><span class="pre">:</span></span></code> Coq infers a type for <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">f</span></span></code>,
whereas with a usual <code class="docutils literal notranslate"><span class="pre">let</span></code> the same term requires an extra type
annotation in order to type check.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk1" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk1"><span class="highlight"><span class="kn">Fail</span> <span class="kn">Definition</span> <span class="nf">f</span> <span class="nv">u</span> := <span class="kr">let</span> (<span class="nv">m</span>, n) := u <span class="kr">in</span> m + n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
Cannot infer a type <span class="kr">for</span> this expression.</span></blockquote></div></div></small></span></pre></div></div>
</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">let:</span></code> construct is just (more legible) notation for the primitive
<span class="smallcaps">Gallina</span> expression <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">match</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">with</span></span> <span class="hole"><span class="pre">pattern</span></span> <span><span class="pre">=&gt;</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">end</span></span></span></code>.</p>
<p>The <span class="smallcaps">SSReflect</span> destructuring assignment supports all the dependent
match annotations; the full syntax is</p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">+=</span> </code><span class="notation"><span>let:</span> <span class="hole">pattern</span> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span class="hole">ident</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <span class="hole">pattern</span></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>return</span> <span class="hole">term</span></span><span class="notation-sup">?</span></span> <span>in</span> <span class="hole">term</span></span></code></dt>
<dd></dd></dl>

<p>where the second <code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code> and the second <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> are <em>types</em>.</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">as</span></code> and <code class="docutils literal notranslate"><span class="pre">return</span></code> keywords are both present, then <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is bound
in both the second <code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code> and the second <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>; variables
in the optional type <code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code> are bound only in the second term, and
other variables in the first  <code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code> are bound only in the third
<code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>, however.</p>
</div>
<div class="section" id="pattern-conditional">
<span id="pattern-conditional-ssr"></span><h3>Pattern conditional<a class="headerlink" href="#pattern-conditional" title="Permalink to this headline">¶</a></h3>
<p>The following construct can be used for a refutable pattern matching,
that is, pattern testing:</p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">+=</span> </code><span class="notation"><span>if</span> <span class="hole">term</span> <span>is</span> <span class="hole">pattern</span> <span>then</span> <span class="hole">term</span> <span>else</span> <span class="hole">term</span></span></code></dt>
<dd></dd></dl>

<p>Although this construct is not strictly ML (it does exist in variants
such as the pattern calculus or the ρ-calculus), it turns out to be
very convenient for writing functions on representations, because most
such functions manipulate simple data types such as Peano integers,
options, lists, or binary trees, and the pattern conditional above is
almost always the right construct for analyzing such simple types. For
example, the null and all list function(al)s can be defined as follows:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<blockquote>
<div></div></blockquote>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">d</span>: <span class="kt">Set</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">null</span> (<span class="nv">s</span> : list d) :=
  <span class="kr">if</span> s <span class="kr">is</span> nil <span class="kr">then</span> true <span class="kr">else</span> false.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">a</span> : d -&gt; bool.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">all</span> (<span class="nv">s</span> : list d) : bool :=
  <span class="kr">if</span> s <span class="kr">is</span> cons x s&#39; <span class="kr">then</span> a x &amp;&amp; <span class="kp">all</span> s&#39; <span class="kr">else</span> true.</span></span></span></pre></div></div>
<p>The pattern conditional also provides a notation for destructuring
assignment with a refutable pattern, adapted to the pure functional
setting of <span class="smallcaps">Gallina</span>, which lacks a <code class="docutils literal notranslate"><span class="pre">Match_Failure</span></code> exception.</p>
<p>Like <code class="docutils literal notranslate"><span class="pre">let:</span></code> above, the <code class="docutils literal notranslate"><span class="pre">if…is</span></code> construct is just (more legible) notation
for the primitive <span class="smallcaps">Gallina</span> expression
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">match</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">with</span></span> <span class="hole"><span class="pre">pattern</span></span> <span><span class="pre">=&gt;</span></span> <span class="hole"><span class="pre">term</span></span> <span class="pre">|</span> <span><span class="pre">_</span></span> <span><span class="pre">=&gt;</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">end</span></span></span></code>.</p>
<p>Similarly, it will always be displayed as the expansion of this form
in terms of primitive match expressions (where the default expression
may be replicated).</p>
<p>Explicit pattern testing also largely subsumes the generalization of
the <code class="docutils literal notranslate"><span class="pre">if</span></code> construct to all binary data types; compare
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">if</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">is</span></span> <span><span class="pre">inl</span></span> <span><span class="pre">_</span></span> <span><span class="pre">then</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">else</span></span> <span class="hole"><span class="pre">term</span></span></span></code> and
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">if</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">then</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">else</span></span> <span class="hole"><span class="pre">term</span></span></span></code>.</p>
<p>The latter appears to be marginally shorter, but it is quite
ambiguous, and indeed often requires an explicit annotation
<code class="docutils literal notranslate"><span class="pre">(term</span> <span class="pre">:</span> <span class="pre">{_}</span> <span class="pre">+</span> <span class="pre">{_})</span></code> to type check, which evens the character count.</p>
<p>Therefore, <span class="smallcaps">SSReflect</span> restricts by default the condition of a plain if
construct to the standard <code class="docutils literal notranslate"><span class="pre">bool</span></code> type; this avoids spurious type
annotations.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">orb</span> <span class="nv">b1</span> <span class="nv">b2</span> := <span class="kr">if</span> b1 <span class="kr">then</span> true <span class="kr">else</span> b2.</span></span></span></pre></div></div>
<p>As pointed out in section <a class="reference internal" href="#compatibility-issues-ssr"><span class="std std-ref">Compatibility issues</span></a>,
this restriction can be removed with
the command:</p>
<p><code class="docutils literal notranslate"><span class="pre">Close</span> <span class="pre">Scope</span> <span class="pre">boolean_if_scope.</span></code></p>
<p>Like <code class="docutils literal notranslate"><span class="pre">let:</span></code> above, the <code class="docutils literal notranslate"><span class="pre">if-is-then-else</span></code>
construct supports
the dependent match annotations:</p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">+=</span> </code><span class="notation"><span>if</span> <span class="hole">term</span> <span>is</span> <span class="hole">pattern</span> <span>as</span> <span class="hole">ident</span> <span>in</span> <span class="hole">pattern</span> <span>return</span> <span class="hole">term</span> <span>then</span> <span class="hole">term</span> <span>else</span> <span class="hole">term</span></span></code></dt>
<dd></dd></dl>

<p>As in <code class="docutils literal notranslate"><span class="pre">let:</span></code> the variable <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> (and those in the type pattern)
are bound in the second <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>; <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is also bound in the
third <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> (but not in the fourth <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>), while the
variables in the first <code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code> are bound only in the third
<code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.</p>
<p>Another variant allows to treat the <code class="docutils literal notranslate"><span class="pre">else</span></code> case first:</p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">+=</span> </code><span class="notation"><span>if</span> <span class="hole">term</span> <span>isn't</span> <span class="hole">pattern</span> <span>then</span> <span class="hole">term</span> <span>else</span> <span class="hole">term</span></span></code></dt>
<dd></dd></dl>

<p>Note that <code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code> eventually binds variables in the third
<code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> and not in the second <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.</p>
</div>
<div class="section" id="parametric-polymorphism">
<span id="parametric-polymorphism-ssr"></span><h3>Parametric polymorphism<a class="headerlink" href="#parametric-polymorphism" title="Permalink to this headline">¶</a></h3>
<p>Unlike ML, polymorphism in core <span class="smallcaps">Gallina</span> is explicit: the type
parameters of polymorphic functions must be declared explicitly, and
supplied at each point of use. However, <span class="smallcaps">Coq</span> provides two features to
suppress redundant parameters:</p>
<ul class="simple">
<li><p>Sections are used to provide (possibly implicit) parameters for a
set of definitions.</p></li>
<li><p>Implicit arguments declarations are used to tell <span class="smallcaps">Coq</span> to use type
inference to deduce some parameters from the context at each point of
call.</p></li>
</ul>
<p>The combination of these features provides a fairly good emulation of
ML-style polymorphism, but unfortunately this emulation breaks down
for higher-order programming. Implicit arguments are indeed not
inferred at all points of use, but only at points of call, leading to
expressions such as</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">all_null</span> (<span class="nv">s</span> : list T) := <span class="kp">all</span> (@null T) s.</span></span></span></pre></div></div>
<p>Unfortunately, such higher-order expressions are quite frequent in
representation functions, especially those which use <span class="smallcaps">Coq</span>'s
<code class="docutils literal notranslate"><span class="pre">Structures</span></code> to emulate Haskell typeclasses.</p>
<p>Therefore, <span class="smallcaps">SSReflect</span> provides a variant of <span class="smallcaps">Coq</span>’s implicit argument
declaration, which causes <span class="smallcaps">Coq</span> to fill in some implicit parameters at
each point of use, e.g., the above definition can be written:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Prenex Implicits</span> <span class="nf">null</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">all_null</span> (<span class="nv">s</span> : list T) := <span class="kp">all</span> null s.</span></span></span></pre></div></div>
<p>Better yet, it can be omitted entirely, since <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">all_null</span></span> <span class="name"><span class="pre">s</span></span></code> isn’t much of
an improvement over <code class="code highlight coq docutils literal notranslate"><span class="keyword pseudo"><span class="pre">all</span></span> <span class="name"><span class="pre">null</span></span> <span class="name"><span class="pre">s</span></span></code>.</p>
<p>The syntax of the new declaration is</p>
<dl class="coq cmd">
<dt id="coq:cmd.prenex-implicits">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Prenex</span> <span>Implicits</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident<sub>i</sub></span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.prenex-implicits" title="Permalink to this definition">¶</a></dt>
<dd><p>This command checks that each <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">i</span></sub></span></span></code> is the name of a functional
constant, whose implicit arguments are prenex, i.e., the first
<span class="math notranslate nohighlight">\(n_i &gt; 0\)</span> arguments of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span><sub><span class="pre">i</span></sub></span></span></code> are implicit; then it assigns
<code class="docutils literal notranslate"><span class="pre">Maximal</span> <span class="pre">Implicit</span></code> status to these arguments.</p>
<p>As these prenex implicit arguments are ubiquitous and have often large
display strings, it is strongly recommended to change the default
display settings of <span class="smallcaps">Coq</span> so that they are not printed (except after
a <code class="docutils literal notranslate"><span class="pre">Set</span> <span class="pre">Printing</span> <span class="pre">All</span></code> command). All <span class="smallcaps">SSReflect</span> library files thus start
with the incantation</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Set Implicit Arguments</span><span class="o">.</span>
<span class="kn">Unset Strict Implicit</span><span class="o">.</span>
<span class="kn">Unset Printing Implicit Defensive</span><span class="o">.</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="anonymous-arguments">
<h3>Anonymous arguments<a class="headerlink" href="#anonymous-arguments" title="Permalink to this headline">¶</a></h3>
<p>When in a definition, the type of a certain argument is mandatory, but
not its name, one usually uses “arrow” abstractions for prenex
arguments, or the <code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">:</span> <span class="pre">term)</span></code> syntax for inner arguments. In <span class="smallcaps">SSReflect</span>,
the latter can be replaced by the open syntax <code class="docutils literal notranslate"><span class="pre">of</span> <span class="pre">term</span></code> or
(equivalently) <code class="docutils literal notranslate"><span class="pre">&amp;</span> <span class="pre">term</span></code>, which are both syntactically equivalent to a
<code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">:</span> <span class="pre">term)</span></code> expression. This feature almost behaves as the
following extension of the binder syntax:</p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">binder</span> <span class="pre">+=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span>&amp;</span> <span class="hole">term</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>of</span> <span class="hole">term</span></span></span></span></code></dt>
<dd></dd></dl>

<p>Caveat: <code class="docutils literal notranslate"><span class="pre">&amp;</span> <span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">of</span> <span class="pre">T</span></code> abbreviations have to appear at the end
of a binder list. For instance, the usual two-constructor polymorphic
type list, i.e. the one of the standard <code class="docutils literal notranslate"><span class="pre">List</span></code> library, can be
defined by the following declaration:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">list</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> := nil | cons of A &amp; list A.</span></span></span></pre></div></div>
</div>
<div class="section" id="wildcards">
<h3>Wildcards<a class="headerlink" href="#wildcards" title="Permalink to this headline">¶</a></h3>
<p>The terms passed as arguments to <span class="smallcaps">SSReflect</span> tactics can contain
<em>holes</em>, materialized by wildcards <code class="docutils literal notranslate"><span class="pre">_</span></code>. Since <span class="smallcaps">SSReflect</span> allows a more
powerful form of type inference for these arguments, it enhances the
possibilities of using such wildcards. These holes are in particular
used as a convenient shorthand for abstractions, especially in local
definitions or type expressions.</p>
<p>Wildcards may be interpreted as abstractions (see for example sections
<a class="reference internal" href="#definitions-ssr"><span class="std std-ref">Definitions</span></a> and <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a>), or their content can be
inferred from the whole context of the goal (see for example section
<a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>).</p>
</div>
<div class="section" id="definitions">
<span id="definitions-ssr"></span><h3>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.pose-ssreflect">
<code class="sig-name descname"><span class="notation"><span>pose</span></span></code><a class="headerlink" href="#coq:tacn.pose-ssreflect" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic allows to add a defined constant to a proof context.
<span class="smallcaps">SSReflect</span> generalizes this tactic in several ways. In particular, the
<span class="smallcaps">SSReflect</span> pose tactic supports <em>open syntax</em>: the body of the
definition does not need surrounding parentheses. For instance:</p>
</dd></dl>

<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">pose</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span>
</pre></div>
</div>
<p>is a valid tactic expression.</p>
<p>The pose tactic is also improved for the local definition of higher
order terms. Local definitions of functions can use the same syntax as
global ones.
For example, the tactic <a class="reference internal" href="#coq:tacn.pose-ssreflect" title="pose (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span></code></a> supports parameters:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk2" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk2"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk3" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk3"><span class="highlight"><span class="nb">pose</span> f x y := x + y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : nat =&gt; x + y</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat -&gt; nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div></div>
<p>The <span class="smallcaps">SSReflect</span> pose tactic also supports (co)fixpoints, by providing
the local counterpart of the <code class="docutils literal notranslate"><span class="pre">Fixpoint</span> <span class="pre">f</span> <span class="pre">:=</span> <span class="pre">…</span></code> and <code class="docutils literal notranslate"><span class="pre">CoFixpoint</span> <span class="pre">f</span> <span class="pre">:=</span> <span class="pre">…</span></code>
constructs. For instance, the following tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">pose fix</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">{</span><span class="kr">struct</span> <span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="kr">is</span> <span class="n">S</span> <span class="n">p</span> <span class="kr">then</span> <span class="n">S</span> <span class="o">(</span><span class="n">f</span> <span class="n">p</span> <span class="n">y</span><span class="o">)</span> <span class="kr">else</span> <span class="mi">0</span><span class="o">.</span>
</pre></div>
</div>
<p>defines a local fixpoint <code class="docutils literal notranslate"><span class="pre">f</span></code>, which mimics the standard plus operation
on natural numbers.</p>
<p>Similarly, local cofixpoints can be defined by a tactic of the form:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">pose cofix</span> <span class="n">f</span> <span class="o">(</span><span class="n">arg</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">:=</span> <span class="o">…</span> <span class="o">.</span>
</pre></div>
</div>
<p>The possibility to include wildcards in the body of the definitions
offers a smooth way of defining local abstractions. The type of
“holes” is guessed by type inference, and the holes are abstracted.
For instance the tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">pose</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">.</span>
</pre></div>
</div>
<p>is shorthand for:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">pose</span> <span class="n">f</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">.</span>
</pre></div>
</div>
<p>When the local definition of a function involves both arguments and
holes, hole abstractions appear first. For instance, the tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">pose</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">_</span><span class="o">.</span>
</pre></div>
</div>
<p>is shorthand for:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">pose</span> <span class="n">f</span> <span class="n">n</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span>
</pre></div>
</div>
<p>The interaction of the pose tactic with the interpretation of implicit
arguments results in a powerful and concise syntax for local
definitions involving dependent types. For instance, the tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">pose</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">).</span>
</pre></div>
</div>
<p>adds to the context the local definition:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">pose</span> <span class="n">f</span> <span class="o">(</span><span class="n">Tx</span> <span class="n">Ty</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Tx</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Ty</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">).</span>
</pre></div>
</div>
<p>The generalization of wildcards makes the use of the pose tactic
resemble ML-like definitions of polymorphic functions.</p>
</div>
<div class="section" id="abbreviations">
<span id="abbreviations-ssr"></span><h3>Abbreviations<a class="headerlink" href="#abbreviations" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.set-ssreflect">
<code class="sig-name descname"><span class="notation"><span>set</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <span class="hole">term</span></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.set-ssreflect" title="Permalink to this definition">¶</a></dt>
<dd><p>The <span class="smallcaps">SSReflect</span> <code class="docutils literal notranslate"><span class="pre">set</span></code> tactic performs abbreviations: it introduces a
defined constant for a subterm appearing in the goal and/or in the
context.</p>
<p><span class="smallcaps">SSReflect</span> extends the <a class="reference internal" href="tactics.html#coq:tacn.set" title="set"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">set</span></code></a> tactic by supplying:</p>
<ul class="simple">
<li><p>an open syntax, similarly to the <a class="reference internal" href="#coq:tacn.pose-ssreflect" title="pose (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span> <span class="pre">(ssreflect)</span></code></a> tactic;</p></li>
<li><p>a more aggressive matching algorithm;</p></li>
<li><p>an improved interpretation of wildcards, taking advantage of the
matching algorithm;</p></li>
<li><p>an improved occurrence selection mechanism allowing to abstract only
selected occurrences of a term.</p></li>
</ul>
</dd></dl>

<dl class="coq prodn">
<dt id="grammar-token-occ_switch">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">occ_switch</span> <span class="pre">::=</span> </code><span class="notation"><span class="curlies">{ <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span>+</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>-</span></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">*</span></span> }</span></span></code><a class="headerlink" href="#grammar-token-occ_switch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>where:</p>
<ul class="simple">
<li><p><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is a fresh identifier chosen by the user.</p></li>
<li><p>term 1 is an optional type annotation. The type annotation term 1
can be given in open syntax (no surrounding parentheses). If no
<a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> (described hereafter) is present,
it is also the case for the second <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.
On the other hand, in presence of <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a>, parentheses
surrounding the second <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> are mandatory.</p></li>
<li><p>In the occurrence switch <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a>, if the first element of the
list is a natural, this element should be a number, and not an Ltac
variable. The empty list <code class="docutils literal notranslate"><span class="pre">{}</span></code> is not interpreted as a valid occurrence
switch, it is rather used as a flag to signal the intent of the user to
clear the name following it (see <a class="reference internal" href="#ssr-rewrite-occ-switch"><span class="std std-ref">Occurrence switches and redex switches</span></a> and
<a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>)</p></li>
</ul>
<p>The tactic:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk4" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk4"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> :  f x + f x = f x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">f x + f x = f x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk5" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk5"><span class="highlight"><span class="nb">set</span> t := f _.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">f x</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">t + t = t</span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk6" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk6"><span class="highlight"><span class="nb">set</span> t := {<span class="mi">2</span>}(f _).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">f x</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">f x + t = f x</span></div></blockquote></div></div></small></span></pre></div></div>
<p>The type annotation may contain wildcards, which will be filled
with the appropriate value by the matching process.</p>
<p>The tactic first tries to find a subterm of the goal matching
the second <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>
(and its type), and stops at the first subterm it finds. Then
the occurrences of this subterm selected by the optional <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a>
are replaced by <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> and a definition <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span class="hole"><span class="pre">term</span></span></span></code>
is added to the
context. If no <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> is present, then all the occurrences are
abstracted.</p>
<div class="section" id="matching">
<h4>Matching<a class="headerlink" href="#matching" title="Permalink to this headline">¶</a></h4>
<p>The matching algorithm compares a pattern <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> with a subterm of the
goal by comparing their heads and then pairwise unifying their
arguments (modulo conversion). Head symbols match under the following
conditions:</p>
<ul class="simple">
<li><p>If the head of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> is a constant, then it should be syntactically
equal to the head symbol of the subterm.</p></li>
<li><p>If this head is a projection of a canonical structure, then
canonical structure equations are used for the matching.</p></li>
<li><p>If the head of term is <em>not</em> a constant, the subterm should have the
same structure (λ abstraction, let…in structure …).</p></li>
<li><p>If the head of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> is a hole, the subterm should have at least as
many arguments as <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk7" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk7"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : nat) :  x + y = z.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y = z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk8" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk8"><span class="highlight"><span class="nb">set</span> t := _ x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">Nat.add x</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">t y = z</span></div></blockquote></div></div></small></span></pre></div></div>
<ul>
<li><p>In the special case where <code class="docutils literal notranslate"><span class="pre">term</span></code> is of the form
<code class="docutils literal notranslate"><span class="pre">(let</span> <span class="pre">f</span> <span class="pre">:=</span> <span class="pre">t0</span> <span class="pre">in</span> <span class="pre">f)</span> <span class="pre">t1</span> <span class="pre">…</span> <span class="pre">tn</span></code> , then the pattern <code class="docutils literal notranslate"><span class="pre">term</span></code> is treated
as <code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">t1</span> <span class="pre">…</span> <span class="pre">tn)</span></code>. For each
subterm in the goal having the form <code class="docutils literal notranslate"><span class="pre">(A</span> <span class="pre">u1</span> <span class="pre">…</span> <span class="pre">um)</span></code> with m ≥ n, the
matching algorithm successively tries to find the largest partial
application <code class="docutils literal notranslate"><span class="pre">(A</span> <span class="pre">u1</span> <span class="pre">…</span> <span class="pre">uj)</span></code> convertible to the head <code class="docutils literal notranslate"><span class="pre">t0</span></code> of <code class="docutils literal notranslate"><span class="pre">term</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk9" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk9"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : (<span class="kr">let</span> <span class="nv">f</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> := x + y + z <span class="kr">in</span> f <span class="mi">1</span>) <span class="mi">2</span> <span class="mi">3</span> = <span class="mi">6</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">let</span> <span class="nv">f</span> := <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : nat =&gt; x + y + z <span class="kr">in</span> f <span class="mi">1</span>) <span class="mi">2</span> <span class="mi">3</span> = <span class="mi">6</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chka" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chka"><span class="highlight"><span class="nb">set</span> t := (<span class="kr">let</span> <span class="nv">g</span> <span class="nv">y</span> <span class="nv">z</span> := S y + z <span class="kr">in</span> g) <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">unkeyed (<span class="kr">fun</span> <span class="nv">y</span> <span class="nv">z</span> : nat =&gt; S y + z) <span class="mi">2</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">t <span class="mi">3</span> = <span class="mi">6</span></span></div></blockquote></div></div></small></span></pre></div></div>
<p>The notation <code class="docutils literal notranslate"><span class="pre">unkeyed</span></code> defined in <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code> is a shorthand for
the degenerate term <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">…</span> <span class="pre">in</span> <span class="pre">x</span></code>.</p>
</li>
</ul>
<p>Moreover:</p>
<ul>
<li><p>Multiple holes in <code class="docutils literal notranslate"><span class="pre">term</span></code> are treated as independent placeholders.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkb" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkb"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : x + y = z.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y = z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkc" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkc"><span class="highlight"><span class="nb">set</span> t := _ + _.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">x + y</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">t = z</span></div></blockquote></div></div></small></span></pre></div></div>
</li>
<li><p>The type of the subterm matched should fit the type (possibly casted
by some type annotations) of the pattern <code class="docutils literal notranslate"><span class="pre">term</span></code>.</p></li>
<li><p>The replacement of the subterm found by the instantiated pattern
should not capture variables. In the example above <code class="docutils literal notranslate"><span class="pre">x</span></code> is bound
and should not be captured.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkd" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkd"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : <span class="kr">forall</span> <span class="nv">x</span> : nat, x + <span class="mi">1</span> = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : nat, x + <span class="mi">1</span> = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chke" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chke"><span class="highlight"><span class="kn">Fail</span> <span class="nb">set</span> t := _ + <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
The <span class="nb">pattern</span> (_ + <span class="mi">1</span>) did not <span class="kr">match</span> <span class="kn">and</span> has holes.
Did you mean <span class="nb">pose</span>?</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : nat, x + <span class="mi">1</span> = <span class="mi">0</span></span></div></blockquote></div></div></small></span></pre></div></div>
</li>
<li><p>Typeclass inference should fill in any residual hole, but matching
should never assign a value to a global existential variable.</p></li>
</ul>
</div>
<div class="section" id="occurrence-selection">
<span id="occurrence-selection-ssr"></span><h4>Occurrence selection<a class="headerlink" href="#occurrence-selection" title="Permalink to this headline">¶</a></h4>
<p><span class="smallcaps">SSReflect</span> provides a generic syntax for the selection of occurrences
by their position indexes. These <em>occurrence switches</em> are shared by
all <span class="smallcaps">SSReflect</span> tactics which require control on subterm selection like
rewriting, generalization, …</p>
<p>An <em>occurrence switch</em> can be:</p>
<ul>
<li><p>A list natural numbers <code class="docutils literal notranslate"><span class="pre">{+</span> <span class="pre">n1</span> <span class="pre">…</span> <span class="pre">nm}</span></code>
of occurrences affected by the tactic.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkf" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkf"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : f <span class="mi">2</span> + f <span class="mi">8</span> = f <span class="mi">2</span> + f <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">f <span class="mi">2</span> + f <span class="mi">8</span> = f <span class="mi">2</span> + f <span class="mi">2</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk10" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk10"><span class="highlight"><span class="nb">set</span> x := {+<span class="mi">1</span> <span class="mi">3</span>}(f <span class="mi">2</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">f <span class="mi">2</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + f <span class="mi">8</span> = f <span class="mi">2</span> + x</span></div></blockquote></div></div></small></span></pre></div></div>
<p>Notice that some occurrences of a given term may be
hidden to the user, for example because of a notation. The vernacular
<code class="docutils literal notranslate"><span class="pre">Set</span> <span class="pre">Printing</span> <span class="pre">All</span></code> command displays all these hidden occurrences and
should be used to find the correct coding of the occurrences to be
selected <a class="footnote-reference brackets" href="#id15" id="id1">11</a>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;a &lt; b&quot;</span>:= (le (S a) b).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk11" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk11"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span> : x &lt; y -&gt; S x &lt; S y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt; y -&gt; S x &lt; S y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk12" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk12"><span class="highlight"><span class="nb">set</span> t := S x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">S x</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">t &lt;= y -&gt; t &lt; S y</span></div></blockquote></div></div></small></span></pre></div></div>
</li>
<li><p>A list of natural numbers between <code class="docutils literal notranslate"><span class="pre">{n1</span> <span class="pre">…</span> <span class="pre">nm}</span></code>.
This is equivalent to the previous <code class="docutils literal notranslate"><span class="pre">{+</span> <span class="pre">n1</span> <span class="pre">…</span> <span class="pre">nm}</span></code> but the list
should start with a number, and not with an Ltac variable.</p></li>
<li><p>A list <code class="docutils literal notranslate"><span class="pre">{-</span> <span class="pre">n1</span> <span class="pre">…</span> <span class="pre">nm}</span></code> of occurrences <em>not</em> to be affected by the
tactic.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk13" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk13"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : f <span class="mi">2</span> + f <span class="mi">8</span> = f <span class="mi">2</span> + f <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">f <span class="mi">2</span> + f <span class="mi">8</span> = f <span class="mi">2</span> + f <span class="mi">2</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk14" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk14"><span class="highlight"><span class="nb">set</span> x := {-<span class="mi">2</span>}(f <span class="mi">2</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">f <span class="mi">2</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + f <span class="mi">8</span> = f <span class="mi">2</span> + x</span></div></blockquote></div></div></small></span></pre></div></div>
<p>Note that, in this goal, it behaves like <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">{1</span> <span class="pre">3}(f</span> <span class="pre">2).</span></code></p>
</li>
<li><p>In particular, the switch <code class="docutils literal notranslate"><span class="pre">{+}</span></code> selects <em>all</em> the occurrences. This
switch is useful to turn off the default behavior of a tactic which
automatically clears some assumptions (see section <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a> for
instance).</p></li>
<li><p>The switch <code class="docutils literal notranslate"><span class="pre">{-}</span></code> imposes that <em>no</em> occurrences of the term should be
affected by the tactic. The tactic: <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">{-}(f</span> <span class="pre">2).</span></code> leaves the goal
unchanged and adds the definition <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:=</span> <span class="pre">f</span> <span class="pre">2</span></code> to the context. This kind
of tactic may be used to take advantage of the power of the matching
algorithm in a local definition, instead of copying large terms by
hand.</p></li>
</ul>
<p>It is important to remember that matching <em>precedes</em> occurrence
selection.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk15" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk15"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : x + y = x + y + z.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y = x + y + z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk16" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk16"><span class="highlight"><span class="nb">set</span> a := {<span class="mi">2</span>}(_ + _).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">x + y</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y = a + z</span></div></blockquote></div></div></small></span></pre></div></div>
</div></blockquote>
<p>Hence, in the following goal, the same tactic fails since there is
only one occurrence of the selected term.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk17" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk17"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : (x + y) + (z + z) = z + z.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y + (z + z) = z + z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk18" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk18"><span class="highlight"><span class="kn">Fail</span> <span class="nb">set</span> a := {<span class="mi">2</span>}(_ + _).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
Only <span class="mi">1</span> &lt; <span class="mi">2</span> occurrence of (x + y + (z + z))</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y + (z + z) = z + z</span></div></blockquote></div></div></small></span></pre></div></div>
</div></blockquote>
</div>
</div>
<div class="section" id="basic-localization">
<span id="basic-localization-ssr"></span><h3>Basic localization<a class="headerlink" href="#basic-localization" title="Permalink to this headline">¶</a></h3>
<p>It is possible to define an abbreviation for a term appearing in the
context of a goal thanks to the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>set</span> <span class="hole">ident</span> <span>:=</span> <span class="hole">term</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><blockquote>
<div><p>This variant of <a class="reference internal" href="#coq:tacn.set-ssreflect" title="set (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">set</span> <span class="pre">(ssreflect)</span></code></a> introduces a defined constant
called <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> in the context, and folds it in
the context entries mentioned on the right hand side of <code class="docutils literal notranslate"><span class="pre">in</span></code>.
The body of <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is the first subterm matching these context
entries (taken in the given order).</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk19" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk19"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> <span class="nv">t</span> (<span class="nv">Hx</span> : x = <span class="mi">3</span>) : x + t = <span class="mi">4</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, t</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hx</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">3</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + t = <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk1a" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk1a"><span class="highlight"><span class="nb">set</span> z := <span class="mi">3</span> <span class="kr">in</span> Hx.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, t</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="mi">3</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hx</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = z</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + t = <span class="mi">4</span></span></div></blockquote></div></div></small></span></pre></div></div>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>set</span> <span class="hole">ident</span> <span>:=</span> <span class="hole">term</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>*</span></span></code></dt>
<dd><blockquote>
<div><p>This variant matches <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> and then folds <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> similarly
in all the given context entries but also folds <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> in the goal.</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk1b"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> <span class="nv">t</span> (<span class="nv">Hx</span> : x = <span class="mi">3</span>) : x + t = <span class="mi">4</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, t</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hx</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">3</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + t = <span class="mi">4</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk1c"><span class="highlight"><span class="nb">set</span> z := <span class="mi">3</span> <span class="kr">in</span> Hx * .</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, t</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="mi">3</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hx</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = z</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + t = S z</span></div></blockquote></div></div></small></span></pre></div><p>Indeed, remember that 4 is just a notation for (S 3).</p>
</div>
</dd></dl>

<p>The use of the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical is not limited to the localization of
abbreviations: for a complete description of the in tactical, see
section <a class="reference internal" href="#bookkeeping-ssr"><span class="std std-ref">Bookkeeping</span></a> and <a class="reference internal" href="#localization-ssr"><span class="std std-ref">Localization</span></a>.</p>
</div>
</div>
<div class="section" id="basic-tactics">
<span id="basic-tactics-ssr"></span><h2>Basic tactics<a class="headerlink" href="#basic-tactics" title="Permalink to this headline">¶</a></h2>
<p>A sizable fraction of proof scripts consists of steps that do not
&quot;prove&quot; anything new, but instead perform menial bookkeeping tasks
such as selecting the names of constants and assumptions or splitting
conjuncts. Although they are logically trivial, bookkeeping steps are
extremely important because they define the structure of the data-flow
of a proof script. This is especially true for reflection-based
proofs, which often involve large numbers of constants and
assumptions. Good bookkeeping consists in always explicitly declaring
(i.e., naming) all new constants and assumptions in the script, and
systematically pruning irrelevant constants and assumptions in the
context. This is essential in the context of an interactive
development environment (IDE), because it facilitates navigating the
proof, allowing to instantly &quot;jump back&quot; to the point at which a
questionable assumption was added, and to find relevant assumptions by
browsing the pruned context. While novice or casual <span class="smallcaps">Coq</span> users may find
the automatic name selection feature convenient, the usage of such a
feature severely undermines the readability and maintainability of
proof scripts, much like automatic variable declaration in programming
languages. The <span class="smallcaps">SSReflect</span> tactics are therefore designed to support
precise bookkeeping and to eliminate name generation heuristics. The
bookkeeping features of <span class="smallcaps">SSReflect</span> are implemented as tacticals (or
pseudo-tacticals), shared across most <span class="smallcaps">SSReflect</span> tactics, and thus form
the foundation of the <span class="smallcaps">SSReflect</span> proof language.</p>
<div class="section" id="bookkeeping">
<span id="bookkeeping-ssr"></span><h3>Bookkeeping<a class="headerlink" href="#bookkeeping" title="Permalink to this headline">¶</a></h3>
<p>During the course of a proof <span class="smallcaps">Coq</span> always present the user with a
<em>sequent</em> whose general form is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ci : Ti
…
dj := ej : Tj
…
Fk : Pk
…
=================
forall (xl : Tl) …,
let ym := bm in … in
Pn -&gt; … -&gt; C
</pre></div>
</div>
<p>The <em>goal</em> to be proved appears below the double line; above the line
is the <em>context</em> of the sequent, a set of declarations of <em>constants</em>
<code class="docutils literal notranslate"><span class="pre">ci</span></code> , <em>defined constants</em> <code class="docutils literal notranslate"><span class="pre">dj</span></code> , and <em>facts</em> <code class="docutils literal notranslate"><span class="pre">Fk</span></code> that can be used to
prove the goal (usually, <code class="docutils literal notranslate"><span class="pre">Ti</span></code> , <code class="docutils literal notranslate"><span class="pre">Tj</span> <span class="pre">:</span> <span class="pre">Type</span></code> and <code class="docutils literal notranslate"><span class="pre">Pk</span> <span class="pre">:</span> <span class="pre">Prop</span></code>).
The various
kinds of declarations can come in any order. The top part of the
context consists of declarations produced by the Section
commands <code class="docutils literal notranslate"><span class="pre">Variable</span></code>, <code class="docutils literal notranslate"><span class="pre">Let</span></code>, and <code class="docutils literal notranslate"><span class="pre">Hypothesis</span></code>.
This <em>section context</em> is never
affected by the <span class="smallcaps">SSReflect</span> tactics: they only operate on the lower part
— the <em>proof context</em>. As in the figure above, the goal often
decomposes into a series of (universally) quantified <em>variables</em>
<code class="docutils literal notranslate"><span class="pre">(xl</span> <span class="pre">:</span> <span class="pre">Tl)</span></code>, local <em>definitions</em>
<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">ym</span> <span class="pre">:=</span> <span class="pre">bm</span> <span class="pre">in</span></code>, and <em>assumptions</em>
<code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">n</span> <span class="pre">-&gt;</span></code>,
and a <em>conclusion</em> <code class="docutils literal notranslate"><span class="pre">C</span></code> (as in the context, variables, definitions, and
assumptions can appear in any order). The conclusion is what actually
needs to be proved — the rest of the goal can be seen as a part of the
proof context that happens to be “below the line”.</p>
<p>However, although they are logically equivalent, there are fundamental
differences between constants and facts on the one hand, and variables
and assumptions on the others. Constants and facts are <em>unordered</em>,
but <em>named</em> explicitly in the proof text; variables and assumptions
are <em>ordered</em>, but <em>unnamed</em>: the display names of variables may
change at any time because of α-conversion.</p>
<p>Similarly, basic deductive steps such as apply can only operate on the
goal because the <span class="smallcaps">Gallina</span> terms that control their action (e.g., the
type of the lemma used by <code class="docutils literal notranslate"><span class="pre">apply</span></code>) only provide unnamed bound variables.
<a class="footnote-reference brackets" href="#id16" id="id2">12</a> Since the proof script can only refer directly to the context, it
must constantly shift declarations from the goal to the context and
conversely in between deductive steps.</p>
<p>In <span class="smallcaps">SSReflect</span> these moves are performed by two <em>tacticals</em> <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> and
<code class="docutils literal notranslate"><span class="pre">:</span></code>, so that the bookkeeping required by a deductive step can be
directly associated to that step, and that tactics in an <span class="smallcaps">SSReflect</span>
script correspond to actual logical steps in the proof rather than
merely shuffle facts. Still, some isolated bookkeeping is unavoidable,
such as naming variables and assumptions at the beginning of a
proof. <span class="smallcaps">SSReflect</span> provides a specific <code class="docutils literal notranslate"><span class="pre">move</span></code> tactic for this purpose.</p>
<p>Now <code class="docutils literal notranslate"><span class="pre">move</span></code> does essentially nothing: it is mostly a placeholder for
<code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">:</span></code>. The <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tactical moves variables, local definitions,
and assumptions to the context, while the <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical moves facts and
constants to the goal.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>For example, the proof of <a class="footnote-reference brackets" href="#id17" id="id3">13</a></p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk1d" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk1d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">subnK</span> : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span>, n &lt;= m -&gt; m - n + n = m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> : nat, n &lt;= m -&gt; m - n + n = m</span></div></blockquote></div></div></small></span></pre></div><p>might start with</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk1e"><span class="highlight"><span class="nb">move</span>=&gt; m n le_n_m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n_m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">m - n + n = m</span></div></blockquote></div></div></small></span></pre></div><p>where move does nothing, but <code class="docutils literal notranslate"><span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">n</span> <span class="pre">le_m_n</span></code> changes
the variables and assumption of the goal in the constants
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">n</span> <span class="pre">:</span> <span class="pre">nat</span></code> and the fact <code class="docutils literal notranslate"><span class="pre">le_n_m</span> <span class="pre">:</span> <span class="pre">n</span> <span class="pre">&lt;=</span>&#160; <span class="pre">m</span></code>, thus exposing the
conclusion <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">m</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical is the converse of <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>, indeed it removes facts and
constants from the context by turning them into variables and
assumptions.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk1f"><span class="highlight"><span class="nb">move</span>: m le_n_m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">m</span> : nat, n &lt;= m -&gt; m - n + n = m</span></div></blockquote></div></div></small></span></pre></div><p>turns back <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">le_m_n</span></code> into a variable and an assumption,
removing them from the proof context, and changing the goal to
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">m,</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">m</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">m</span></code>
which can be proved by induction on <code class="docutils literal notranslate"><span class="pre">n</span></code> using <code class="docutils literal notranslate"><span class="pre">elim:</span> <span class="pre">n</span></code>.</p>
</div>
<p>Because they are tacticals, <code class="docutils literal notranslate"><span class="pre">:</span></code> and <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> can be combined, as in</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">move</span><span class="o">:</span> <span class="n">m</span> <span class="n">le_n_m</span> <span class="o">=&gt;</span> <span class="n">p</span> <span class="n">le_n_p</span><span class="o">.</span>
</pre></div>
</div>
<p>simultaneously renames <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">le_m_n</span></code> into <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">le_n_p</span></code>,
respectively, by first turning them into unnamed variables, then
turning these variables back into constants and facts.</p>
<p>Furthermore, <span class="smallcaps">SSReflect</span> redefines the basic <span class="smallcaps">Coq</span> tactics <code class="docutils literal notranslate"><span class="pre">case</span></code>, <code class="docutils literal notranslate"><span class="pre">elim</span></code>,
and <code class="docutils literal notranslate"><span class="pre">apply</span></code> so that they can take better advantage of
<code class="docutils literal notranslate"><span class="pre">:</span></code> and <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>. In there
<span class="smallcaps">SSReflect</span> variants, these tactic operate on the first variable or
constant of the goal and they do not use or change the proof context.
The <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical is used to operate on an element in the context.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>For instance the proof of <code class="docutils literal notranslate"><span class="pre">subnK</span></code> could continue with <code class="docutils literal notranslate"><span class="pre">elim:</span> <span class="pre">n</span></code>.
Instead of <code class="docutils literal notranslate"><span class="pre">elim</span> <span class="pre">n</span></code> (note, no colon), this has the advantage of
removing n from the context. Better yet, this <code class="docutils literal notranslate"><span class="pre">elim</span></code> can be combined
with previous move and with the branching version of the <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tactical
(described in <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>),
to encapsulate the inductive step in a single
command:</p>
</div></blockquote>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk20" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk20"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">subnK</span> : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span>, n &lt;= m -&gt; m - n + n = m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> : nat, n &lt;= m -&gt; m - n + n = m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk21" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk21"><span class="highlight"><span class="nb">move</span>=&gt; m n le_n_m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n_m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= m</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">m - n + n = m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk22" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk22"><span class="highlight"><span class="nb">elim</span>: n m le_n_m =&gt; [|n IHn] m =&gt; [_ | lt_n_m].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">m - <span class="mi">0</span> + <span class="mi">0</span> = m</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk23" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">m0</span> : nat, n &lt;= m0 -&gt; m0 - n + n = m0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">lt_n_m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= m</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk23"><hr></label><div class="goal-conclusion"><span class="highlight">m - S n + S n = m</span></div></blockquote></div></div></div></small></span></pre></div><p>which breaks down the proof into two subgoals, the second one
having in its context
<code class="docutils literal notranslate"><span class="pre">lt_n_m</span> <span class="pre">:</span> <span class="pre">S</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">m</span></code> and
<code class="docutils literal notranslate"><span class="pre">IHn</span> <span class="pre">:</span> <span class="pre">forall</span> <span class="pre">m,</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">m</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">m</span></code>.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">:</span></code> and <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tacticals can be explained very simply if one views
the goal as a stack of variables and assumptions piled on a conclusion:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code> pushes the context constants <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code> as goal
variables <em>before</em> performing tactic.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code> pops the top three goal variables as context
constants <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, <em>after</em> tactic has been performed.</p></li>
</ul>
<p>These pushes and pops do not need to balance out as in the examples
above, so <code class="docutils literal notranslate"><span class="pre">move:</span> <span class="pre">m</span> <span class="pre">le_n_m</span> <span class="pre">=&gt;</span> <span class="pre">p</span></code>
would rename <code class="docutils literal notranslate"><span class="pre">m</span></code> into <code class="docutils literal notranslate"><span class="pre">p</span></code>, but leave an extra assumption <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">p</span></code>
in the goal.</p>
<p>Basic tactics like apply and elim can also be used without the ’:’
tactical: for example we can directly start a proof of <code class="docutils literal notranslate"><span class="pre">subnK</span></code> by
induction on the top variable <code class="docutils literal notranslate"><span class="pre">m</span></code> with</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">elim</span><span class="o">=&gt;</span> <span class="o">[|</span><span class="n">m</span> <span class="n">IHm</span><span class="o">]</span> <span class="n">n</span> <span class="n">le_n</span><span class="o">.</span>
</pre></div>
</div>
<p>The general form of the localization tactical in is also best
explained in terms of the goal stack:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>tactic in a H1 H2 *.
</pre></div>
</div>
<p>is basically equivalent to</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">move</span><span class="o">:</span> <span class="n">a</span> <span class="n">H1</span> <span class="n">H2</span><span class="o">;</span> <span class="n">tactic</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="n">H1</span> <span class="n">H2</span><span class="o">.</span>
</pre></div>
</div>
<p>with two differences: the in tactical will preserve the body of an if a
is a defined constant, and if the <code class="docutils literal notranslate"><span class="pre">*</span></code> is omitted it will use a
temporary abbreviation to hide the statement of the goal from
<code class="docutils literal notranslate"><span class="pre">tactic</span></code>.</p>
<p>The general form of the in tactical can be used directly with the
<code class="docutils literal notranslate"><span class="pre">move</span></code>, <code class="docutils literal notranslate"><span class="pre">case</span></code> and <code class="docutils literal notranslate"><span class="pre">elim</span></code> tactics, so that one can write</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">elim</span><span class="o">:</span> <span class="n">n</span> <span class="o">=&gt;</span> <span class="o">[|</span><span class="n">n</span> <span class="n">IHn</span><span class="o">]</span> <span class="kr">in</span> <span class="n">m</span> <span class="n">le_n_m</span> <span class="o">*.</span>
</pre></div>
</div>
<p>instead of</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">elim</span><span class="o">:</span> <span class="n">n</span> <span class="n">m</span> <span class="n">le_n_m</span> <span class="o">=&gt;</span> <span class="o">[|</span><span class="n">n</span> <span class="n">IHn</span><span class="o">]</span> <span class="n">m</span> <span class="n">le_n_m</span><span class="o">.</span>
</pre></div>
</div>
<p>This is quite useful for inductive proofs that involve many facts.</p>
<p>See section <a class="reference internal" href="#localization-ssr"><span class="std std-ref">Localization</span></a> for
the general syntax and presentation of the in
tactical.</p>
</div>
<div class="section" id="the-defective-tactics">
<span id="the-defective-tactics-ssr"></span><h3>The defective tactics<a class="headerlink" href="#the-defective-tactics" title="Permalink to this headline">¶</a></h3>
<p>In this section we briefly present the three basic tactics performing
context manipulations and the main backward chaining tool.</p>
<div class="section" id="the-move-tactic">
<h4>The move tactic.<a class="headerlink" href="#the-move-tactic" title="Permalink to this headline">¶</a></h4>
<dl class="coq tacn">
<dt id="coq:tacn.move">
<code class="sig-name descname"><span class="notation"><span>move</span></span></code><a class="headerlink" href="#coq:tacn.move" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic, in its defective form, behaves like the <a class="reference internal" href="tactics.html#coq:tacn.hnf" title="hnf"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">hnf</span></code></a> tactic.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> ssreflect.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk24" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk24"><span class="highlight"><span class="kn">Goal</span> not <span class="kt">False</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk25" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk25"><span class="highlight"><span class="nb">move</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span> -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small></span></pre></div></div>
<p>More precisely, the <a class="reference internal" href="#coq:tacn.move" title="move"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">move</span></code></a> tactic inspects the goal and does nothing
(<a class="reference internal" href="ltac.html#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a>) if an introduction step is possible, i.e. if the goal is a
product or a <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">…</span> <span class="pre">in</span></code>, and performs <a class="reference internal" href="tactics.html#coq:tacn.hnf" title="hnf"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">hnf</span></code></a> otherwise.</p>
<p>Of course this tactic is most often used in combination with the bookkeeping
tacticals (see section <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a> and <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>).
These combinations mostly subsume the <a class="reference internal" href="tactics.html#coq:tacv.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.generalize" title="generalize"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">generalize</span></code></a>,
<a class="reference internal" href="tactics.html#coq:tacn.revert" title="revert"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">revert</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.rename" title="rename"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rename</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.clear" title="clear"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">clear</span></code></a> and <a class="reference internal" href="tactics.html#coq:tacn.pattern" title="pattern"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pattern</span></code></a> tactics.</p>
</dd></dl>

</div>
<div class="section" id="the-case-tactic">
<h4>The case tactic<a class="headerlink" href="#the-case-tactic" title="Permalink to this headline">¶</a></h4>
<dl class="coq tacn">
<dt id="coq:tacn.case-ssreflect">
<code class="sig-name descname"><span class="notation"><span>case</span></span></code><a class="headerlink" href="#coq:tacn.case-ssreflect" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic performs <em>primitive case analysis</em> on (co)inductive
types; specifically, it destructs the top variable or assumption of
the goal, exposing its constructor(s) and its arguments, as well as
setting the value of its type family indices if it belongs to a type
family (see section <a class="reference internal" href="#type-families-ssr"><span class="std std-ref">Type families</span></a>).</p>
<p>The <span class="smallcaps">SSReflect</span> case tactic has a special behavior on equalities. If the
top assumption of the goal is an equality, the case tactic “destructs”
it as a set of equalities between the constructor arguments of its
left and right hand sides, as per the tactic injection. For example,
<code class="docutils literal notranslate"><span class="pre">case</span></code> changes the goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(x, y) = (1, 2) -&gt; G.
</pre></div>
</div>
<p>into:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>x = 1 -&gt; y = 2 -&gt; G.
</pre></div>
</div>
<p>Note also that the case of <span class="smallcaps">SSReflect</span> performs <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">False</span></span></code> elimination, even
if no branch is generated by this case operation. Hence the tactic
<a class="reference internal" href="tactics.html#coq:tacn.case" title="case"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">case</span></code></a> on a goal of the form <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">False</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">G</span></span></code> will succeed and
prove the goal.</p>
</dd></dl>

</div>
<div class="section" id="the-elim-tactic">
<h4>The elim tactic<a class="headerlink" href="#the-elim-tactic" title="Permalink to this headline">¶</a></h4>
<dl class="coq tacn">
<dt id="coq:tacn.elim-ssreflect">
<code class="sig-name descname"><span class="notation"><span>elim</span></span></code><a class="headerlink" href="#coq:tacn.elim-ssreflect" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic performs inductive elimination on inductive types. In its
defective form, the tactic performs inductive elimination on a goal whose
top assumption has an inductive type.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk26" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk26"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">m</span> : <span class="kr">forall</span> <span class="nv">n</span> : nat, m &lt;= n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, m &lt;= n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk27" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk27"><span class="highlight"><span class="nb">elim</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">m &lt;= <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk28" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk28"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, m &lt;= n -&gt; m &lt;= S n</span></div></blockquote></div></div></div></small></span></pre></div></div>
</dd></dl>

</div>
<div class="section" id="the-apply-tactic">
<span id="apply-ssr"></span><h4>The apply tactic<a class="headerlink" href="#the-apply-tactic" title="Permalink to this headline">¶</a></h4>
<dl class="coq tacn">
<dt id="coq:tacn.apply-ssreflect">
<code class="sig-name descname"><span class="notation"><span>apply</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">term</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.apply-ssreflect" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the main backward chaining tactic of the proof system.
It takes as argument any <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> and applies it to the goal.
Assumptions in the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> that don’t directly match the goal
may generate one or more subgoals.</p>
<p>In its defective form, this tactic is a synonym for:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>intro top; first [refine top | refine (top _) | refine (top _ _) | …]; clear top.
</pre></div>
</div>
<p>where <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">top</span></span></code> is a fresh name, and the sequence of <a class="reference internal" href="tactics.html#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> tactics
tries to catch the appropriate number of wildcards to be inserted. Note that
this use of the <a class="reference internal" href="tactics.html#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> tactic implies that the tactic tries to match
the goal up to expansion of constants and evaluation of subterms.</p>
</dd></dl>

<p><a class="reference internal" href="#coq:tacn.apply-ssreflect" title="apply (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span> <span class="pre">(ssreflect)</span></code></a> has a special behavior on goals containing
existential metavariables of sort <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk29" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk29"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : <span class="kr">forall</span> <span class="nv">y</span>, <span class="mi">1</span> &lt; y -&gt; y &lt; <span class="mi">2</span> -&gt; <span class="kr">exists</span> <span class="nv">x</span> : { n | n &lt; <span class="mi">3</span> }, <span class="mi">0</span> &lt; proj1_sig x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : nat,
<span class="mi">1</span> &lt; y -&gt;
y &lt; <span class="mi">2</span> -&gt; <span class="kr">exists</span> <span class="nv">x</span> : {n : nat | n &lt; <span class="mi">3</span>}, <span class="mi">0</span> &lt; proj1_sig x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk2a" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk2a"><span class="highlight"><span class="nb">move</span>=&gt; y y_gt1 y_lt2; <span class="nb">apply</span>: (ex_intro _ (exist _ y _)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y_gt1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">1</span> &lt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y_lt2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y &lt; <span class="mi">2</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">y &lt; <span class="mi">3</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk2b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y_gt1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">1</span> &lt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y_lt2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y &lt; <span class="mi">2</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk2b"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">Hyp0</span> : y &lt; <span class="mi">3</span>,
<span class="mi">0</span> &lt; proj1_sig (exist (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; n &lt; <span class="mi">3</span>) y Hyp0)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk2c" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk2c"><span class="highlight"><span class="bp">by</span> <span class="nb">apply</span>: lt_trans y_lt2 _.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y_gt1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">1</span> &lt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y_lt2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y &lt; <span class="mi">2</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">Hyp0</span> : y &lt; <span class="mi">3</span>,
<span class="mi">0</span> &lt; proj1_sig (exist (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; n &lt; <span class="mi">3</span>) y Hyp0)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">by</span> <span class="nb">move</span>=&gt; y_lt3; <span class="nb">apply</span>: lt_trans y_gt1.</span></span></span></pre></div><p>Note that the last <code class="docutils literal notranslate"><span class="pre">_</span></code> of the tactic
<code class="docutils literal notranslate"><span class="pre">apply:</span> <span class="pre">(ex_intro</span> <span class="pre">_</span> <span class="pre">(exist</span> <span class="pre">_</span> <span class="pre">y</span> <span class="pre">_))</span></code>
represents a proof that <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">3</span></code>. Instead of generating the goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>0 &lt; proj1_sig (exist (fun n : nat =&gt; n &lt; 3) y ?Goal).
</pre></div>
</div>
<p>the system tries to prove <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">3</span></code> calling the trivial tactic.
If it succeeds, let’s say because the context contains
<code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">:</span> <span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">3</span></code>, then the
system generates the following goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>0 &lt; proj1_sig (exist (fun n =&gt; n &lt; 3) y H).
</pre></div>
</div>
<p>Otherwise the missing proof is considered to be irrelevant, and is
thus discharged generating the two goals shown above.</p>
<p>Last, the user can replace the trivial tactic by defining an Ltac
expression named <code class="docutils literal notranslate"><span class="pre">ssrautoprop</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="discharge">
<span id="discharge-ssr"></span><h3>Discharge<a class="headerlink" href="#discharge" title="Permalink to this headline">¶</a></h3>
<p>The general syntax of the discharging tactical <code class="docutils literal notranslate"><span class="pre">:</span></code> is:</p>
<dl class="coq tacn">
<dt id="coq:tacn.ssreflect">
<code class="sig-name descname"><span class="notation"><span class="hole">tactic</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.ssreflect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq prodn">
<dt id="grammar-token-d_item">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">d_item</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span></span></span><span class="notation-sup">?</span></span> <span class="hole">term</span></span></code><a class="headerlink" href="#grammar-token-d_item" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq prodn">
<dt id="grammar-token-clear_switch">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">clear_switch</span> <span class="pre">::=</span> </code><span class="notation"><span class="curlies">{ <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> }</span></span></code><a class="headerlink" href="#grammar-token-clear_switch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>with the following requirements:</p>
<ul class="simple">
<li><p><code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code> must be one of the four basic tactics described in <a class="reference internal" href="#the-defective-tactics-ssr"><span class="std std-ref">The defective tactics</span></a>,
i.e., <code class="docutils literal notranslate"><span class="pre">move</span></code>, <code class="docutils literal notranslate"><span class="pre">case</span></code>, <code class="docutils literal notranslate"><span class="pre">elim</span></code> or <code class="docutils literal notranslate"><span class="pre">apply</span></code>, the <code class="docutils literal notranslate"><span class="pre">exact</span></code>
tactic (section <a class="reference internal" href="#terminators-ssr"><span class="std std-ref">Terminators</span></a>),
the <code class="docutils literal notranslate"><span class="pre">congr</span></code> tactic (section <a class="reference internal" href="#congruence-ssr"><span class="std std-ref">Congruence</span></a>),
or the application of the <em>view</em>
tactical ‘/’ (section <a class="reference internal" href="#interpreting-assumptions-ssr"><span class="std std-ref">Interpreting assumptions</span></a>) to one of move, case, or elim.</p></li>
<li><p>The optional <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> specifies <em>equation generation</em> (section <a class="reference internal" href="#generation-of-equations-ssr"><span class="std std-ref">Generation of equations</span></a>),
and is only allowed if tactic is <code class="docutils literal notranslate"><span class="pre">move</span></code>, <code class="docutils literal notranslate"><span class="pre">case</span></code> or <code class="docutils literal notranslate"><span class="pre">elim</span></code>, or the
application of the view tactical ‘/’ (section <a class="reference internal" href="#interpreting-assumptions-ssr"><span class="std std-ref">Interpreting assumptions</span></a>) to <code class="docutils literal notranslate"><span class="pre">case</span></code> or <code class="docutils literal notranslate"><span class="pre">elim</span></code>.</p></li>
<li><p>An <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> selects occurrences of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>, as in <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>; <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a>
is not allowed if <code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code> is <code class="docutils literal notranslate"><span class="pre">apply</span></code> or <code class="docutils literal notranslate"><span class="pre">exact</span></code>.</p></li>
<li><p>A clear item <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> specifies facts and constants to be
deleted from the proof context (as per the clear tactic).</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical first <em>discharges</em> all the <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>, right to left,
and then performs tactic, i.e., for each <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>, starting with the last one :</p>
<ol class="arabic simple">
<li><p>The <span class="smallcaps">SSReflect</span> matching algorithm described in section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a> is
used to find occurrences of term in the goal, after filling any holes
‘_’ in term; however if tactic is apply or exact a different matching
algorithm, described below, is used <a class="footnote-reference brackets" href="#id18" id="id4">14</a>.</p></li>
<li><p>These occurrences are replaced by a new variable; in particular, if
term is a fact, this adds an assumption to the goal.</p></li>
<li><p>If term is <em>exactly</em> the name of a constant or fact in the proof
context, it is deleted from the context, unless there is an
<a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a>.</p></li>
</ol>
<p>Finally, tactic is performed just after the first <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>
has been generalized
— that is, between steps 2 and 3. The names listed in
the final <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> (if it is present) are cleared first, before
<a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> n is discharged.</p>
<p>Switches affect the discharging of a <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> as follows:</p>
<ul class="simple">
<li><p>An <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> restricts generalization (step 2) to a specific subset
of the occurrences of term, as per section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>, and prevents clearing (step
3).</p></li>
<li><p>All the names specified by a <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> are deleted from the
context in step 3, possibly in addition to term.</p></li>
</ul>
<p>For example, the tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">move</span><span class="o">:</span> <span class="n">n</span> <span class="o">{</span><span class="mi">2</span><span class="o">}</span><span class="n">n</span> <span class="o">(</span><span class="n">refl_equal</span> <span class="n">n</span><span class="o">).</span>
</pre></div>
</div>
<ul class="simple">
<li><p>first generalizes <code class="docutils literal notranslate"><span class="pre">(refl_equal</span> <span class="pre">n</span> <span class="pre">:</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">n)</span></code>;</p></li>
<li><p>then generalizes the second occurrence of <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></li>
<li><p>finally generalizes all the other occurrences of <code class="docutils literal notranslate"><span class="pre">n</span></code>, and clears <code class="docutils literal notranslate"><span class="pre">n</span></code>
from the proof context (assuming n is a proof constant).</p></li>
</ul>
<p>Therefore this tactic changes any goal <code class="docutils literal notranslate"><span class="pre">G</span></code> into</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n0</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n0</span> <span class="o">-&gt;</span> <span class="n">G</span><span class="o">.</span>
</pre></div>
</div>
<p>where the name <code class="docutils literal notranslate"><span class="pre">n0</span></code> is picked by the <span class="smallcaps">Coq</span> display function, and assuming
<code class="docutils literal notranslate"><span class="pre">n</span></code> appeared only in <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p>
<p>Finally, note that a discharge operation generalizes defined constants
as variables, and not as local definitions. To override this behavior,
prefix the name of the local definition with a <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, like in <code class="docutils literal notranslate"><span class="pre">move:</span> <span class="pre">&#64;n</span></code>.</p>
<p>This is in contrast with the behavior of the in tactical (see
section <a class="reference internal" href="#localization-ssr"><span class="std std-ref">Localization</span></a>), which preserves local
definitions by default.</p>
<div class="section" id="clear-rules">
<h4>Clear rules<a class="headerlink" href="#clear-rules" title="Permalink to this headline">¶</a></h4>
<p>The clear step will fail if term is a proof constant that appears in
other facts; in that case either the facts should be cleared
explicitly with a <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a>, or the clear step should be disabled.
The latter can be done by adding an <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> or simply by putting
parentheses around term: both
<code class="docutils literal notranslate"><span class="pre">move:</span> <span class="pre">(n).</span></code>
and
<code class="docutils literal notranslate"><span class="pre">move:</span> <span class="pre">{+}n.</span></code>
generalize <code class="docutils literal notranslate"><span class="pre">n</span></code> without clearing <code class="docutils literal notranslate"><span class="pre">n</span></code> from the proof context.</p>
<p>The clear step will also fail if the <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> contains a <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> that
is not in the <em>proof</em> context. Note that <span class="smallcaps">SSReflect</span> never clears a
section constant.</p>
<p>If tactic is <code class="docutils literal notranslate"><span class="pre">move</span></code> or <code class="docutils literal notranslate"><span class="pre">case</span></code> and an equation <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is given, then clear
(step 3) for <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> is suppressed (see section <a class="reference internal" href="#generation-of-equations-ssr"><span class="std std-ref">Generation of equations</span></a>).</p>
<p>Intro patterns (see section <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>)
and the <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> tactic (see section <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a>)
let one place a <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> in the middle of other items
(namely identifiers, views and rewrite rules).  This can trigger the
addition of proof context items to the ones being explicitly
cleared, and in turn this can result in clear errors (e.g. if the
context item automatically added occurs in the goal).  The
relevant sections describe ways to avoid the unintended clear of
context items.</p>
</div>
<div class="section" id="matching-for-apply-and-exact">
<h4>Matching for apply and exact<a class="headerlink" href="#matching-for-apply-and-exact" title="Permalink to this headline">¶</a></h4>
<p>The matching algorithm for <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> of the <span class="smallcaps">SSReflect</span>
<code class="docutils literal notranslate"><span class="pre">apply</span></code> and <code class="docutils literal notranslate"><span class="pre">exact</span></code>
tactics exploits the type of the first <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> to interpret
wildcards in the
other <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> and to determine which occurrences of these should be
generalized. Therefore, occur switches are not needed for apply and
exact.</p>
<p>Indeed, the <span class="smallcaps">SSReflect</span> tactic <code class="docutils literal notranslate"><span class="pre">apply:</span> <span class="pre">H</span> <span class="pre">x</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">refine</span> <span class="pre">(&#64;H</span> <span class="pre">_</span> <span class="pre">…</span> <span class="pre">_</span> <span class="pre">x);</span> <span class="pre">clear</span> <span class="pre">H</span> <span class="pre">x</span></code>
with an appropriate number of wildcards between <code class="docutils literal notranslate"><span class="pre">H</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Note that this means that matching for <code class="docutils literal notranslate"><span class="pre">apply</span></code> and <code class="docutils literal notranslate"><span class="pre">exact</span></code> has much more
context to interpret wildcards; in particular it can accommodate the
<code class="docutils literal notranslate"><span class="pre">_</span></code> <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>, which would always be rejected after <code class="docutils literal notranslate"><span class="pre">move:</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk2d" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk2d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">Hfg</span> : <span class="kr">forall</span> <span class="nv">x</span>, f x = g x) <span class="nv">a</span> <span class="nv">b</span> : f a = g b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">Hfg</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : nat, f x = g x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">f a = g b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk2e"><span class="highlight"><span class="nb">apply</span>: trans_equal (Hfg _) _.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">Hfg</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : nat, f x = g x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">g a = g b</span></div></blockquote></div></div></small></span></pre></div></div>
<p>This tactic is equivalent (see section
<a class="reference internal" href="#bookkeeping-ssr"><span class="std std-ref">Bookkeeping</span></a>) to:
<code class="docutils literal notranslate"><span class="pre">refine</span> <span class="pre">(trans_equal</span> <span class="pre">(Hfg</span> <span class="pre">_)</span> <span class="pre">_).</span></code>
and this is a common idiom for applying transitivity on the left hand
side of an equation.</p>
</div>
<div class="section" id="the-abstract-tactic">
<span id="abstract-ssr"></span><h4>The abstract tactic<a class="headerlink" href="#the-abstract-tactic" title="Permalink to this headline">¶</a></h4>
<dl class="coq tacn">
<dt id="coq:tacn.abstract-ssreflect">
<code class="sig-name descname"><span class="notation"><span>abstract:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn.abstract-ssreflect" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic assigns an abstract constant previously introduced with the
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[:</span></span> <span class="hole"><span class="pre">ident</span></span> <span><span class="pre">]</span></span></span></code> intro pattern (see section <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>).</p>
</dd></dl>

<p>In a goal like the following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>m : nat
abs : &lt;hidden&gt;
n : nat
=============
m &lt; 5 + n
</pre></div>
</div>
<p>The tactic <code class="code highlight coq docutils literal notranslate"><span class="keyword pseudo"><span class="pre">abstract</span></span><span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">abs</span></span> <span class="name"><span class="pre">n</span></span></code> first generalizes the goal with respect to <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>
(that is not visible to the abstract constant abs) and then assigns
abs. The resulting goal is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>m : nat
n : nat
=============
m &lt; 5 + n
</pre></div>
</div>
<p>Once this subgoal is closed, all other goals having abs in their
context see the type assigned to <code class="docutils literal notranslate"><span class="pre">abs</span></code>. In this case:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>m : nat
abs : forall n, m &lt; 5 + n
=============
…
</pre></div>
</div>
<p>For a more detailed example the reader should refer to
section <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a>.</p>
</div>
</div>
<div class="section" id="introduction-in-the-context">
<span id="introduction-ssr"></span><h3>Introduction in the context<a class="headerlink" href="#introduction-in-the-context" title="Permalink to this headline">¶</a></h3>
<p>The application of a tactic to a given goal can generate (quantified)
variables, assumptions, or definitions, which the user may want to
<em>introduce</em> as new facts, constants or defined constants,
respectively. If the tactic splits the goal into several subgoals,
each of them may require the introduction of different constants and
facts. Furthermore it is very common to immediately decompose or
rewrite with an assumption instead of adding it to the context, as the
goal can often be simplified and even proved after this.</p>
<p>All these operations are performed by the introduction tactical <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>,
whose general syntax is</p>
<dl class="coq tacn">
<dt id="coq:tacn.">
<code class="sig-name descname"><span class="notation"><span class="hole">tactic</span> <span>=&gt;</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn." title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq prodn">
<dt id="grammar-token-i_item">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">i_item</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-i_view"><span class="hole">i_view</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-i_block"><span class="hole">i_block</span></a></span></span></span></code><a class="headerlink" href="#grammar-token-i_item" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq prodn">
<dt id="grammar-token-s_item">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">s_item</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span>/=</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>//</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>//=</span></span></span></span></code><a class="headerlink" href="#grammar-token-s_item" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq prodn">
<dt id="grammar-token-i_view">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">i_view</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>{</span><span>}</span></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><span>/</span><span class="hole">term</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>/ltac:(</span> <span class="hole">tactic</span> <span>)</span></span></span></span></code><a class="headerlink" href="#grammar-token-i_view" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq prodn">
<dt id="grammar-token-i_pattern">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">i_pattern</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span class="hole">ident</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>&gt;</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>_</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>?</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>*</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>+</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><span>-&gt;</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>&lt;-</span></span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>[</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">?</span><span class="notation-sub">|</span></span> <span>]</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>-</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>[:</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>]</span></span></span></span></code><a class="headerlink" href="#grammar-token-i_pattern" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq prodn">
<dt id="grammar-token-i_block">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">i_block</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span>[^</span> <span class="hole">ident</span> <span>]</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>[^~</span> <span class="alternative"><span class="alternative-block"><span class="hole">ident</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="hole">num</span></span></span> <span>]</span></span></span></span></code><a class="headerlink" href="#grammar-token-i_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tactical first executes <code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code>, then the <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a>s,
left to right. An <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> specifies a
simplification operation; a <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a>
specifies context pruning as in <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>.
The <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>s can be seen as a variant of <em>intro patterns</em>
(see <a class="reference internal" href="tactics.html#coq:tacv.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a>:) each performs an introduction operation, i.e., pops some
variables or assumptions from the goal.</p>
<div class="section" id="simplification-items">
<h4>Simplification items<a class="headerlink" href="#simplification-items" title="Permalink to this headline">¶</a></h4>
<p>An <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> can simplify the set of subgoals or the subgoals themselves:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">//</span></code> removes all the “trivial” subgoals that can be resolved by the
<span class="smallcaps">SSReflect</span> tactic <a class="reference internal" href="#coq:tacn.done" title="done"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">done</span></code></a> described in <a class="reference internal" href="#terminators-ssr"><span class="std std-ref">Terminators</span></a>, i.e.,
it executes <code class="docutils literal notranslate"><span class="pre">try</span> <span class="pre">done</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/=</span></code> simplifies the goal by performing partial evaluation, as per the
tactic <a class="reference internal" href="tactics.html#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a> <a class="footnote-reference brackets" href="#id19" id="id5">15</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">//=</span></code> combines both kinds of simplification; it is equivalent to
<code class="docutils literal notranslate"><span class="pre">/=</span> <span class="pre">//</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">simpl;</span> <span class="pre">try</span> <span class="pre">done</span></code>.</p></li>
</ul>
<p>When an <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> immediately precedes a <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a>, then the
<a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> is executed
<em>after</em> the <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a>, e.g., <code class="docutils literal notranslate"><span class="pre">{IHn}//</span></code> will solve some subgoals,
possibly using the fact <code class="docutils literal notranslate"><span class="pre">IHn</span></code>, and will erase <code class="docutils literal notranslate"><span class="pre">IHn</span></code> from the context
of the remaining subgoals.</p>
</div>
<div class="section" id="views">
<h4>Views<a class="headerlink" href="#views" title="Permalink to this headline">¶</a></h4>
<p>The first entry in the <a class="reference internal" href="#grammar-token-i_view"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_view</span></code></a> grammar rule, <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">/</span></span><span class="hole"><span class="pre">term</span></span></span></code>,
represents a view (see section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>).
It interprets the top of the stack with the view <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.
It is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">move/</span></span><span class="hole"><span class="pre">term</span></span></span></code>.</p>
<p>A <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> that immediately precedes an <a class="reference internal" href="#grammar-token-i_view"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_view</span></code></a>
is complemented with the name of the view if an only if the <a class="reference internal" href="#grammar-token-i_view"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_view</span></code></a>
is a simple proof context entry <a class="footnote-reference brackets" href="#id24" id="id6">20</a>.
E.g. <code class="docutils literal notranslate"><span class="pre">{}/v</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">/v{v}</span></code>.
This behavior can be avoided by separating the <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a>
from the <a class="reference internal" href="#grammar-token-i_view"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_view</span></code></a> with the <code class="docutils literal notranslate"><span class="pre">-</span></code> intro pattern or by putting
parentheses around the view.</p>
<p>A <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> that immediately precedes an <a class="reference internal" href="#grammar-token-i_view"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_view</span></code></a>
is executed after the view application.</p>
<p>If the next <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> is a view, then the view is
applied to the assumption in top position once all the
previous <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> have been performed.</p>
<p>The second entry in the <a class="reference internal" href="#grammar-token-i_view"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_view</span></code></a> grammar rule,
<code class="docutils literal notranslate"><span class="pre">/ltac:(</span></code> <code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code> <code class="docutils literal notranslate"><span class="pre">)</span></code>, executes <code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code>.
Notations can be used to name tactics,  for example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Notation myop := (ltac:(some ltac code)) : ssripat_scope.
</pre></div>
</div>
<p>lets one write just <code class="docutils literal notranslate"><span class="pre">/myop</span></code> in the intro pattern. Note the scope
annotation: views are interpreted opening the <code class="docutils literal notranslate"><span class="pre">ssripat</span></code> scope.</p>
</div>
<div class="section" id="intro-patterns">
<h4>Intro patterns<a class="headerlink" href="#intro-patterns" title="Permalink to this headline">¶</a></h4>
<p><span class="smallcaps">SSReflect</span> supports the following <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>s:</p>
<dl>
<dt><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></dt><dd><p>pops the top variable, assumption, or local definition into
a new constant, fact, or defined constant <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>, respectively.
Note that defined constants cannot be introduced when δ-expansion is
required to expose the top variable or assumption.
A <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> (even an empty one) immediately preceding an
<code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is complemented with that <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> if and only if
the identifier is a simple proof context entry <a class="footnote-reference brackets" href="#id24" id="id7">20</a>.
As a consequence  by prefixing the
<code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> with <code class="docutils literal notranslate"><span class="pre">{}</span></code> one can <em>replace</em> a context entry.
This behavior can be avoided by separating the <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a>
from the <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> with the <code class="docutils literal notranslate"><span class="pre">-</span></code> intro pattern.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></dt><dd><p>pops every variable occurring in the rest of the stack.
Type class instances are popped even if they don't occur
in the rest of the stack.
The tactic <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">&gt;</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">?</span> <span class="pre">?</span></code> on a goal such as:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall x y, x &lt; y -&gt; G
</pre></div>
</div>
<p>A typical use if <code class="docutils literal notranslate"><span class="pre">move=&gt;&gt;</span> <span class="pre">H</span></code> to name <code class="docutils literal notranslate"><span class="pre">H</span></code> the first assumption,
in the example above <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">?</span></code></dt><dd><p>pops the top variable into an anonymous constant or fact, whose name
is picked by the tactic interpreter. <span class="smallcaps">SSReflect</span> only generates names that cannot
appear later in the user script <a class="footnote-reference brackets" href="#id20" id="id8">16</a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_</span></code></dt><dd><p>pops the top variable into an anonymous constant that will be deleted
from the proof context of all the subgoals produced by the <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tactical.
They should thus never be displayed, except in an error message if the
constant is still actually used in the goal or context after the last
<a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> has been executed (<a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> can erase goals or
terms where the constant appears).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">*</span></code></dt><dd><p>pops all the remaining apparent variables/assumptions as anonymous
constants/facts. Unlike <code class="docutils literal notranslate"><span class="pre">?</span></code> and <code class="docutils literal notranslate"><span class="pre">move</span></code> the <code class="docutils literal notranslate"><span class="pre">*</span></code>
<a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> does not
expand definitions in the goal to expose quantifiers, so it may be useful
to repeat a <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">*</span></code> tactic, e.g., on the goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall a b : bool, a &lt;&gt; b
</pre></div>
</div>
<p>a first <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">*</span></code> adds only <code class="docutils literal notranslate"><span class="pre">_a_</span> <span class="pre">:</span> <span class="pre">bool</span></code> and <code class="docutils literal notranslate"><span class="pre">_b_</span> <span class="pre">:</span> <span class="pre">bool</span></code>
to the context; it takes a second <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">*</span></code> to add <code class="docutils literal notranslate"><span class="pre">_Hyp_</span> <span class="pre">:</span> <span class="pre">_a_</span> <span class="pre">=</span> <span class="pre">_b_</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">+</span></code></dt><dd><p>temporarily introduces the top variable. It is discharged at the end
of the intro pattern. For example <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">+</span> <span class="pre">y</span></code> on a goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall x y, P
</pre></div>
</div>
<p>is equivalent to <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">_x_</span> <span class="pre">y;</span> <span class="pre">move:</span> <span class="pre">_x_</span></code> that results in the goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall x, P
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">occ</span></span><span><span class="pre">_</span></span><span><span class="pre">switch</span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span class="pre">-&gt;</span></span></span></code></dt><dd><p>(resp. <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> <code class="docutils literal notranslate"><span class="pre">&lt;-</span></code>)
pops the top assumption (which should be a rewritable proposition) into an
anonymous fact, rewrites (resp. rewrites right to left) the goal with this
fact (using the <span class="smallcaps">SSReflect</span> <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> tactic described in section
<a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a>, and honoring the optional occurrence selector), and
finally deletes the anonymous fact from the context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[</span></code> <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">…</span> <span class="pre">|</span></code> <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">]</span></code></dt><dd><p>when it is the
very <em>first</em> <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> after tactic <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tactical <em>and</em> tactic
is not a move, is a <em>branching</em><a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>. It executes the sequence
<a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a><span class="math notranslate nohighlight">\(_i\)</span> on the i-th   subgoal produced by tactic. The
execution of tactic should thus generate exactly m subgoals, unless the
<code class="docutils literal notranslate"><span class="pre">[…]</span></code> <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> comes after an initial <code class="docutils literal notranslate"><span class="pre">//</span></code> or <code class="docutils literal notranslate"><span class="pre">//=</span></code>
<a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> that closes some of the goals produced by <code class="docutils literal notranslate"><span class="pre">tactic</span></code>, in
which case exactly m subgoals should remain after the <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a>, or we have
the trivial branching <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> [], which always does nothing,
regardless of the number of remaining subgoals.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[</span></code> <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">…</span> <span class="pre">|</span></code> <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">]</span></code></dt><dd><p>when it is <em>not</em>
the first <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> or when tactic is a <code class="docutils literal notranslate"><span class="pre">move</span></code>, is a
<em>destructing</em> <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>. It starts by destructing the top
variable, using the <span class="smallcaps">SSReflect</span> <code class="docutils literal notranslate"><span class="pre">case</span></code> tactic described in
<a class="reference internal" href="#the-defective-tactics-ssr"><span class="std std-ref">The defective tactics</span></a>. It then behaves as the corresponding
branching <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>, executing the
sequence <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-i_item"><span class="hole"><span class="pre">i_item</span><sub><span class="pre">i</span></sub></span></a></span></code>  in the i-th subgoal generated by the
case analysis; unless we have the trivial destructing <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>
<code class="docutils literal notranslate"><span class="pre">[]</span></code>, the latter should generate exactly m subgoals, i.e., the top
variable should have an inductive type with exactly m constructors <a class="footnote-reference brackets" href="#id21" id="id9">17</a>.
While it is good style to use the <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> i * to pop the variables
and assumptions corresponding to each constructor, this is not enforced by
<span class="smallcaps">SSReflect</span>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-</span></code></dt><dd><p>does nothing, but counts as an intro pattern. It can also be used to
force the interpretation of <code class="docutils literal notranslate"><span class="pre">[</span></code> <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">…</span> <span class="pre">|</span></code>
<a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">]</span></code> as a case analysis like in <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">-[H1</span> <span class="pre">H2]</span></code>. It
can also be used to indicate explicitly the link between a view and a name
like in <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">/eqP-H1</span></code>.  Last, it can serve as a separator between
views.  Section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a> <a class="footnote-reference brackets" href="#id23" id="id10">19</a> explains in which
respect the tactic <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">/v1/v2</span></code> differs from the tactic <code class="docutils literal notranslate"><span class="pre">move=&gt;</span>
<span class="pre">/v1-/v2</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[:</span></code> <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> <code class="docutils literal notranslate"><span class="pre">…]</span></code></dt><dd><p>introduces in the context an abstract constant
for each <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>.  Its type has to be fixed later on by using the
<code class="docutils literal notranslate"><span class="pre">abstract</span></code> tactic.  Before then the type displayed is <code class="docutils literal notranslate"><span class="pre">&lt;hidden&gt;</span></code>.</p>
</dd>
</dl>
<p>Note that <span class="smallcaps">SSReflect</span> does not support the syntax <code class="docutils literal notranslate"><span class="pre">(ipat,</span> <span class="pre">…,</span> <span class="pre">ipat)</span></code> for
destructing intro patterns.</p>
</div>
<div class="section" id="clear-switch">
<h4>Clear switch<a class="headerlink" href="#clear-switch" title="Permalink to this headline">¶</a></h4>
<p>Clears are deferred until the end of the intro pattern.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk2f" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk2f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span> : Nat.leb <span class="mi">0</span> x = true -&gt; (Nat.leb <span class="mi">0</span> x) &amp;&amp; (Nat.leb y <span class="mi">2</span>) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Nat.leb <span class="mi">0</span> x = true -&gt;
Nat.leb <span class="mi">0</span> x &amp;&amp; Nat.leb y <span class="mi">2</span> = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk30" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk30"><span class="highlight"><span class="nb">move</span>=&gt; {x} -&gt;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true &amp;&amp; Nat.leb y <span class="mi">2</span> = true</span></div></blockquote></div></div></small></span></pre></div></div>
<p>If the cleared names are reused in the same intro pattern, a renaming
is performed behind the scenes.</p>
<p>Facts mentioned in a clear switch must be valid names in the proof
context (excluding the section context).</p>
</div>
<div class="section" id="branching-and-destructuring">
<h4>Branching and destructuring<a class="headerlink" href="#branching-and-destructuring" title="Permalink to this headline">¶</a></h4>
<p>The rules for interpreting branching and destructing <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> are
motivated by the fact that it would be pointless to have a branching
pattern if tactic is a <code class="docutils literal notranslate"><span class="pre">move</span></code>, and in most of the remaining cases
tactic is <code class="docutils literal notranslate"><span class="pre">case</span></code> or <code class="docutils literal notranslate"><span class="pre">elim</span></code>, which implies destruction.
The rules above imply that:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">[a</span> <span class="pre">b].</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">case=&gt;</span> <span class="pre">[a</span> <span class="pre">b].</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">case=&gt;</span> <span class="pre">a</span> <span class="pre">b.</span></code></p></li>
</ul>
<p>are all equivalent, so which one to use is a matter of style; <code class="docutils literal notranslate"><span class="pre">move</span></code> should
be used for casual decomposition, such as splitting a pair, and <code class="docutils literal notranslate"><span class="pre">case</span></code>
should be used for actual decompositions, in particular for type families
(see <a class="reference internal" href="#type-families-ssr"><span class="std std-ref">Type families</span></a>) and proof by contradiction.</p>
<p>The trivial branching <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> can be used to force the branching
interpretation, e.g.:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">case=&gt;</span> <span class="pre">[]</span> <span class="pre">[a</span> <span class="pre">b]</span> <span class="pre">c.</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">[[a</span> <span class="pre">b]</span> <span class="pre">c].</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">case;</span> <span class="pre">case=&gt;</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c.</span></code></p></li>
</ul>
<p>are all equivalent.</p>
</div>
<div class="section" id="block-introduction">
<h4>Block introduction<a class="headerlink" href="#block-introduction" title="Permalink to this headline">¶</a></h4>
<p><span class="smallcaps">SSReflect</span> supports the following <a class="reference internal" href="#grammar-token-i_block"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_block</span></code></a>s:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[^</span></span> <span class="hole"><span class="pre">ident</span></span> <span><span class="pre">]</span></span></span></code></dt><dd><p><em>block destructing</em> <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>. It performs a case analysis
on the top variable and introduces, in one go, all the variables coming
from the case analysis. The names of these variables are obtained by
taking the names used in the inductive type declaration and prefixing them
with <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>. If the intro pattern immediately follows a call
to <code class="docutils literal notranslate"><span class="pre">elim</span></code> with a custom eliminator (see <a class="reference internal" href="#custom-elim-ssr"><span class="std std-ref">Interpreting eliminations</span></a>) then
the names are taken from the ones used in the type of the eliminator.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">r</span> := { a : nat; b := (a, <span class="mi">3</span>); _ : bool; }.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk31" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk31"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : r -&gt; <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">r -&gt; <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk32" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk32"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">r -&gt; <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk33" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk33"><span class="highlight"><span class="nb">move</span> =&gt; [^ x ].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">xa</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xb</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">(xa, <span class="mi">3</span>)</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(nat * nat)%type</span></span></span></div><div class="goal-hyp"><span class="hyp-names">_x?_</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div></div>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[^~</span></span> <span class="hole"><span class="pre">ident</span></span> <span><span class="pre">]</span></span></span></code></dt><dd><p><em>block destructing</em> using <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> as a suffix.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[^~</span></span> <span class="hole"><span class="pre">num</span></span> <span><span class="pre">]</span></span></span></code></dt><dd><p><em>block destructing</em> using <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code> as a suffix.</p>
<p>Only a <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> is allowed between the elimination tactic and
the block destructing.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="generation-of-equations">
<span id="generation-of-equations-ssr"></span><h3>Generation of equations<a class="headerlink" href="#generation-of-equations" title="Permalink to this headline">¶</a></h3>
<p>The generation of named equations option stores the definition of a
new constant as an equation. The tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">move</span> <span class="n">En</span><span class="o">:</span> <span class="o">(</span><span class="n">size</span> <span class="n">l</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">n</span><span class="o">.</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">l</span></code> is a list, replaces <code class="docutils literal notranslate"><span class="pre">size</span> <span class="pre">l</span></code> by <code class="docutils literal notranslate"><span class="pre">n</span></code> in the goal and
adds the fact <code class="docutils literal notranslate"><span class="pre">En</span> <span class="pre">:</span> <span class="pre">size</span> <span class="pre">l</span> <span class="pre">=</span> <span class="pre">n</span></code> to the context.
This is quite different from:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">pose</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">(</span><span class="n">size</span> <span class="n">l</span><span class="o">).</span>
</pre></div>
</div>
<p>which generates a definition <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:=</span> <span class="pre">(size</span> <span class="pre">l)</span></code>. It is not possible to
generalize or rewrite such a definition; on the other hand, it is
automatically expanded during computation, whereas expanding the
equation <code class="docutils literal notranslate"><span class="pre">En</span></code> requires explicit rewriting.</p>
<p>The use of this equation name generation option with a <code class="docutils literal notranslate"><span class="pre">case</span></code> or an
<code class="docutils literal notranslate"><span class="pre">elim</span></code> tactic changes the status of the first <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a>, in order to
deal with the possible parameters of the constants introduced.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk34" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk34"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">a</span> <span class="nv">b</span> :nat) : a &lt;&gt; b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a &lt;&gt; b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk35" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk35"><span class="highlight"><span class="nb">case</span> E : a =&gt; [|n].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = <span class="mi">0</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt;&gt; b</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk36" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = S n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk36"><hr></label><div class="goal-conclusion"><span class="highlight">S n &lt;&gt; b</span></div></blockquote></div></div></div></small></span></pre></div></div>
<p>If the user does not provide a branching <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> as first
<a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a>, or if the <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> does not provide enough names for
the arguments of a constructor, then the constants generated are introduced
under fresh <span class="smallcaps">SSReflect</span> names.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk37" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk37"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">a</span> <span class="nv">b</span> :nat) : a &lt;&gt; b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a &lt;&gt; b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk38" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk38"><span class="highlight"><span class="nb">case</span> E : a =&gt; H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = b</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk39" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, _n_</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = S _n_</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S _n_ = b</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk39"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk3a" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk3a"><span class="highlight"><span class="kn">Show</span> <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">subgoal <span class="mi">2</span> <span class="kr">is</span>:

  a, b, _n_ : nat
  E : a = S _n_
  H : S _n_ = b
  ============================
  <span class="kt">False</span></span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = b</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk3b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, _n_</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = S _n_</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S _n_ = b</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk3b"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></div></small></span></pre></div></div>
<p>Combining the generation of named equations mechanism with the <a class="reference internal" href="tactics.html#coq:tacn.case" title="case"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">case</span></code></a>
tactic strengthens the power of a case analysis. On the other hand,
when combined with the <a class="reference internal" href="tactics.html#coq:tacv.elim" title="elim"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">elim</span></code></a> tactic, this feature is mostly useful for
debug purposes, to trace the values of decomposed parameters and
pinpoint failing branches.</p>
</div>
<div class="section" id="type-families">
<span id="type-families-ssr"></span><h3>Type families<a class="headerlink" href="#type-families" title="Permalink to this headline">¶</a></h3>
<p>When the top assumption of a goal has an inductive type, two specific
operations are possible: the case analysis performed by the <a class="reference internal" href="tactics.html#coq:tacn.case" title="case"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">case</span></code></a>
tactic, and the application of an induction principle, performed by
the <a class="reference internal" href="tactics.html#coq:tacv.elim" title="elim"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">elim</span></code></a> tactic. When this top assumption has an inductive type, which
is moreover an instance of a type family, <span class="smallcaps">Coq</span> may need help from the
user to specify which occurrences of the parameters of the type should
be substituted.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>case:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span> <span>/</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>elim:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span> <span>/</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>A specific <code class="docutils literal notranslate"><span class="pre">/</span></code> switch indicates the type family parameters of the type
of a <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> immediately following this <code class="docutils literal notranslate"><span class="pre">/</span></code> switch.
The <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> on the right side of the <code class="docutils literal notranslate"><span class="pre">/</span></code> switch are discharged as
described in section <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>. The case analysis or elimination
will be done on the type of the top assumption after these discharge
operations.</p>
<p>Every <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> preceding the <code class="docutils literal notranslate"><span class="pre">/</span></code> is interpreted as arguments of this
type, which should be an instance of an inductive type family. These terms
are not actually generalized, but rather selected for substitution.
Occurrence switches can be used to restrict the substitution. If a term is
left completely implicit (e.g. writing just <code class="docutils literal notranslate"><span class="pre">_</span></code>), then a pattern is
inferred looking at the type of the top assumption. This allows for the
compact syntax:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">case</span><span class="o">:</span> <span class="o">{</span><span class="mi">2</span><span class="o">}</span><span class="n">_</span> <span class="o">/</span> <span class="n">eqP</span><span class="o">.</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">_</span></code> is interpreted as <code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">==</span> <span class="pre">_)</span></code> since
<code class="docutils literal notranslate"><span class="pre">eqP</span> <span class="pre">T</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">reflect</span> <span class="pre">(a</span> <span class="pre">=</span> <span class="pre">b)</span> <span class="pre">(a</span> <span class="pre">==</span> <span class="pre">b)</span></code> and reflect is a type family with
one index.</p>
<p>Moreover if the <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> list is too short, it is padded with an
initial sequence of <code class="docutils literal notranslate"><span class="pre">_</span></code> of the right length.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Here is a small example on lists. We define first a function which
adds an element at the end of a given list.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> List.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">LastCases</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">A</span> : <span class="kt">Type</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Implicit Type</span> <span class="nf">l</span> : list A.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">add_last</span> <span class="nv">a</span> <span class="nv">l</span> : list A :=
  <span class="kr">match</span> l <span class="kr">with</span>
 | nil =&gt; a :: nil
 | hd :: tl =&gt; hd :: (add_last a tl) <span class="kr">end</span>.</span></span></span></pre></div><p>Then we define an inductive predicate for case analysis on lists
according to their last element:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">last_spec</span> : list A -&gt; <span class="kt">Type</span> :=
| LastSeq0 : last_spec nil
| LastAdd s x : last_spec (add_last x s).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk3c" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk3c"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">lastP</span> : <span class="kr">forall</span> <span class="nv">l</span> : list A, last_spec l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list A, last_spec l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre></div><p>We are now ready to use <code class="docutils literal notranslate"><span class="pre">lastP</span></code> in conjunction with <code class="docutils literal notranslate"><span class="pre">case</span></code>.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk3d" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk3d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">l</span> : (length l) * <span class="mi">2</span> = length (l ++ l).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length l * <span class="mi">2</span> = length (l ++ l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk3e" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk3e"><span class="highlight"><span class="nb">case</span>: (lastP l).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length nil * <span class="mi">2</span> = length (nil ++ nil)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk3f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk3f"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : list A) (<span class="nv">x</span> : A),
length (add_last x s) * <span class="mi">2</span> =
length (add_last x s ++ add_last x s)</span></div></blockquote></div></div></div></small></span></pre></div><p>Applied to the same goal, the tactc <code class="docutils literal notranslate"><span class="pre">case:</span> <span class="pre">l</span> <span class="pre">/</span> <span class="pre">(lastP</span> <span class="pre">l)</span></code>
generates the same subgoals but <code class="docutils literal notranslate"><span class="pre">l</span></code> has been cleared from both contexts:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk40" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk40"><span class="highlight"><span class="nb">case</span>: l / (lastP l).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length nil * <span class="mi">2</span> = length (nil ++ nil)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk41" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk41"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : list A) (<span class="nv">x</span> : A),
length (add_last x s) * <span class="mi">2</span> =
length (add_last x s ++ add_last x s)</span></div></blockquote></div></div></div></small></span></pre></div><p>Again applied to the same goal:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk42" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk42"><span class="highlight"><span class="nb">case</span>: {<span class="mi">1</span> <span class="mi">3</span>}l / (lastP l).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length nil * <span class="mi">2</span> = length (l ++ nil)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk43" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk43"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : list A) (<span class="nv">x</span> : A),
length (add_last x s) * <span class="mi">2</span> = length (l ++ add_last x s)</span></div></blockquote></div></div></div></small></span></pre></div><p>Note that selected occurrences on the left of the <code class="docutils literal notranslate"><span class="pre">/</span></code>
switch have been substituted with l instead of being affected by
the case analysis.</p>
</div>
<p>The equation name generation feature combined with a type family <code class="docutils literal notranslate"><span class="pre">/</span></code>
switch generates an equation for the <em>first</em> dependent <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>
specified by the user. Again starting with the above goal, the
command:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk44" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk44"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">l</span> : (length l) * <span class="mi">2</span> = length (l ++ l).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length l * <span class="mi">2</span> = length (l ++ l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk45" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk45"><span class="highlight"><span class="nb">case</span> E: {<span class="mi">1</span> <span class="mi">3</span>}l / (lastP l) =&gt; [|s x].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">l = nil</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length nil * <span class="mi">2</span> = length (l ++ nil)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk46" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">l = add_last x s</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk46"><hr></label><div class="goal-conclusion"><span class="highlight">length (add_last x s) * <span class="mi">2</span> = length (l ++ add_last x s)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk47" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk47"><span class="highlight"><span class="kn">Show</span> <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">subgoal <span class="mi">2</span> <span class="kr">is</span>:

  A : <span class="kt">Type</span>
  l, s : list A
  x : A
  E : l = add_last x s
  ============================
  length (add_last x s) * <span class="mi">2</span> =
  length (l ++ add_last x s)</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">l = nil</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length nil * <span class="mi">2</span> = length (l ++ nil)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk48" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, s</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">l = add_last x s</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk48"><hr></label><div class="goal-conclusion"><span class="highlight">length (add_last x s) * <span class="mi">2</span> = length (l ++ add_last x s)</span></div></blockquote></div></div></div></small></span></pre></div></div>
<p>There must be at least one <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> to the left of the <code class="docutils literal notranslate"><span class="pre">/</span></code> switch; this
prevents any confusion with the view feature. However, the <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>
to the right of the <code class="docutils literal notranslate"><span class="pre">/</span></code> are optional, and if they are omitted the first
assumption provides the instance of the type family.</p>
<p>The equation always refers to the first <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> in the actual tactic
call, before any padding with initial <code class="docutils literal notranslate"><span class="pre">_</span></code>. Thus, if an inductive type
has two family parameters, it is possible to have <span class="smallcaps">SSReflect</span> generate an
equation for the second one by omitting the pattern for the first;
note however that this will fail if the type of the second parameter
depends on the value of the first parameter.</p>
</dd></dl>

</div>
</div>
<div class="section" id="control-flow">
<h2>Control flow<a class="headerlink" href="#control-flow" title="Permalink to this headline">¶</a></h2>
<div class="section" id="indentation-and-bullets">
<span id="indentation-ssr"></span><h3>Indentation and bullets<a class="headerlink" href="#indentation-and-bullets" title="Permalink to this headline">¶</a></h3>
<p>A linear development of <span class="smallcaps">Coq</span> scripts gives little information on the
structure of the proof. In addition, replaying a proof after some
changes in the statement to be proved will usually not display
information to distinguish between the various branches of case
analysis for instance.</p>
<p>To help the user in this organization of the proof script at development
time, <span class="smallcaps">SSReflect</span> provides some bullets to highlight the structure of branching
proofs. The available bullets are <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">*</span></code>.  Combined with
tabulation, this lets us highlight four nested levels of branching; the most
we have ever needed is three. Indeed, the use of “simpl and closing”
switches, of terminators (see above section <a class="reference internal" href="#terminators-ssr"><span class="std std-ref">Terminators</span></a>) and
selectors (see section <a class="reference internal" href="#selectors-ssr"><span class="std std-ref">Selectors</span></a>) is powerful enough to avoid most
of the time more than two levels of indentation.</p>
<p>Here is a fragment of such a structured script:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>case E1: (abezoutn _ _) =&gt; [[| k1] [| k2]].
- rewrite !muln0 !gexpn0 mulg1 =&gt; H1.
  move/eqP: (sym_equal F0); rewrite -H1 orderg1 eqn_mul1.
  by case/andP; move/eqP.
- rewrite muln0 gexpn0 mulg1 =&gt; H1.
  have F1: t %| t * S k2.+1 - 1.
    apply: (@dvdn_trans (orderg x)); first by rewrite F0; exact: dvdn_mull.
    rewrite orderg_dvd; apply/eqP; apply: (mulgI x).
    rewrite -{1}(gexpn1 x) mulg1 gexpn_add leq_add_sub //.
    by move: P1; case t.
  rewrite dvdn_subr in F1; last by exact: dvdn_mulr.
  + rewrite H1 F0 -{2}(muln1 (p ^ l)); congr (_ * _).
    by apply/eqP; rewrite -dvdn1.
  + by move: P1; case: (t) =&gt; [| [| s1]].
- rewrite muln0 gexpn0 mul1g =&gt; H1.
...
</pre></div>
</div>
</div>
<div class="section" id="terminators">
<span id="terminators-ssr"></span><h3>Terminators<a class="headerlink" href="#terminators" title="Permalink to this headline">¶</a></h3>
<p>To further structure scripts, <span class="smallcaps">SSReflect</span> supplies <em>terminating</em>
tacticals to explicitly close off tactics. When replaying scripts, we
then have the nice property that an error immediately occurs when a
closed tactic fails to prove its subgoal.</p>
<p>It is hence recommended practice that the proof of any subgoal should
end with a tactic which <em>fails if it does not solve the current goal</em>,
like <a class="reference internal" href="tactics.html#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.contradiction" title="contradiction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">contradiction</span></code></a> or <a class="reference internal" href="tactics.html#coq:tacn.assumption" title="assumption"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assumption</span></code></a>.</p>
<p>In fact, <span class="smallcaps">SSReflect</span> provides a generic tactical which turns any tactic
into a closing one (similar to <a class="reference internal" href="tactics.html#coq:tacv.now" title="now"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">now</span></code></a>). Its general syntax is:</p>
<dl class="coq tacn">
<dt id="coq:tacn.by">
<code class="sig-name descname"><span class="notation"><span>by</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:tacn.by" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The Ltac expression <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">by</span></span> <span><span class="pre">[</span></span><span class="hole"><span class="pre">tactic</span></span> <span class="pre">|</span> <span class="hole"><span class="pre">tactic</span></span> <span class="pre">|</span> <span><span class="pre">…]</span></span></span></code> is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">do</span></span> <span><span class="pre">[done</span></span> <span class="pre">|</span> <span><span class="pre">by</span></span> <span class="hole"><span class="pre">tactic</span></span> <span class="pre">|</span> <span><span class="pre">by</span></span> <span class="hole"><span class="pre">tactic</span></span> <span class="pre">|</span> <span><span class="pre">…]</span></span></span></code>, which corresponds to the
standard Ltac expression <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">first</span></span> <span><span class="pre">[done</span></span> <span class="pre">|</span> <span class="hole"><span class="pre">tactic</span></span><span><span class="pre">;</span></span> <span><span class="pre">done</span></span> <span class="pre">|</span> <span class="hole"><span class="pre">tactic</span></span><span><span class="pre">;</span></span> <span><span class="pre">done</span></span> <span class="pre">|</span> <span><span class="pre">…]</span></span></span></code>.</p>
<p>In the script provided as example in section <a class="reference internal" href="#indentation-ssr"><span class="std std-ref">Indentation and bullets</span></a>, the
paragraph corresponding to each sub-case ends with a tactic line prefixed
with a <code class="docutils literal notranslate"><span class="pre">by</span></code>, like in:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="bp">by</span> <span class="nb">apply</span><span class="o">/</span><span class="n">eqP</span><span class="o">;</span> <span class="nb">rewrite</span> <span class="o">-</span><span class="n">dvdn1</span><span class="o">.</span>
</pre></div>
</div>
<dl class="coq tacn">
<dt id="coq:tacn.done">
<code class="sig-name descname"><span class="notation"><span>done</span></span></code><a class="headerlink" href="#coq:tacn.done" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#coq:tacn.by" title="by"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">by</span></code></a> tactical is implemented using the user-defined, and extensible
<a class="reference internal" href="#coq:tacn.done" title="done"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">done</span></code></a> tactic. This <a class="reference internal" href="#coq:tacn.done" title="done"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">done</span></code></a> tactic tries to solve the current goal by some
trivial means and fails if it doesn’t succeed. Indeed, the tactic
expression <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">by</span></span> <span class="hole"><span class="pre">tactic</span></span></span></code> is equivalent to <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span><span><span class="pre">;</span></span> <span><span class="pre">done</span></span></span></code>.</p>
<p>Conversely, the tactic <code class="docutils literal notranslate"><span class="pre">by</span> <span class="pre">[</span> <span class="pre">]</span></code> is equivalent to <a class="reference internal" href="#coq:tacn.done" title="done"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">done</span></code></a>.</p>
<p>The default implementation of the done tactic, in the <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code>
file, is:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Ltac</span> <span class="nf">done</span> <span class="o">:=</span>
  <span class="nb">trivial</span><span class="o">;</span> <span class="nb">hnf</span><span class="o">;</span> <span class="nb">intros</span><span class="o">;</span> <span class="kp">solve</span>
   <span class="o">[</span> <span class="kp">do</span> <span class="o">![</span><span class="kp">solve</span> <span class="o">[</span><span class="nb">trivial</span> <span class="o">|</span> <span class="nb">apply</span><span class="o">:</span> <span class="n">sym_equal</span><span class="o">;</span> <span class="nb">trivial</span><span class="o">]</span>
         <span class="o">|</span> <span class="bp">discriminate</span> <span class="o">|</span> <span class="bp">contradiction</span> <span class="o">|</span> <span class="nb">split</span><span class="o">]</span>
   <span class="o">|</span> <span class="nb">case</span> <span class="n">not_locked_false_eq_true</span><span class="o">;</span> <span class="bp">assumption</span>
   <span class="o">|</span> <span class="kr">match goal with</span> <span class="n">H</span> <span class="o">:</span> <span class="o">~</span> <span class="n">_</span> <span class="o">|-</span> <span class="n">_</span> <span class="o">=&gt;</span> <span class="kp">solve</span> <span class="o">[</span><span class="nb">case</span> <span class="n">H</span><span class="o">;</span> <span class="nb">trivial</span><span class="o">]</span> <span class="kr">end</span> <span class="o">].</span>
</pre></div>
</div>
<p>The lemma <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">not_locked_false_eq_true</span></span></code> is needed to discriminate
<em>locked</em> boolean predicates (see section <a class="reference internal" href="#locking-ssr"><span class="std std-ref">Locking, unlocking</span></a>). The iterator
tactical do is presented in section <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a>. This tactic can be
customized by the user, for instance to include an <a class="reference internal" href="tactics.html#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> tactic.</p>
</dd></dl>

<p>A natural and common way of closing a goal is to apply a lemma which
is the exact one needed for the goal to be solved. The defective form
of the tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="bp">exact</span><span class="o">.</span>
</pre></div>
</div>
<p>is equivalent to:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kp">do</span> <span class="o">[</span><span class="bp">done</span> <span class="o">|</span> <span class="bp">by</span> <span class="nb">move</span><span class="o">=&gt;</span> <span class="n">top</span><span class="o">;</span> <span class="nb">apply</span> <span class="n">top</span><span class="o">].</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">top</span></code> is a fresh name assigned to the top assumption of the goal.
This applied form is supported by the <code class="docutils literal notranslate"><span class="pre">:</span></code> discharge tactical, and the
tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="bp">exact</span><span class="o">:</span> <span class="n">MyLemma</span><span class="o">.</span>
</pre></div>
</div>
<p>is equivalent to:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="bp">by</span> <span class="nb">apply</span><span class="o">:</span> <span class="n">MyLemma</span><span class="o">.</span>
</pre></div>
</div>
<p>(see section <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a> for the documentation of the apply: combination).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The list of tactics (possibly chained by semicolons) that
follows the <code class="docutils literal notranslate"><span class="pre">by</span></code> keyword is considered to be a parenthesized block applied to
the current goal. Hence for example if the tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="bp">by</span> <span class="nb">rewrite</span> <span class="n">my_lemma1</span><span class="o">.</span>
</pre></div>
</div>
<p>succeeds, then the tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="bp">by</span> <span class="nb">rewrite</span> <span class="n">my_lemma1</span><span class="o">;</span> <span class="nb">apply</span> <span class="n">my_lemma2</span><span class="o">.</span>
</pre></div>
</div>
<p>usually fails since it is equivalent to:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="bp">by</span> <span class="o">(</span><span class="nb">rewrite</span> <span class="n">my_lemma1</span><span class="o">;</span> <span class="nb">apply</span> <span class="n">my_lemma2</span><span class="o">).</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="selectors">
<span id="selectors-ssr"></span><h3>Selectors<a class="headerlink" href="#selectors" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.last">
<code class="sig-name descname"><span class="notation"><span>last</span></span></code><a class="headerlink" href="#coq:tacn.last" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacn.first-ssreflect">
<code class="sig-name descname"><span class="notation"><span>first</span></span></code><a class="headerlink" href="#coq:tacn.first-ssreflect" title="Permalink to this definition">¶</a></dt>
<dd><p>When composing tactics, the two tacticals <code class="docutils literal notranslate"><span class="pre">first</span></code> and <code class="docutils literal notranslate"><span class="pre">last</span></code> let the user
restrict the application of a tactic to only one of the subgoals
generated by the previous tactic. This covers the frequent cases where
a tactic generates two subgoals one of which can be easily disposed
of.</p>
<p>This is another powerful way of linearization of scripts, since it
happens very often that a trivial subgoal can be solved in a less than
one line tactic. For instance, <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span> <span><span class="pre">;</span></span> <span><span class="pre">last</span></span> <span><span class="pre">by</span></span> <span class="hole"><span class="pre">tactic</span></span></span></code>
tries to solve the last subgoal generated by the first
tactic using the given second tactic, and fails if it does not succeed.
Its analogue <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span> <span><span class="pre">;</span></span> <span><span class="pre">first</span></span> <span><span class="pre">by</span></span> <span class="hole"><span class="pre">tactic</span></span></span></code>
tries to solve the first subgoal generated by the first tactic using the
second given tactic, and fails if it does not succeed.</p>
</dd></dl>

<p><span class="smallcaps">SSReflect</span> also offers an extension of this facility, by supplying
tactics to <em>permute</em> the subgoals generated by a tactic.</p>
<dl class="coq tacv">
<dt id="coq:tacv.last-first">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>last</span> <span>first</span></span></code><a class="headerlink" href="#coq:tacv.last-first" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacv.first-last">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>first</span> <span>last</span></span></code><a class="headerlink" href="#coq:tacv.first-last" title="Permalink to this definition">¶</a></dt>
<dd><p>These two equivalent tactics invert the order of the subgoals in focus.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>last</span> <span class="hole">num</span> <span>first</span></span></code></dt>
<dd><p>If <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code>'s value is <span class="math notranslate nohighlight">\(k\)</span>,
this tactic rotates the <span class="math notranslate nohighlight">\(n\)</span> subgoals <span class="math notranslate nohighlight">\(G_1\)</span> , …, <span class="math notranslate nohighlight">\(G_n\)</span>
in focus. The first subgoal becomes <span class="math notranslate nohighlight">\(G_{n + 1 − k}\)</span> and the
circular order of subgoals remains unchanged.</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>first</span> <span class="hole">num</span> <span>last</span></span></code></dt>
<dd><p>If <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code>'s value is <span class="math notranslate nohighlight">\(k\)</span>,
this tactic rotates the <span class="math notranslate nohighlight">\(n\)</span> subgoals <span class="math notranslate nohighlight">\(G_1\)</span> , …, <span class="math notranslate nohighlight">\(G_n\)</span>
in focus. The first subgoal becomes <span class="math notranslate nohighlight">\(G_k\)</span> and the circular order
of subgoals remains unchanged.</p>
</dd></dl>

</dd></dl>

<p>Finally, the tactics <code class="docutils literal notranslate"><span class="pre">last</span></code> and <code class="docutils literal notranslate"><span class="pre">first</span></code> combine with the branching syntax
of Ltac: if the tactic generates n subgoals on a given goal,
then the tactic</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="n">tactic</span> <span class="o">;</span> <span class="nb">last</span> <span class="n">k</span> <span class="o">[</span> <span class="n">tactic1</span> <span class="o">|…|</span> <span class="n">tacticm</span> <span class="o">]</span> <span class="o">||</span> <span class="n">tacticn</span><span class="o">.</span>
</pre></div>
</div>
<p>where natural denotes the integer <span class="math notranslate nohighlight">\(k\)</span> as above, applies tactic1 to the
<span class="math notranslate nohighlight">\(n−k+1\)</span>-th goal, … tacticm to the <span class="math notranslate nohighlight">\(n−k+2\)</span>-th goal and tacticn
to the others.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Here is a small example on lists. We define first a function which
adds an element at the end of a given list.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">test</span> : nat -&gt; <span class="kt">Prop</span> :=
| C1 n of n = <span class="mi">1</span> : test n
| C2 n of n = <span class="mi">2</span> : test n
| C3 n of n = <span class="mi">3</span> : test n
| C4 n of n = <span class="mi">4</span> : test n.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk49" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk49"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">example</span> <span class="nv">n</span> (<span class="nv">t</span> : test n) : <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">test n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk4a" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk4a"><span class="highlight"><span class="nb">case</span>: t; <span class="nb">last</span> <span class="mi">2</span> [<span class="nb">move</span>=&gt; k| <span class="nb">move</span>=&gt; l]; <span class="kp">idtac</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> : nat, n0 = <span class="mi">1</span> -&gt; <span class="kt">True</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk4b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, k</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk4b"><hr></label><div class="goal-conclusion"><span class="highlight">k = <span class="mi">2</span> -&gt; <span class="kt">True</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk4c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk4c"><hr></label><div class="goal-conclusion"><span class="highlight">l = <span class="mi">3</span> -&gt; <span class="kt">True</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk4d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk4d"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> : nat, n0 = <span class="mi">4</span> -&gt; <span class="kt">True</span></span></div></blockquote></div></div></div></small></span></pre></div></div>
</div>
<div class="section" id="iteration">
<span id="iteration-ssr"></span><h3>Iteration<a class="headerlink" href="#iteration" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.do-ssreflect">
<code class="sig-name descname"><span class="notation"><span>do</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><span class="hole">tactic</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">tactic</span></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span>]</span></span></span></span></code><a class="headerlink" href="#coq:tacn.do-ssreflect" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactical offers an accurate control on the repetition of tactics.
<a class="reference internal" href="#grammar-token-mult"><code class="xref std std-token docutils literal notranslate"><span class="pre">mult</span></code></a> is a <em>multiplier</em>.</p>
<p>Brackets can only be omitted if a single tactic is given <em>and</em> a
multiplier is present.</p>
</dd></dl>

<p>A tactic of the form:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kp">do</span> <span class="o">[</span> <span class="n">tactic</span> <span class="mi">1</span> <span class="o">|</span> <span class="o">…</span> <span class="o">|</span> <span class="n">tactic</span> <span class="n">n</span> <span class="o">].</span>
</pre></div>
</div>
<p>is equivalent to the standard Ltac expression:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kp">first</span> <span class="o">[</span> <span class="n">tactic</span> <span class="mi">1</span> <span class="o">|</span> <span class="o">…</span> <span class="o">|</span> <span class="n">tactic</span> <span class="n">n</span> <span class="o">].</span>
</pre></div>
</div>
<p>The optional multiplier <a class="reference internal" href="#grammar-token-mult"><code class="xref std std-token docutils literal notranslate"><span class="pre">mult</span></code></a> specifies how many times the action of
tactic should be repeated on the current subgoal.</p>
<p>There are four kinds of multipliers:</p>
<dl class="coq prodn">
<dt id="grammar-token-mult">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">mult</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span class="hole">num</span> <span>!</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>!</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="hole">num</span> <span>?</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>?</span></span></span></span></code><a class="headerlink" href="#grammar-token-mult" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Their meaning is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n!</span></code> the step tactic is repeated exactly n times (where n is a
positive integer argument).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!</span></code> the step tactic is repeated as many times as possible, and done
at least once.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">?</span></code> the step tactic is repeated as many times as possible,
optionally.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n?</span></code> the step tactic is repeated up to n times, optionally.</p></li>
</ul>
<p>For instance, the tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="n">tactic</span><span class="o">;</span> <span class="kp">do</span> <span class="mi">1</span><span class="o">?</span> <span class="nb">rewrite</span> <span class="n">mult_comm</span><span class="o">.</span>
</pre></div>
</div>
<p>rewrites at most one time the lemma <code class="docutils literal notranslate"><span class="pre">mult_comm</span></code> in all the subgoals
generated by tactic, whereas the tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="n">tactic</span><span class="o">;</span> <span class="kp">do</span> <span class="mi">2</span><span class="o">!</span> <span class="nb">rewrite</span> <span class="n">mult_comm</span><span class="o">.</span>
</pre></div>
</div>
<p>rewrites exactly two times the lemma <code class="docutils literal notranslate"><span class="pre">mult_comm</span></code> in all the subgoals
generated by tactic, and fails if this rewrite is not possible in some
subgoal.</p>
<p>Note that the combination of multipliers and rewrite is so often used
that multipliers are in fact integrated to the syntax of the
<span class="smallcaps">SSReflect</span> rewrite tactic, see section <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a>.</p>
</div>
<div class="section" id="localization">
<span id="localization-ssr"></span><h3>Localization<a class="headerlink" href="#localization" title="Permalink to this headline">¶</a></h3>
<p>In sections <a class="reference internal" href="#basic-localization-ssr"><span class="std std-ref">Basic localization</span></a> and <a class="reference internal" href="#bookkeeping-ssr"><span class="std std-ref">Bookkeeping</span></a>, we have
already presented the <em>localization</em> tactical in, whose general syntax is:</p>
<dl class="coq tacn">
<dt id="coq:tacn.in">
<code class="sig-name descname"><span class="notation"><span class="hole">tactic</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><span>*</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.in" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>where <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is a name in the
context. On the left side of <code class="docutils literal notranslate"><span class="pre">in</span></code>,
<code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code> can be <code class="docutils literal notranslate"><span class="pre">move</span></code>, <code class="docutils literal notranslate"><span class="pre">case</span></code>, <code class="docutils literal notranslate"><span class="pre">elim</span></code>, <code class="docutils literal notranslate"><span class="pre">rewrite</span></code>, <code class="docutils literal notranslate"><span class="pre">set</span></code>,
or any tactic formed with the general iteration tactical <code class="docutils literal notranslate"><span class="pre">do</span></code> (see section
<a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a>).</p>
<p>The operation described by tactic is performed in the facts listed after
<code class="docutils literal notranslate"><span class="pre">in</span></code> and in the goal if a <code class="docutils literal notranslate"><span class="pre">*</span></code> ends the list of names.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical successively:</p>
<ul class="simple">
<li><p>generalizes the selected hypotheses, possibly “protecting” the goal
if <code class="docutils literal notranslate"><span class="pre">*</span></code> is not present,</p></li>
<li><p>performs <code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code>, on the obtained goal,</p></li>
<li><p>reintroduces the generalized facts, under the same names.</p></li>
</ul>
<p>This defective form of the <code class="docutils literal notranslate"><span class="pre">do</span></code> tactical is useful to avoid clashes
between standard Ltac in and the <span class="smallcaps">SSReflect</span> tactical in.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">mytac</span> H := <span class="nb">rewrite</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk4e" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk4e"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span> (<span class="nv">H1</span> : x = y) (<span class="nv">H2</span> : y = <span class="mi">3</span>) : x + y = <span class="mi">6</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">3</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y = <span class="mi">6</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk4f" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk4f"><span class="highlight"><span class="kp">do</span> [mytac H2] <span class="kr">in</span> H1 *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = <span class="mi">3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = <span class="mi">3</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + <span class="mi">3</span> = <span class="mi">6</span></span></div></blockquote></div></div></small></span></pre></div><p>the last tactic rewrites the hypothesis <code class="docutils literal notranslate"><span class="pre">H2</span> <span class="pre">:</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">3</span></code> both in
<code class="docutils literal notranslate"><span class="pre">H1</span> <span class="pre">:</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code> and in the goal <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">6</span></code>.</p>
</div>
<p>By default <code class="docutils literal notranslate"><span class="pre">in</span></code> keeps the body of local definitions. To erase the body
of a local definition during the generalization phase, the name of the
local definition must be written between parentheses, like in
<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">H</span> <span class="pre">in</span> <span class="pre">H1</span> <span class="pre">(def_n)</span> <span class="pre">H2.</span></code></p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">tactic</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><span>&#64;</span></span><span class="notation-sup">?</span></span><span class="hole">ident</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>(</span> <span class="hole">ident</span> <span>)</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>(</span> <span class="repeat-wrapper"><span class="repeat"><span>&#64;</span></span><span class="notation-sup">?</span></span><span class="hole">ident</span> <span>:=</span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a> <span>)</span></span></span></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><span>*</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This is the most general form of the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical.
In its simplest form the last option lets one rename hypotheses that
can’t be cleared (like section variables). For example, <code class="docutils literal notranslate"><span class="pre">(y</span> <span class="pre">:=</span> <span class="pre">x)</span></code>
generalizes over <code class="docutils literal notranslate"><span class="pre">x</span></code> and reintroduces the generalized variable under the
name <code class="docutils literal notranslate"><span class="pre">y</span></code> (and does not clear <code class="docutils literal notranslate"><span class="pre">x</span></code>).
For a more precise description of this form of localization refer
to <a class="reference internal" href="#advanced-generalization-ssr"><span class="std std-ref">Advanced generalization</span></a>.</p>
</dd></dl>

</div>
<div class="section" id="structure">
<span id="structure-ssr"></span><h3>Structure<a class="headerlink" href="#structure" title="Permalink to this headline">¶</a></h3>
<p>Forward reasoning structures the script by explicitly specifying some
assumptions to be added to the proof context. It is closely associated
with the declarative style of proof, since an extensive use of these
highlighted statements make the script closer to a (very detailed)
textbook proof.</p>
<p>Forward chaining tactics allow to state an intermediate lemma and start a
piece of script dedicated to the proof of this statement. The use of closing
tactics (see section <a class="reference internal" href="#terminators-ssr"><span class="std std-ref">Terminators</span></a>) and of indentation makes
syntactically explicit the portion of the script building the proof of the
intermediate statement.</p>
<div class="section" id="the-have-tactic">
<h4>The have tactic.<a class="headerlink" href="#the-have-tactic" title="Permalink to this headline">¶</a></h4>
<dl class="coq tacn">
<dt id="coq:tacn.have">
<code class="sig-name descname"><span class="notation"><span>have</span> <span>:</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.have" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the main <span class="smallcaps">SSReflect</span> forward reasoning tactic. It can
be used in two modes: one starts a new (sub)proof for an intermediate
result in the main proof, and the other provides explicitly a proof
term for this intermediate step.</p>
<p>This tactic supports open syntax for <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>. Applied to a goal <code class="docutils literal notranslate"><span class="pre">G</span></code>, it
generates a first subgoal requiring a proof of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> in the context of
<code class="docutils literal notranslate"><span class="pre">G</span></code>. The second generated subgoal is of the form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">term</span></span> <span><span class="pre">-&gt;</span></span> <span><span class="pre">G</span></span></span></code>, where term
becomes the new top assumption, instead of being introduced with a
fresh name. At the proof-term level, the have tactic creates a β
redex, and introduces the lemma under a fresh name, automatically
chosen.</p>
</dd></dl>

<p>Like in the case of the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pose</span></span> <span><span class="pre">(ssreflect)</span></span></span></code> tactic (see section <a class="reference internal" href="#definitions-ssr"><span class="std std-ref">Definitions</span></a>), the types of
the holes are abstracted in term.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk50" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk50"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk51" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk51"><span class="highlight"><span class="nb">have</span>: _ * <span class="mi">0</span> = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, n * <span class="mi">0</span> = <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk52" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk52"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">n</span> : nat, n * <span class="mi">0</span> = <span class="mi">0</span>) -&gt; <span class="kt">True</span></span></div></blockquote></div></div></div></small></span></pre></div><p>The invocation of <code class="docutils literal notranslate"><span class="pre">have</span></code> is equivalent to:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk53" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk53"><span class="highlight"><span class="nb">have</span>: <span class="kr">forall</span> <span class="nv">n</span> : nat, n * <span class="mi">0</span> = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, n * <span class="mi">0</span> = <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk54" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk54"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">n</span> : nat, n * <span class="mi">0</span> = <span class="mi">0</span>) -&gt; <span class="kt">True</span></span></div></blockquote></div></div></div></small></span></pre></div></div>
<p>The have tactic also enjoys the same abstraction mechanism as the <code class="docutils literal notranslate"><span class="pre">pose</span></code>
tactic for the non-inferred implicit arguments. For instance, the
tactic:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk55" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk55"><span class="highlight"><span class="nb">have</span>: <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, (x, y) = (x, y + <span class="mi">0</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : T) (<span class="nv">y</span> : nat),
(x, y) = (x, y + <span class="mi">0</span>)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk56" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk56"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : T) (<span class="nv">y</span> : nat),
 (x, y) = (x, y + <span class="mi">0</span>)) -&gt; <span class="kt">True</span></span></div></blockquote></div></div></div></small></span></pre></div><p>opens a new subgoal where the type of <code class="docutils literal notranslate"><span class="pre">x</span></code> is quantified.</p>
</div>
<p>The behavior of the defective have tactic makes it possible to
generalize it in the following general construction:</p>
<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>have</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <span class="hole">term</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span>:=</span> <span class="hole">term</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>by</span> <span class="hole">tactic</span></span></span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>Open syntax is supported for both <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>. For the description
of <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> and <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> see section
<a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>. The first mode of the
have tactic, which opens a sub-proof for an intermediate result, uses
tactics of the form:</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>have</span> <a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a> <a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a> <span>:</span> <span class="hole">term</span> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dd></dd></dl>

<p>which behave like:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">have</span><span class="o">:</span> <span class="n">term</span> <span class="o">;</span> <span class="kp">first</span> <span class="bp">by</span> <span class="n">tactic</span><span class="o">.</span>
<span class="nb">move</span><span class="o">=&gt;</span> <span class="n">clear_switch</span> <span class="n">i_item</span><span class="o">.</span>
</pre></div>
</div>
<p>Note that the <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> <em>precedes</em> the <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a>, which
allows to reuse
a name of the context, possibly used by the proof of the assumption,
to introduce the new assumption itself.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">by</span></code> feature is especially convenient when the proof script of the
statement is very short, basically when it fits in one line like in:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">have</span> <span class="n">H23</span> <span class="o">:</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="bp">by</span> <span class="nb">rewrite</span> <span class="n">addnC</span><span class="o">.</span>
</pre></div>
</div>
<p>The possibility of using <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> supplies a very concise syntax for
the further use of the intermediate step. For instance,</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk57" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk57"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">a</span> : <span class="mi">3</span> * a - <span class="mi">1</span> = a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> * a - <span class="mi">1</span> = a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk58" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk58"><span class="highlight"><span class="nb">have</span> -&gt; : <span class="kr">forall</span> <span class="nv">x</span>, x * a = a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : nat, x * a = a</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk59" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk59"><hr></label><div class="goal-conclusion"><span class="highlight">a - <span class="mi">1</span> = a</span></div></blockquote></div></div></div></small></span></pre></div><p>Note how the second goal was rewritten using the stated equality.
Also note that in this last subgoal, the intermediate result does not
appear in the context.</p>
</div>
<p>Thanks to the deferred execution of clears, the following idiom is
also supported (assuming x occurs in the goal only):</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">have</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">-&gt;</span> <span class="o">:</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span>
</pre></div>
</div>
<p>Another frequent use of the intro patterns combined with <code class="docutils literal notranslate"><span class="pre">have</span></code> is the
destruction of existential assumptions like in the tactic:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk5a" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk5a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk5b" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk5b"><span class="highlight"><span class="nb">have</span> [x Px]: <span class="kr">exists</span> <span class="nv">x</span> : nat, x &gt; <span class="mi">0</span>; <span class="nb">last first</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Px</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &gt; <span class="mi">0</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk5c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk5c"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">x</span> : nat, x &gt; <span class="mi">0</span></span></div></blockquote></div></div></div></small></span></pre></div></div>
<p>An alternative use of the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic is to provide the explicit proof
term for the intermediate lemma, using tactics of the form:</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>have</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="hole">term</span></span></code></dt>
<dd><p>This tactic creates a new assumption of type the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.
If the
optional <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is present, this assumption is introduced under the
name <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>. Note that the body of the constant is lost for the user.</p>
<p>Again, non inferred implicit arguments and explicit holes are
abstracted.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk5d" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk5d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk5e" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk5e"><span class="highlight"><span class="nb">have</span> H := <span class="kr">forall</span> <span class="nv">x</span>, (x, x) = (x, x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span> -&gt; <span class="kt">Prop</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div><p>adds to the context <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">:</span> <span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Prop.</span></code> This is a schematic example but
the feature is specially useful when the proof term to give involves
for instance a lemma with some hidden implicit arguments.</p>
</div>
<p>After the <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>, a list of binders is allowed.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk5f" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk5f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk60" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk60"><span class="highlight"><span class="nb">have</span> H x (y : nat) : <span class="mi">2</span> * x + y = x + x + y <span class="bp">by</span> <span class="bp">omega</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : nat, <span class="mi">2</span> * x + y = x + x + y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div></div>
<p>A proof term provided after <code class="docutils literal notranslate"><span class="pre">:=</span></code> can mention these bound variables
(that are automatically introduced with the given names).
Since the <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> can be omitted, to avoid ambiguity,
bound variables can be surrounded
with parentheses even if no type is specified:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk61" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk61"><span class="highlight"><span class="nb">have</span> (x) : <span class="mi">2</span> * x = x + x <span class="bp">by</span> <span class="bp">omega</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">x</span> : nat, <span class="mi">2</span> * x = x + x) -&gt; <span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div><p>The <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> and <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> can be used to interpret the asserted
hypothesis with views (see section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>) or simplify the resulting
goals.</p>
<p>The <a class="reference internal" href="#coq:tacn.have" title="have"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">have</span></code></a> tactic also supports a <code class="docutils literal notranslate"><span class="pre">suff</span></code> modifier which allows for
asserting that a given statement implies the current goal without
copying the goal itself.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk62" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk62"><span class="highlight"><span class="nb">have suff</span> H : <span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">3</span>; <span class="nb">last first</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">3</span> -&gt; <span class="kt">True</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk63" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk63"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> + <span class="mi">2</span> = <span class="mi">3</span> -&gt; <span class="kt">True</span></span></div></blockquote></div></div></div></small></span></pre></div><p>Note that H is introduced in the second goal.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">suff</span></code> modifier is not
compatible with the presence of a list of binders.</p>
</div>
<div class="section" id="generating-let-in-context-entries-with-have">
<span id="generating-let-ssr"></span><h4>Generating let in context entries with have<a class="headerlink" href="#generating-let-in-context-entries-with-have" title="Permalink to this headline">¶</a></h4>
<p>Since <span class="smallcaps">SSReflect</span> 1.5 the <a class="reference internal" href="#coq:tacn.have" title="have"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">have</span></code></a> tactic supports a “transparent” modifier
to generate let in context entries: the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> symbol in front of the
context entry name.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">Ord</span> <span class="nv">n</span> := Sub x of x &lt; n.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&#39;I_ n&quot;</span> := (Ord n) (<span class="kn">at level</span> <span class="mi">8</span>, n <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;I_&#39; n&quot;</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Arguments</span> Sub {_} _ _.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk64" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk64"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">n</span> <span class="nv">m</span> (<span class="nv">H</span> : m + <span class="mi">1</span> &lt; n) : <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m + <span class="mi">1</span> &lt; n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk65" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk65"><span class="highlight"><span class="nb">have</span> @i : <span class="err">&#39;</span>I_n <span class="bp">by</span> <span class="nb">apply</span>: (Sub m); <span class="bp">omega</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m + <span class="mi">1</span> &lt; n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">Sub m
  (Decidable.dec_not_not (m &lt; n) (dec_lt m n)
     (<span class="kr">fun</span> <span class="nv">H0</span> : ~ m &lt; n =&gt;
      (<span class="kr">fun</span> <span class="nv">H1</span> : m &gt;= n =&gt;
       (<span class="kr">fun</span> (<span class="nv">P</span> : Z -&gt; <span class="kt">Prop</span>)
          (<span class="nv">H2</span> : P (Z.of_nat m + Z.of_nat <span class="mi">1</span>)%Z) =&gt;
        eq_ind_r P H2 (Nat2Z.inj_add m <span class="mi">1</span>))
         (<span class="kr">fun</span> <span class="nv">x</span> : Z =&gt; (x &lt; Z.of_nat n)%Z -&gt; <span class="kt">False</span>)
         (<span class="kr">fun</span> <span class="nv">H2</span> : (Z.of_nat m + <span class="mi">1</span> &lt; Z.of_nat n)%Z
          =&gt;
          (<span class="kr">fun</span> <span class="nv">H3</span> : (Z.of_nat m &gt;= Z.of_nat n)%Z =&gt;
           ex_ind
             (<span class="kr">fun</span> (<span class="nv">Zvar0</span> : Z)
                (<span class="nv">Omega5</span> : Z.of_nat m = Zvar0 /\
                          (<span class="mi">0</span> &lt;= Zvar0 * <span class="mi">1</span> + <span class="mi">0</span>)%Z)
              =&gt;
              and_ind
                (<span class="kr">fun</span> (<span class="nv">Omega0</span> : Z.of_nat m = Zvar0)
                   (<span class="nv">_</span> : (<span class="mi">0</span> &lt;= Zvar0 * <span class="mi">1</span> + <span class="mi">0</span>)%Z) =&gt;
                 ex_ind
                   (<span class="kr">fun</span> (<span class="nv">Zvar1</span> : Z)
                      (<span class="nv">Omega4</span> : ... = Zvar1 /\
                                (...)%Z) =&gt;
                    and_ind
                      (<span class="kr">fun</span> ... ... =&gt;
                       ... ... ... ...) Omega4)
                   (intro_Z n)) Omega5) (intro_Z m))
            (inj_ge m n H1)) (inj_lt (m + <span class="mi">1</span>) n H))
        (not_lt m n H0)))</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="err">&#39;</span>I_n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div></div>
<p>Note that the subterm produced by <a class="reference internal" href="tactics.html#coq:tacn.omega" title="omega"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">omega</span></code></a> is in general huge and
uninteresting, and hence one may want to hide it.
For this purpose the <code class="docutils literal notranslate"><span class="pre">[:</span> <span class="pre">name</span> <span class="pre">]</span></code> intro pattern and the tactic
<code class="docutils literal notranslate"><span class="pre">abstract</span></code> (see <a class="reference internal" href="#abstract-ssr"><span class="std std-ref">The abstract tactic</span></a>) are provided.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk66" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk66"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">n</span> <span class="nv">m</span> (<span class="nv">H</span> : m + <span class="mi">1</span> &lt; n) : <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m + <span class="mi">1</span> &lt; n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk67" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk67"><span class="highlight"><span class="nb">have</span> [:pm] @i : <span class="err">&#39;</span>I_n <span class="bp">by</span> <span class="nb">apply</span>: (Sub m); <span class="kp">abstract</span>: pm; <span class="bp">omega</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m + <span class="mi">1</span> &lt; n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">pm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m &lt; n <span class="c">(*1*)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">Sub m pm</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="err">&#39;</span>I_n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div><p>The type of <code class="docutils literal notranslate"><span class="pre">pm</span></code> can be cleaned up by its annotation <code class="docutils literal notranslate"><span class="pre">(*1*)</span></code> by just
simplifying it. The annotations are there for technical reasons only.</p>
</div>
<p>When intro patterns for abstract constants are used in conjunction
with have and an explicit term, they must be used as follows:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk68" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk68"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">n</span> <span class="nv">m</span> (<span class="nv">H</span> : m + <span class="mi">1</span> &lt; n) : <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m + <span class="mi">1</span> &lt; n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk69" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk69"><span class="highlight"><span class="nb">have</span> [:pm] @i : <span class="err">&#39;</span>I_n := Sub m pm.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m + <span class="mi">1</span> &lt; n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">S m &lt;= n</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk6a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m + <span class="mi">1</span> &lt; n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">pm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S m &lt;= n <span class="c">(*1*)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">Sub m pm : <span class="err">&#39;</span>I_n</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="err">&#39;</span>I_n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk6a"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk6b" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk6b"><span class="highlight"><span class="bp">by</span> <span class="bp">omega</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m + <span class="mi">1</span> &lt; n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">pm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S m &lt;= n <span class="c">(*1*)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">Sub m pm : <span class="err">&#39;</span>I_n</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="err">&#39;</span>I_n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div></div>
<p>In this case the abstract constant <code class="docutils literal notranslate"><span class="pre">pm</span></code> is assigned by using it in
the term that follows <code class="docutils literal notranslate"><span class="pre">:=</span></code> and its corresponding goal is left to be
solved. Goals corresponding to intro patterns for abstract constants
are opened in the order in which the abstract constants are declared
(not in the “order” in which they are used in the term).</p>
<p>Note that abstract constants do respect scopes. Hence, if a variable
is declared after their introduction, it has to be properly
generalized (i.e. explicitly passed to the abstract constant when one
makes use of it).</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk6c" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk6c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">n</span> <span class="nv">m</span> (<span class="nv">H</span> : m + <span class="mi">1</span> &lt; n) : <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m + <span class="mi">1</span> &lt; n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk6d" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk6d"><span class="highlight"><span class="nb">have</span> [:pm] @i k : <span class="err">&#39;</span>I_(n+k) <span class="bp">by</span> <span class="nb">apply</span>: (Sub m); <span class="kp">abstract</span>: pm k; <span class="bp">omega</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m + <span class="mi">1</span> &lt; n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">pm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(<span class="kr">forall</span> <span class="nv">k</span> : nat, m &lt; n + k) <span class="c">(*1*)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; Sub m (pm k)</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : nat, <span class="err">&#39;</span>I_(n + k)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div></div>
<p>Last, notice that the use of intro patterns for abstract constants is
orthogonal to the transparent flag <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> for have.</p>
</div>
<div class="section" id="the-have-tactic-and-typeclass-resolution">
<h4>The have tactic and typeclass resolution<a class="headerlink" href="#the-have-tactic-and-typeclass-resolution" title="Permalink to this headline">¶</a></h4>
<p>Since <span class="smallcaps">SSReflect</span> 1.5 the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic behaves as follows with respect to
typeclass inference.</p>
<blockquote>
<div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk6e" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk6e"><span class="highlight"><span class="nb">have</span> foo : ty.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">ty</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk6f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">foo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ty</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk6f"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></div></small></span></pre></div><p>Full inference for <code class="docutils literal notranslate"><span class="pre">ty</span></code>. The first subgoal demands a
proof of such instantiated statement.</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">have</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">ty</span> <span class="o">:=</span> <span class="o">.</span>
</pre></div>
</div>
<p>No inference for <code class="docutils literal notranslate"><span class="pre">ty</span></code>. Unresolved instances are
quantified in <code class="docutils literal notranslate"><span class="pre">ty</span></code>. The first subgoal demands a proof of such quantified
statement. Note that no proof term follows <code class="docutils literal notranslate"><span class="pre">:=</span></code>, hence two subgoals are
generated.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk70" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk70"><span class="highlight"><span class="nb">have</span> foo : ty := t.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">foo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ty</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div><p>No inference for <code class="docutils literal notranslate"><span class="pre">ty</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk71" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk71"><span class="highlight"><span class="nb">have</span> foo := t.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">foo</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ty</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div><p>No inference for <code class="docutils literal notranslate"><span class="pre">t</span></code>. Unresolved instances are
quantified in the (inferred) type of <code class="docutils literal notranslate"><span class="pre">t</span></code> and abstracted in <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
</div></blockquote>
<dl class="coq flag">
<dt id="coq:flag.ssrhave-notcresolution">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>SsrHave</span> <span>NoTCResolution</span></span></code><a class="headerlink" href="#coq:flag.ssrhave-notcresolution" title="Permalink to this definition">¶</a></dt>
<dd><p>This option restores the behavior of <span class="smallcaps">SSReflect</span> 1.4 and below (never resolve typeclasses).</p>
</dd></dl>

</div>
<div class="section" id="variants-the-suff-and-wlog-tactics">
<h4>Variants: the suff and wlog tactics<a class="headerlink" href="#variants-the-suff-and-wlog-tactics" title="Permalink to this headline">¶</a></h4>
<p>As it is often the case in mathematical textbooks, forward reasoning
may be used in slightly different variants. One of these variants is
to show that the intermediate step L easily implies the initial goal
G. By easily we mean here that the proof of L ⇒ G is shorter than the
one of L itself. This kind of reasoning step usually starts with: “It
suffices to show that …”.</p>
<p>This is such a frequent way of reasoning that <span class="smallcaps">SSReflect</span> has a variant
of the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic called <code class="docutils literal notranslate"><span class="pre">suffices</span></code> (whose abridged name is <code class="docutils literal notranslate"><span class="pre">suff</span></code>).
The
<code class="docutils literal notranslate"><span class="pre">have</span></code> and <code class="docutils literal notranslate"><span class="pre">suff</span></code> tactics are equivalent and have the same syntax but:</p>
<ul>
<li><p>the order of the generated subgoals is inverted</p></li>
<li><p>the optional clear item is still performed in the <em>second</em>
branch. This means that the tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">suff</span> <span class="o">{</span><span class="n">H</span><span class="o">}</span> <span class="n">H</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">.</span>
</pre></div>
</div>
<p>fails if the context of the current goal indeed contains an
assumption named <code class="docutils literal notranslate"><span class="pre">H</span></code>.</p>
</li>
</ul>
<p>The rationale of this clearing policy is to make possible “trivial”
refinements of an assumption, without changing its name in the main
branch of the reasoning.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">have</span></code> modifier can follow the <code class="docutils literal notranslate"><span class="pre">suff</span></code> tactic.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk72" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk72"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : G.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">G</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk73" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk73"><span class="highlight"><span class="nb">suff have</span> H : P.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">G</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk74" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk74"><hr></label><div class="goal-conclusion"><span class="highlight">(P -&gt; G) -&gt; G</span></div></blockquote></div></div></div></small></span></pre></div><p>Note that, in contrast with <code class="docutils literal notranslate"><span class="pre">have</span> <span class="pre">suff</span></code>, the name H has been introduced
in the first goal.</p>
</div>
<p>Another useful construct is reduction, showing that a particular case
is in fact general enough to prove a general property. This kind of
reasoning step usually starts with: “Without loss of generality, we
can suppose that …”. Formally, this corresponds to the proof of a goal
<code class="docutils literal notranslate"><span class="pre">G</span></code> by introducing a cut <code class="docutils literal notranslate"><span class="pre">wlog_statement</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code>. Hence the user shall
provide a proof for both <code class="docutils literal notranslate"><span class="pre">(wlog_statement</span> <span class="pre">-&gt;</span> <span class="pre">G)</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code> and
<code class="docutils literal notranslate"><span class="pre">wlog_statement</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code>. However, such cuts are usually rather
painful to perform by
hand, because the statement <code class="docutils literal notranslate"><span class="pre">wlog_statement</span></code> is tedious to write by hand,
and sometimes even to read.</p>
<p><span class="smallcaps">SSReflect</span> implements this kind of reasoning step through the <a class="reference internal" href="#coq:tacn.without-loss" title="without loss"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">without</span> <span class="pre">loss</span></code></a>
tactic, whose short name is <a class="reference internal" href="#coq:tacn.wlog" title="wlog"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">wlog</span></code></a>. It offers support to describe
the shape of the cut statements, by providing the simplifying
hypothesis and by pointing at the elements of the initial goals which
should be generalized. The general syntax of without loss is:</p>
<dl class="coq tacn">
<dt id="coq:tacn.wlog">
<code class="sig-name descname"><span class="notation"><span>wlog</span> <span class="repeat-wrapper"><span class="repeat"><span>suff</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">*</span></span> <span>/</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.wlog" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacn.without-loss">
<code class="sig-name descname"><span class="notation"><span>without</span> <span>loss</span> <span class="repeat-wrapper"><span class="repeat"><span>suff</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">*</span></span> <span>/</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.without-loss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>where each <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is a constant in the context
of the goal. Open syntax is supported for <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.</p>
<p>In its defective form:</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>wlog:</span> <span>/</span> <span class="hole">term</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>without</span> <span>loss:</span> <span>/</span> <span class="hole">term</span></span></code></dt>
<dd></dd></dl>

<p>on a goal G, it creates two subgoals: a first one to prove the
formula (term -&gt; G) -&gt; G and a second one to prove the formula
term -&gt; G.</p>
<p>If the optional list of <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is present
on the left side of <code class="docutils literal notranslate"><span class="pre">/</span></code>, these constants are generalized in the
premise (term -&gt; G) of the first subgoal. By default bodies of local
definitions are erased. This behavior can be inhibited by prefixing the
name of the local definition with the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> character.</p>
<p>In the second subgoal, the tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">move</span><span class="o">=&gt;</span> <span class="n">clear_switch</span> <span class="n">i_item</span><span class="o">.</span>
</pre></div>
</div>
<p>is performed if at least one of these optional switches is present in
the <a class="reference internal" href="#coq:tacn.wlog" title="wlog"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">wlog</span></code></a> tactic.</p>
<p>The <a class="reference internal" href="#coq:tacn.wlog" title="wlog"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">wlog</span></code></a> tactic is specially useful when a symmetry argument
simplifies a proof. Here is an example showing the beginning of the
proof that quotient and reminder of natural number euclidean division
are unique.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk75" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk75"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">quo_rem_unicity</span> <span class="nv">d</span> <span class="nv">q1</span> <span class="nv">q2</span> <span class="nv">r1</span> <span class="nv">r2</span> :
  q1*d + r1 = q2*d + r2 -&gt; r1 &lt; d -&gt; r2 &lt; d -&gt; (q1, r1) = (q2, r2).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">d, q1, q2, r1, r2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">q1 * d + r1 = q2 * d + r2 -&gt;
r1 &lt; d -&gt; r2 &lt; d -&gt; (q1, r1) = (q2, r2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk76" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk76"><span class="highlight"><span class="nb">wlog</span>: q1 q2 r1 r2 / q1 &lt;= q2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">d, q1, q2, r1, r2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">q3</span> <span class="nv">q4</span> <span class="nv">r3</span> <span class="nv">r4</span> : nat,
 q3 &lt;= q4 -&gt;
 q3 * d + r3 = q4 * d + r4 -&gt;
 r3 &lt; d -&gt; r4 &lt; d -&gt; (q3, r3) = (q4, r4)) -&gt;
q1 * d + r1 = q2 * d + r2 -&gt;
r1 &lt; d -&gt; r2 &lt; d -&gt; (q1, r1) = (q2, r2)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk77" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">d, q1, q2, r1, r2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk77"><hr></label><div class="goal-conclusion"><span class="highlight">q1 &lt;= q2 -&gt;
q1 * d + r1 = q2 * d + r2 -&gt;
r1 &lt; d -&gt; r2 &lt; d -&gt; (q1, r1) = (q2, r2)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk78" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk78"><span class="highlight"><span class="bp">by</span> <span class="nb">case</span> (le_gt_dec q1 q2)=&gt; H; <span class="nb">last</span> <span class="nb">symmetry</span>; <span class="nb">eauto with</span> arith.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">d, q1, q2, r1, r2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">q1 &lt;= q2 -&gt;
q1 * d + r1 = q2 * d + r2 -&gt;
r1 &lt; d -&gt; r2 &lt; d -&gt; (q1, r1) = (q2, r2)</span></div></blockquote></div></div></small></span></pre></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">wlog</span> <span class="pre">suff</span></code> variant is simpler, since it cuts <code class="docutils literal notranslate"><span class="pre">wlog_statement</span></code> instead
of <code class="docutils literal notranslate"><span class="pre">wlog_statement</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code>. It thus opens the goals
<code class="docutils literal notranslate"><span class="pre">wlog_statement</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code>
and <code class="docutils literal notranslate"><span class="pre">wlog_statement</span></code>.</p>
<p>In its simplest form the <code class="docutils literal notranslate"><span class="pre">generally</span> <span class="pre">have</span> <span class="pre">:</span> <span class="pre">…</span></code> tactic is equivalent to
<code class="docutils literal notranslate"><span class="pre">wlog</span> <span class="pre">suff</span> <span class="pre">:</span> <span class="pre">…</span></code> followed by last first. When the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic is used
with the <code class="docutils literal notranslate"><span class="pre">generally</span></code> (or <code class="docutils literal notranslate"><span class="pre">gen</span></code>) modifier it accepts an extra identifier
followed by a comma before the usual intro pattern. The identifier
will name the new hypothesis in its more general form, while the intro
pattern will be used to process its instance.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk79" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk79"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">simple</span> <span class="nv">n</span> (<span class="nv">ngt0</span> : <span class="mi">0</span> &lt; n ) : P n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">ngt0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> &lt; n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk7a" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk7a"><span class="highlight"><span class="nb">gen have</span> ltnV, /andP[nge0 neq0] : n ngt0 / (<span class="mi">0</span> &lt;= n) &amp;&amp; (n != <span class="mi">0</span>); <span class="nb">last first</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">ngt0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> &lt; n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">ltnV</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> : nat,
<span class="mi">0</span> &lt; n0 -&gt; (<span class="mi">0</span> &lt;= n0) &amp;&amp; (n0 != <span class="mi">0</span>)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nge0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true (<span class="mi">0</span> &lt;= n)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">neq0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true (n != <span class="mi">0</span>)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P n</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk7b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">ngt0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> &lt; n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk7b"><hr></label><div class="goal-conclusion"><span class="highlight">is_true ((<span class="mi">0</span> &lt;= n) &amp;&amp; (n != <span class="mi">0</span>))</span></div></blockquote></div></div></div></small></span></pre></div></div>
<div class="section" id="advanced-generalization">
<span id="advanced-generalization-ssr"></span><h5>Advanced generalization<a class="headerlink" href="#advanced-generalization" title="Permalink to this headline">¶</a></h5>
<p>The complete syntax for the items on the left hand side of the <code class="docutils literal notranslate"><span class="pre">/</span></code>
separator is the following one:</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>wlog</span> <span>…</span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><span>&#64;</span></span><span class="notation-sup">?</span></span><span class="hole">ident</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>(</span> <span class="repeat-wrapper"><span class="repeat"><span>&#64;</span></span><span class="notation-sup">?</span></span><span class="hole">ident</span> <span>:=</span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a><span>)</span></span></span></span><span class="notation-sup">?</span></span> <span>/</span> <span class="hole">term</span></span></code></dt>
<dd></dd></dl>

<p>Clear operations are intertwined with generalization operations. This
helps in particular avoiding dependency issues while generalizing some
facts.</p>
<p>If an <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is prefixed with the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> mark, then a let-in redex is
created, which keeps track if its body (if any). The syntax
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole"><span class="pre">c_pattern</span></span></a><span><span class="pre">)</span></span></span></code> allows to generalize an arbitrary term using a
given name. Note that its simplest form <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:=</span> <span class="pre">y)</span></code> is just a renaming of
<code class="docutils literal notranslate"><span class="pre">y</span></code> into <code class="docutils literal notranslate"><span class="pre">x</span></code>. In particular, this can be useful in order to simulate the
generalization of a section variable, otherwise not allowed. Indeed
renaming does not require the original variable to be cleared.</p>
<p>The syntax <code class="docutils literal notranslate"><span class="pre">(&#64;x</span> <span class="pre">:=</span> <span class="pre">y)</span></code> generates a let-in abstraction but with the
following caveat: <code class="docutils literal notranslate"><span class="pre">x</span></code> will not bind <code class="docutils literal notranslate"><span class="pre">y</span></code>, but its body, whenever <code class="docutils literal notranslate"><span class="pre">y</span></code> can be
unfolded. This covers the case of both local and global definitions, as
illustrated in the following example.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">Test</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">x</span> : nat.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">addx</span> <span class="nv">z</span> := z + x.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk7c" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk7c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : x &lt;= addx x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt;= addx x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk7d" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk7d"><span class="highlight"><span class="nb">wlog</span> H : (y := x) (@twoy := addx x) / twoy = <span class="mi">2</span> * y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">y</span> : nat,
 <span class="kr">let</span> <span class="nv">twoy</span> := y + y <span class="kr">in</span> twoy = <span class="mi">2</span> * y -&gt; y &lt;= twoy) -&gt;
x &lt;= addx x</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk7e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">twoy</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">y + y</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">twoy = <span class="mi">2</span> * y</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk7e"><hr></label><div class="goal-conclusion"><span class="highlight">y &lt;= twoy</span></div></blockquote></div></div></div></small></span></pre></div><p>To avoid unfolding the term captured by the pattern add x one can use
the pattern <code class="docutils literal notranslate"><span class="pre">id</span> <span class="pre">(addx</span> <span class="pre">x)</span></code>, that would produce the following first
subgoal</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk7f" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk7f"><span class="highlight"><span class="nb">wlog</span> H : (y := x) (@twoy := id (addx x)) / twoy = <span class="mi">2</span> * y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">y</span> : nat,
 <span class="kr">let</span> <span class="nv">twoy</span> := addx y <span class="kr">in</span> twoy = <span class="mi">2</span> * y -&gt; y &lt;= addx y) -&gt;
x &lt;= addx x</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk80" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">twoy</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">addx y</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">twoy = <span class="mi">2</span> * y</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk80"><hr></label><div class="goal-conclusion"><span class="highlight">y &lt;= addx y</span></div></blockquote></div></div></div></small></span></pre></div></div>
</div>
</div>
</div>
</div>
<div class="section" id="rewriting">
<span id="rewriting-ssr"></span><h2>Rewriting<a class="headerlink" href="#rewriting" title="Permalink to this headline">¶</a></h2>
<p>The generalized use of reflection implies that most of the
intermediate results handled are properties of effectively computable
functions. The most efficient mean of establishing such results are
computation and simplification of expressions involving such
functions, i.e., rewriting. <span class="smallcaps">SSReflect</span> therefore includes an
extended <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> tactic, that unifies and combines most of the
rewriting functionalities.</p>
<div class="section" id="an-extended-rewrite-tactic">
<h3>An extended rewrite tactic<a class="headerlink" href="#an-extended-rewrite-tactic" title="Permalink to this headline">¶</a></h3>
<p>The main features of the rewrite tactic are:</p>
<ul class="simple">
<li><p>It can perform an entire series of such operations in any subset of
the goal and/or context;</p></li>
<li><p>It allows to perform rewriting, simplifications, folding/unfolding
of definitions, closing of goals;</p></li>
<li><p>Several rewriting operations can be chained in a single tactic;</p></li>
<li><p>Control over the occurrence at which rewriting is to be performed is
significantly enhanced.</p></li>
</ul>
<p>The general form of an <span class="smallcaps">SSReflect</span> rewrite tactic is:</p>
<dl class="coq tacn">
<dt id="coq:tacn.rewrite-ssreflect">
<code class="sig-name descname"><span class="notation"><span>rewrite</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-rstep"><span class="hole">rstep</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn.rewrite-ssreflect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The combination of a rewrite tactic with the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical (see section
<a class="reference internal" href="#localization-ssr"><span class="std std-ref">Localization</span></a>) performs rewriting in both the context and the goal.</p>
<p>A rewrite step <a class="reference internal" href="#grammar-token-rstep"><code class="xref std std-token docutils literal notranslate"><span class="pre">rstep</span></code></a> has the general form:</p>
<dl class="coq prodn">
<dt id="grammar-token-rstep">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">rstep</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_prefix"><span class="hole">r_prefix</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-r_item"><span class="hole">r_item</span></a></span></code><a class="headerlink" href="#grammar-token-rstep" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq prodn">
<dt id="grammar-token-r_prefix">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">r_prefix</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>-</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-mult"><span class="hole">mult</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>[</span> <a class="reference internal" href="#grammar-token-r_pattern"><span class="hole">r_pattern</span></a> <span>]</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#grammar-token-r_prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq prodn">
<dt id="grammar-token-r_pattern">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">r_pattern</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span class="hole">term</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>in</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span> <span>in</span></span><span class="notation-sup">?</span></span> <span class="hole">term</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="alternative"><span class="alternative-block"><span class="hole">term</span> <span>in</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="hole">term</span> <span>as</span></span></span> <span class="hole">ident</span> <span>in</span> <span class="hole">term</span></span></span></span></code><a class="headerlink" href="#grammar-token-r_pattern" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq prodn">
<dt id="grammar-token-r_item">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">r_item</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><span>/</span></span><span class="notation-sup">?</span></span> <span class="hole">term</span></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span></span></span></code><a class="headerlink" href="#grammar-token-r_item" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>An <a class="reference internal" href="#grammar-token-r_prefix"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_prefix</span></code></a> contains annotations to qualify where and how the rewrite
operation should be performed:</p>
<ul>
<li><p>The optional initial <code class="docutils literal notranslate"><span class="pre">-</span></code> indicates the direction of the rewriting of
<a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>:
if present the direction is right-to-left and it is left-to-right otherwise.</p></li>
<li><p>The multiplier <a class="reference internal" href="#grammar-token-mult"><code class="xref std std-token docutils literal notranslate"><span class="pre">mult</span></code></a> (see section <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a>)
specifies if and how the
rewrite operation should be repeated.</p></li>
<li><p>A rewrite operation matches the occurrences of a <em>rewrite pattern</em>,
and replaces these occurrences by another term, according to the
given <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>. The optional <em>redex switch</em> <code class="docutils literal notranslate"><span class="pre">[r_pattern]</span></code>,
which should
always be surrounded by brackets, gives explicitly this rewrite
pattern. In its simplest form, it is a regular term. If no explicit
redex switch is present the rewrite pattern to be matched is inferred
from the <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>.</p></li>
<li><p>This optional term, or the <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>, may be preceded by an
<a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> (see section <a class="reference internal" href="#selectors-ssr"><span class="std std-ref">Selectors</span></a>) or a
<a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> (see section <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>),
these two possibilities being exclusive.</p>
<p>An occurrence switch selects
the occurrences of the rewrite pattern which should be affected by the
rewrite operation.</p>
<p>A clear switch, even an empty one, is performed <em>after</em> the
<a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a> is actually processed and is complemented with the name of
the rewrite rule if an only if it is a simple proof context entry <a class="footnote-reference brackets" href="#id24" id="id11">20</a>.
As a consequence one can
write <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">{}H</span></code> to rewrite with <code class="docutils literal notranslate"><span class="pre">H</span></code> and dispose <code class="docutils literal notranslate"><span class="pre">H</span></code> immediately
afterwards.
This behavior can be avoided by putting parentheses around the rewrite rule.</p>
</li>
</ul>
<p>An <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a> can be:</p>
<ul>
<li><p>A <em>simplification</em> <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>,
represented by a <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> (see section
<a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>). Simplification operations are intertwined with the possible
other rewrite operations specified by the list of <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>.</p></li>
<li><p>A <em>folding/unfolding</em> <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>. The tactic:
<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">/term</span></code> unfolds the
head constant of term in every occurrence of the first matching of
term in the goal. In particular, if <code class="docutils literal notranslate"><span class="pre">my_def</span></code> is a (local or global)
defined constant, the tactic: <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">/my_def.</span></code> is analogous to:
<code class="docutils literal notranslate"><span class="pre">unfold</span> <span class="pre">my_def</span></code>.
Conversely: <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">-/my_def.</span></code> is equivalent to: <code class="docutils literal notranslate"><span class="pre">fold</span> <span class="pre">my_def</span></code>.
When an unfold <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a> is combined with a
redex pattern, a conversion
operation is performed. A tactic of the form:
<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">-[term1]/term2.</span></code>
is equivalent to: <code class="docutils literal notranslate"><span class="pre">change</span> <span class="pre">term1</span> <span class="pre">with</span> <span class="pre">term2.</span></code> If <code class="docutils literal notranslate"><span class="pre">term2</span></code> is a
single constant and <code class="docutils literal notranslate"><span class="pre">term1</span></code> head symbol is not <code class="docutils literal notranslate"><span class="pre">term2</span></code>, then the head
symbol of <code class="docutils literal notranslate"><span class="pre">term1</span></code> is repeatedly unfolded until <code class="docutils literal notranslate"><span class="pre">term2</span></code> appears.</p></li>
<li><dl class="simple">
<dt>A <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>, which can be:</dt><dd><ul class="simple">
<li><p>A term whose type has the form:
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">(x1</span> <span class="pre">:</span> <span class="pre">A1</span> <span class="pre">)…(xn</span> <span class="pre">:</span> <span class="pre">An</span> <span class="pre">),</span> <span class="pre">eq</span> <span class="pre">term1</span> <span class="pre">term2</span></code> where
<code class="docutils literal notranslate"><span class="pre">eq</span></code> is the Leibniz equality or a registered setoid
equality.</p></li>
<li><p>A list of terms <code class="docutils literal notranslate"><span class="pre">(t1</span> <span class="pre">,…,tn)</span></code>, each <code class="docutils literal notranslate"><span class="pre">ti</span></code> having a type above.
The tactic: <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">r_prefix</span> <span class="pre">(t1</span> <span class="pre">,…,tn</span> <span class="pre">).</span></code>
is equivalent to: <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">[rewrite</span> <span class="pre">r_prefix</span> <span class="pre">t1</span> <span class="pre">|</span> <span class="pre">…</span> <span class="pre">|</span> <span class="pre">rewrite</span> <span class="pre">r_prefix</span> <span class="pre">tn</span> <span class="pre">].</span></code></p></li>
<li><p>An anonymous rewrite lemma <code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">:</span> <span class="pre">term)</span></code>, where term has a type as above.  tactic: <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">(_</span> <span class="pre">:</span> <span class="pre">term)</span></code> is in fact synonym of: <code class="docutils literal notranslate"><span class="pre">cutrewrite</span> <span class="pre">(term).</span></code>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">double</span> <span class="nv">x</span> := x + x.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ddouble</span> <span class="nv">x</span> := double (double x).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk81" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk81"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> : ddouble x = <span class="mi">4</span> * x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">ddouble x = <span class="mi">4</span> * x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk82" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk82"><span class="highlight"><span class="nb">rewrite</span> [ddouble _]/double.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">double x + double x = <span class="mi">4</span> * x</span></div></blockquote></div></div></small></span></pre></div></div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <span class="smallcaps">SSReflect</span> terms containing holes are <em>not</em> typed as
abstractions in this context. Hence the following script fails.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">f</span> := <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; x + y.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk83" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk83"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span> : x + y = f y x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y = f y x</span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk84" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ssreflect-proof-language-rst-chk84"><span class="highlight"><span class="nb">rewrite</span> -[f y]/(y + _).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight"><span class="nb">fold</span> <span class="nb">pattern</span> (y + _) does not <span class="kr">match</span> redex (f y)</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y = f y x</span></div></blockquote></div></div></small></span></pre></div><p>but the following script succeeds</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk85" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk85"><span class="highlight"><span class="nb">rewrite</span> -[f y x]/(y + _).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y = y + x</span></div></blockquote></div></div></small></span></pre></div></div>
</li>
</ul>
<dl class="coq flag">
<dt id="coq:flag.ssroldrewritegoalsorder">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>SsrOldRewriteGoalsOrder</span></span></code><a class="headerlink" href="#coq:flag.ssroldrewritegoalsorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the order in which generated subgoals (side conditions)
are added to the
proof context.  The flag is off by default, which puts subgoals generated
by conditional rules first, followed by the main goal.  When it is on,
the main goal appears first.  If your proofs are organized to complete
proving the main goal before side conditions, turning the flag on will save you
from having to add <a class="reference internal" href="#coq:tacv.last-first" title="last first"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">last</span> <span class="pre">first</span></code></a> tactics that would be needed
to keep the main goal as the currently focused goal.</p>
</dd></dl>

</div>
<div class="section" id="remarks-and-examples">
<h3>Remarks and examples<a class="headerlink" href="#remarks-and-examples" title="Permalink to this headline">¶</a></h3>
<div class="section" id="rewrite-redex-selection">
<h4>Rewrite redex selection<a class="headerlink" href="#rewrite-redex-selection" title="Permalink to this headline">¶</a></h4>
<p>The general strategy of <span class="smallcaps">SSReflect</span> is to grasp as many redexes as
possible and to let the user select the ones to be rewritten thanks to
the improved syntax for the control of rewriting.</p>
<p>This may be a source of incompatibilities between the two rewrite
tactics.</p>
<p>In a rewrite tactic of the form:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">rewrite</span> <span class="n">occ_switch</span> <span class="o">[</span><span class="n">term1</span><span class="o">]</span><span class="n">term2</span><span class="o">.</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">term1</span></code> is the explicit rewrite redex and <code class="docutils literal notranslate"><span class="pre">term2</span></code> is the rewrite rule.
This execution of this tactic unfolds as follows:</p>
<ul class="simple">
<li><p>First <code class="docutils literal notranslate"><span class="pre">term1</span></code> and <code class="docutils literal notranslate"><span class="pre">term2</span></code> are βι normalized. Then <code class="docutils literal notranslate"><span class="pre">term2</span></code>
is put in head
normal form if the Leibniz equality constructor <code class="docutils literal notranslate"><span class="pre">eq</span></code> is not the head
symbol. This may involve ζ reductions.</p></li>
<li><p>Then, the matching algorithm (see section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>)
determines the
first subterm of the goal matching the rewrite pattern. The rewrite
pattern is given by <code class="docutils literal notranslate"><span class="pre">term1</span></code>, if an explicit redex pattern switch is
provided, or by the type of <code class="docutils literal notranslate"><span class="pre">term2</span></code> otherwise. However, matching skips
over matches that would lead to trivial rewrites. All the occurrences
of this subterm in the goal are candidates for rewriting.</p></li>
<li><p>Then only the occurrences coded by <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> (see again section
<a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>) are finally selected for rewriting.</p></li>
<li><p>The left hand side of <code class="docutils literal notranslate"><span class="pre">term2</span></code> is unified with the subterm found by
the matching algorithm, and if this succeeds, all the selected
occurrences in the goal are replaced by the right hand side of <code class="docutils literal notranslate"><span class="pre">term2</span></code>.</p></li>
<li><p>Finally the goal is βι normalized.</p></li>
</ul>
<p>In the case <code class="docutils literal notranslate"><span class="pre">term2</span></code> is a list of terms, the first top-down (in the
goal) left-to-right (in the list) matching rule gets selected.</p>
</div>
<div class="section" id="chained-rewrite-steps">
<h4>Chained rewrite steps<a class="headerlink" href="#chained-rewrite-steps" title="Permalink to this headline">¶</a></h4>
<p>The possibility to chain rewrite operations in a single tactic makes
scripts more compact and gathers in a single command line a bunch of
surgical operations which would be described by a one sentence in a
pen and paper proof.</p>
<p>Performing rewrite and simplification operations in a single tactic
enhances significantly the concision of scripts. For instance the
tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">rewrite</span> <span class="o">/</span><span class="n">my_def</span> <span class="o">{</span><span class="mi">2</span><span class="o">}[</span><span class="n">f</span> <span class="n">_</span><span class="o">]/=</span> <span class="n">my_eq</span> <span class="o">//=.</span>
</pre></div>
</div>
<p>unfolds <code class="docutils literal notranslate"><span class="pre">my_def</span></code> in the goal, simplifies the second occurrence of the
first subterm matching pattern <code class="docutils literal notranslate"><span class="pre">[f</span> <span class="pre">_]</span></code>, rewrites <code class="docutils literal notranslate"><span class="pre">my_eq</span></code>, simplifies the
goals and closes trivial goals.</p>
<p>Here are some concrete examples of chained rewrite operations, in the
proof of basic results on natural numbers arithmetic.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">addn0</span> : <span class="kr">forall</span> <span class="nv">m</span>, m + <span class="mi">0</span> = m.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">addnS</span> : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span>, m + S n = S (m + n).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">addSnnS</span> : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span>, S m + n = m + S n.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk86" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk86"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">addnCA</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">p</span> : m + (n + p) = n + (m + p).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n, p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">m + (n + p) = n + (m + p)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">by</span> <span class="nb">elim</span>: m p =&gt; [ | m Hrec] p; <span class="nb">rewrite</span> ?addSnnS -?addnS.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk87" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk87"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">addnC</span> <span class="nv">n</span> <span class="nv">m</span> : m + n = n + m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">m + n = n + m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[n]addn0 addnCA addn0.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div></div>
<p>Note the use of the <code class="docutils literal notranslate"><span class="pre">?</span></code> switch for parallel rewrite operations in the
proof of <code class="docutils literal notranslate"><span class="pre">addnCA</span></code>.</p>
</div>
<div class="section" id="explicit-redex-switches-are-matched-first">
<h4>Explicit redex switches are matched first<a class="headerlink" href="#explicit-redex-switches-are-matched-first" title="Permalink to this headline">¶</a></h4>
<p>If an <a class="reference internal" href="#grammar-token-r_prefix"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_prefix</span></code></a> involves a <em>redex switch</em>, the first step is to find a
subterm matching this redex pattern, independently from the left hand
side of the equality the user wants to rewrite.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk88" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk88"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">t</span> <span class="nv">u</span>, t + u = u + t) <span class="nv">x</span> <span class="nv">y</span> : x + y = y + x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">t</span> <span class="nv">u</span> : nat, t + u = u + t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y = y + x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk89" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk89"><span class="highlight"><span class="nb">rewrite</span> [y + _]H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">t</span> <span class="nv">u</span> : nat, t + u = u + t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y = x + y</span></div></blockquote></div></div></small></span></pre></div></div>
<p>Note that if this first pattern matching is not compatible with the
<a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>, the rewrite fails, even if the goal contains a
correct redex matching both the redex switch and the left hand side of
the equality.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk8a" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk8a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">t</span> <span class="nv">u</span>, t + u * <span class="mi">0</span> = t) <span class="nv">x</span> <span class="nv">y</span> : x + y * <span class="mi">4</span> + <span class="mi">2</span> * <span class="mi">0</span> = x + <span class="mi">2</span> * <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">t</span> <span class="nv">u</span> : nat, t + u * <span class="mi">0</span> = t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y * <span class="mi">4</span> + <span class="mi">2</span> * <span class="mi">0</span> = x + <span class="mi">2</span> * <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk8b" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk8b"><span class="highlight"><span class="kn">Fail</span> <span class="nb">rewrite</span> [x + _]H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
<span class="nb">pattern</span> (x + y * <span class="mi">4</span>) does not <span class="kr">match</span> LHS of H</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">t</span> <span class="nv">u</span> : nat, t + u * <span class="mi">0</span> = t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y * <span class="mi">4</span> + <span class="mi">2</span> * <span class="mi">0</span> = x + <span class="mi">2</span> * <span class="mi">0</span></span></div></blockquote></div></div></small></span></pre></div><p>Indeed the left hand side of <code class="docutils literal notranslate"><span class="pre">H</span></code> does not match
the redex identified by the pattern <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">4</span></code>.</p>
</div>
</div>
<div class="section" id="occurrence-switches-and-redex-switches">
<span id="ssr-rewrite-occ-switch"></span><h4>Occurrence switches and redex switches<a class="headerlink" href="#occurrence-switches-and-redex-switches" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk8c" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk8c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span> : x + y + <span class="mi">0</span> = x + y + y + <span class="mi">0</span> + <span class="mi">0</span> + (x + y + <span class="mi">0</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y + <span class="mi">0</span> = x + y + y + <span class="mi">0</span> + <span class="mi">0</span> + (x + y + <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk8d" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk8d"><span class="highlight"><span class="nb">rewrite</span> {<span class="mi">2</span>}[_ + y + <span class="mi">0</span>](_: <span class="kr">forall</span> <span class="nv">z</span>, z + <span class="mi">0</span> = z).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : nat, z + <span class="mi">0</span> = z</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk8e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk8e"><hr></label><div class="goal-conclusion"><span class="highlight">x + y + <span class="mi">0</span> = x + y + y + <span class="mi">0</span> + <span class="mi">0</span> + (x + y)</span></div></blockquote></div></div></div></small></span></pre></div></div>
<p>The second subgoal is generated by the use of an anonymous lemma in
the rewrite tactic. The effect of the tactic on the initial goal is to
rewrite this lemma at the second occurrence of the first matching
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">0</span></code> of the explicit rewrite redex <code class="docutils literal notranslate"><span class="pre">_</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">0</span></code>.</p>
</div>
<div class="section" id="occurrence-selection-and-repetition">
<h4>Occurrence selection and repetition<a class="headerlink" href="#occurrence-selection-and-repetition" title="Permalink to this headline">¶</a></h4>
<p>Occurrence selection has priority over repetition switches. This means
the repetition of a rewrite tactic specified by a multiplier will
perform matching each time an elementary rewrite operation is
performed. Repeated rewrite tactics apply to every subgoal generated
by the previous tactic, including the previous instances of the
repetition.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk8f" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk8f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span> (<span class="nv">z</span> : nat) : x + <span class="mi">1</span> = x + y + <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + <span class="mi">1</span> = x + y + <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk90" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk90"><span class="highlight"><span class="nb">rewrite</span> <span class="mi">2</span>!(_ : _ + <span class="mi">1</span> = z).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + <span class="mi">1</span> = z</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk91" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk91"><hr></label><div class="goal-conclusion"><span class="highlight">z = z</span></div></blockquote><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk92" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk92"><hr></label><div class="goal-conclusion"><span class="highlight">x + y + <span class="mi">1</span> = z</span></div></blockquote><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk93" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk93"><hr></label><div class="goal-conclusion"><span class="highlight">z = z</span></div></blockquote></div></div></div></small></span></pre></div></div>
<p>This last tactic generates <em>three</em> subgoals because
the second rewrite operation specified with the <code class="docutils literal notranslate"><span class="pre">2!</span></code> multiplier
applies to the two subgoals generated by the first rewrite.</p>
</div>
<div class="section" id="multi-rule-rewriting">
<h4>Multi-rule rewriting<a class="headerlink" href="#multi-rule-rewriting" title="Permalink to this headline">¶</a></h4>
<p>The rewrite tactic can be provided a <em>tuple</em> of rewrite rules, or more
generally a tree of such rules, since this tuple can feature arbitrary
inner parentheses. We call <em>multirule</em> such a generalized rewrite
rule. This feature is of special interest when it is combined with
multiplier switches, which makes the rewrite tactic iterate the
rewrite operations prescribed by the rules on the current goal.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variables</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : nat).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hypothesis</span> <span class="nv">eqab</span> : a = b.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hypothesis</span> <span class="nv">eqac</span> : a = c.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk94" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk94"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : a = a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqab</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = b</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqac</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = c</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a = a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk95" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk95"><span class="highlight"><span class="nb">rewrite</span> (eqab, eqac).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqab</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = b</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqac</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = c</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">b = b</span></div></blockquote></div></div></small></span></pre></div><p>Indeed rule <code class="docutils literal notranslate"><span class="pre">eqab</span></code> is the first to apply among the ones
gathered in the tuple passed to the rewrite tactic. This multirule
<code class="docutils literal notranslate"><span class="pre">(eqab,</span> <span class="pre">eqac)</span></code> is actually a <span class="smallcaps">Coq</span> term and we can name it with a
definition:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">multi1</span> := (eqab, eqac).</span></span></span></pre></div><p>In this case, the tactic <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">multi1</span></code> is a synonym for
<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">(eqab,</span> <span class="pre">eqac)</span></code>.</p>
</div>
<p>More precisely, a multirule rewrites the first subterm to which one of
the rules applies in a left-to-right traversal of the goal, with the
first rule from the multirule tree in left-to-right order. Matching is
performed according to the algorithm described in
Section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>, but
literal matches have priority.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">d</span> := a.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hypotheses</span> <span class="nv">eqd0</span> : d = <span class="mi">0</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">multi2</span> := (eqab, eqd0).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk96" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk96"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : d = b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqab</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = b</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqac</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = c</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqd0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = <span class="mi">0</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">d = b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk97" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk97"><span class="highlight"><span class="nb">rewrite</span> multi2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqab</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = b</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqac</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = c</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqd0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = <span class="mi">0</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = b</span></div></blockquote></div></div></small></span></pre></div><p>Indeed rule <code class="docutils literal notranslate"><span class="pre">eqd0</span></code> applies without unfolding the
definition of <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p>
</div>
<p>For repeated rewrites the selection process is
repeated anew.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hypothesis</span> <span class="nv">eq_adda_b</span> : <span class="kr">forall</span> <span class="nv">x</span>, x + a = b.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hypothesis</span> <span class="nv">eq_adda_c</span> : <span class="kr">forall</span> <span class="nv">x</span>, x + a = c.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hypothesis</span> <span class="nv">eqb0</span> : b = <span class="mi">0</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">multi3</span> := (eq_adda_b, eq_adda_c, eqb0).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk98" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk98"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : <span class="mi">1</span> + a = <span class="mi">12</span> + a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqab</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = b</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqac</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = c</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqd0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_adda_b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : nat, x + a = b</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_adda_c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : nat, x + a = c</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqb0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = <span class="mi">0</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> + a = <span class="mi">12</span> + a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk99" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk99"><span class="highlight"><span class="nb">rewrite</span> <span class="mi">2</span>!multi3.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqab</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = b</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqac</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a = c</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqd0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_adda_b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : nat, x + a = b</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_adda_c</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : nat, x + a = c</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqb0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = <span class="mi">0</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> = <span class="mi">12</span> + a</span></div></blockquote></div></div></small></span></pre></div><p>It uses <code class="docutils literal notranslate"><span class="pre">eq_adda_b</span></code> then <code class="docutils literal notranslate"><span class="pre">eqb0</span></code> on the left-hand
side only. Without the bound <code class="docutils literal notranslate"><span class="pre">2</span></code> one would obtain <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
</div>
<p>The grouping of rules inside a multirule does not affect the selection
strategy but can make it easier to include one rule set in another or
to (universally) quantify over the parameters of a subset of rules (as
there is special code that will omit unnecessary quantifiers for rules
that can be syntactically extracted). It is also possible to reverse
the direction of a rule subset, using a special dedicated syntax: the
tactic rewrite <code class="docutils literal notranslate"><span class="pre">(=~</span> <span class="pre">multi1)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">multi1_rev</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hypothesis</span> <span class="nv">eqba</span> : b = a.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hypothesis</span> <span class="nv">eqca</span> : c = a.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">multi1_rev</span> := (eqba, eqca).</span></span></span></pre></div></div>
<p>except that the constants <code class="docutils literal notranslate"><span class="pre">eqba</span></code>, <code class="docutils literal notranslate"><span class="pre">eqab</span></code>, <code class="docutils literal notranslate"><span class="pre">mult1_rev</span></code>
have not been created.</p>
<p>Rewriting with multirules is useful to implement simplification or
transformation procedures, to be applied on terms of small to medium
size. For instance the library <code class="docutils literal notranslate"><span class="pre">ssrnat</span></code> (Mathematical Components library)
provides two implementations
for arithmetic operations on natural numbers: an elementary one and a
tail recursive version, less inefficient but also less convenient for
reasoning purposes. The library also provides one lemma per such
operation, stating that both versions return the same values when
applied to the same arguments:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Lemma</span> <span class="nf">addE</span> <span class="o">:</span> <span class="n">add</span> <span class="o">=</span><span class="mi">2</span> <span class="n">addn</span><span class="o">.</span>
<span class="kn">Lemma</span> <span class="nf">doubleE</span> <span class="o">:</span> <span class="n">double</span> <span class="o">=</span><span class="mi">1</span> <span class="n">doublen</span><span class="o">.</span>
<span class="kn">Lemma</span> <span class="nf">add_mulE</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">s</span> <span class="o">:</span> <span class="n">add_mul</span> <span class="n">n</span> <span class="n">m</span> <span class="n">s</span> <span class="o">=</span> <span class="n">addn</span> <span class="o">(</span><span class="n">muln</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="n">s</span><span class="o">.</span>
<span class="kn">Lemma</span> <span class="nf">mulE</span> <span class="o">:</span> <span class="n">mul</span> <span class="o">=</span><span class="mi">2</span> <span class="n">muln</span><span class="o">.</span>
<span class="kn">Lemma</span> <span class="nf">mul_expE</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">p</span> <span class="o">:</span> <span class="n">mul_exp</span> <span class="n">m</span> <span class="n">n</span> <span class="n">p</span> <span class="o">=</span> <span class="n">muln</span> <span class="o">(</span><span class="n">expn</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="n">p</span><span class="o">.</span>
<span class="kn">Lemma</span> <span class="nf">expE</span> <span class="o">:</span> <span class="n">exp</span> <span class="o">=</span><span class="mi">2</span> <span class="n">expn</span><span class="o">.</span>
<span class="kn">Lemma</span> <span class="nf">oddE</span> <span class="o">:</span> <span class="n">odd</span> <span class="o">=</span><span class="mi">1</span> <span class="n">oddn</span><span class="o">.</span>
</pre></div>
</div>
<p>The operation on the left hand side of each lemma is the efficient
version, and the corresponding naive implementation is on the right
hand side. In order to reason conveniently on expressions involving
the efficient operations, we gather all these rules in the definition
<code class="docutils literal notranslate"><span class="pre">trecE</span></code>:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Definition</span> <span class="nf">trecE</span> <span class="o">:=</span> <span class="o">(</span><span class="n">addE</span><span class="o">,</span> <span class="o">(</span><span class="n">doubleE</span><span class="o">,</span> <span class="n">oddE</span><span class="o">),</span> <span class="o">(</span><span class="n">mulE</span><span class="o">,</span> <span class="n">add_mulE</span><span class="o">,</span> <span class="o">(</span><span class="n">expE</span><span class="o">,</span> <span class="n">mul_expE</span><span class="o">))).</span>
</pre></div>
</div>
<p>The tactic: <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">!trecE.</span></code>
restores the naive versions of each operation in a goal involving the
efficient ones, e.g. for the purpose of a correctness proof.</p>
</div>
<div class="section" id="wildcards-vs-abstractions">
<h4>Wildcards vs abstractions<a class="headerlink" href="#wildcards-vs-abstractions" title="Permalink to this headline">¶</a></h4>
<p>The rewrite tactic supports <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>s containing holes. For example, in
the tactic <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">(_</span> <span class="pre">:</span> <span class="pre">_</span> <span class="pre">*</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0).</span></code>
the term <code class="docutils literal notranslate"><span class="pre">_</span> <span class="pre">*</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0</span></code> is interpreted as <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">n</span> <span class="pre">:</span> <span class="pre">nat,</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0.</span></code>
Anyway this tactic is <em>not</em> equivalent to
<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">(_</span> <span class="pre">:</span> <span class="pre">forall</span> <span class="pre">x,</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0).</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk9a" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk9a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">y</span> <span class="nv">z</span> : y * <span class="mi">0</span> + y * (z * <span class="mi">0</span>) = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">y * <span class="mi">0</span> + y * (z * <span class="mi">0</span>) = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk9b" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk9b"><span class="highlight"><span class="nb">rewrite</span> (_ : _ * <span class="mi">0</span> = <span class="mi">0</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">y * <span class="mi">0</span> = <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk9c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk9c"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> + y * (z * <span class="mi">0</span>) = <span class="mi">0</span></span></div></blockquote></div></div></div></small></span></pre></div><p>while the other tactic results in</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk9d" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk9d"><span class="highlight"><span class="nb">rewrite</span> (_ : <span class="kr">forall</span> <span class="nv">x</span>, x * <span class="mi">0</span> = <span class="mi">0</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : nat, x * <span class="mi">0</span> = <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chk9e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chk9e"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> + y * (z * <span class="mi">0</span>) = <span class="mi">0</span></span></div></blockquote></div></div></div></small></span></pre></div><p>The first tactic requires you to prove the instance of the (missing)
lemma that was used, while the latter requires you prove the quantified
form.</p>
</div>
</div>
<div class="section" id="when-ssr-rewrite-fails-on-standard-coq-licit-rewrite">
<h4>When <span class="smallcaps">SSReflect</span> rewrite fails on standard <span class="smallcaps">Coq</span> licit rewrite<a class="headerlink" href="#when-ssr-rewrite-fails-on-standard-coq-licit-rewrite" title="Permalink to this headline">¶</a></h4>
<p>In a few cases, the <span class="smallcaps">SSReflect</span> rewrite tactic fails rewriting some
redexes which standard <span class="smallcaps">Coq</span> successfully rewrites. There are two main
cases:</p>
<ul>
<li><p><span class="smallcaps">SSReflect</span> never accepts to rewrite indeterminate patterns like:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Lemma</span> <span class="nf">foo</span> <span class="o">(</span><span class="nv">x</span> <span class="o">:</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="o">=</span> <span class="n">tt</span><span class="o">.</span>
</pre></div>
</div>
<p><span class="smallcaps">SSReflect</span> will however accept the
ηζ expansion of this rule:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Lemma</span> <span class="nf">fubar</span> <span class="o">(</span><span class="nv">x</span> <span class="o">:</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="kr">let</span> <span class="nv">u</span> <span class="o">:=</span> <span class="n">x</span> <span class="kr">in</span> <span class="n">u</span><span class="o">)</span> <span class="o">=</span> <span class="n">tt</span><span class="o">.</span>
</pre></div>
</div>
</li>
<li><p>The standard rewrite tactic provided by <span class="smallcaps">Coq</span> uses a different algorithm
to find instances of the rewrite rule.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">g</span> : nat -&gt; nat.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">f</span> := g.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">x</span>, g x = <span class="mi">0</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk9f" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk9f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : f <span class="mi">3</span> + f <span class="mi">3</span> = f <span class="mi">6</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">f <span class="mi">3</span> + f <span class="mi">3</span> = f <span class="mi">6</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight"><span class="c">(* we call the standard rewrite tactic here *)</span>
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chka0" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chka0"><span class="highlight"><span class="nb">rewrite</span> -&gt; H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> + <span class="mi">0</span> = f <span class="mi">6</span></span></div></blockquote></div></div></small></span></pre></div><p>This rewriting is not possible in <span class="smallcaps">SSReflect</span> because
there is no occurrence of the head symbol <code class="docutils literal notranslate"><span class="pre">f</span></code> of the rewrite rule in the
goal.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chka1" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ssreflect-proof-language-rst-chka1"><span class="highlight"><span class="nb">rewrite</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The LHS of H
    (g _)
does not <span class="kr">match</span> any subterm of the goal</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">f <span class="mi">3</span> + f <span class="mi">3</span> = f <span class="mi">6</span></span></div></blockquote></div></div></small></span></pre></div><p>Rewriting with <code class="docutils literal notranslate"><span class="pre">H</span></code> first requires unfolding the occurrences of
<code class="docutils literal notranslate"><span class="pre">f</span></code>
where the substitution is to be performed (here there is a single such
occurrence), using tactic <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">/f</span></code> (for a global replacement of
f by g) or <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">pattern/f</span></code>, for a finer selection.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chka2" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chka2"><span class="highlight"><span class="nb">rewrite</span> /f H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> + <span class="mi">0</span> = g <span class="mi">6</span></span></div></blockquote></div></div></small></span></pre></div><p>alternatively one can override the pattern inferred from <code class="docutils literal notranslate"><span class="pre">H</span></code></p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chka3" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chka3"><span class="highlight"><span class="nb">rewrite</span> [f _]H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> + <span class="mi">0</span> = f <span class="mi">6</span></span></div></blockquote></div></div></small></span></pre></div></div>
</li>
</ul>
</div>
<div class="section" id="existential-metavariables-and-rewriting">
<h4>Existential metavariables and rewriting<a class="headerlink" href="#existential-metavariables-and-rewriting" title="Permalink to this headline">¶</a></h4>
<p>The rewrite tactic will not instantiate existing existential
metavariables when matching a redex pattern.</p>
<p>If a rewrite rule generates a goal with new existential metavariables
in the <code class="docutils literal notranslate"><span class="pre">Prop</span></code> sort, these will be generalized as for <code class="docutils literal notranslate"><span class="pre">apply</span></code>
(see <a class="reference internal" href="#apply-ssr"><span class="std std-ref">The apply tactic</span></a>) and
corresponding new goals will be generated.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">leq</span> : nat -&gt; nat -&gt; bool.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;m &lt;= n&quot;</span> := (leq m n) : nat_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;m &lt; n&quot;</span>  := (S m &lt;= n) : nat_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">Ord</span> <span class="nv">n</span> := Sub x of x &lt; n.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&#39;I_ n&quot;</span> := (Ord n) (<span class="kn">at level</span> <span class="mi">8</span>, n <span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">format</span> <span class="s2">&quot;&#39;&#39;I_&#39; n&quot;</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Arguments</span> Sub {_} _ _.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">val</span> <span class="nv">n</span> (<span class="nv">i</span> : <span class="err">&#39;</span>I_n) := <span class="kr">let</span>: Sub a _ := i <span class="kr">in</span> a.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">insub</span> <span class="nv">n</span> <span class="nv">x</span> :=
  <span class="kr">if</span> @idP (x &lt; n) <span class="kr">is</span> ReflectT _ Px <span class="kr">then</span> Some (Sub x Px) <span class="kr">else</span> None.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">insubT</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">x</span> <span class="nv">Px</span>, insub n x = Some (Sub x Px).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chka4" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chka4"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">x</span> : <span class="err">&#39;</span>I_2) <span class="nv">y</span> : Some x = insub <span class="mi">2</span> y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="err">&#39;</span>I_2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Some x = insub <span class="mi">2</span> y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chka5" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chka5"><span class="highlight"><span class="nb">rewrite</span> insubT.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="err">&#39;</span>I_2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">Hyp0</span> : y &lt; <span class="mi">2</span>, Some x = Some (Sub y Hyp0)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chka6" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="err">&#39;</span>I_2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chka6"><hr></label><div class="goal-conclusion"><span class="highlight">is_true (y &lt; <span class="mi">2</span>)</span></div></blockquote></div></div></div></small></span></pre></div><p>Since the argument corresponding to Px is not supplied by the user, the
resulting goal should be <code class="docutils literal notranslate"><span class="pre">Some</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">(Sub</span> <span class="pre">y</span> <span class="pre">?Goal).</span></code>
Instead, <span class="smallcaps">SSReflect</span> <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> tactic hides the existential variable.</p>
<p>As in <a class="reference internal" href="#apply-ssr"><span class="std std-ref">The apply tactic</span></a>, the <code class="docutils literal notranslate"><span class="pre">ssrautoprop</span></code> tactic is used to try to
solve the existential variable.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chka7" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chka7"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">x</span> : <span class="err">&#39;</span>I_2) <span class="nv">y</span> (<span class="nv">H</span> : y &lt; <span class="mi">2</span>) : Some x = insub <span class="mi">2</span> y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="err">&#39;</span>I_2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true (y &lt; <span class="mi">2</span>)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Some x = insub <span class="mi">2</span> y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chka8" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chka8"><span class="highlight"><span class="nb">rewrite</span> insubT.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="err">&#39;</span>I_2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true (y &lt; <span class="mi">2</span>)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Some x = Some (Sub y H)</span></div></blockquote></div></div></small></span></pre></div></div>
<p>As a temporary limitation, this behavior is available only if the
rewriting rule is stated using Leibniz equality (as opposed to setoid
relations). It will be extended to other rewriting relations in the
future.</p>
</div>
</div>
<div class="section" id="rewriting-under-binders">
<span id="under-ssr"></span><h3>Rewriting under binders<a class="headerlink" href="#rewriting-under-binders" title="Permalink to this headline">¶</a></h3>
<p>Goals involving objects defined with higher-order functions often
require &quot;rewriting under binders&quot;. While setoid rewriting is a
possible approach in this case, it is common to use regular rewriting
along with dedicated extensionality lemmas. This may cause some
practical issues during the development of the corresponding scripts,
notably as we might be forced to provide the rewrite tactic with
complete terms, as shown by the simple example below.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">subnn</span> : <span class="kr">forall</span> <span class="nv">n</span> : nat, n - n = <span class="mi">0</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">map</span> : (nat -&gt; nat) -&gt; list nat -&gt; list nat.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">sumlist</span> : list nat -&gt; nat.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">eq_map</span> :
  <span class="kr">forall</span> <span class="nv">F1</span> <span class="nv">F2</span> : nat -&gt; nat,
  (<span class="kr">forall</span> <span class="nv">n</span> : nat, F1 n = F2 n) -&gt;
  <span class="kr">forall</span> <span class="nv">l</span> : list nat, map F1 l = map F2 l.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chka9" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chka9"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">example_map</span> <span class="nv">l</span> : sumlist (map (<span class="kr">fun</span> <span class="nv">m</span> =&gt; m - m) l) = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">sumlist (map (<span class="kr">fun</span> <span class="nv">m</span> : nat =&gt; m - m) l) = <span class="mi">0</span></span></div></blockquote></div></div></small></span></pre></div><p>In this context, one cannot directly use <code class="docutils literal notranslate"><span class="pre">eq_map</span></code>:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkaa" style="display: none" type="checkbox"><label class="coq-input alectryon-failed" for="ssreflect-proof-language-rst-chkaa"><span class="highlight"><span class="nb">rewrite</span> eq_map.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">Unable to find an instance <span class="kr">for</span> the variable
F2.
Rule&#39;s type:
(<span class="kr">forall</span> <span class="nv">F1</span> <span class="nv">F2</span> : nat -&gt; nat,
 (<span class="kr">forall</span> <span class="nv">n</span> : nat, F1 n = F2 n) -&gt;
 <span class="kr">forall</span> <span class="nv">l</span> : list nat, map F1 l = map F2 l)</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">sumlist (map (<span class="kr">fun</span> <span class="nv">m</span> : nat =&gt; m - m) l) = <span class="mi">0</span></span></div></blockquote></div></div></small></span></pre></div><p>as we need to explicitly provide the non-inferable argument <code class="docutils literal notranslate"><span class="pre">F2</span></code>,
which corresponds here to the term we want to obtain <em>after</em> the
rewriting step. In order to perform the rewrite step one has to
provide the term by hand as follows:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkab" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkab"><span class="highlight"><span class="nb">rewrite</span> (@eq_map _ (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; <span class="mi">0</span>)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, n - n = <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chkac" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chkac"><hr></label><div class="goal-conclusion"><span class="highlight">sumlist (map (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; <span class="mi">0</span>) l) = <span class="mi">0</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkad" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkad"><span class="highlight"><span class="bp">by</span> <span class="nb">move</span>=&gt; m; <span class="nb">rewrite</span> subnn.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">sumlist (map (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; <span class="mi">0</span>) l) = <span class="mi">0</span></span></div></blockquote></div></div></small></span></pre></div><p>The <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> tactic lets one perform the same operation in a more
convenient way:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkae" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkae"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">example_map</span> <span class="nv">l</span> : sumlist (map (<span class="kr">fun</span> <span class="nv">m</span> =&gt; m - m) l) = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">sumlist (map (<span class="kr">fun</span> <span class="nv">m</span> : nat =&gt; m - m) l) = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkaf" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkaf"><span class="highlight"><span class="nb">under</span> eq_map =&gt; m <span class="kp">do</span> <span class="nb">rewrite</span> subnn.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">sumlist (map (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; <span class="mi">0</span>) l) = <span class="mi">0</span></span></div></blockquote></div></div></small></span></pre></div></div>
<div class="section" id="the-under-tactic">
<h4>The under tactic<a class="headerlink" href="#the-under-tactic" title="Permalink to this headline">¶</a></h4>
<p>The convenience <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> tactic supports the following syntax:</p>
<dl class="coq tacn">
<dt id="coq:tacn.under">
<code class="sig-name descname"><span class="notation"><span>under</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_prefix"><span class="hole">r_prefix</span></a></span><span class="notation-sup">?</span></span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>=&gt;</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>do</span> <span class="alternative"><span class="alternative-block"><span class="hole">tactic</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">tactic</span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span>]</span></span></span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.under" title="Permalink to this definition">¶</a></dt>
<dd><p>Operate under the context proved to be extensional by
lemma <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.</p>
<dl class="coq exn">
<dt id="coq:exn.incorrect-number-of-tactics-expected-n-tactics-was-given-m">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Incorrect</span> <span>number</span> <span>of</span> <span>tactics</span> <span>(expected</span> <span>N</span> <span>tactics,</span> <span>was</span> <span>given</span> <span>M).</span></span></code><a class="headerlink" href="#coq:exn.incorrect-number-of-tactics-expected-n-tactics-was-given-m" title="Permalink to this definition">¶</a></dt>
<dd><p>This error can occur when using the version with a <code class="docutils literal notranslate"><span class="pre">do</span></code> clause.</p>
</dd></dl>

<p>The multiplier part of <a class="reference internal" href="#grammar-token-r_prefix"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_prefix</span></code></a> is not supported.</p>
</dd></dl>

<p>We distinguish two modes,
<a class="reference internal" href="#under-interactive"><span class="std std-ref">interactive mode</span></a> without a <code class="docutils literal notranslate"><span class="pre">do</span></code> clause, and
<a class="reference internal" href="#under-one-liner"><span class="std std-ref">one-liner mode</span></a> with a <code class="docutils literal notranslate"><span class="pre">do</span></code> clause,
which are explained in more detail below.</p>
</div>
<div class="section" id="interactive-mode">
<span id="under-interactive"></span><h4>Interactive mode<a class="headerlink" href="#interactive-mode" title="Permalink to this headline">¶</a></h4>
<p>Let us redo the running example in interactive mode.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkb0" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkb0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">example_map</span> <span class="nv">l</span> : sumlist (map (<span class="kr">fun</span> <span class="nv">m</span> =&gt; m - m) l) = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">sumlist (map (<span class="kr">fun</span> <span class="nv">m</span> : nat =&gt; m - m) l) = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkb1" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkb1"><span class="highlight"><span class="nb">under</span> eq_map =&gt; m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="err">&#39;</span>Under[ m - m ]</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chkb2" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chkb2"><hr></label><div class="goal-conclusion"><span class="highlight">sumlist (map ?<span class="kn">Goal</span> l) = <span class="mi">0</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkb3" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkb3"><span class="highlight"><span class="nb">rewrite</span> subnn.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="err">&#39;</span>Under[ <span class="mi">0</span> ]</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chkb4" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chkb4"><hr></label><div class="goal-conclusion"><span class="highlight">sumlist (map ?<span class="kn">Goal</span> l) = <span class="mi">0</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkb5" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkb5"><span class="highlight"><span class="nb">over</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">sumlist (map (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; <span class="mi">0</span>) l) = <span class="mi">0</span></span></div></blockquote></div></div></small></span></pre></div></div>
<p>The execution of the Ltac expression:</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">under</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">=&gt;</span></span> <span><span class="pre">[</span></span> <a class="reference internal" href="#grammar-token-i_item"><span class="hole"><span class="pre">i_item</span><sub><span class="pre">1</span></sub></span></a> <span class="pre">|</span> <span><span class="pre">…</span></span> <span class="pre">|</span> <a class="reference internal" href="#grammar-token-i_item"><span class="hole"><span class="pre">i_item</span><sub><span class="pre">n</span></sub></span></a> <span><span class="pre">].</span></span></span></code></p>
<p>involves the following steps:</p>
<ol class="arabic simple">
<li><p>It performs a <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span class="hole"><span class="pre">term</span></span></span></code>
without failing like in the first example with <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">eq_map.</span></code>,
but creating evars (see <a class="reference internal" href="tactics.html#coq:tacn.evar" title="evar"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">evar</span></code></a>). If <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">term</span></span></span></code> is prefixed by
a pattern or an occurrence selector, then the modifiers are honoured.</p></li>
<li><p>As a n-branches intro pattern is provided <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> checks that
n+1 subgoals have been created. The last one is the main subgoal,
while the other ones correspond to premises of the rewrite rule (such as
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">n,</span> <span class="pre">F1</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">F2</span> <span class="pre">n</span></code> for <code class="docutils literal notranslate"><span class="pre">eq_map</span></code>).</p></li>
<li><p>If so <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> puts these n goals in head normal form (using
the defective form of the tactic <a class="reference internal" href="#coq:tacn.move" title="move"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">move</span></code></a>), then executes
the corresponding intro pattern <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole"><span class="pre">i_pattern</span><sub><span class="pre">i</span></sub></span></a></span></code> in each goal.</p></li>
<li><p>Then <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> checks that the first n subgoals
are (quantified) equalities or double implications between a
term and an evar (e.g. <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">-</span> <span class="pre">m</span> <span class="pre">=</span> <span class="pre">?F2</span> <span class="pre">m</span></code> in the running example).</p></li>
<li><p>If so <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> protects these n goals against an
accidental instantiation of the evar.
These protected goals are displayed using the <code class="docutils literal notranslate"><span class="pre">'Under[</span> <span class="pre">…</span> <span class="pre">]</span></code>
notation (e.g. <code class="docutils literal notranslate"><span class="pre">'Under[</span> <span class="pre">m</span> <span class="pre">-</span> <span class="pre">m</span> <span class="pre">]</span></code> in the running example).</p></li>
<li><p>The expression inside the <code class="docutils literal notranslate"><span class="pre">'Under[</span> <span class="pre">…</span> <span class="pre">]</span></code> notation can be
proved equivalent to the desired expression
by using a regular <a class="reference internal" href="tactics.html#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> tactic.</p></li>
<li><p>Interactive editing of the first n goals has to be signalled by
using the <a class="reference internal" href="#coq:tacn.over" title="over"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">over</span></code></a> tactic or rewrite rule (see below).</p></li>
<li><p>Finally, a post-processing step is performed in the main goal
to keep the name(s) for the bound variables chosen by the user in
the intro pattern for the first branch.</p></li>
</ol>
<div class="section" id="the-over-tactic">
<span id="over-ssr"></span><h5>The over tactic<a class="headerlink" href="#the-over-tactic" title="Permalink to this headline">¶</a></h5>
<p>Two equivalent facilities (a terminator and a lemma) are provided to
close intermediate subgoals generated by <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> (i.e. goals
displayed as <code class="docutils literal notranslate"><span class="pre">'Under[</span> <span class="pre">…</span> <span class="pre">]</span></code>):</p>
<dl class="coq tacn">
<dt id="coq:tacn.over">
<code class="sig-name descname"><span class="notation"><span>over</span></span></code><a class="headerlink" href="#coq:tacn.over" title="Permalink to this definition">¶</a></dt>
<dd><p>This terminator tactic allows one to close goals of the form
<code class="docutils literal notranslate"><span class="pre">'Under[</span> <span class="pre">…</span> <span class="pre">]</span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>by</span> <span>rewrite</span> <span>over</span></span></code></dt>
<dd><p>This is a variant of <a class="reference internal" href="#coq:tacn.over" title="over"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">over</span></code></a> in order to close <code class="docutils literal notranslate"><span class="pre">'Under[</span> <span class="pre">…</span> <span class="pre">]</span></code>
goals, relying on the <code class="docutils literal notranslate"><span class="pre">over</span></code> rewrite rule.</p>
</dd></dl>

</div>
</div>
<div class="section" id="one-liner-mode">
<span id="under-one-liner"></span><h4>One-liner mode<a class="headerlink" href="#one-liner-mode" title="Permalink to this headline">¶</a></h4>
<p>The Ltac expression:</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">under</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">=&gt;</span></span> <span><span class="pre">[</span></span> <a class="reference internal" href="#grammar-token-i_item"><span class="hole"><span class="pre">i_item</span><sub><span class="pre">1</span></sub></span></a> <span class="pre">|</span> <span><span class="pre">…</span></span> <span class="pre">|</span> <a class="reference internal" href="#grammar-token-i_item"><span class="hole"><span class="pre">i_item</span><sub><span class="pre">n</span></sub></span></a> <span><span class="pre">]</span></span> <span><span class="pre">do</span></span> <span><span class="pre">[</span></span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span> <span class="pre">|</span> <span><span class="pre">…</span></span> <span class="pre">|</span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">n</span></sub></span> <span><span class="pre">].</span></span></span></code></p>
<p>can be seen as a shorter form for the following expression:</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(under</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">)</span></span> <span><span class="pre">=&gt;</span></span> <span><span class="pre">[</span></span> <a class="reference internal" href="#grammar-token-i_item"><span class="hole"><span class="pre">i_item</span><sub><span class="pre">1</span></sub></span></a> <span class="pre">|</span> <span><span class="pre">…</span></span> <span class="pre">|</span> <a class="reference internal" href="#grammar-token-i_item"><span class="hole"><span class="pre">i_item</span><sub><span class="pre">n</span></sub></span></a> <span class="pre">|</span> <span><span class="pre">];</span></span> <span><span class="pre">[</span></span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span><span><span class="pre">;</span></span> <span><span class="pre">over</span></span> <span class="pre">|</span> <span><span class="pre">…</span></span> <span class="pre">|</span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">n</span></sub></span><span><span class="pre">;</span></span> <span><span class="pre">over</span></span> <span class="pre">|</span> <span><span class="pre">cbv</span></span> <span><span class="pre">beta</span></span> <span><span class="pre">iota</span></span> <span><span class="pre">].</span></span></span></code></p>
<p>Notes:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">beta-iota</span></code> reduction here is useful to get rid of the beta
redexes that could be introduced after the substitution of the evars
by the <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> tactic.</p></li>
<li><p>Note that the provided tactics can as well
involve other <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> tactics. See below for a typical example
involving the <code class="docutils literal notranslate"><span class="pre">bigop</span></code> theory from the Mathematical Components library.</p></li>
<li><p>If there is only one tactic, the brackets can be omitted, e.g.:
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">under</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">=&gt;</span></span> <span><span class="pre">i</span></span> <span><span class="pre">do</span></span> <span class="hole"><span class="pre">tactic</span></span><span><span class="pre">.</span></span></span></code> and that shorter form should be
preferred.</p></li>
<li><p>If the <code class="docutils literal notranslate"><span class="pre">do</span></code> clause is provided and the intro pattern is omitted,
then the default <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> <code class="docutils literal notranslate"><span class="pre">*</span></code> is applied to each branch.
E.g., the Ltac expression:
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">under</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">do</span></span> <span><span class="pre">[</span></span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span> <span class="pre">|</span> <span><span class="pre">…</span></span> <span class="pre">|</span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">n</span></sub></span> <span><span class="pre">]</span></span></span></code> is equivalent to:
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">under</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">=&gt;</span></span> <span><span class="pre">[</span></span> <span><span class="pre">*</span></span> <span class="pre">|</span> <span><span class="pre">…</span></span> <span class="pre">|</span> <span><span class="pre">*</span></span> <span><span class="pre">]</span></span> <span><span class="pre">do</span></span> <span><span class="pre">[</span></span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span> <span class="pre">|</span> <span><span class="pre">…</span></span> <span class="pre">|</span> <span class="hole"><span class="pre">tactic</span><sub><span class="pre">n</span></sub></span> <span><span class="pre">]</span></span></span></code>
(and it can be noted here that the <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> tactic performs a
<code class="docutils literal notranslate"><span class="pre">move.</span></code> before processing the intro patterns <code class="docutils literal notranslate"><span class="pre">=&gt;</span> <span class="pre">[</span> <span class="pre">*</span> <span class="pre">|</span> <span class="pre">…</span> <span class="pre">|</span> <span class="pre">*</span> <span class="pre">]</span></code>).</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">addnC</span> : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> : nat, m + n = n + m.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">muln1</span> : <span class="kr">forall</span> <span class="nv">n</span> : nat, n * <span class="mi">1</span> = n.</span></span></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkb6" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkb6"><span class="highlight"><span class="kn">Check</span> eq_bigr.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">eq_bigr
     : <span class="kr">forall</span> (<span class="nv">n</span> <span class="nv">m</span> : nat) (<span class="nv">P</span> : nat -&gt; bool)
         (<span class="nv">F1</span> <span class="nv">F2</span> : nat -&gt; nat),
       (<span class="kr">forall</span> <span class="nv">x</span> : nat, P x -&gt; F1 x = F2 x) -&gt;
       \sum_(n &lt;= i &lt; m | P i) F1 i =
       \sum_(n &lt;= i &lt; m | P i) F2 i</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkb7" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkb7"><span class="highlight"><span class="kn">Check</span> eq_big.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">eq_big
     : <span class="kr">forall</span> (<span class="nv">n</span> <span class="nv">m</span> : nat) (<span class="nv">P1</span> <span class="nv">P2</span> : nat -&gt; bool)
         (<span class="nv">F1</span> <span class="nv">F2</span> : nat -&gt; nat),
       (<span class="kr">forall</span> <span class="nv">x</span> : nat, P1 x = P2 x) -&gt;
       (<span class="kr">forall</span> <span class="nv">i</span> : nat, P1 i -&gt; F1 i = F2 i) -&gt;
       \sum_(n &lt;= i &lt; m | P1 i) F1 i =
       \sum_(n &lt;= i &lt; m | P2 i) F2 i</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkb8" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkb8"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_big_nested</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) :
  \sum_(<span class="mi">0</span> &lt;= a &lt; m | prime a) \sum_(<span class="mi">0</span> &lt;= j &lt; n | odd (j * <span class="mi">1</span>)) (a + j) =
  \sum_(<span class="mi">0</span> &lt;= i &lt; m | prime i) \sum_(<span class="mi">0</span> &lt;= j &lt; n | odd j) (j + i).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">\sum_(<span class="mi">0</span> &lt;= a &lt; m | prime a)
   \sum_(<span class="mi">0</span> &lt;= j &lt; n | odd (j * <span class="mi">1</span>)) (a + j) =
\sum_(<span class="mi">0</span> &lt;= i &lt; m | prime i)
   \sum_(<span class="mi">0</span> &lt;= j &lt; n | odd j) (j + i)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkb9" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkb9"><span class="highlight"><span class="nb">under</span> eq_bigr =&gt; i prime_i <span class="kp">do</span>
  <span class="nb">under</span> eq_big =&gt; [ j | j odd_j ] <span class="kp">do</span>
    [ <span class="nb">rewrite</span> (muln1 j) | <span class="nb">rewrite</span> (addnC i j) ].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">\sum_(<span class="mi">0</span> &lt;= i &lt; m | prime i)
   \sum_(<span class="mi">0</span> &lt;= j &lt; n | odd j) (j + i) =
\sum_(<span class="mi">0</span> &lt;= i &lt; m | prime i)
   \sum_(<span class="mi">0</span> &lt;= j &lt; n | odd j) (j + i)</span></div></blockquote></div></div></small></span></pre></div><p>Remark how the final goal uses the name <code class="docutils literal notranslate"><span class="pre">i</span></code> (the name given in the
intro pattern) rather than <code class="docutils literal notranslate"><span class="pre">a</span></code> in the binder of the first summation.</p>
</div>
</div>
</div>
<div class="section" id="locking-unlocking">
<span id="locking-ssr"></span><h3>Locking, unlocking<a class="headerlink" href="#locking-unlocking" title="Permalink to this headline">¶</a></h3>
<p>As program proofs tend to generate large goals, it is important to be
able to control the partial evaluation performed by the simplification
operations that are performed by the tactics. These evaluations can
for example come from a <code class="docutils literal notranslate"><span class="pre">/=</span></code> simplification switch, or from rewrite
steps which may expand large terms while performing conversion. We
definitely want to avoid repeating large subterms of the goal in the
proof script. We do this by “clamping down” selected function symbols
in the goal, which prevents them from being considered in
simplification or rewriting steps. This clamping is accomplished by
using the occurrence switches (see section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>)
together with “term tagging” operations.</p>
<p><span class="smallcaps">SSReflect</span> provides two levels of tagging.</p>
<p>The first one uses auxiliary definitions to introduce a provably equal
copy of any term t. However this copy is (on purpose) <em>not
convertible</em> to t in the <span class="smallcaps">Coq</span> system <a class="footnote-reference brackets" href="#id22" id="id12">18</a>. The job is done by the
following construction:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Lemma</span> <span class="nf">master_key</span> <span class="o">:</span> <span class="n">unit</span><span class="o">.</span> <span class="kn">Proof</span><span class="o">.</span> <span class="bp">exact</span> <span class="n">tt</span><span class="o">.</span> <span class="kn">Qed</span><span class="o">.</span>
<span class="kn">Definition</span> <span class="nf">locked</span> <span class="nv">A</span> <span class="o">:=</span> <span class="kr">let</span><span class="o">:</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">master_key</span> <span class="kr">in</span> <span class="kr">fun</span> <span class="nv">x</span> <span class="o">:</span> <span class="n">A</span> <span class="o">=&gt;</span> <span class="n">x</span><span class="o">.</span>
<span class="kn">Lemma</span> <span class="nf">lock</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">x</span><span class="o">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">locked</span> <span class="n">x</span> <span class="o">:&gt;</span> <span class="n">A</span><span class="o">.</span>
</pre></div>
</div>
<p>Note that the definition of <em>master_key</em> is explicitly opaque. The
equation <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">locked</span> <span class="pre">t</span></code> given by the <code class="docutils literal notranslate"><span class="pre">lock</span></code> lemma can be used for
selective rewriting, blocking on the fly the reduction in the term <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">A</span> : <span class="kt">Type</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">has</span> (<span class="nv">p</span> : A -&gt; bool) (<span class="nv">l</span> : list A) : bool :=
  <span class="kr">if</span> l <span class="kr">is</span> cons x l <span class="kr">then</span> p x || (has p l) <span class="kr">else</span> false.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkba" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkba"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">p</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">l</span> (<span class="nv">H</span> : p x = true) : has p ( x :: y :: l) = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">p x = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">has p (x :: y :: l) = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkbb" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkbb"><span class="highlight"><span class="nb">rewrite</span> {<span class="mi">2</span>}[cons]lock /= -lock.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">p x = true</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">p x || has p (y :: l) = true</span></div></blockquote></div></div></small></span></pre></div></div>
<p>It is sometimes desirable to globally prevent a definition from being
expanded by simplification; this is done by adding locked in the
definition.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lid</span> := locked (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkbc" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkbc"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> : lid <span class="mi">3</span> = <span class="mi">3</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">lid <span class="mi">3</span> = <span class="mi">3</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkbd" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkbd"><span class="highlight"><span class="nb">rewrite</span> /=.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">lid <span class="mi">3</span> = <span class="mi">3</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkbe" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkbe"><span class="highlight"><span class="nb">unlock</span> lid.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">3</span> = <span class="mi">3</span></span></div></blockquote></div></div></small></span></pre></div></div>
<dl class="coq tacn">
<dt id="coq:tacn.unlock">
<code class="sig-name descname"><span class="notation"><span>unlock</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <span class="hole">ident</span></span></code><a class="headerlink" href="#coq:tacn.unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic unfolds such definitions while removing “locks”, i.e. it
replaces the occurrence(s) of <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> coded by the
<a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> with the corresponding body.</p>
</dd></dl>

<p>We found that it was usually preferable to prevent the expansion of
some functions by the partial evaluation switch <code class="docutils literal notranslate"><span class="pre">/=</span></code>, unless this
allowed the evaluation of a condition. This is possible thanks to another
mechanism of term tagging, resting on the following <em>Notation</em>:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Notation</span> <span class="s2">&quot;&#39;nosimpl&#39; t&quot;</span> <span class="o">:=</span> <span class="o">(</span><span class="kr">let</span><span class="o">:</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">tt</span> <span class="kr">in</span> <span class="n">t</span><span class="o">).</span>
</pre></div>
</div>
<p>The term <code class="docutils literal notranslate"><span class="pre">(nosimpl</span> <span class="pre">t)</span></code> simplifies to <code class="docutils literal notranslate"><span class="pre">t</span></code> <em>except</em> in a definition.
More precisely, given:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Definition</span> <span class="nf">foo</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nosimpl</span> <span class="n">bar</span><span class="o">).</span>
</pre></div>
</div>
<p>the term <code class="docutils literal notranslate"><span class="pre">foo</span></code> (or <code class="docutils literal notranslate"><span class="pre">(foo</span> <span class="pre">t’)</span></code>) will <em>not</em> be expanded by the <em>simpl</em>
tactic unless it is in a forcing context (e.g., in <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">foo</span> <span class="pre">t’</span> <span class="pre">with</span> <span class="pre">…</span>
<span class="pre">end</span></code>, <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">t’</span></code> will be reduced if this allows <code class="docutils literal notranslate"><span class="pre">match</span></code> to be reduced).
Note that <code class="docutils literal notranslate"><span class="pre">nosimpl</span> <span class="pre">bar</span></code> is simply notation for a term that reduces to
<code class="docutils literal notranslate"><span class="pre">bar</span></code>; hence <code class="docutils literal notranslate"><span class="pre">unfold</span> <span class="pre">foo</span></code> will replace <code class="docutils literal notranslate"><span class="pre">foo</span></code> by <code class="docutils literal notranslate"><span class="pre">bar</span></code>, and
<code class="docutils literal notranslate"><span class="pre">fold</span> <span class="pre">foo</span></code> will replace <code class="docutils literal notranslate"><span class="pre">bar</span></code> by <code class="docutils literal notranslate"><span class="pre">foo</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nosimpl</span></code> trick only works if no reduction is apparent in
<code class="docutils literal notranslate"><span class="pre">t</span></code>; in particular, the declaration:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Definition</span> <span class="nf">foo</span> <span class="nv">x</span> <span class="o">:=</span> <span class="n">nosimpl</span> <span class="o">(</span><span class="n">bar</span> <span class="n">x</span><span class="o">).</span>
</pre></div>
</div>
<p>will usually not work. Anyway, the common practice is to tag only the
function, and to use the following definition, which blocks the
reduction as expected:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Definition</span> <span class="nf">foo</span> <span class="nv">x</span> <span class="o">:=</span> <span class="n">nosimpl</span> <span class="n">bar</span> <span class="n">x</span><span class="o">.</span>
</pre></div>
</div>
</div>
<p>A standard example making this technique shine is the case of
arithmetic operations. We define for instance:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Definition</span> <span class="nf">addn</span> <span class="o">:=</span> <span class="n">nosimpl</span> <span class="n">plus</span><span class="o">.</span>
</pre></div>
</div>
<p>The operation <code class="docutils literal notranslate"><span class="pre">addn</span></code> behaves exactly like <code class="docutils literal notranslate"><span class="pre">plus</span></code>, except that
<code class="docutils literal notranslate"><span class="pre">(addn</span> <span class="pre">(S</span> <span class="pre">n)</span> <span class="pre">m)</span></code> will not simplify spontaneously to
<code class="docutils literal notranslate"><span class="pre">(S</span> <span class="pre">(addn</span> <span class="pre">n</span> <span class="pre">m))</span></code> (the two terms, however, are convertible).
In addition, the unfolding step: <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">/addn</span></code>
will replace <code class="docutils literal notranslate"><span class="pre">addn</span></code> directly with <code class="docutils literal notranslate"><span class="pre">plus</span></code>, so the <code class="docutils literal notranslate"><span class="pre">nosimpl</span></code> form is
essentially invisible.</p>
</div>
<div class="section" id="congruence">
<span id="congruence-ssr"></span><h3>Congruence<a class="headerlink" href="#congruence" title="Permalink to this headline">¶</a></h3>
<p>Because of the way matching interferes with parameters of type families,
the tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">apply</span><span class="o">:</span> <span class="n">my_congr_property</span><span class="o">.</span>
</pre></div>
</div>
<p>will generally fail to perform congruence simplification, even on
rather simple cases. We therefore provide a more robust alternative in
which the function is supplied:</p>
<dl class="coq tacn">
<dt id="coq:tacn.congr">
<code class="sig-name descname"><span class="notation"><span>congr</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">?</span></span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:tacn.congr" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic:</p>
<ul class="simple">
<li><p>checks that the goal is a Leibniz equality;</p></li>
<li><p>matches both sides of this equality with “term applied to some arguments”, inferring the right number of arguments from the goal and the type of term. This may expand some definitions or fixpoints;</p></li>
<li><p>generates the subgoals corresponding to pairwise equalities of the arguments present in the goal.</p></li>
</ul>
<p>The goal can be a non dependent product <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">-&gt;</span> <span class="pre">Q</span></code>. In that case, the
system asserts the equation <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">Q</span></code>, uses it to solve the goal, and
calls the <code class="docutils literal notranslate"><span class="pre">congr</span></code> tactic on the remaining goal <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">Q</span></code>. This can be useful
for instance to perform a transitivity step, like in the following
situation.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkbf" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkbf"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : nat) (<span class="nv">H</span> : x = y) : x = z.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x = z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkc0" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkc0"><span class="highlight"><span class="nb">congr</span> (_ = _) : H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">y = z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkc1" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkc1"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : nat) : x = y -&gt; x = z.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x = y -&gt; x = z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkc2" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkc2"><span class="highlight"><span class="nb">congr</span> (_ = _).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">y = z</span></div></blockquote></div></div></small></span></pre></div></div>
<p>The optional <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code> forces the number of arguments for which the
tactic should generate equality proof obligations.</p>
<p>This tactic supports equalities between applications with dependent
arguments. Yet dependent arguments should have exactly the same
parameters on both sides, and these parameters should appear as first
arguments.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">f</span> <span class="nv">n</span> :=
  <span class="kr">if</span> n <span class="kr">is</span> <span class="mi">0</span> <span class="kr">then</span> plus <span class="kr">else</span> mult.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">g</span> (<span class="nv">n</span> <span class="nv">m</span> : nat) := plus.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkc3" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkc3"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span> : f <span class="mi">0</span> x y = g <span class="mi">1</span> <span class="mi">1</span> x y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">f <span class="mi">0</span> x y = g <span class="mi">1</span> <span class="mi">1</span> x y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">congr</span> plus.</span></span></span></pre></div><p>This script shows that the <code class="docutils literal notranslate"><span class="pre">congr</span></code> tactic matches <code class="docutils literal notranslate"><span class="pre">plus</span></code>
with <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">0</span></code> on the left hand side and <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">1</span> <span class="pre">1</span></code> on the right hand
side, and solves the goal.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkc4" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkc4"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">n</span> <span class="nv">m</span> (<span class="nv">Hnm</span> : m &lt;= n) : S m + (S n - S m) = S n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m &lt;= n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">S m + (S n - S m) = S n</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkc5" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkc5"><span class="highlight"><span class="nb">congr</span> S; <span class="nb">rewrite</span> -/plus.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnm</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">m &lt;= n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">m + (S n - S m) = n</span></div></blockquote></div></div></small></span></pre></div><p>The tactic <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">-/plus</span></code> folds back the expansion of plus
which was necessary for matching both sides of the equality with
an application of <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
</div>
<p>Like most <span class="smallcaps">SSReflect</span> arguments, <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> can contain wildcards.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkc6" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkc6"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span> : x + (y * (y + x - x)) = x * <span class="mi">1</span> + (y + <span class="mi">0</span>) * y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x + y * (y + x - x) = x * <span class="mi">1</span> + (y + <span class="mi">0</span>) * y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkc7" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkc7"><span class="highlight"><span class="nb">congr</span> ( _ + (_ * _)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x = x * <span class="mi">1</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chkc8" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chkc8"><hr></label><div class="goal-conclusion"><span class="highlight">y = y + <span class="mi">0</span></span></div></blockquote><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chkc9" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chkc9"><hr></label><div class="goal-conclusion"><span class="highlight">y + x - x = y</span></div></blockquote></div></div></div></small></span></pre></div></div>
</dd></dl>

</div>
</div>
<div class="section" id="contextual-patterns">
<span id="contextual-patterns-ssr"></span><h2>Contextual patterns<a class="headerlink" href="#contextual-patterns" title="Permalink to this headline">¶</a></h2>
<p>The simple form of patterns used so far, terms possibly containing
wild cards, often require an additional <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> to be specified.
While this may work pretty fine for small goals, the use of
polymorphic functions and dependent types may lead to an invisible
duplication of function arguments. These copies usually end up in
types hidden by the implicit arguments machinery or by user-defined
notations. In these situations computing the right occurrence numbers
is very tedious because they must be counted on the goal as printed
after setting the <a class="reference internal" href="../language/gallina-extensions.html#coq:flag.printing-all" title="Printing All"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">All</span></code></a> flag. Moreover the resulting script is
not really informative for the reader, since it refers to occurrence
numbers he cannot easily see.</p>
<p>Contextual patterns mitigate these issues allowing to specify
occurrences according to the context they occur in.</p>
<div class="section" id="syntax">
<h3>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h3>
<p>The following table summarizes the full syntax of <a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a> and the
corresponding subterm(s) identified by the pattern. In the third
column we use s.m.r. for “the subterms matching the redex” specified
in the second column.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a></p></th>
<th class="head"><p>redex</p></th>
<th class="head"><p>subterms affected</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
<td><p>all occurrences of <code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code></p></td>
<td><p>subterm of <code class="docutils literal notranslate"><span class="pre">term</span></code> selected by <code class="docutils literal notranslate"><span class="pre">ident</span></code></p></td>
<td><p>all the subterms identified by <code class="docutils literal notranslate"><span class="pre">ident</span></code> in all the
occurrences of <code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">term1</span> <span class="pre">in</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term1</span></code> in all s.m.r.</p></td>
<td><p>in all the subterms identified by
<code class="docutils literal notranslate"><span class="pre">ident</span></code> in all the occurrences of <code class="docutils literal notranslate"><span class="pre">term2</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">term1</span> <span class="pre">as</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">1</span></code></p></td>
<td><p>in all the subterms identified by <code class="docutils literal notranslate"><span class="pre">ident</span></code>
in all the occurrences of <code class="docutils literal notranslate"><span class="pre">term2[term</span> <span class="pre">1</span> <span class="pre">/ident]</span></code></p></td>
</tr>
</tbody>
</table>
<p>The rewrite tactic supports two more patterns obtained prefixing the
first two with in. The intended meaning is that the pattern identifies
all subterms of the specified context. The <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> tactic will infer a
pattern for the redex looking at the rule used for rewriting.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><a class="reference internal" href="#grammar-token-r_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_pattern</span></code></a></p></th>
<th class="head"><p>redex</p></th>
<th class="head"><p>subterms affected</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">term</span></code></p></td>
<td><p>inferred from rule</p></td>
<td><p>in all s.m.r. in all occurrences of <code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code></p></td>
<td><p>inferred from rule</p></td>
<td><p>in all s.m.r. in all the subterms identified by <code class="docutils literal notranslate"><span class="pre">ident</span></code>
in all the occurrences of <code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
</tr>
</tbody>
</table>
<p>The first <a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a> is the simplest form matching any context but
selecting a specific redex and has been described in the previous
sections. We have seen so far that the possibility of selecting a
redex using a term with holes is already a powerful means of redex
selection. Similarly, any terms provided by the user in the more
complex forms of <a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a>s
presented in the tables above can contain
holes.</p>
<p>For a quick glance at what can be expressed with the last
<a class="reference internal" href="#grammar-token-r_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_pattern</span></code></a>
consider the goal <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code> and the tactic</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">rewrite</span> <span class="o">[</span><span class="kr">in</span> <span class="n">X</span> <span class="kr">in</span> <span class="n">_</span> <span class="o">=</span> <span class="n">X</span><span class="o">]</span><span class="n">rule</span><span class="o">.</span>
</pre></div>
</div>
<p>It rewrites all occurrences of the left hand side of <code class="docutils literal notranslate"><span class="pre">rule</span></code>
inside <code class="docutils literal notranslate"><span class="pre">b</span></code>  only (<code class="docutils literal notranslate"><span class="pre">a</span></code>, and the hidden type of the equality, are ignored). Note that the
variant <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">[X</span> <span class="pre">in</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">X]rule</span></code> would have rewritten <code class="docutils literal notranslate"><span class="pre">b</span></code>
exactly (i.e., it would only work if <code class="docutils literal notranslate"><span class="pre">b</span></code> and the left hand side
of rule can be unified).</p>
</div>
<div class="section" id="matching-contextual-patterns">
<h3>Matching contextual patterns<a class="headerlink" href="#matching-contextual-patterns" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a> and <a class="reference internal" href="#grammar-token-r_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_pattern</span></code></a> involving terms
with holes are matched
against the goal in order to find a closed instantiation. This
matching proceeds as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a></p></th>
<th class="head"><p>instantiation order and place for <code class="docutils literal notranslate"><span class="pre">term_i</span></code> and redex</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term</span></code> is matched against the goal, redex is unified with
the instantiation of <code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term</span></code> is matched against the goal, redex is unified with the
subterm of the instantiation of <code class="docutils literal notranslate"><span class="pre">term</span></code> identified by
<code class="docutils literal notranslate"><span class="pre">ident</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">term1</span> <span class="pre">in</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term2</span></code> is matched against the goal, <code class="docutils literal notranslate"><span class="pre">term1</span></code>
is matched against the subterm of the instantiation of
<code class="docutils literal notranslate"><span class="pre">term1</span></code> identified by <code class="docutils literal notranslate"><span class="pre">ident</span></code>, redex is unified with
the instantiation of <code class="docutils literal notranslate"><span class="pre">term1</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">term1</span> <span class="pre">as</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term2[term1/ident]</span></code> is matched against
the goal, redex is unified with the instantiation of <code class="docutils literal notranslate"><span class="pre">term1</span></code></p></td>
</tr>
</tbody>
</table>
<p>In the following patterns, the redex is intended to be inferred from
the rewrite rule.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><a class="reference internal" href="#grammar-token-r_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_pattern</span></code></a></p></th>
<th class="head"><p>instantiation order and place for <code class="docutils literal notranslate"><span class="pre">term_i</span></code> and redex</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term</span></code> is matched against the goal, the redex is matched against
the subterm of the instantiation of <code class="docutils literal notranslate"><span class="pre">term</span></code> identified by
<code class="docutils literal notranslate"><span class="pre">ident</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">term</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term</span></code> is matched against the goal, redex is matched against the
instantiation of <code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<div class="section" id="contextual-pattern-in-set-and-the-tactical">
<h4>Contextual pattern in set and the : tactical<a class="headerlink" href="#contextual-pattern-in-set-and-the-tactical" title="Permalink to this headline">¶</a></h4>
<p>As already mentioned in section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a> the <code class="docutils literal notranslate"><span class="pre">set</span></code>
tactic takes as an
argument a term in open syntax. This term is interpreted as the
simplest form of <a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a>. To avoid confusion in the grammar, open
syntax is supported only for the simplest form of patterns, while
parentheses are required around more complex patterns.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkca" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkca"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">a</span> <span class="nv">b</span> : a + b + <span class="mi">1</span> = b + (a + <span class="mi">1</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a + b + <span class="mi">1</span> = b + (a + <span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkcb" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkcb"><span class="highlight"><span class="nb">set</span> t := (X <span class="kr">in</span> _ = X).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">b + (a + <span class="mi">1</span>)</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a + b + <span class="mi">1</span> = t</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkcc" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkcc"><span class="highlight"><span class="nb">rewrite</span> {}/t.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a + b + <span class="mi">1</span> = b + (a + <span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkcd" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkcd"><span class="highlight"><span class="nb">set</span> t := (a + _ <span class="kr">in</span> X <span class="kr">in</span> _ = X).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight">a + <span class="mi">1</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a + b + <span class="mi">1</span> = b + t</span></div></blockquote></div></div></small></span></pre></div></div>
<p>Since the user may define an infix notation for <code class="docutils literal notranslate"><span class="pre">in</span></code> the result of the former
tactic may be ambiguous. The disambiguation rule implemented is to prefer
patterns over simple terms, but to interpret a pattern with double
parentheses as a simple term. For example, the following tactic would
capture any occurrence of the term <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">in</span> <span class="pre">A</span></code>.</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">((</span><span class="n">a</span> <span class="kr">in</span> <span class="n">A</span><span class="o">)).</span>
</pre></div>
</div>
<p>Contextual patterns can also be used as arguments of the <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical.
For example:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">elim</span><span class="o">:</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span> <span class="kr">in</span> <span class="n">_</span> <span class="o">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">refl_equal</span> <span class="n">n</span><span class="o">).</span>
</pre></div>
</div>
</div>
<div class="section" id="contextual-patterns-in-rewrite">
<h4>Contextual patterns in rewrite<a class="headerlink" href="#contextual-patterns-in-rewrite" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;n .+1&quot;</span> := (Datatypes.S n) (<span class="kn">at level</span> <span class="mi">2</span>, <span class="kn">left associativity</span>,
                     <span class="kn">format</span> <span class="s2">&quot;n .+1&quot;</span>) : nat_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">addSn</span> : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span>, m.+<span class="mi">1</span> + n = (m + n).+<span class="mi">1</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">addn0</span> : <span class="kr">forall</span> <span class="nv">m</span>, m + <span class="mi">0</span> = m.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">addnC</span> : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span>, m + n = n + m.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkce" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkce"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">f</span> : (x.+<span class="mi">1</span> + y) + f (x.+<span class="mi">1</span> + y) (z + (x + y).+<span class="mi">1</span>) = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat -&gt; nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x.+<span class="mi">1</span> + y + f (x.+<span class="mi">1</span> + y) (z + (x + y).+<span class="mi">1</span>) = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkcf" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkcf"><span class="highlight"><span class="nb">rewrite</span> [<span class="kr">in</span> f _ _]addSn.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat -&gt; nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x.+<span class="mi">1</span> + y + f (x + y).+<span class="mi">1</span> (z + (x + y).+<span class="mi">1</span>) = <span class="mi">0</span></span></div></blockquote></div></div></small></span></pre></div><p>Note: the simplification rule <code class="docutils literal notranslate"><span class="pre">addSn</span></code> is applied only under the <code class="docutils literal notranslate"><span class="pre">f</span></code>
symbol.
Then we simplify also the first addition and expand <code class="docutils literal notranslate"><span class="pre">0</span></code> into <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">+</span> <span class="pre">0</span></code>.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkd0" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkd0"><span class="highlight"><span class="nb">rewrite</span> addSn -[X <span class="kr">in</span> _ = X]addn0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat -&gt; nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(x + y).+<span class="mi">1</span> + f (x + y).+<span class="mi">1</span> (z + (x + y).+<span class="mi">1</span>) = <span class="mi">0</span> + <span class="mi">0</span></span></div></blockquote></div></div></small></span></pre></div><p>Note that the right hand side of <code class="docutils literal notranslate"><span class="pre">addn0</span></code> is undetermined, but the
rewrite pattern specifies the redex explicitly. The right hand side
of <code class="docutils literal notranslate"><span class="pre">addn0</span></code> is unified with the term identified by <code class="docutils literal notranslate"><span class="pre">X</span></code>, here <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>The following pattern does not specify a redex, since it identifies an
entire region, hence the rewrite rule has to be instantiated
explicitly. Thus the tactic:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkd1" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkd1"><span class="highlight"><span class="nb">rewrite</span> -{<span class="mi">2</span>}[<span class="kr">in</span> X <span class="kr">in</span> _ = X](addn0 <span class="mi">0</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat -&gt; nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(x + y).+<span class="mi">1</span> + f (x + y).+<span class="mi">1</span> (z + (x + y).+<span class="mi">1</span>) =
<span class="mi">0</span> + (<span class="mi">0</span> + <span class="mi">0</span>)</span></div></blockquote></div></div></small></span></pre></div><p>The following tactic is quite tricky:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkd2" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkd2"><span class="highlight"><span class="nb">rewrite</span> [_.+<span class="mi">1</span> <span class="kr">in</span> X <span class="kr">in</span> f _ X](addnC x.+<span class="mi">1</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat -&gt; nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(x + y).+<span class="mi">1</span> + f (x + y).+<span class="mi">1</span> (z + (y + x.+<span class="mi">1</span>)) =
<span class="mi">0</span> + (<span class="mi">0</span> + <span class="mi">0</span>)</span></div></blockquote></div></div></small></span></pre></div><p>The explicit redex <code class="docutils literal notranslate"><span class="pre">_.+1</span></code> is important since its head constant <code class="docutils literal notranslate"><span class="pre">S</span></code>
differs from the head constant inferred from
<code class="docutils literal notranslate"><span class="pre">(addnC</span> <span class="pre">x.+1)</span></code> (that is <code class="docutils literal notranslate"><span class="pre">+</span></code>).
Moreover, the pattern <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">_</span> <span class="pre">X</span></code> is important to rule out
the first occurrence of <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y).+1</span></code>.
Last, only the subterms of <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">_</span> <span class="pre">X</span></code>
identified by <code class="docutils literal notranslate"><span class="pre">X</span></code> are rewritten, thus the first argument of
<code class="docutils literal notranslate"><span class="pre">f</span></code> is skipped too.
Also note the pattern <code class="docutils literal notranslate"><span class="pre">_.+1</span></code> is interpreted in the context
identified by <code class="docutils literal notranslate"><span class="pre">X</span></code>, thus it gets instantiated to
<code class="docutils literal notranslate"><span class="pre">(y</span> <span class="pre">+</span> <span class="pre">x).+1</span></code> and not <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y).+1</span></code>.</p>
<p>The last rewrite pattern allows to specify exactly the shape of the
term identified by X, that is thus unified with the left hand side of
the rewrite rule.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkd3" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkd3"><span class="highlight"><span class="nb">rewrite</span> [x.+<span class="mi">1</span> + y <span class="kr">as</span> X <span class="kr">in</span> f X _]addnC.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat -&gt; nat -&gt; nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(x + y).+<span class="mi">1</span> + f (y + x.+<span class="mi">1</span>) (z + (y + x.+<span class="mi">1</span>)) =
<span class="mi">0</span> + (<span class="mi">0</span> + <span class="mi">0</span>)</span></div></blockquote></div></div></small></span></pre></div></div>
</div>
</div>
<div class="section" id="patterns-for-recurrent-contexts">
<h3>Patterns for recurrent contexts<a class="headerlink" href="#patterns-for-recurrent-contexts" title="Permalink to this headline">¶</a></h3>
<p>The user can define shortcuts for recurrent contexts corresponding to
the <code class="docutils literal notranslate"><span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code> part. The notation scope identified with
<code class="docutils literal notranslate"><span class="pre">%pattern</span></code>
provides a special notation <code class="docutils literal notranslate"><span class="pre">(X</span> <span class="pre">in</span> <span class="pre">t)</span></code> the user must adopt
in order to define
context shortcuts.</p>
<p>The following example is taken from <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code> where the
<code class="docutils literal notranslate"><span class="pre">LHS</span></code> and <code class="docutils literal notranslate"><span class="pre">RHS</span></code> shortcuts are defined.</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Notation</span> <span class="nf">RHS</span> <span class="o">:=</span> <span class="o">(</span><span class="n">X</span> <span class="kr">in</span> <span class="n">_</span> <span class="o">=</span> <span class="n">X</span><span class="o">)%</span><span class="nb">pattern</span><span class="o">.</span>
<span class="kn">Notation</span> <span class="nf">LHS</span> <span class="o">:=</span> <span class="o">(</span><span class="n">X</span> <span class="kr">in</span> <span class="n">X</span> <span class="o">=</span> <span class="n">_</span><span class="o">)%</span><span class="nb">pattern</span><span class="o">.</span>
</pre></div>
</div>
<p>Shortcuts defined this way can be freely used in place of the trailing
<code class="docutils literal notranslate"><span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code> part of any contextual pattern. Some examples follow:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span> <span class="n">rhs</span> <span class="o">:=</span> <span class="n">RHS</span><span class="o">.</span>
<span class="nb">rewrite</span> <span class="o">[</span><span class="kr">in</span> <span class="n">RHS</span><span class="o">]</span><span class="n">rule</span><span class="o">.</span>
<span class="nb">case</span><span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">_</span> <span class="kr">in</span> <span class="n">RHS</span><span class="o">).</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="views-and-reflection">
<span id="views-and-reflection-ssr"></span><h2>Views and reflection<a class="headerlink" href="#views-and-reflection" title="Permalink to this headline">¶</a></h2>
<p>The bookkeeping facilities presented in section <a class="reference internal" href="#basic-tactics-ssr"><span class="std std-ref">Basic tactics</span></a> are
crafted to ease simultaneous introductions and generalizations of facts and
operations of casing, naming etc. It also a common practice to make a stack
operation immediately followed by an <em>interpretation</em> of the fact
being pushed, that is, to apply a lemma to this fact before passing it
to a tactic for decomposition, application and so on.</p>
<p><span class="smallcaps">SSReflect</span> provides a convenient, unified syntax to combine these
interpretation operations with the proof stack operations. This <em>view
mechanism</em> relies on the combination of the <code class="docutils literal notranslate"><span class="pre">/</span></code> view switch with
bookkeeping tactics and tacticals.</p>
<div class="section" id="interpreting-eliminations">
<span id="custom-elim-ssr"></span><h3>Interpreting eliminations<a class="headerlink" href="#interpreting-eliminations" title="Permalink to this headline">¶</a></h3>
<p>The view syntax combined with the <code class="docutils literal notranslate"><span class="pre">elim</span></code> tactic specifies an elimination
scheme to be used instead of the default, generated, one. Hence the
<span class="smallcaps">SSReflect</span> tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">elim</span><span class="o">/</span><span class="n">V</span><span class="o">.</span>
</pre></div>
</div>
<p>is a synonym for:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">intro</span> <span class="n">top</span><span class="o">;</span> <span class="nb">elim</span> <span class="n">top</span> <span class="nb">using</span> <span class="n">V</span><span class="o">;</span> <span class="nb">clear</span> <span class="n">top</span><span class="o">.</span>
</pre></div>
</div>
<p>where top is a fresh name and V any second-order lemma.</p>
<p>Since an elimination view supports the two bookkeeping tacticals of
discharge and introduction (see section <a class="reference internal" href="#basic-tactics-ssr"><span class="std std-ref">Basic tactics</span></a>),
the <span class="smallcaps">SSReflect</span> tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">elim</span><span class="o">/</span><span class="n">V</span><span class="o">:</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">y</span><span class="o">.</span>
</pre></div>
</div>
<p>is a synonym for:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">elim</span> <span class="n">x</span> <span class="nb">using</span> <span class="n">V</span><span class="o">;</span> <span class="nb">clear</span> <span class="n">x</span><span class="o">;</span> <span class="nb">intro</span> <span class="n">y</span><span class="o">.</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">x</span></code> is a variable in the context, <code class="docutils literal notranslate"><span class="pre">y</span></code> a fresh name and <code class="docutils literal notranslate"><span class="pre">V</span></code>
any second order lemma; <span class="smallcaps">SSReflect</span> relaxes the syntactic restrictions of the <span class="smallcaps">Coq</span>
<code class="docutils literal notranslate"><span class="pre">elim</span></code>. The first pattern following <code class="docutils literal notranslate"><span class="pre">:</span></code> can be a <code class="docutils literal notranslate"><span class="pre">_</span></code> wildcard if the
conclusion of the view <code class="docutils literal notranslate"><span class="pre">V</span></code> specifies a pattern for its last argument
(e.g., if <code class="docutils literal notranslate"><span class="pre">V</span></code> is a functional induction lemma generated by the
<code class="docutils literal notranslate"><span class="pre">Function</span></code> command).</p>
<p>The elimination view mechanism is compatible with the equation name
generation (see section <a class="reference internal" href="#generation-of-equations-ssr"><span class="std std-ref">Generation of equations</span></a>).</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>The following script illustrates a toy example of this feature. Let us
define a function adding an element at the end of a list:</p>
</div></blockquote>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">d</span> : <span class="kt">Type</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">add_last</span> (<span class="nv">s</span> : list d) (<span class="nv">z</span> : d) {<span class="nv">struct</span> <span class="nv">s</span>} : list d :=
  <span class="kr">if</span> s <span class="kr">is</span> cons x s&#39; <span class="kr">then</span> cons x (add_last s&#39; z) <span class="kr">else</span> z :: nil.</span></span></span></pre></div><p>One can define an alternative, reversed, induction principle on
inductively defined lists, by proving the following lemma:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">last_ind_list</span> : <span class="kr">forall</span> <span class="nv">P</span> : list d -&gt; <span class="kt">Prop</span>,
  P nil -&gt; (<span class="kr">forall</span> <span class="nv">s</span> (<span class="nv">x</span> : d), P s -&gt; P (add_last s x)) -&gt;
    <span class="kr">forall</span> <span class="nv">s</span> : list d, P s.</span></span></span></pre></div><p>Then the combination of elimination views with equation names result
in a concise syntax for reasoning inductively using the user-defined
elimination scheme.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkd4" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkd4"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">x</span> : d) (<span class="nv">l</span> : list d): l = l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list d</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">l = l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkd5" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkd5"><span class="highlight"><span class="nb">elim</span>/last_ind_list E : l=&gt; [| u v]; <span class="nb">last first</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d</span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list d</span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list d</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">l = add_last u v</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">u = u -&gt; add_last u v = add_last u v</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chkd6" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">d</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list d</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">l = nil</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chkd6"><hr></label><div class="goal-conclusion"><span class="highlight">nil = nil</span></div></blockquote></div></div></div></small></span></pre></div></div>
<p>User-provided eliminators (potentially generated with <span class="smallcaps">Coq</span>’s <code class="docutils literal notranslate"><span class="pre">Function</span></code>
command) can be combined with the type family switches described
in section <a class="reference internal" href="#type-families-ssr"><span class="std std-ref">Type families</span></a>.
Consider an eliminator <code class="docutils literal notranslate"><span class="pre">foo_ind</span></code> of type:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="n">foo_ind</span> <span class="o">:</span> <span class="kr">forall</span> <span class="o">…,</span> <span class="kr">forall</span> <span class="nv">x</span> <span class="o">:</span> <span class="n">T</span><span class="o">,</span> <span class="n">P</span> <span class="n">p1</span> <span class="o">…</span> <span class="n">pm</span><span class="o">.</span>
</pre></div>
</div>
<p>and consider the tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">elim</span><span class="o">/</span><span class="n">foo_ind</span><span class="o">:</span> <span class="n">e1</span> <span class="o">…</span> <span class="o">/</span> <span class="n">en</span><span class="o">.</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">elim/</span></code> tactic distinguishes two cases:</p>
<dl class="field-list simple">
<dt class="field-odd">truncated eliminator</dt>
<dd class="field-odd"><p>when <code class="docutils literal notranslate"><span class="pre">x</span></code> does not occur in <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">p1</span> <span class="pre">…</span> <span class="pre">pm</span></code> and the
type of <code class="docutils literal notranslate"><span class="pre">en</span></code> unifies with <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">en</span></code> is not <code class="docutils literal notranslate"><span class="pre">_</span></code>.
In that case, <code class="docutils literal notranslate"><span class="pre">en</span></code> is
passed to the eliminator as the last argument (<code class="docutils literal notranslate"><span class="pre">x</span></code> in <code class="docutils literal notranslate"><span class="pre">foo_ind</span></code>) and
<code class="docutils literal notranslate"><span class="pre">en−1</span> <span class="pre">…</span> <span class="pre">e1</span></code> are used as patterns to select in the goal the occurrences that
will be bound by the predicate <code class="docutils literal notranslate"><span class="pre">P</span></code>, thus it must be possible to unify
the subterm of the goal matched by <code class="docutils literal notranslate"><span class="pre">en−1</span></code> with <code class="docutils literal notranslate"><span class="pre">pm</span></code> , the one matched
by <code class="docutils literal notranslate"><span class="pre">en−2</span></code> with <code class="docutils literal notranslate"><span class="pre">pm−1</span></code> and so on.</p>
</dd>
<dt class="field-even">regular eliminator</dt>
<dd class="field-even"><p>in all the other cases. Here it must be possible
to unify the term matched by <code class="docutils literal notranslate"><span class="pre">en</span></code> with <code class="docutils literal notranslate"><span class="pre">pm</span></code> , the one matched by
<code class="docutils literal notranslate"><span class="pre">en−1</span></code>
with <code class="docutils literal notranslate"><span class="pre">pm−1</span></code> and so on. Note that standard eliminators have the shape
<code class="docutils literal notranslate"><span class="pre">…forall</span> <span class="pre">x,</span> <span class="pre">P</span> <span class="pre">…</span> <span class="pre">x</span></code>, thus <code class="docutils literal notranslate"><span class="pre">en</span></code> is the pattern identifying the
eliminated term, as expected.</p>
</dd>
</dl>
<p>As explained in section <a class="reference internal" href="#type-families-ssr"><span class="std std-ref">Type families</span></a>, the initial prefix of
<code class="docutils literal notranslate"><span class="pre">ei</span></code> can be omitted.</p>
<p>Here is an example of a regular, but nontrivial, eliminator.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Here is a toy example illustrating this feature.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Function</span> <span class="nf">plus</span> (m n : nat) {<span class="kr">struct</span> n} : nat :=
  <span class="kr">if</span> n <span class="kr">is</span> S p <span class="kr">then</span> S (plus m p) <span class="kr">else</span> m.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkd7" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkd7"><span class="highlight"><span class="kn">About</span> plus_ind.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">plus_ind :
<span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">P</span> : nat -&gt; nat -&gt; <span class="kt">Prop</span>),
(<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat,
 n = S p -&gt; P p (plus m p) -&gt; P (S p) (S (plus m p))) -&gt;
(<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">_x</span> : nat,
 n = _x -&gt;
 <span class="kr">match</span> _x <span class="kr">with</span>
 | <span class="mi">0</span> =&gt; <span class="kt">True</span>
 | S _ =&gt; <span class="kt">False</span>
 <span class="kr">end</span> -&gt; P _x m) -&gt; <span class="kr">forall</span> <span class="nv">n</span> : nat, P n (plus m n)

plus_ind <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> m, P are implicit
Argument scopes are [nat_scope function_scope
  function_scope function_scope nat_scope]
plus_ind <span class="kr">is</span> transparent
Expands to: Constant SerTop.<span class="kn">Test</span>.plus_ind</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkd8" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkd8"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : plus (plus x y) z = plus x (plus y z).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">plus (plus x y) z = plus x (plus y z)</span></div></blockquote></div></div></small></span></pre></div><p>The following tactics are all valid and perform the same elimination
on this goal.</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">elim</span><span class="o">/</span><span class="n">plus_ind</span><span class="o">:</span> <span class="n">z</span> <span class="o">/</span> <span class="o">(</span><span class="n">plus</span> <span class="n">_</span> <span class="n">z</span><span class="o">).</span>
<span class="nb">elim</span><span class="o">/</span><span class="n">plus_ind</span><span class="o">:</span> <span class="o">{</span><span class="n">z</span><span class="o">}(</span><span class="n">plus</span> <span class="n">_</span> <span class="n">z</span><span class="o">).</span>
<span class="nb">elim</span><span class="o">/</span><span class="n">plus_ind</span><span class="o">:</span> <span class="o">{</span><span class="n">z</span><span class="o">}</span><span class="n">_</span><span class="o">.</span>
<span class="nb">elim</span><span class="o">/</span><span class="n">plus_ind</span><span class="o">:</span> <span class="n">z</span> <span class="o">/</span> <span class="n">_</span><span class="o">.</span>
</pre></div>
</div>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkd9" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkd9"><span class="highlight"><span class="nb">elim</span>/plus_ind: z / _.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span> : nat,
n = S p -&gt;
plus (plus x y) p = plus x (plus y p) -&gt;
S (plus (plus x y) p) = plus x (plus y (S p))</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chkda" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chkda"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">_x</span> : nat,
n = _x -&gt;
<span class="kr">match</span> _x <span class="kr">with</span>
| <span class="mi">0</span> =&gt; <span class="kt">True</span>
| S _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt; plus x y = plus x (plus y _x)</span></div></blockquote></div></div></div></small></span></pre></div><p>The two latter examples feature a wildcard pattern: in this case,
the resulting pattern is inferred from the type of the eliminator.
In both these examples, it is <code class="docutils literal notranslate"><span class="pre">(plus</span> <span class="pre">_</span> <span class="pre">_)</span></code>, which matches the subterm
<code class="docutils literal notranslate"><span class="pre">plus</span> <span class="pre">(plus</span> <span class="pre">x</span> <span class="pre">y)</span> <span class="pre">z</span></code> thus instantiating the last <code class="docutils literal notranslate"><span class="pre">_</span></code> with <code class="docutils literal notranslate"><span class="pre">z</span></code>.
Note that the tactic:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkdb" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkdb"><span class="highlight"><span class="kn">Fail</span> <span class="nb">elim</span>/plus_ind: y / _.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
The given <span class="nb">pattern</span> matches the term y
while the inferred <span class="nb">pattern</span> z doesn&#39;t</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">plus (plus x y) z = plus x (plus y z)</span></div></blockquote></div></div></small></span></pre></div><p>triggers an error: in the conclusion
of the <code class="docutils literal notranslate"><span class="pre">plus_ind</span></code> eliminator, the first argument of the predicate
<code class="docutils literal notranslate"><span class="pre">P</span></code> should be the same as the second argument of <code class="docutils literal notranslate"><span class="pre">plus</span></code>, in the
second argument of <code class="docutils literal notranslate"><span class="pre">P</span></code>, but <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> do no unify.</p>
</div>
<p>Here is an example of a truncated eliminator:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Consider the goal:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">p</span> <span class="nv">n</span> <span class="o">(</span><span class="nv">n_gt0</span> <span class="o">:</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="nv">pr_p</span> <span class="o">:</span> <span class="n">prime</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">p</span> <span class="o">%|</span> <span class="o">\</span><span class="n">prod_</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;-</span> <span class="n">prime_decomp</span> <span class="n">n</span> <span class="o">|</span> <span class="n">i</span> <span class="o">\</span><span class="kr">in</span> <span class="n">prime_decomp</span> <span class="n">n</span><span class="o">)</span> <span class="n">i</span><span class="o">.</span><span class="mi">1</span> <span class="o">^</span> <span class="n">i</span><span class="o">.</span><span class="mi">2</span> <span class="o">-&gt;</span>
    <span class="kr">exists2</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">*</span> <span class="n">nat</span><span class="o">,</span> <span class="n">x</span> <span class="o">\</span><span class="kr">in</span> <span class="n">prime_decomp</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="mi">1</span><span class="o">.</span>
<span class="kn">Proof</span><span class="o">.</span>
<span class="nb">elim</span><span class="o">/</span><span class="n">big_prop</span><span class="o">:</span> <span class="n">_</span> <span class="o">=&gt;</span> <span class="o">[|</span> <span class="n">u</span> <span class="n">v</span> <span class="n">IHu</span> <span class="n">IHv</span> <span class="o">|</span> <span class="o">[</span><span class="n">q</span> <span class="n">e</span><span class="o">]</span> <span class="o">/=].</span>
</pre></div>
</div>
<p>where the type of the <code class="docutils literal notranslate"><span class="pre">big_prop</span></code> eliminator is</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="n">big_prop</span><span class="o">:</span> <span class="kr">forall</span> <span class="o">(</span><span class="nv">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="nv">Pb</span> <span class="o">:</span> <span class="n">R</span> <span class="o">-&gt;</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="nv">idx</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="nv">op1</span> <span class="o">:</span> <span class="n">R</span> <span class="o">-&gt;</span> <span class="n">R</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="o">),</span> <span class="n">Pb</span> <span class="n">idx</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">Pb</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">Pb</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">Pb</span> <span class="o">(</span><span class="n">op1</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span> <span class="o">-&gt;</span>
  <span class="kr">forall</span> <span class="o">(</span><span class="nv">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="nv">r</span> <span class="o">:</span> <span class="n">seq</span> <span class="n">I</span><span class="o">)</span> <span class="o">(</span><span class="nv">P</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">I</span><span class="o">)</span> <span class="o">(</span><span class="nv">F</span> <span class="o">:</span> <span class="n">I</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="o">),</span>
  <span class="o">(</span><span class="kr">forall</span> <span class="nv">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">P</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">Pb</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">))</span> <span class="o">-&gt;</span>
    <span class="n">Pb</span> <span class="o">(\</span><span class="n">big</span><span class="o">[</span><span class="n">op1</span><span class="o">/</span><span class="n">idx</span><span class="o">]</span><span class="n">_</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;-</span> <span class="n">r</span> <span class="o">|</span> <span class="n">P</span> <span class="n">i</span><span class="o">)</span> <span class="n">F</span> <span class="n">i</span><span class="o">).</span>
</pre></div>
</div>
<p>Since the pattern for the argument of Pb is not specified, the
inferred one is used instead: <code class="docutils literal notranslate"><span class="pre">big[_/_]_(i</span> <span class="pre">&lt;-</span> <span class="pre">_</span> <span class="pre">|</span> <span class="pre">_</span> <span class="pre">i)</span> <span class="pre">_</span> <span class="pre">i</span></code>,
and after the introductions, the following goals are generated:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="n">subgoal</span> <span class="mi">1</span> <span class="kr">is</span><span class="o">:</span>
  <span class="n">p</span> <span class="o">%|</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="kr">exists2</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">*</span> <span class="n">nat</span><span class="o">,</span> <span class="n">x</span> <span class="o">\</span><span class="kr">in</span> <span class="n">prime_decomp</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="mi">1</span>
<span class="n">subgoal</span> <span class="mi">2</span> <span class="kr">is</span><span class="o">:</span>
  <span class="n">p</span> <span class="o">%|</span> <span class="n">u</span> <span class="o">*</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="kr">exists2</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">*</span> <span class="n">nat</span><span class="o">,</span> <span class="n">x</span> <span class="o">\</span><span class="kr">in</span> <span class="n">prime_decomp</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="mi">1</span>
<span class="n">subgoal</span> <span class="mi">3</span> <span class="kr">is</span><span class="o">:</span>
  <span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="o">\</span><span class="kr">in</span> <span class="n">prime_decomp</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">p</span> <span class="o">%|</span> <span class="n">q</span> <span class="o">^</span> <span class="n">e</span> <span class="o">-&gt;</span>
    <span class="kr">exists2</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">*</span> <span class="n">nat</span><span class="o">,</span> <span class="n">x</span> <span class="o">\</span><span class="kr">in</span> <span class="n">prime_decomp</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="mi">1</span><span class="o">.</span>
</pre></div>
</div>
<p>Note that the pattern matching algorithm instantiated all the
variables occurring in the pattern.</p>
</div>
</div>
<div class="section" id="interpreting-assumptions">
<span id="interpreting-assumptions-ssr"></span><h3>Interpreting assumptions<a class="headerlink" href="#interpreting-assumptions" title="Permalink to this headline">¶</a></h3>
<p>Interpreting an assumption in the context of a proof consists in
applying to it a lemma before generalizing, and/or decomposing this
assumption. For instance, with the extensive use of boolean reflection
(see section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>), it is quite frequent
to need to decompose the logical interpretation of (the boolean
expression of) a fact, rather than the fact itself. This can be
achieved by a combination of <code class="docutils literal notranslate"><span class="pre">move</span> <span class="pre">:</span> <span class="pre">_</span> <span class="pre">=&gt;</span> <span class="pre">_</span></code> switches, like in the
following example, where <code class="docutils literal notranslate"><span class="pre">||</span></code> is a notation for the boolean
disjunction.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variables</span> <span class="nv">P</span> <span class="nv">Q</span> : bool -&gt; <span class="kt">Prop</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hypothesis</span> <span class="nv">P2Q</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P (a || b) -&gt; Q a.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkdc" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkdc"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">a</span> : P (a || a) -&gt; <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P2Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">b</span> : bool, P (a0 || b) -&gt; Q a0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P (a || a) -&gt; <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkdd" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkdd"><span class="highlight"><span class="nb">move</span>=&gt; HPa; <span class="nb">move</span>: {HPa}(P2Q HPa) =&gt; HQa.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P2Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">b</span> : bool, P (a0 || b) -&gt; Q a0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HQa</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q a</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div><p>which transforms the hypothesis <code class="docutils literal notranslate"><span class="pre">HPa</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">a</span></code> which has been introduced
from the initial statement into <code class="docutils literal notranslate"><span class="pre">HQa</span> <span class="pre">:</span> <span class="pre">Q</span> <span class="pre">a</span></code>.
This operation is so common that the tactic shell has specific
syntax for it. The following scripts:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkde" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkde"><span class="highlight"><span class="nb">move</span>=&gt; HPa; <span class="nb">move</span>/P2Q: HPa =&gt; HQa.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P2Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">b</span> : bool, P (a0 || b) -&gt; Q a0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HQa</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q a</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div><p>or more directly:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkdf" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkdf"><span class="highlight"><span class="nb">move</span>/P2Q=&gt; HQa.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P2Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">b</span> : bool, P (a0 || b) -&gt; Q a0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HQa</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q a</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div><p>are equivalent to the former one. The former script shows how to
interpret a fact (already in the context), thanks to the discharge
tactical (see section <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>) and the latter, how to interpret the top
assumption of a goal. Note that the number of wildcards to be inserted
to find the correct application of the view lemma to the hypothesis
has been automatically inferred.</p>
</div>
<p>The view mechanism is compatible with the <code class="docutils literal notranslate"><span class="pre">case</span></code> tactic and with the
equation name generation mechanism (see section <a class="reference internal" href="#generation-of-equations-ssr"><span class="std std-ref">Generation of equations</span></a>):</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variables</span> <span class="nv">P</span> <span class="nv">Q</span>: bool -&gt; <span class="kt">Prop</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hypothesis</span> <span class="nv">Q2P</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, Q (a || b) -&gt; P a \/ P b.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chke0" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chke0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">a</span> <span class="nv">b</span> : Q (a || b) -&gt; <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q2P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">b0</span> : bool, Q (a0 || b0) -&gt; P a0 \/ P b0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Q (a || b) -&gt; <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chke1" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chke1"><span class="highlight"><span class="nb">case</span>/Q2P=&gt; [HPa | HPb].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q2P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">b0</span> : bool, Q (a0 || b0) -&gt; P a0 \/ P b0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPa</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P a</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chke2" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q2P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">b0</span> : bool, Q (a0 || b0) -&gt; P a0 \/ P b0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P b</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chke2"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></div></small></span></pre></div><p>This view tactic performs:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">move</span><span class="o">=&gt;</span> <span class="n">HQ</span><span class="o">;</span> <span class="nb">case</span><span class="o">:</span> <span class="o">{</span><span class="n">HQ</span><span class="o">}(</span><span class="n">Q2P</span> <span class="n">HQ</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="n">HPa</span> <span class="o">|</span> <span class="n">HPb</span><span class="o">].</span>
</pre></div>
</div>
</div>
<p>The term on the right of the <code class="docutils literal notranslate"><span class="pre">/</span></code> view switch is called a <em>view lemma</em>.
Any <span class="smallcaps">SSReflect</span> term coercing to a product type can be used as a view
lemma.</p>
<p>The examples we have given so far explicitly provide the direction of
the translation to be performed. In fact, view lemmas need not to be
oriented. The view mechanism is able to detect which application is
relevant for the current goal.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variables</span> <span class="nv">P</span> <span class="nv">Q</span>: bool -&gt; <span class="kt">Prop</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hypothesis</span> <span class="nv">PQequiv</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P (a || b) &lt;-&gt; Q a.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chke3" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chke3"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">a</span> <span class="nv">b</span> : P (a || b) -&gt; <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">PQequiv</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">b0</span> : bool, P (a0 || b0) &lt;-&gt; Q a0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P (a || b) -&gt; <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chke4" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chke4"><span class="highlight"><span class="nb">move</span>/PQequiv=&gt; HQab.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">PQequiv</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">b0</span> : bool, P (a0 || b0) &lt;-&gt; Q a0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HQab</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q a</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div><p>has the same behavior as the first example above.</p>
<p>The view mechanism can insert automatically a <em>view hint</em> to transform
the double implication into the expected simple implication. The last
script is in fact equivalent to:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">a</span> <span class="nv">b</span> <span class="o">:</span> <span class="n">P</span> <span class="o">(</span><span class="n">a</span> <span class="o">||</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">True</span><span class="o">.</span>
<span class="nb">move</span><span class="o">/(</span><span class="n">iffLR</span> <span class="o">(</span><span class="n">PQequiv</span> <span class="n">_</span> <span class="n">_</span><span class="o">)).</span>
</pre></div>
</div>
<p>where:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Lemma</span> <span class="nf">iffLR</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="o">:</span> <span class="o">(</span><span class="n">P</span> <span class="o">&lt;-&gt;</span> <span class="n">Q</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">P</span> <span class="o">-&gt;</span> <span class="n">Q</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="specializing-assumptions">
<h4>Specializing assumptions<a class="headerlink" href="#specializing-assumptions" title="Permalink to this headline">¶</a></h4>
<p>The special case when the <em>head symbol</em> of the view lemma is a
wildcard is used to interpret an assumption by <em>specializing</em> it. The
view mechanism hence offers the possibility to apply a higher-order
assumption to some given arguments.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chke5" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chke5"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">z</span> : (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x + y = z -&gt; z = x) -&gt; z = <span class="mi">0</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : nat, x + y = z -&gt; z = x) -&gt; z = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chke6" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chke6"><span class="highlight"><span class="nb">move</span>/(_ <span class="mi">0</span> z).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="mi">0</span> + z = z -&gt; z = <span class="mi">0</span>) -&gt; z = <span class="mi">0</span></span></div></blockquote></div></div></small></span></pre></div></div>
</div>
</div>
<div class="section" id="interpreting-goals">
<h3>Interpreting goals<a class="headerlink" href="#interpreting-goals" title="Permalink to this headline">¶</a></h3>
<p>In a similar way, it is also often convenient to
changing a goal by turning it into an equivalent proposition. The view
mechanism of <span class="smallcaps">SSReflect</span> has a special syntax <code class="docutils literal notranslate"><span class="pre">apply/</span></code> for combining  in a
single tactic simultaneous goal interpretation operations and
bookkeeping steps.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>The following example use the <code class="docutils literal notranslate"><span class="pre">~~</span></code> prenex notation for boolean negation:</p>
</div></blockquote>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variables</span> <span class="nv">P</span> <span class="nv">Q</span>: bool -&gt; <span class="kt">Prop</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hypothesis</span> <span class="nv">PQequiv</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P (a || b) &lt;-&gt; Q a.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chke7" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chke7"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">a</span> : P ((~~ a) || a).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">PQequiv</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">b</span> : bool, P (a0 || b) &lt;-&gt; Q a0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P (~~ a || a)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chke8" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chke8"><span class="highlight"><span class="nb">apply</span>/PQequiv.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">PQequiv</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">a0</span> <span class="nv">b</span> : bool, P (a0 || b) &lt;-&gt; Q a0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Q (~~ a)</span></div></blockquote></div></div></small></span></pre></div><p>thus in this case, the tactic <code class="docutils literal notranslate"><span class="pre">apply/PQequiv</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">apply:</span> <span class="pre">(iffRL</span> <span class="pre">(PQequiv</span> <span class="pre">_</span> <span class="pre">_))</span></code>, where <code class="docutils literal notranslate"><span class="pre">iffRL</span></code> is the analogue of
<code class="docutils literal notranslate"><span class="pre">iffRL</span></code> for the converse implication.</p>
</div>
<p>Any <span class="smallcaps">SSReflect</span> term whose type coerces to a double implication can be
used as a view for goal interpretation.</p>
<p>Note that the goal interpretation view mechanism supports both <code class="docutils literal notranslate"><span class="pre">apply</span></code>
and <code class="docutils literal notranslate"><span class="pre">exact</span></code> tactics. As expected, a goal interpretation view command
exact/term should solve the current goal or it will fail.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Goal interpretation view tactics are <em>not</em> compatible with
the bookkeeping tactical <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> since this would be redundant with the
<code class="docutils literal notranslate"><span class="pre">apply:</span> <span class="pre">term</span> <span class="pre">=&gt;</span> <span class="pre">_</span></code> construction.</p>
</div>
</div>
<div class="section" id="boolean-reflection">
<h3>Boolean reflection<a class="headerlink" href="#boolean-reflection" title="Permalink to this headline">¶</a></h3>
<p>In the Calculus of Inductive Constructions, there is an obvious
distinction between logical propositions and boolean values. On the
one hand, logical propositions are objects of <em>sort</em> <code class="docutils literal notranslate"><span class="pre">Prop</span></code> which is
the carrier of intuitionistic reasoning. Logical connectives in
<code class="docutils literal notranslate"><span class="pre">Prop</span></code> are <em>types</em>, which give precise information on the structure
of their proofs; this information is automatically exploited by <span class="smallcaps">Coq</span>
tactics.  For example, <span class="smallcaps">Coq</span> knows that a proof of <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">\/</span> <span class="pre">B</span></code> is
either a proof of <code class="docutils literal notranslate"><span class="pre">A</span></code> or a proof of <code class="docutils literal notranslate"><span class="pre">B</span></code>.  The tactics <code class="docutils literal notranslate"><span class="pre">left</span></code> and
<code class="docutils literal notranslate"><span class="pre">right</span></code> change the goal <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">\/</span> <span class="pre">B</span></code> to <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>, respectively;
dually, the tactic <code class="docutils literal notranslate"><span class="pre">case</span></code> reduces the goal <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">\/</span> <span class="pre">B</span> <span class="pre">=&gt;</span> <span class="pre">G</span></code> to two
subgoals <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=&gt;</span> <span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=&gt;</span> <span class="pre">G</span></code>.</p>
<p>On the other hand, bool is an inductive <em>datatype</em> with two
constructors true and false. Logical connectives on bool are
<em>computable functions</em>, defined by their truth tables, using case
analysis:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">orb</span> (<span class="nv">b1</span> <span class="nv">b2</span> : bool) := <span class="kr">if</span> b1 <span class="kr">then</span> true <span class="kr">else</span> b2.</span></span></span></pre></div></div>
<p>Properties of such connectives are also established using case
analysis</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chke9" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chke9"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> <span class="nv">b</span> : b || ~~ b = true.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">b || ~~ b = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">by</span> <span class="nb">case</span>: b.</span></span></span></pre></div><p>Once <code class="docutils literal notranslate"><span class="pre">b</span></code> is replaced by <code class="docutils literal notranslate"><span class="pre">true</span></code> in the first goal and by <code class="docutils literal notranslate"><span class="pre">false</span></code> in the
second one, the goals reduce by computations to the trivial <code class="docutils literal notranslate"><span class="pre">true</span> <span class="pre">=</span> <span class="pre">true</span></code>.</p>
</div>
<p>Thus, <code class="docutils literal notranslate"><span class="pre">Prop</span></code> and <code class="docutils literal notranslate"><span class="pre">bool</span></code> are truly complementary: the former supports
robust natural deduction, the latter allows brute-force
evaluation. <span class="smallcaps">SSReflect</span> supplies a generic mechanism to have the best of
the two worlds and move freely from a propositional version of a
decidable predicate to its boolean version.</p>
<p>First, booleans are injected into propositions using the coercion
mechanism:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Coercion</span> <span class="nf">is_true</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">true</span><span class="o">.</span>
</pre></div>
</div>
<p>This allows any boolean formula <code class="docutils literal notranslate"><span class="pre">b</span></code> to be used in a context where <span class="smallcaps">Coq</span>
would expect a proposition, e.g., after <code class="docutils literal notranslate"><span class="pre">Lemma</span> <span class="pre">…</span> <span class="pre">:</span></code>. It is then
interpreted as <code class="docutils literal notranslate"><span class="pre">(is_true</span> <span class="pre">b)</span></code>, i.e., the proposition <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">true</span></code>. Coercions
are elided by the pretty-printer, so they are essentially transparent
to the user.</p>
</div>
<div class="section" id="the-reflect-predicate">
<h3>The reflect predicate<a class="headerlink" href="#the-reflect-predicate" title="Permalink to this headline">¶</a></h3>
<p>To get all the benefits of the boolean reflection, it is in fact
convenient to introduce the following inductive predicate <code class="docutils literal notranslate"><span class="pre">reflect</span></code> to
relate propositions and booleans:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Inductive</span> <span class="nf">reflect</span> <span class="o">(</span><span class="nv">P</span><span class="o">:</span> <span class="kt">Prop</span><span class="o">):</span> <span class="n">bool</span> <span class="o">-&gt;</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">|</span> <span class="n">Reflect_true</span> <span class="o">:</span> <span class="n">P</span> <span class="o">-&gt;</span> <span class="n">reflect</span> <span class="n">P</span> <span class="n">true</span>
<span class="o">|</span> <span class="n">Reflect_false</span> <span class="o">:</span> <span class="o">~</span><span class="n">P</span> <span class="o">-&gt;</span> <span class="n">reflect</span> <span class="n">P</span> <span class="n">false</span><span class="o">.</span>
</pre></div>
</div>
<p>The statement <code class="docutils literal notranslate"><span class="pre">(reflect</span> <span class="pre">P</span> <span class="pre">b)</span></code> asserts that <code class="docutils literal notranslate"><span class="pre">(is_true</span> <span class="pre">b)</span></code> and <code class="docutils literal notranslate"><span class="pre">P</span></code> are
logically equivalent propositions.</p>
<p>For instance, the following lemma:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Lemma</span> <span class="nf">andP</span><span class="o">:</span> <span class="kr">forall</span> <span class="nv">b1</span> <span class="nv">b2</span><span class="o">,</span> <span class="n">reflect</span> <span class="o">(</span><span class="n">b1</span> <span class="o">/\</span> <span class="n">b2</span><span class="o">)</span> <span class="o">(</span><span class="n">b1</span> <span class="o">&amp;&amp;</span> <span class="n">b2</span><span class="o">).</span>
</pre></div>
</div>
<p>relates the boolean conjunction to the logical one <code class="docutils literal notranslate"><span class="pre">/\</span></code>. Note that in
<code class="docutils literal notranslate"><span class="pre">andP</span></code>, <code class="docutils literal notranslate"><span class="pre">b1</span></code> and <code class="docutils literal notranslate"><span class="pre">b2</span></code> are two boolean variables and the
proposition <code class="docutils literal notranslate"><span class="pre">b1</span> <span class="pre">/\</span> <span class="pre">b2</span></code> hides two coercions. The conjunction of
<code class="docutils literal notranslate"><span class="pre">b1</span></code> and <code class="docutils literal notranslate"><span class="pre">b2</span></code> can then be viewed as <code class="docutils literal notranslate"><span class="pre">b1</span> <span class="pre">/\</span> <span class="pre">b2</span></code> or as <code class="docutils literal notranslate"><span class="pre">b1</span> <span class="pre">&amp;&amp;</span> <span class="pre">b2</span></code>.</p>
<p>Expressing logical equivalences through this family of inductive types
makes possible to take benefit from <em>rewritable equations</em> associated
to the case analysis of <span class="smallcaps">Coq</span>’s inductive types.</p>
<p>Since the equivalence predicate is defined in <span class="smallcaps">Coq</span> as:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Definition</span> <span class="nf">iff</span> <span class="o">(</span><span class="nv">A</span> <span class="nv">B</span><span class="o">:</span><span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="o">/\</span> <span class="o">(</span><span class="n">B</span> <span class="o">-&gt;</span> <span class="n">A</span><span class="o">).</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">/\</span></code> is a notation for <code class="docutils literal notranslate"><span class="pre">and</span></code>:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Inductive</span> <span class="nf">and</span> <span class="o">(</span><span class="nv">A</span> <span class="nv">B</span><span class="o">:</span><span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">conj</span> <span class="o">:</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="kn">and</span> <span class="n">A</span> <span class="n">B</span><span class="o">.</span>
</pre></div>
</div>
<p>This make case analysis very different according to the way an
equivalence property has been defined.</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Lemma</span> <span class="nf">andE</span> <span class="o">(</span><span class="nv">b1</span> <span class="nv">b2</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">b1</span> <span class="o">/\</span> <span class="n">b2</span><span class="o">)</span> <span class="o">&lt;-&gt;</span> <span class="o">(</span><span class="n">b1</span> <span class="o">&amp;&amp;</span> <span class="n">b2</span><span class="o">).</span>
</pre></div>
</div>
<p>Let us compare the respective behaviors of <code class="docutils literal notranslate"><span class="pre">andE</span></code> and <code class="docutils literal notranslate"><span class="pre">andP</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkea" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkea"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">b1</span> <span class="nv">b2</span> : bool) : <span class="kr">if</span> (b1 &amp;&amp; b2) <span class="kr">then</span> b1 <span class="kr">else</span> ~~(b1||b2).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b1, b2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_true (<span class="kr">if</span> b1 &amp;&amp; b2 <span class="kr">then</span> b1 <span class="kr">else</span> ~~ (b1 || b2))</span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkeb" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkeb"><span class="highlight"><span class="nb">case</span>: (@andE b1 b2).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b1, b2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(b1 /\ b2 -&gt; b1 &amp;&amp; b2) -&gt;
(b1 &amp;&amp; b2 -&gt; b1 /\ b2) -&gt;
<span class="kr">if</span> b1 &amp;&amp; b2 <span class="kr">then</span> b1 <span class="kr">else</span> ~~ (b1 || b2)</span></div></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkec" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkec"><span class="highlight"><span class="nb">case</span>: (@andP b1 b2).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b1, b2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">b1 /\ b2 -&gt; b1</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chked" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b1, b2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chked"><hr></label><div class="goal-conclusion"><span class="highlight">~ (b1 /\ b2) -&gt; ~~ (b1 || b2)</span></div></blockquote></div></div></div></small></span></pre></div></div>
<p>Expressing reflection relation through the <code class="docutils literal notranslate"><span class="pre">reflect</span></code> predicate is hence
a very convenient way to deal with classical reasoning, by case
analysis. Using the <code class="docutils literal notranslate"><span class="pre">reflect</span></code> predicate allows moreover to program rich
specifications inside its two constructors, which will be
automatically taken into account during destruction. This
formalisation style gives far more efficient specifications than
quantified (double) implications.</p>
<p>A naming convention in <span class="smallcaps">SSReflect</span> is to postfix the name of view lemmas
with <code class="docutils literal notranslate"><span class="pre">P</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">orP</span></code> relates <code class="docutils literal notranslate"><span class="pre">||</span></code> and <code class="docutils literal notranslate"><span class="pre">\/</span></code>,
<code class="docutils literal notranslate"><span class="pre">negP</span></code> relates <code class="docutils literal notranslate"><span class="pre">~~</span></code> and <code class="docutils literal notranslate"><span class="pre">~</span></code>.</p>
<p>The view mechanism is compatible with reflect predicates.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkee" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkee"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">a</span> <span class="nv">b</span> : bool) (<span class="nv">Ha</span> : a) (<span class="nv">Hb</span> : b) : a /\ b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ha</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true b</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a /\ b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkef" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkef"><span class="highlight"><span class="nb">apply</span>/andP.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ha</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true b</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_true (a &amp;&amp; b)</span></div></blockquote></div></div></small></span></pre></div><p>Conversely</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkf0" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkf0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">a</span> <span class="nv">b</span> : bool) : a /\ b -&gt; a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a /\ b -&gt; a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkf1" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkf1"><span class="highlight"><span class="nb">move</span>/andP.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a &amp;&amp; b -&gt; a</span></div></blockquote></div></div></small></span></pre></div></div>
<p>The same tactics can also be used to perform the converse operation,
changing a boolean conjunction into a logical one. The view mechanism
guesses the direction of the transformation to be used i.e., the
constructor of the reflect predicate which should be chosen.</p>
</div>
<div class="section" id="general-mechanism-for-interpreting-goals-and-assumptions">
<h3>General mechanism for interpreting goals and assumptions<a class="headerlink" href="#general-mechanism-for-interpreting-goals-and-assumptions" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id13">
<h4>Specializing assumptions<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>The <span class="smallcaps">SSReflect</span> tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">move</span><span class="o">/(</span><span class="n">_</span> <span class="n">term1</span> <span class="o">…</span> <span class="n">termn</span><span class="o">).</span>
</pre></div>
</div>
<p>is equivalent to the tactic:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">intro</span> <span class="n">top</span><span class="o">;</span> <span class="nb">generalize</span> <span class="o">(</span><span class="n">top</span> <span class="n">term1</span> <span class="o">…</span> <span class="n">termn</span><span class="o">);</span> <span class="nb">clear</span> <span class="n">top</span><span class="o">.</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">top</span></code> is a fresh name for introducing the top assumption of the
current goal.</p>
</div>
<div class="section" id="id14">
<h4>Interpreting assumptions<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>The general form of an assumption view tactic is:</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="alternative"><span class="alternative-block"><span>move</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>case</span></span></span> <span>/</span> <span class="hole">term</span></span></code></dt>
<dd></dd></dl>

<p>The term , called the <em>view lemma</em> can be:</p>
<ul class="simple">
<li><p>a (term coercible to a) function;</p></li>
<li><p>a (possibly quantified) implication;</p></li>
<li><p>a (possibly quantified) double implication;</p></li>
<li><p>a (possibly quantified) instance of the reflect predicate (see
section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>).</p></li>
</ul>
<p>Let <code class="docutils literal notranslate"><span class="pre">top</span></code> be the top assumption in the goal.</p>
<p>There are three steps in the behavior of an assumption view tactic:</p>
<ul class="simple">
<li><p>It first introduces <code class="docutils literal notranslate"><span class="pre">top</span></code>.</p></li>
<li><p>If the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> is neither a double implication nor an
instance of the reflect predicate, then the tactic automatically
generalises a term of the form: <code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">term1</span> <span class="pre">…</span> <span class="pre">termn</span></code> where the
terms <code class="docutils literal notranslate"><span class="pre">term1</span> <span class="pre">…</span> <span class="pre">termn</span></code> instantiate the possible quantified variables of
<code class="docutils literal notranslate"><span class="pre">term</span></code> , in order for <code class="docutils literal notranslate"><span class="pre">(term</span> <span class="pre">term1</span> <span class="pre">…</span> <span class="pre">termn</span> <span class="pre">top)</span></code> to be well typed.</p></li>
<li><p>If the type of <code class="docutils literal notranslate"><span class="pre">term</span></code> is an equivalence, or an instance of the
reflect predicate, it generalises a term of the form:
<code class="docutils literal notranslate"><span class="pre">(termvh</span> <span class="pre">(term</span> <span class="pre">term1</span> <span class="pre">…</span> <span class="pre">termn</span> <span class="pre">))</span></code> where the term <code class="docutils literal notranslate"><span class="pre">termvh</span></code>
inserted is called an
<em>assumption interpretation view hint</em>.</p></li>
<li><p>It finally clears top.</p></li>
</ul>
<p>For a <code class="docutils literal notranslate"><span class="pre">case/term</span></code> tactic, the generalisation step is replaced by a
case analysis step.</p>
<p><em>View hints</em> are declared by the user (see section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>) and are
stored in the Hint View database. The proof engine automatically
detects from the shape of the top assumption <code class="docutils literal notranslate"><span class="pre">top</span></code> and of the view lemma
<code class="docutils literal notranslate"><span class="pre">term</span></code> provided to the tactic the appropriate view hint in the
database to be inserted.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">term</span></code> is a double implication, then the view hint will be one of
the defined view hints for implication. These hints are by default the
ones present in the file <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code>:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Lemma</span> <span class="nf">iffLR</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span><span class="o">,</span> <span class="o">(</span><span class="n">P</span> <span class="o">&lt;-&gt;</span> <span class="n">Q</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">P</span> <span class="o">-&gt;</span> <span class="n">Q</span><span class="o">.</span>
</pre></div>
</div>
<p>which transforms a double implication into the left-to-right one, or:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Lemma</span> <span class="nf">iffRL</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span><span class="o">,</span> <span class="o">(</span><span class="n">P</span> <span class="o">&lt;-&gt;</span> <span class="n">Q</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Q</span> <span class="o">-&gt;</span> <span class="n">P</span><span class="o">.</span>
</pre></div>
</div>
<p>which produces the converse implication. In both cases, the two
first Prop arguments are implicit.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">term</span></code> is an instance of the <code class="docutils literal notranslate"><span class="pre">reflect</span></code> predicate, then <code class="docutils literal notranslate"><span class="pre">A</span></code> will be one
of the defined view hints for the <code class="docutils literal notranslate"><span class="pre">reflect</span></code> predicate, which are by
default the ones present in the file <code class="docutils literal notranslate"><span class="pre">ssrbool.v</span></code>. These hints are not
only used for choosing the appropriate direction of the translation,
but they also allow complex transformation, involving negations.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkf2" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkf2"><span class="highlight"><span class="kn">Check</span> introN.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">introN
     : <span class="kr">forall</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">b</span> : bool),
       reflect P b -&gt; ~ P -&gt; ~~ b</span></blockquote></div></div></small></span></pre></div><div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkf3" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkf3"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">a</span> <span class="nv">b</span> : bool) (<span class="nv">Ha</span> : a) (<span class="nv">Hb</span> : b) : ~~ (a &amp;&amp; b).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ha</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true b</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_true (~~ (a &amp;&amp; b))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkf4" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkf4"><span class="highlight"><span class="nb">apply</span>/andP.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ha</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true b</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ (a /\ b)</span></div></blockquote></div></div></small></span></pre></div><p>In fact this last script does not
exactly use the hint <code class="docutils literal notranslate"><span class="pre">introN</span></code>, but the more general hint:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkf5" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkf5"><span class="highlight"><span class="kn">Check</span> introNTF.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">introNTF
     : <span class="kr">forall</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">b</span> <span class="nv">c</span> : bool),
       reflect P b -&gt;
       (<span class="kr">if</span> c <span class="kr">then</span> ~ P <span class="kr">else</span> P) -&gt; ~~ b = c</span></blockquote></div><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ha</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true b</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ (a /\ b)</span></div></blockquote></div></div></small></span></pre></div><p>The lemma <code class="docutils literal notranslate"><span class="pre">introN</span></code> is an instantiation of <code class="docutils literal notranslate"><span class="pre">introNF</span></code> using <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">:=</span> <span class="pre">true</span></code>.</p>
</div>
<p>Note that views, being part of <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>, can be used to interpret
assertions too. For example the following script asserts <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;&amp;</span> <span class="pre">b</span></code> but
actually uses its propositional interpretation.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkf6" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkf6"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">a</span> <span class="nv">b</span> : bool) (<span class="nv">pab</span> : b &amp;&amp; a) : b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">pab</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true (b &amp;&amp; a)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_true b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkf7" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkf7"><span class="highlight"><span class="nb">have</span> /andP [pa -&gt;] : (a &amp;&amp; b) <span class="bp">by</span> <span class="nb">rewrite</span> andbC.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">pab</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true (b &amp;&amp; a)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">pa</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_true a</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_true true</span></div></blockquote></div></div></small></span></pre></div></div>
<p>Interpreting goals</p>
<p>A goal interpretation view tactic of the form:</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>apply/</span><span class="hole">term</span></span></code></dt>
<dd></dd></dl>

<p>applied to a goal <code class="docutils literal notranslate"><span class="pre">top</span></code> is interpreted in the following way:</p>
<ul class="simple">
<li><p>If the type of <code class="docutils literal notranslate"><span class="pre">term</span></code> is not an instance of the <code class="docutils literal notranslate"><span class="pre">reflect</span></code> predicate,
nor an equivalence, then the term <code class="docutils literal notranslate"><span class="pre">term</span></code> is applied to the current
goal <code class="docutils literal notranslate"><span class="pre">top</span></code>, possibly inserting implicit arguments.</p></li>
<li><p>If the type of <code class="docutils literal notranslate"><span class="pre">term</span></code> is an instance of the reflect predicate or an
equivalence, then a <em>goal interpretation view hint</em> can possibly be
inserted, which corresponds to the application of a term
<code class="docutils literal notranslate"><span class="pre">(termvh</span> <span class="pre">(term</span> <span class="pre">_</span> <span class="pre">…</span> <span class="pre">_))</span></code> to the current goal, possibly inserting implicit arguments.</p></li>
</ul>
<p>Like assumption interpretation view hints, goal interpretation ones
are user-defined lemmas stored (see section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>) in the <code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">View</span></code>
database bridging the possible gap between the type of <code class="docutils literal notranslate"><span class="pre">term</span></code> and the
type of the goal.</p>
</div>
</div>
<div class="section" id="interpreting-equivalences">
<h3>Interpreting equivalences<a class="headerlink" href="#interpreting-equivalences" title="Permalink to this headline">¶</a></h3>
<p>Equivalent boolean propositions are simply <em>equal</em> boolean terms. A
special construction helps the user to prove boolean equalities by
considering them as logical double implications (between their coerced
versions), while performing at the same time logical operations on
both sides.</p>
<p>The syntax of double views is:</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>apply/</span><span class="hole">term</span><span>/</span><span class="hole">term</span></span></code></dt>
<dd></dd></dl>

<p>The first term is the view lemma applied to the left hand side of the
equality, while the second term is the one applied to the right hand side.</p>
<p>In this context, the identity view can be used when no view has to be applied:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Lemma</span> <span class="nf">idP</span> <span class="o">:</span> <span class="n">reflect</span> <span class="n">b1</span> <span class="n">b1</span><span class="o">.</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkf8" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkf8"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">b1</span> <span class="nv">b2</span> <span class="nv">b3</span> : bool) : ~~ (b1 || b2) = b3.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b1, b2, b3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~~ (b1 || b2) = b3</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkf9" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkf9"><span class="highlight"><span class="nb">apply</span>/idP/idP.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b1, b2, b3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~~ (b1 || b2) -&gt; b3</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chkfa" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b1, b2, b3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chkfa"><hr></label><div class="goal-conclusion"><span class="highlight">b3 -&gt; ~~ (b1 || b2)</span></div></blockquote></div></div></div></small></span></pre></div><p>The same goal can be decomposed in several ways, and the user may
choose the most convenient interpretation.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkfb" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkfb"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">b1</span> <span class="nv">b2</span> <span class="nv">b3</span> : bool) : ~~ (b1 || b2) = b3.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b1, b2, b3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~~ (b1 || b2) = b3</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkfc" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkfc"><span class="highlight"><span class="nb">apply</span>/norP/idP.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b1, b2, b3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~~ b1 /\ ~~ b2 -&gt; b3</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="ssreflect-proof-language-rst-chkfd" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b1, b2, b3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="ssreflect-proof-language-rst-chkfd"><hr></label><div class="goal-conclusion"><span class="highlight">b3 -&gt; ~~ b1 /\ ~~ b2</span></div></blockquote></div></div></div></small></span></pre></div></div>
</div>
<div class="section" id="declaring-new-hint-views">
<span id="declaring-new-hints-ssr"></span><h3>Declaring new Hint Views<a class="headerlink" href="#declaring-new-hint-views" title="Permalink to this headline">¶</a></h3>
<dl class="coq cmd">
<dt id="coq:cmd.hint-view-for-move">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>View</span> <span>for</span> <span>move</span> <span>/</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat">| <span class="hole">num</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.hint-view-for-move" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmd.hint-view-for-apply">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>View</span> <span>for</span> <span>apply</span> <span>/</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat">| <span class="hole">num</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.hint-view-for-apply" title="Permalink to this definition">¶</a></dt>
<dd><p>This command can be used to extend the database of hints for the view
mechanism.</p>
<p>As library <code class="docutils literal notranslate"><span class="pre">ssrbool.v</span></code> already declares a
corpus of hints, this feature is probably useful only for users who
define their own logical connectives.</p>
<p>The <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is the name of the lemma to be
declared as a hint. If <code class="docutils literal notranslate"><span class="pre">move</span></code> is used as
tactic, the hint is declared for assumption interpretation tactics,
<code class="docutils literal notranslate"><span class="pre">apply</span></code> declares hints for goal interpretations. Goal interpretation
view hints are declared for both simple views and left hand side
views. The optional natural number is the number of implicit
arguments to be considered for the declared hint view lemma.</p>
<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>View</span> <span>for</span> <span>apply//</span><span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat">| <span class="hole">num</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This variant with a double slash <code class="docutils literal notranslate"><span class="pre">//</span></code>, declares hint views for right
hand sides of double views.</p>
<p>See the files <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code> and <code class="docutils literal notranslate"><span class="pre">ssrbool.v</span></code> for examples.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="multiple-views">
<h3>Multiple views<a class="headerlink" href="#multiple-views" title="Permalink to this headline">¶</a></h3>
<p>The hypotheses and the goal can be interpreted by applying multiple views
in sequence. Both move and apply can be followed by an arbitrary
number of <code class="docutils literal notranslate"><span class="pre">/term</span></code>. The main difference between the following two
tactics</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">apply</span><span class="o">/</span><span class="n">v1</span><span class="o">/</span><span class="n">v2</span><span class="o">/</span><span class="n">v3</span><span class="o">.</span>
<span class="nb">apply</span><span class="o">/</span><span class="n">v1</span><span class="o">;</span> <span class="nb">apply</span><span class="o">/</span><span class="n">v2</span><span class="o">;</span> <span class="nb">apply</span><span class="o">/</span><span class="n">v3</span><span class="o">.</span>
</pre></div>
</div>
<p>is that the former applies all the views to the principal goal.
Applying a view with hypotheses generates new goals, and the second
line would apply the view <code class="docutils literal notranslate"><span class="pre">v2</span></code> to all the goals generated by <code class="docutils literal notranslate"><span class="pre">apply/v1</span></code>.</p>
<p>Note that the NO-OP intro pattern <code class="docutils literal notranslate"><span class="pre">-</span></code> can be used to separate two views,
making the two following examples equivalent:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="nb">move</span><span class="o">=&gt;</span> <span class="o">/</span><span class="n">v1</span><span class="o">;</span> <span class="nb">move</span><span class="o">=&gt;</span> <span class="o">/</span><span class="n">v2</span><span class="o">.</span>
<span class="nb">move</span><span class="o">=&gt;</span> <span class="o">/</span><span class="n">v1</span> <span class="o">-</span> <span class="o">/</span><span class="n">v2</span><span class="o">.</span>
</pre></div>
</div>
<p>The tactic <code class="docutils literal notranslate"><span class="pre">move</span></code> can be used together with the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical to
pass a given hypothesis to a lemma.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">P2Q</span> : P -&gt; Q.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">Q2R</span> : Q -&gt; R.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkfe" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkfe"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test</span> (<span class="nv">p</span> : P) : <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P2Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P -&gt; Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q2R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q -&gt; R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chkff" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chkff"><span class="highlight"><span class="nb">move</span>/P2Q/Q2R <span class="kr">in</span> p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P2Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P -&gt; Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q2R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q -&gt; R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small></span></pre></div></div>
<p>If the list of views is of length two, <code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Views</span></code> for interpreting
equivalences are indeed taken into account, otherwise only single
<code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Views</span></code> are used.</p>
</div>
</div>
<div class="section" id="ssr-searching-tool">
<h2><span class="smallcaps">SSReflect</span> searching tool<a class="headerlink" href="#ssr-searching-tool" title="Permalink to this headline">¶</a></h2>
<dl class="coq cmd">
<dt id="coq:cmd.search-ssreflect">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Search</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">pattern</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span>-</span></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="hole">pattern</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span>%</span> <span class="hole">ident</span></span><span class="notation-sup">?</span></span></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span>-</span></span><span class="notation-sup">?</span></span> <span class="hole">qualid</span></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.search-ssreflect" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the <span class="smallcaps">SSReflect</span> extension of the Search command. <code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code> is the
name of an open module. This command returns the list of lemmas:</p>
<ul class="simple">
<li><p>whose <em>conclusion</em> contains a subterm matching the optional first
pattern. A <code class="docutils literal notranslate"><span class="pre">-</span></code> reverses the test, producing the list of lemmas whose
conclusion does not contain any subterm matching the pattern;</p></li>
<li><p>whose name contains the given string. A <code class="docutils literal notranslate"><span class="pre">-</span></code> prefix reverses the test,
producing the list of lemmas whose name does not contain the string. A
string that contains symbols or is followed by a scope key, is
interpreted as the constant whose notation involves that string (e.g.,
<code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">+</span></span></code> for <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">addn</span></span></code>), if this is unambiguous; otherwise the diagnostic
includes the output of the <a class="reference internal" href="vernacular-commands.html#coq:cmd.locate" title="Locate"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Locate</span></code></a> vernacular command.</p></li>
<li><p>whose statement, including assumptions and types, contains a subterm
matching the next patterns. If a pattern is prefixed by <code class="docutils literal notranslate"><span class="pre">-</span></code>, the test is
reversed;</p></li>
<li><p>contained in the given list of modules, except the ones in the
modules prefixed by a <code class="docutils literal notranslate"><span class="pre">-</span></code>.</p></li>
</ul>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li><p>As for regular terms, patterns can feature scope indications. For
instance, the command: <code class="docutils literal notranslate"><span class="pre">Search</span> <span class="pre">_</span> <span class="pre">(_</span> <span class="pre">+</span> <span class="pre">_)%N.</span></code> lists all the lemmas whose
statement (conclusion or hypotheses) involves an application of the
binary operation denoted by the infix <code class="docutils literal notranslate"><span class="pre">+</span></code> symbol in the <code class="docutils literal notranslate"><span class="pre">N</span></code> scope (which is
<span class="smallcaps">SSReflect</span> scope for natural numbers).</p></li>
<li><p>Patterns with holes should be surrounded by parentheses.</p></li>
<li><p>Search always volunteers the expansion of the notation, avoiding the
need to execute Locate independently. Moreover, a string fragment
looks for any notation that contains fragment as a substring. If the
<code class="docutils literal notranslate"><span class="pre">ssrbool.v</span></code> library is imported, the command: <code class="docutils literal notranslate"><span class="pre">Search</span> <span class="pre">&quot;~~&quot;.</span></code> answers :</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="ssreflect-proof-language-rst-chk100" style="display: none" type="checkbox"><label class="coq-input" for="ssreflect-proof-language-rst-chk100"><span class="highlight"><span class="kn">Search</span> <span class="s2">&quot;~~&quot;</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight"><span class="s2">&quot;~~&quot;</span> <span class="kr">is</span> part of notation (<span class="s2">&quot;~~ _&quot;</span>)</span></blockquote><blockquote class="coq-response"><span class="highlight">In bool_scope, (<span class="s2">&quot;~~ b&quot;</span>) denotes negb b</span></blockquote><blockquote class="coq-response"><span class="highlight">Listing <span class="kp">only</span> lemmas <span class="kr">with</span> conclusion matching (~~ ?b)</span></blockquote><blockquote class="coq-response"><span class="highlight">negbT: <span class="kr">forall</span> <span class="nv">b</span> : bool, b = false -&gt; ~~ b
</span></blockquote><blockquote class="coq-response"><span class="highlight">contra: <span class="kr">forall</span> <span class="nv">c</span> <span class="nv">b</span> : bool, (c -&gt; b) -&gt; ~~ b -&gt; ~~ c
</span></blockquote><blockquote class="coq-response"><span class="highlight">contraNN: <span class="kr">forall</span> <span class="nv">c</span> <span class="nv">b</span> : bool, (c -&gt; b) -&gt; ~~ b -&gt; ~~ c
</span></blockquote><blockquote class="coq-response"><span class="highlight">contraL: <span class="kr">forall</span> <span class="nv">c</span> <span class="nv">b</span> : bool, (c -&gt; ~~ b) -&gt; b -&gt; ~~ c
</span></blockquote><blockquote class="coq-response"><span class="highlight">contraTN: <span class="kr">forall</span> <span class="nv">c</span> <span class="nv">b</span> : bool, (c -&gt; ~~ b) -&gt; b -&gt; ~~ c
</span></blockquote><blockquote class="coq-response"><span class="highlight">contraFN:
  <span class="kr">forall</span> <span class="nv">c</span> <span class="nv">b</span> : bool, (c -&gt; b) -&gt; b = false -&gt; ~~ c
</span></blockquote><blockquote class="coq-response"><span class="highlight">introN:
  <span class="kr">forall</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">b</span> : bool),
  reflect P b -&gt; ~ P -&gt; ~~ b
</span></blockquote></div></div></small></span></pre></div></li>
<li><p>A diagnostic is issued if there are different matching notations; it
is an error if all matches are partial.</p></li>
<li><p>Similarly, a diagnostic warns about multiple interpretations, and
signals an error if there is no default one.</p></li>
<li><p>The command <code class="docutils literal notranslate"><span class="pre">Search</span> <span class="pre">in</span> <span class="pre">M.</span></code> is a way of obtaining the complete
signature of the module <code class="docutils literal notranslate"><span class="pre">M</span></code>.</p></li>
<li><p>Strings and pattern indications can be interleaved, but the first
indication has a special status if it is a pattern, and only filters
the conclusion of lemmas:</p>
<ul class="simple">
<li><p>The command : <code class="docutils literal notranslate"><span class="pre">Search</span> <span class="pre">(_</span> <span class="pre">=1</span> <span class="pre">_)</span> <span class="pre">&quot;bij&quot;.</span></code> lists all the lemmas whose
conclusion features a <code class="docutils literal notranslate"><span class="pre">=1</span></code> and whose name contains the string <code class="docutils literal notranslate"><span class="pre">bij</span></code>.</p></li>
<li><p>The command : <code class="docutils literal notranslate"><span class="pre">Search</span> <span class="pre">&quot;bij&quot;</span> <span class="pre">(_</span> <span class="pre">=1</span> <span class="pre">_).</span></code> lists all the lemmas whose
statement, including hypotheses, features a <code class="docutils literal notranslate"><span class="pre">=1</span></code> and whose name
contains the string <code class="docutils literal notranslate"><span class="pre">bij</span></code>.</p></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="synopsis-and-index">
<h2>Synopsis and Index<a class="headerlink" href="#synopsis-and-index" title="Permalink to this headline">¶</a></h2>
<div class="section" id="parameters">
<h3>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h3>
<p><span class="smallcaps">SSReflect</span> tactics</p>
<dl class="coq prodn">
<dt id="grammar-token-d_tactic">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">d_tactic</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span>elim</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>case</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>congr</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>apply</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>exact</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>move</span></span></span></span></code><a class="headerlink" href="#grammar-token-d_tactic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Notation scope</p>
<dl class="coq prodn">
<dt id="grammar-token-key">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">::=</span> </code><span class="notation"><span class="hole">ident</span></span></code><a class="headerlink" href="#grammar-token-key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Module name</p>
<dl class="coq prodn">
<dt id="grammar-token-modname">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">modname</span> <span class="pre">::=</span> </code><span class="notation"><span class="hole">qualid</span></span></code><a class="headerlink" href="#grammar-token-modname" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Natural number</p>
<dl class="coq prodn">
<dt id="grammar-token-natural">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">natural</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span class="hole">num</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="hole">ident</span></span></span></span></code><a class="headerlink" href="#grammar-token-natural" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>where <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is an Ltac variable denoting a standard <span class="smallcaps">Coq</span> numeral
(should not be the name of a tactic which can be followed by a
bracket <code class="docutils literal notranslate"><span class="pre">[</span></code>, like <code class="docutils literal notranslate"><span class="pre">do</span></code>, <code class="docutils literal notranslate"><span class="pre">have</span></code>,…)</p>
</div>
<div class="section" id="items-and-switches">
<h3>Items and switches<a class="headerlink" href="#items-and-switches" title="Permalink to this headline">¶</a></h3>
<dl class="coq prodn">
<dt id="grammar-token-ssr_binder">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">ssr_binder</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span class="hole">ident</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>(</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <span class="hole">term</span></span><span class="notation-sup">?</span></span> <span>)</span></span></span></span></code><a class="headerlink" href="#grammar-token-ssr_binder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>binder see <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>.</p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">clear_switch</span> <span class="pre">::=</span> </code><span class="notation"><span class="curlies">{ <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> }</span></span></code></dt>
<dd></dd></dl>

<p>clear switch see <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a></p>
<dl class="coq prodn">
<dt id="grammar-token-c_pattern">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">c_pattern</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span class="hole">term</span> <span>in</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="hole">term</span> <span>as</span></span></span></span><span class="notation-sup">?</span></span> <span class="hole">ident</span> <span>in</span> <span class="hole">term</span></span></code><a class="headerlink" href="#grammar-token-c_pattern" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>context pattern see <a class="reference internal" href="#contextual-patterns-ssr"><span class="std std-ref">Contextual patterns</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">d_item</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span class="hole">term</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>(</span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a> <span>)</span></span></span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>discharge item see <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a></p>
<dl class="coq prodn">
<dt id="grammar-token-gen_item">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">gen_item</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><span>&#64;</span></span><span class="notation-sup">?</span></span> <span class="hole">ident</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>(</span> <span class="hole">ident</span> <span>)</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>(</span> <span class="repeat-wrapper"><span class="repeat"><span>&#64;</span></span><span class="notation-sup">?</span></span> <span class="hole">ident</span> <span>:=</span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a> <span>)</span></span></span></span></code><a class="headerlink" href="#grammar-token-gen_item" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>generalization item see <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">i_pattern</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span class="hole">ident</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>&gt;</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>_</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>?</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>*</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>+</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><span>-&gt;</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>&lt;-</span></span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>[</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">?</span><span class="notation-sub">|</span></span> <span>]</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>-</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>[:</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>]</span></span></span></span></code></dt>
<dd></dd></dl>

<p>intro pattern <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">i_item</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-i_view"><span class="hole">i_view</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-i_block"><span class="hole">i_block</span></a></span></span></span></code></dt>
<dd></dd></dl>

<p>view <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">i_view</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>{</span><span>}</span></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><span>/</span><span class="hole">term</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>/ltac:(</span> <span class="hole">tactic</span> <span>)</span></span></span></span></code></dt>
<dd></dd></dl>

<p>intro block <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">i_block</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span>[^</span> <span class="hole">ident</span> <span>]</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>[^~</span> <span class="alternative"><span class="alternative-block"><span class="hole">ident</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="hole">num</span></span></span> <span>]</span></span></span></span></code></dt>
<dd></dd></dl>

<p>intro item  see <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a></p>
<dl class="coq prodn">
<dt id="grammar-token-int_mult">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">int_mult</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-mult_mark"><span class="hole">mult_mark</span></a></span></code><a class="headerlink" href="#grammar-token-int_mult" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>multiplier  see <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">occ_switch</span> <span class="pre">::=</span> </code><span class="notation"><span class="curlies">{ <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span>+</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>-</span></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">*</span></span> }</span></span></code></dt>
<dd></dd></dl>

<p>occur. switch see <a class="reference internal" href="#occurrence-selection-ssr"><span class="std std-ref">Occurrence selection</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">mult</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-mult_mark"><span class="hole">mult_mark</span></a></span></code></dt>
<dd></dd></dl>

<p>multiplier see <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a></p>
<dl class="coq prodn">
<dt id="grammar-token-mult_mark">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">mult_mark</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span>?</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>!</span></span></span></span></code><a class="headerlink" href="#grammar-token-mult_mark" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>multiplier mark see <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">r_item</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><span>/</span></span><span class="notation-sup">?</span></span> <span class="hole">term</span></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span></span></span></code></dt>
<dd></dd></dl>

<p>rewrite item see <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">r_prefix</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>-</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-int_mult"><span class="hole">int_mult</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>[</span> <a class="reference internal" href="#grammar-token-r_pattern"><span class="hole">r_pattern</span></a> <span>]</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>rewrite prefix see <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">r_pattern</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span class="hole">term</span></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span>in</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span> <span>in</span></span><span class="notation-sup">?</span></span> <span class="hole">term</span></span></span></span></code></dt>
<dd></dd></dl>

<p>rewrite pattern see <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a></p>
<dl class="coq prodn">
<dt id="grammar-token-r_step">
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">r_step</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_prefix"><span class="hole">r_prefix</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-r_item"><span class="hole">r_item</span></a></span></code><a class="headerlink" href="#grammar-token-r_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>rewrite step see <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">s_item</span> <span class="pre">::=</span> </code><span class="notation"><span class="alternative"><span class="alternative-block"><span>/=</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>//</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>//=</span></span></span></span></code></dt>
<dd></dd></dl>

<p>simplify switch see <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a></p>
</div>
<div class="section" id="tactics">
<h3>Tactics<a class="headerlink" href="#tactics" title="Permalink to this headline">¶</a></h3>
<p><em>Note</em>: <code class="docutils literal notranslate"><span class="pre">without</span> <span class="pre">loss</span></code> and <code class="docutils literal notranslate"><span class="pre">suffices</span></code> are synonyms for <code class="docutils literal notranslate"><span class="pre">wlog</span></code> and <code class="docutils literal notranslate"><span class="pre">suff</span></code>
respectively.</p>
<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>move</span></span></code></dt>
<dd><p><a class="reference internal" href="ltac.html#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a> or <a class="reference internal" href="tactics.html#coq:tacn.hnf" title="hnf"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">hnf</span></code></a> (see  <a class="reference internal" href="#bookkeeping-ssr"><span class="std std-ref">Bookkeeping</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>apply</span></span></code></dt>
<dt>
<code class="sig-name descname"><span class="notation"><span>exact</span></span></code></dt>
<dd><p>application (see <a class="reference internal" href="#the-defective-tactics-ssr"><span class="std std-ref">The defective tactics</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>abstract</span></span></code></dt>
<dd><p>see <a class="reference internal" href="#abstract-ssr"><span class="std std-ref">The abstract tactic</span></a> and <a class="reference internal" href="#generating-let-ssr"><span class="std std-ref">Generating let in context entries with have</span></a></p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>elim</span></span></code></dt>
<dd><p>induction (see <a class="reference internal" href="#the-defective-tactics-ssr"><span class="std std-ref">The defective tactics</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>case</span></span></code></dt>
<dd><p>case analysis (see <a class="reference internal" href="#the-defective-tactics-ssr"><span class="std std-ref">The defective tactics</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>rewrite</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_step"><span class="hole">r_step</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>rewrite (see <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>under</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_prefix"><span class="hole">r_prefix</span></a></span><span class="notation-sup">?</span></span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>=&gt;</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>do</span> <span class="alternative"><span class="alternative-block"><span class="hole">tactic</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">tactic</span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span>]</span></span></span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>under (see <a class="reference internal" href="#under-ssr"><span class="std std-ref">Rewriting under binders</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>over</span></span></code></dt>
<dd><p>over (see <a class="reference internal" href="#over-ssr"><span class="std std-ref">The over tactic</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>have</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <span class="hole">term</span></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="hole">term</span></span></code></dt>
<dt>
<code class="sig-name descname"><span class="notation"><span>have</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span></span></span></span><span class="notation-sup">?</span></span> <span>:</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dt>
<code class="sig-name descname"><span class="notation"><span>have</span> <span>suff</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <span class="hole">term</span></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="hole">term</span></span></code></dt>
<dt>
<code class="sig-name descname"><span class="notation"><span>have</span> <span>suff</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dt>
<code class="sig-name descname"><span class="notation"><span>gen</span> <span>have</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span> <span>,</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-gen_item"><span class="hole">gen_item</span></a></span><span class="notation-sup">+</span></span> <span>/</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dt id="coq:tacn.generally-have">
<code class="sig-name descname"><span class="notation"><span>generally</span> <span>have</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span> <span>,</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-gen_item"><span class="hole">gen_item</span></a></span><span class="notation-sup">+</span></span> <span>/</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.generally-have" title="Permalink to this definition">¶</a></dt>
<dd><p>forward chaining (see <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>wlog</span> <span class="repeat-wrapper"><span class="repeat"><span>suff</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-gen_item"><span class="hole">gen_item</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span></span></span><span class="notation-sup">*</span></span> <span>/</span> <span class="hole">term</span></span></code></dt>
<dd><p>specializing (see <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.suff">
<code class="sig-name descname"><span class="notation"><span>suff</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.suff" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacn.suffices">
<code class="sig-name descname"><span class="notation"><span>suffices</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.suffices" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="sig-name descname"><span class="notation"><span>suff</span> <span class="repeat-wrapper"><span class="repeat"><span>have</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dt>
<code class="sig-name descname"><span class="notation"><span>suffices</span> <span class="repeat-wrapper"><span class="repeat"><span>have</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>backchaining (see <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>pose</span> <span class="hole">ident</span> <span>:=</span> <span class="hole">term</span></span></code></dt>
<dd><p>local definition (see <a class="reference internal" href="#definitions-ssr"><span class="std std-ref">Definitions</span></a>)</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>pose</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span> <span>:=</span> <span class="hole">term</span></span></code></dt>
<dd><p>local function definition</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>pose</span> <span>fix</span> <span class="hole">fix_body</span></span></code></dt>
<dd><p>local fix definition</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>pose</span> <span>cofix</span> <span class="hole">fix_body</span></span></code></dt>
<dd><p>local cofix definition</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>set</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <span class="hole">term</span></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><span class="hole">term</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>(</span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a><span>)</span></span></span></span></code></dt>
<dd><p>abbreviation (see <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>unlock</span> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_prefix"><span class="hole">r_prefix</span></a></span><span class="notation-sup">?</span></span> <span class="hole">ident</span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>unlock (see <a class="reference internal" href="#locking-ssr"><span class="std std-ref">Locking, unlocking</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt>
<code class="sig-name descname"><span class="notation"><span>congr</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">?</span></span> <span class="hole">term</span></span></code></dt>
<dd><p>congruence (see <a class="reference internal" href="#congruence-ssr"><span class="std std-ref">Congruence</span></a>)</p>
</dd></dl>

</div>
<div class="section" id="tacticals">
<h3>Tacticals<a class="headerlink" href="#tacticals" title="Permalink to this headline">¶</a></h3>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">+=</span> </code><span class="notation"><a class="reference internal" href="#grammar-token-d_tactic"><span class="hole">d_tactic</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>discharge <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">+=</span> </code><span class="notation"><span class="hole">tactic</span> <span>=&gt;</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<p>introduction see <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">+=</span> </code><span class="notation"><span class="hole">tactic</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-gen_item"><span class="hole">gen_item</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span></span></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><span>*</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>localization see <a class="reference internal" href="#localization-ssr"><span class="std std-ref">Localization</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">+=</span> </code><span class="notation"><span>do</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-mult"><span class="hole">mult</span></a></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><span class="hole">tactic</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">tactic</span></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span>]</span></span></span></span></code></dt>
<dd></dd></dl>

<p>iteration  see <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">+=</span> </code><span class="notation"><span class="hole">tactic</span> <span>;</span> <span class="alternative"><span class="alternative-block"><span>first</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>last</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><span class="hole">tactic</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">tactic</span></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span>]</span></span></span></span></code></dt>
<dd></dd></dl>

<p>selector  see <a class="reference internal" href="#selectors-ssr"><span class="std std-ref">Selectors</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">+=</span> </code><span class="notation"><span class="hole">tactic</span> <span>;</span> <span class="alternative"><span class="alternative-block"><span>first</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>last</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>rotation see <a class="reference internal" href="#selectors-ssr"><span class="std std-ref">Selectors</span></a></p>
<dl class="coq prodn">
<dt>
<code class="sig-name descname"><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">+=</span> </code><span class="notation"><span>by</span> <span class="alternative"><span class="alternative-block"><span class="hole">tactic</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">tactic</span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span>]</span></span></span></span></code></dt>
<dd></dd></dl>

<p>closing see <a class="reference internal" href="#terminators-ssr"><span class="std std-ref">Terminators</span></a></p>
</div>
<div class="section" id="commands">
<h3>Commands<a class="headerlink" href="#commands" title="Permalink to this headline">¶</a></h3>
<dl class="coq cmd">
<dt id="coq:cmd.hint-view-for">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>View</span> <span>for</span> <span class="alternative"><span class="alternative-block"><span>move</span></span><span class="alternative-separator">​</span><span class="alternative-block"><span>apply</span></span></span> <span>/</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat">| <span class="hole">num</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.hint-view-for" title="Permalink to this definition">¶</a></dt>
<dd><p>view hint declaration (see <a class="reference internal" href="#declaring-new-hints-ssr"><span class="std std-ref">Declaring new Hint Views</span></a>)</p>
</dd></dl>

<dl class="coq cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Hint</span> <span>View</span> <span>for</span> <span>apply</span> <span>//</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">num</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>right hand side double , view hint declaration (see <a class="reference internal" href="#declaring-new-hints-ssr"><span class="std std-ref">Declaring new Hint Views</span></a>)</p>
</dd></dl>

<dl class="coq cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Prenex</span> <span>Implicits</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>prenex implicits declaration (see <a class="reference internal" href="#parametric-polymorphism-ssr"><span class="std std-ref">Parametric polymorphism</span></a>)</p>
</dd></dl>

</div>
<div class="section" id="settings">
<h3>Settings<a class="headerlink" href="#settings" title="Permalink to this headline">¶</a></h3>
<dl class="coq flag">
<dt id="coq:flag.debug-ssreflect">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Debug</span> <span>Ssreflect</span></span></code><a class="headerlink" href="#coq:flag.debug-ssreflect" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Developer only.</em> Print debug information on reflect.</p>
</dd></dl>

<dl class="coq flag">
<dt id="coq:flag.debug-ssrmatching">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Debug</span> <span>SsrMatching</span></span></code><a class="headerlink" href="#coq:flag.debug-ssrmatching" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Developer only.</em> Print debug information on SSR matching.</p>
</dd></dl>

<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="id15"><span class="brackets"><a class="fn-backref" href="#id1">11</a></span></dt>
<dd><p>Unfortunately, even after a call to the Set Printing All command,
some occurrences are still not displayed to the user, essentially the
ones possibly hidden in the predicate of a dependent match structure.</p>
</dd>
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id2">12</a></span></dt>
<dd><p>Thus scripts that depend on bound variable names, e.g., via intros
or with, are inherently fragile.</p>
</dd>
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id3">13</a></span></dt>
<dd><p>The name <code class="docutils literal notranslate"><span class="pre">subnK</span></code> reads as “right cancellation rule for nat
subtraction”.</p>
</dd>
<dt class="label" id="id18"><span class="brackets"><a class="fn-backref" href="#id4">14</a></span></dt>
<dd><p>Also, a slightly different variant may be used for the first <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>
of case and elim; see section <a class="reference internal" href="#type-families-ssr"><span class="std std-ref">Type families</span></a>.</p>
</dd>
<dt class="label" id="id19"><span class="brackets"><a class="fn-backref" href="#id5">15</a></span></dt>
<dd><p>Except /= does not expand the local definitions created by the
<span class="smallcaps">SSReflect</span> in tactical.</p>
</dd>
<dt class="label" id="id20"><span class="brackets"><a class="fn-backref" href="#id8">16</a></span></dt>
<dd><p><span class="smallcaps">SSReflect</span> reserves all identifiers of the form “_x_”, which is
used for such generated names.</p>
</dd>
<dt class="label" id="id21"><span class="brackets"><a class="fn-backref" href="#id9">17</a></span></dt>
<dd><p>More precisely, it should have a quantified inductive type with a
assumptions and m − a constructors.</p>
</dd>
<dt class="label" id="id22"><span class="brackets"><a class="fn-backref" href="#id12">18</a></span></dt>
<dd><p>This is an implementation feature: there is no such obstruction
in the metatheory</p>
</dd>
<dt class="label" id="id23"><span class="brackets"><a class="fn-backref" href="#id10">19</a></span></dt>
<dd><p>The current state of the proof shall be displayed by the Show
Proof command of <span class="smallcaps">Coq</span> proof mode.</p>
</dd>
<dt class="label" id="id24"><span class="brackets">20</span><span class="fn-backref">(<a href="#id6">1</a>,<a href="#id7">2</a>,<a href="#id11">3</a>)</span></dt>
<dd><p>A simple proof context entry is a naked identifier (i.e. not between
parentheses) designating a context entry that is not a section variable.</p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../user-extensions/syntax-extensions.html" class="btn btn-neutral float-right" title="Syntax extensions and interpretation scopes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="detailed-tactic-examples.html" class="btn btn-neutral float-left" title="Detailed examples of tactics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>