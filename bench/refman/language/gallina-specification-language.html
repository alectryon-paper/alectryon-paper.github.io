

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Gallina specification language &mdash; Coq 8.10.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/notations.js"></script>
        <script src="../_static/alectryon.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
  <link rel="stylesheet" href="../_static/alectryon.css" type="text/css" />
  <link rel="stylesheet" href="../_static/tango_subtle.css" type="text/css" />
  <link rel="stylesheet" href="../_static/tango_subtle.min.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Extensions of Gallina" href="gallina-extensions.html" />
    <link rel="prev" title="Recent changes" href="../changes.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.10.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Indexes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">Preamble</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction and Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">Early history of Coq</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../history.html#historical-roots">Historical roots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-1-to-5">Versions 1 to 5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-1">Version 1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-2">Version 2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-3">Version 3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-4">Version 4</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-5">Version 5</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-6">Versions 6</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-1">Version 6.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-2">Version 6.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-3">Version 6.3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-7">Versions 7</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-0-and-7-1">Details of changes in 7.0 and 7.1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#main-novelties">Main novelties</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-2">Details of changes in 7.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-3">Details of changes in 7.3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#changes-in-7-3-1">Changes in 7.3.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-4">Details of changes in 7.4</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changes.html">Recent changes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-10">Version 8.10</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#other-changes-in-8-10-beta1">Other changes in 8.10+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-beta2">Changes in 8.10+beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-beta3">Changes in 8.10+beta3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-0">Changes in 8.10.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-1">Changes in 8.10.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-2">Changes in 8.10.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-9">Version 8.9</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id147">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-9-beta1">Details of changes in 8.9+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-8-0">Changes in 8.8.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-8-1">Changes in 8.8.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-8">Version 8.8</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id149">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-beta1">Details of changes in 8.8+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-0">Details of changes in 8.8.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-1">Details of changes in 8.8.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-2">Details of changes in 8.8.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-7">Version 8.7</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id150">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#potential-compatibility-issues">Potential compatibility issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta1">Details of changes in 8.7+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta2">Details of changes in 8.7+beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-0">Details of changes in 8.7.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-1">Details of changes in 8.7.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-2">Details of changes in 8.7.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-6">Version 8.6</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id151">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#potential-sources-of-incompatibilities">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6beta1">Details of changes in 8.6beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6">Details of changes in 8.6</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6-1">Details of changes in 8.6.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-5">Version 8.5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id152">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id153">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta1">Details of changes in 8.5beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta2">Details of changes in 8.5beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta3">Details of changes in 8.5beta3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5">Details of changes in 8.5</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl1">Details of changes in 8.5pl1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl2">Details of changes in 8.5pl2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl3">Details of changes in 8.5pl3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-4">Version 8.4</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id154">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id156">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta">Details of changes in 8.4beta</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta2">Details of changes in 8.4beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4">Details of changes in 8.4</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-3">Version 8.3</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id157">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-2">Version 8.2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id158">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id159">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-1">Version 8.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id160">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1beta">Details of changes in 8.1beta</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1gamma">Details of changes in 8.1gamma</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1">Details of changes in 8.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-0">Version 8.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id161">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-old-syntax">Details of changes in 8.0beta old syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-new-syntax">Details of changes in 8.0beta new syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0">Details of changes in 8.0</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">The language</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">The Gallina specification language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#about-the-grammars-in-the-manual">About the grammars in the manual</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lexical-conventions">Lexical conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#terms">Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#syntax-of-terms">Syntax of terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#types">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#qualified-identifiers-and-simple-identifiers">Qualified identifiers and simple identifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#numerals">Numerals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#binders">Binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="#abstractions">Abstractions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#products">Products</a></li>
<li class="toctree-l3"><a class="reference internal" href="#applications">Applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-cast">Type cast</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inferable-subterms">Inferable subterms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#let-in-definitions">Let-in definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definition-by-case-analysis">Definition by case analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#recursive-functions">Recursive functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-vernacular">The Vernacular</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#assumptions">Assumptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inductive-definitions">Inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple-inductive-types">Simple inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simple-annotated-inductive-types">Simple annotated inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parameterized-inductive-types">Parameterized inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variants">Variants</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mutually-defined-inductive-types">Mutually defined inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#co-inductive-types">Co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#definition-of-recursive-functions">Definition of recursive functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#definition-of-functions-by-recursion-over-inductive-objects">Definition of functions by recursion over inductive objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#definitions-of-recursive-objects-in-co-inductive-types">Definitions of recursive objects in co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#assertions-and-proofs">Assertions and proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#attributes">Attributes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a><ul>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#record-types">Record types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#primitive-projections">Primitive Projections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#primitive-record-types">Primitive Record Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#compatibility-projections-and-match">Compatibility Projections and <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">match</span></span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#variants-and-extensions-of-match">Variants and extensions of <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">match</span></span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#multiple-and-nested-pattern-matching">Multiple and nested pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#pattern-matching-on-boolean-values-the-if-expression">Pattern-matching on boolean values: the if expression</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#irrefutable-patterns-the-destructuring-let-variants">Irrefutable patterns: the destructuring let variants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#first-destructuring-let-syntax">First destructuring let syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#second-destructuring-let-syntax">Second destructuring let syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#controlling-pretty-printing-of-match-expressions">Controlling pretty-printing of match expressions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#printing-nested-patterns">Printing nested patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#factorization-of-clauses-with-same-right-hand-side">Factorization of clauses with same right-hand side</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#use-of-a-default-clause">Use of a default clause</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#printing-of-wildcard-patterns">Printing of wildcard patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#printing-of-the-elimination-predicate">Printing of the elimination predicate</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#printing-matching-on-irrefutable-patterns">Printing matching on irrefutable patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#printing-matching-on-booleans">Printing matching on booleans</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#advanced-recursive-functions">Advanced recursive functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#section-mechanism">Section mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#module-system">Module system</a><ul>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#reserved-commands-inside-an-interactive-module">Reserved commands inside an interactive module</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#reserved-commands-inside-an-interactive-module-type">Reserved commands inside an interactive module type:</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#libraries-and-qualified-names">Libraries and qualified names</a><ul>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#names-of-libraries">Names of libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#qualified-names">Qualified names</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#libraries-and-filesystem">Libraries and filesystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#implicit-arguments">Implicit arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#the-different-kinds-of-implicit-arguments">The different kinds of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function">Implicit arguments inferable from the knowledge of other arguments of a function</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#implicit-arguments-inferable-by-resolution">Implicit arguments inferable by resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#maximal-or-non-maximal-insertion-of-implicit-arguments">Maximal or non maximal insertion of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#casual-use-of-implicit-arguments">Casual use of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#declaration-of-implicit-arguments">Declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#implicit-argument-binders">Implicit Argument Binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#declaring-implicit-arguments">Declaring Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#automatic-declaration-of-implicit-arguments">Automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#mode-for-automatic-declaration-of-implicit-arguments">Mode for automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#controlling-strict-implicit-arguments">Controlling strict implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#controlling-contextual-implicit-arguments">Controlling contextual implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#controlling-reversible-pattern-implicit-arguments">Controlling reversible-pattern implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments">Controlling the insertion of implicit arguments not followed by explicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#explicit-applications">Explicit applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#renaming-implicit-arguments">Renaming implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#displaying-what-the-implicit-arguments-are">Displaying what the implicit arguments are</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#explicit-displaying-of-implicit-arguments-for-pretty-printing">Explicit displaying of implicit arguments for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#interaction-with-subtyping">Interaction with subtyping</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#deactivation-of-implicit-arguments-for-parsing">Deactivation of implicit arguments for parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#canonical-structures">Canonical structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#implicit-types-of-variables">Implicit types of variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#implicit-generalization">Implicit generalization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#coercions">Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#printing-constructions-in-full">Printing constructions in full</a></li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#printing-universes">Printing universes</a></li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#existential-variables">Existential variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#explicit-displaying-of-existential-instances-for-pretty-printing">Explicit displaying of existential instances for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#solving-existential-variables-using-tactics">Solving existential variables using tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#primitive-integers">Primitive Integers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="coq-library.html">The <span class="smallcaps">Coq</span> library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="coq-library.html#the-basic-library">The basic library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#notations">Notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#logic">Logic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#propositional-connectives">Propositional Connectives</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#quantifiers">Quantifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#equality">Equality</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#lemmas">Lemmas</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#datatypes">Datatypes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#programming">Programming</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#specification">Specification</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#basic-arithmetics">Basic Arithmetics</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#well-founded-recursion">Well-founded recursion</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#accessing-the-type-level">Accessing the Type level</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#tactics">Tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="coq-library.html#the-standard-library">The standard library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#survey">Survey</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#peanos-arithmetic-nat">Peano’s arithmetic (nat)</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#notations-for-integer-arithmetics">Notations for integer arithmetics</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#real-numbers-library">Real numbers library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#notations-for-real-numbers">Notations for real numbers</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#some-tactics-for-real-numbers">Some tactics for real numbers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#list-library">List library</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="coq-library.html#users-contributions">Users’ contributions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="cic.html">Calculus of Inductive Constructions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="cic.html#the-terms">The terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="cic.html#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#terms">Terms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cic.html#typing-rules">Typing rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="cic.html#conversion-rules">Conversion rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="cic.html#reduction">β-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#iota-reduction">ι-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#delta-reduction">δ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#zeta-reduction">ζ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#expansion">η-expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#proof-irrelevance">Proof Irrelevance</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#convertibility">Convertibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cic.html#subtyping-rules">Subtyping rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="cic.html#inductive-definitions">Inductive Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="cic.html#types-of-inductive-objects">Types of inductive objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#well-formed-inductive-definitions">Well-formed inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="cic.html#arity-of-a-given-sort">Arity of a given sort</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#arity">Arity</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#type-of-constructor">Type of constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#positivity-condition">Positivity Condition</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#strict-positivity">Strict positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#nested-positivity">Nested Positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#correctness-rules">Correctness rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#template-polymorphism">Template polymorphism</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#destructors">Destructors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="cic.html#the-match-with-end-construction">The match ... with ... end construction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#fixpoint-definitions">Fixpoint definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="cic.html#id29">Typing rule</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#reduction-rule">Reduction rule</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cic.html#admissible-rules-for-global-environments">Admissible rules for global environments</a></li>
<li class="toctree-l2"><a class="reference internal" href="cic.html#co-inductive-types">Co-inductive types</a></li>
<li class="toctree-l2"><a class="reference internal" href="cic.html#the-calculus-of-inductive-constructions-with-impredicative-set">The Calculus of Inductive Constructions with impredicative Set</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="module-system.html">The Module System</a><ul>
<li class="toctree-l2"><a class="reference internal" href="module-system.html#modules-and-module-types">Modules and module types</a></li>
<li class="toctree-l2"><a class="reference internal" href="module-system.html#typing-modules">Typing Modules</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">The proof engine</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/vernacular-commands.html">Vernacular commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#displaying">Displaying</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#flags-options-and-tables">Flags, Options and Tables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#scope-qualifiers-for-set-and-unset">Scope qualifiers for <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Set</span></code> and <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Unset</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#requests-to-the-environment">Requests to the environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#printing-flags">Printing flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#loading-files">Loading files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#compiled-files">Compiled files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#loadpath">Loadpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#backtracking">Backtracking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#quitting-and-debugging">Quitting and debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-display">Controlling display</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-the-reduction-strategies-and-the-conversion-algorithm">Controlling the reduction strategies and the conversion algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-the-locality-of-commands">Controlling the locality of commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#internal-registration-commands">Internal registration commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#exposing-constants-to-ocaml-libraries">Exposing constants to OCaml libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#inlining-hints-for-the-fast-reduction-machines">Inlining hints for the fast reduction machines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#registering-primitive-operations">Registering primitive operations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/proof-handling.html">Proof handling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#switching-on-off-the-proof-editing-mode">Switching on/off the proof editing mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#proof-using-options">Proof using options</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#name-a-set-of-section-hypotheses-for-proof-using">Name a set of section hypotheses for <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#navigation-in-the-proof-tree">Navigation in the proof tree</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#bullets">Bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#set-bullet-behavior">Set Bullet Behavior</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#requesting-information">Requesting information</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#showing-differences-between-proof-steps">Showing differences between proof steps</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#how-to-enable-diffs">How to enable diffs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#how-diffs-are-calculated">How diffs are calculated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#controlling-the-effect-of-proof-editing-commands">Controlling the effect of proof editing commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#controlling-memory-usage">Controlling memory usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/tactics.html">Tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#common-elements-of-tactics">Common elements of tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#invocation-of-tactics">Invocation of tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#bindings-list">Bindings list</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#occurrence-sets-and-occurrence-clauses">Occurrence sets and occurrence clauses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#applying-theorems">Applying theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#managing-the-local-context">Managing the local context</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#controlling-the-proof-flow">Controlling the proof flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#case-analysis-and-induction">Case analysis and induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#rewriting-expressions">Rewriting expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#performing-computations">Performing computations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#conversion-tactics-applied-to-hypotheses">Conversion tactics applied to hypotheses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#automation">Automation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#controlling-automation">Controlling automation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#the-hints-databases-for-auto-and-eauto">The hints databases for auto and eauto</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/tactics.html#creating-hint-databases">Creating Hint databases</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#hint-databases-defined-in-the-coq-standard-library">Hint databases defined in the Coq standard library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#hint-locality">Hint locality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#setting-implicit-automation-tactics">Setting implicit automation tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#decision-procedures">Decision procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#checking-properties-of-terms">Checking properties of terms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#equality">Equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#equality-and-inductive-sets">Equality and inductive sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#inversion">Inversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#classical-tactics">Classical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#automating">Automating</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#non-logical-tactics">Non-logical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#delaying-solving-unification-constraints">Delaying solving unification constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#proof-maintenance">Proof maintenance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#performance-oriented-tactic-variants">Performance-oriented tactic variants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ltac.html">The tactic language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html#semantics">Semantics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#sequence">Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#local-application-of-tactics">Local application of tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#goal-selectors">Goal selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#for-loop">For loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#repeat-loop">Repeat loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#error-catching">Error catching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#detecting-progress">Detecting progress</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#backtracking-branching">Backtracking branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#first-tactic-to-work">First tactic to work</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#left-biased-branching">Left-biased branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#generalized-biased-branching">Generalized biased branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#soft-cut">Soft cut</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#checking-the-successes">Checking the successes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#checking-the-failure">Checking the failure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#checking-the-success">Checking the success</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#solving">Solving</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#identity">Identity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#failing">Failing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#timeout">Timeout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#timing-a-tactic">Timing a tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#timing-a-tactic-that-evaluates-to-a-term">Timing a tactic that evaluates to a term</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#local-definitions">Local definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#application">Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#function-construction">Function construction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#pattern-matching-on-terms">Pattern matching on terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#pattern-matching-on-goals">Pattern matching on goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#filling-a-term-context">Filling a term context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#generating-fresh-hypothesis-names">Generating fresh hypothesis names</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#computing-in-a-constr">Computing in a constr</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#recovering-the-type-of-a-term">Recovering the type of a term</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#manipulating-untyped-terms">Manipulating untyped terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#counting-the-goals">Counting the goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#testing-boolean-expressions">Testing boolean expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#proving-a-subgoal-as-a-separate-lemma">Proving a subgoal as a separate lemma</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html#tactic-toplevel-definitions">Tactic toplevel definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#defining-ltac-functions">Defining <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#printing-ltac-tactics">Printing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html#examples-of-using-ltac">Examples of using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#proof-that-the-natural-numbers-have-at-least-two-elements">Proof that the natural numbers have at least two elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#proving-that-a-list-is-a-permutation-of-a-second-list">Proving that a list is a permutation of a second list</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#deciding-intuitionistic-propositional-logic">Deciding intuitionistic propositional logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#deciding-type-isomorphisms">Deciding type isomorphisms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html#debugging-ltac-tactics">Debugging <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#backtraces">Backtraces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#info-trace">Info trace</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#interactive-debugger">Interactive debugger</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#profiling-ltac-tactics">Profiling <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#run-time-optimization-tactic">Run-time optimization tactic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html">Detailed examples of tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html#dependent-induction">dependent induction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html#a-larger-example">A larger example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html#autorewrite">autorewrite</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#usage">Usage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#getting-started">Getting started</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#compatibility-issues">Compatibility issues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#gallina-extensions"><span class="smallcaps">Gallina</span> extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#pattern-assignment">Pattern assignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#pattern-conditional">Pattern conditional</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#parametric-polymorphism">Parametric polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#anonymous-arguments">Anonymous arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#wildcards">Wildcards</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#abbreviations">Abbreviations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#matching">Matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#occurrence-selection">Occurrence selection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#basic-localization">Basic localization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#basic-tactics">Basic tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#bookkeeping">Bookkeeping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-defective-tactics">The defective tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-move-tactic">The move tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-case-tactic">The case tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-elim-tactic">The elim tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-apply-tactic">The apply tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#discharge">Discharge</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#clear-rules">Clear rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#matching-for-apply-and-exact">Matching for apply and exact</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-abstract-tactic">The abstract tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#introduction-in-the-context">Introduction in the context</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#simplification-items">Simplification items</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#views">Views</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#clear-switch">Clear switch</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#branching-and-destructuring">Branching and destructuring</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#block-introduction">Block introduction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#generation-of-equations">Generation of equations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#type-families">Type families</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#control-flow">Control flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#indentation-and-bullets">Indentation and bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#terminators">Terminators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#selectors">Selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#iteration">Iteration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#localization">Localization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#structure">Structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-have-tactic">The have tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#generating-let-in-context-entries-with-have">Generating let in context entries with have</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-have-tactic-and-typeclass-resolution">The have tactic and typeclass resolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#variants-the-suff-and-wlog-tactics">Variants: the suff and wlog tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#rewriting">Rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#an-extended-rewrite-tactic">An extended rewrite tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#remarks-and-examples">Remarks and examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#rewrite-redex-selection">Rewrite redex selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#chained-rewrite-steps">Chained rewrite steps</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#explicit-redex-switches-are-matched-first">Explicit redex switches are matched first</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#occurrence-switches-and-redex-switches">Occurrence switches and redex switches</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#occurrence-selection-and-repetition">Occurrence selection and repetition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#multi-rule-rewriting">Multi-rule rewriting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#wildcards-vs-abstractions">Wildcards vs abstractions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#when-ssr-rewrite-fails-on-standard-coq-licit-rewrite">When <span class="smallcaps">SSReflect</span> rewrite fails on standard <span class="smallcaps">Coq</span> licit rewrite</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#existential-metavariables-and-rewriting">Existential metavariables and rewriting</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#rewriting-under-binders">Rewriting under binders</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-under-tactic">The under tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interactive-mode">Interactive mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#one-liner-mode">One-liner mode</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#locking-unlocking">Locking, unlocking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#congruence">Congruence</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#contextual-patterns">Contextual patterns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#matching-contextual-patterns">Matching contextual patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#examples">Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#contextual-pattern-in-set-and-the-tactical">Contextual pattern in set and the : tactical</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#contextual-patterns-in-rewrite">Contextual patterns in rewrite</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#patterns-for-recurrent-contexts">Patterns for recurrent contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#views-and-reflection">Views and reflection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-eliminations">Interpreting eliminations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-assumptions">Interpreting assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#specializing-assumptions">Specializing assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-goals">Interpreting goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#boolean-reflection">Boolean reflection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-reflect-predicate">The reflect predicate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#general-mechanism-for-interpreting-goals-and-assumptions">General mechanism for interpreting goals and assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#id13">Specializing assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#id14">Interpreting assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-equivalences">Interpreting equivalences</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#declaring-new-hint-views">Declaring new Hint Views</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#multiple-views">Multiple views</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#ssr-searching-tool"><span class="smallcaps">SSReflect</span> searching tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#synopsis-and-index">Synopsis and Index</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#parameters">Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#items-and-switches">Items and switches</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#tacticals">Tacticals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#commands">Commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#settings">Settings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">User extensions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations">Notations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#basic-notations">Basic notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#precedences-and-associativity">Precedences and associativity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#complex-notations">Complex notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simple-factorization-rules">Simple factorization rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-symbolic-notations">Displaying symbolic notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-infix-command">The Infix command</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#reserving-notations">Reserving notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simultaneous-definition-of-terms-and-notations">Simultaneous definition of terms and notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-notations">Displaying information about notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#locating-notations">Locating notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-and-binders">Notations and binders</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-identifiers">Binders bound in the notation and parsed as identifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-patterns">Binders bound in the notation and parsed as patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-terms">Binders bound in the notation and parsed as terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-not-bound-in-the-notation">Binders not bound in the notation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns">Notations with recursive patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns-involving-binders">Notations with recursive patterns involving binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#predefined-entries">Predefined entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#custom-entries">Custom entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#summary">Summary</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#syntax-of-notations">Syntax of notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#persistence-of-notations">Persistence of notations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes">Interpretation scopes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#global-interpretation-rules-for-notations">Global interpretation rules for notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-interpretation-rules-for-notations">Local interpretation rules for notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-opening-of-an-interpretation-scope">Local opening of an interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binding-arguments-of-a-constant-to-an-interpretation-scope">Binding arguments of a constant to an interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binding-types-of-arguments-to-an-interpretation-scope">Binding types of arguments to an interpretation scope</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-type-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">type_scope</span></code> interpretation scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-function-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">function_scope</span></code> interpretation scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes-used-in-the-standard-library-of-coq">Interpretation scopes used in the standard library of Coq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-scopes">Displaying information about scopes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#numeral-notations">Numeral notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#string-notations">String notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#tactic-notations">Tactic Notations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-induction-principles-with-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#automatic-declaration-of-schemes">Automatic declaration of schemes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#combined-scheme">Combined Scheme</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-induction-principles-with-functional-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Functional</span></code> <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-inversion-principles-with-derive-inversion">Generation of inversion principles with <code class="docutils literal notranslate"><span class="pre">Derive</span></code> <code class="docutils literal notranslate"><span class="pre">Inversion</span></code></a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Practical tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#interactive-use-coqtop">Interactive use (coqtop)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#batch-compilation-coqc">Batch compilation (coqc)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#customization-at-launch-time">Customization at launch time</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-resource-file">By resource file</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-environment-variables">By environment variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-command-line-options">By command line options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-libraries-checker-coqchk">Compiled libraries checker (coqchk)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#using-coq-as-a-library">Using Coq as a library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project">Building a <span class="smallcaps">Coq</span> project</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-coq-makefile">Building a <span class="smallcaps">Coq</span> project with coq_makefile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#coqmakefile-local">CoqMakefile.local</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#timing-targets-and-performance-testing">Timing targets and performance testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#reusing-extending-the-generated-makefile">Reusing/extending the generated Makefile</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#building-a-subset-of-the-targets-with-j">Building a subset of the targets with <code class="docutils literal notranslate"><span class="pre">-j</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-dune">Building a <span class="smallcaps">Coq</span> project with Dune</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#computing-module-dependencies">Computing Module dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#documenting-coq-files-with-coqdoc">Documenting <span class="smallcaps">Coq</span> files with coqdoc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#principles">Principles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#coq-material-inside-documentation"><span class="smallcaps">Coq</span> material inside documentation.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#pretty-printing">Pretty-printing.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#sections">Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#lists">Lists.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#rules">Rules.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#emphasis">Emphasis.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#escaping-to-latex-and-html">Escaping to <span class="smallcaps">LaTeX</span> and HTML.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#verbatim">Verbatim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#hyperlinks">Hyperlinks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#hiding-showing-parts-of-the-source">Hiding / Showing parts of the source.</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#the-coqdoc-latex-style-file">The coqdoc <span class="smallcaps">LaTeX</span> style file</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#embedded-coq-phrases-inside-latex-documents">Embedded Coq phrases inside <span class="smallcaps">LaTeX</span> documents</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#man-pages">Man pages</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#managing-files-and-buffers-basic-editing">Managing files and buffers, basic editing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#interactive-navigation-into-coq-scripts">Interactive navigation into Coq scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#proof-folding">Proof folding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#vernacular-commands-templates">Vernacular commands, templates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#queries">Queries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#compilation">Compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#customizations">Customizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#using-unicode-symbols">Using Unicode symbols</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#displaying-unicode-symbols">Displaying Unicode symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#bindings-for-input-of-unicode-symbols">Bindings for input of Unicode symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#adding-custom-bindings">Adding custom bindings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#character-encoding-for-saved-files">Character encoding for saved files</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Addendum</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extended-pattern-matching.html">Extended pattern matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#patterns">Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#multiple-patterns">Multiple patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#aliasing-subpatterns">Aliasing subpatterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#nested-patterns">Nested patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#disjunctive-patterns">Disjunctive patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#about-patterns-of-parametric-types">About patterns of parametric types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#parameters-in-patterns">Parameters in patterns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#implicit-arguments-in-patterns">Implicit arguments in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#matching-objects-of-dependent-types">Matching objects of dependent types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#understanding-dependencies-in-patterns">Understanding dependencies in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#when-the-elimination-predicate-must-be-provided">When the elimination predicate must be provided</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#dependent-pattern-matching">Dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#multiple-dependent-pattern-matching">Multiple dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#patterns-in-in">Patterns in <code class="docutils literal notranslate"><span class="pre">in</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#using-pattern-matching-to-write-proofs">Using pattern matching to write proofs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#pattern-matching-on-inductive-objects-involving-local-definitions">Pattern-matching on inductive objects involving local definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#pattern-matching-and-coercions">Pattern-matching and coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#when-does-the-expansion-strategy-fail">When does the expansion strategy fail?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#general-presentation">General Presentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions">Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#identity-coercions">Identity Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#inheritance-graph">Inheritance Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#declaring-coercions">Declaring Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#displaying-available-coercions">Displaying Available Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#activating-the-printing-of-coercions">Activating the Printing of Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#classes-as-records">Classes as Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-sections">Coercions and Sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-modules">Coercions and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-at-function-application">Coercion at function application</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-to-a-type">Coercion to a type</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-to-a-function">Coercion to a function</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/canonical-structures.html">Canonical Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/canonical-structures.html#notation-overloading">Notation overloading</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/canonical-structures.html#derived-canonical-structures">Derived Canonical Structures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/canonical-structures.html#hierarchy-of-structures">Hierarchy of structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/canonical-structures.html#compact-declaration-of-canonical-structures">Compact declaration of Canonical Structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/type-classes.html">Typeclasses</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#class-and-instance-declarations">Class and Instance declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#binding-classes">Binding classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#parameterized-instances">Parameterized Instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#sections-and-contexts">Sections and contexts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#building-hierarchies">Building hierarchies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#superclasses">Superclasses</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#substructures">Substructures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#summary-of-the-commands">Summary of the commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-transparent-typeclasses-opaque">Typeclasses Transparent, Typeclasses Opaque</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#settings">Settings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-eauto">Typeclasses eauto <code class="docutils literal notranslate"><span class="pre">:=</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#description-of-omega">Description of <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#arithmetical-goals-recognized-by-omega">Arithmetical goals recognized by <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#messages-from-omega">Messages from <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#using-omega">Using <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#options">Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#technical-data">Technical data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#overview-of-the-tactic">Overview of the tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#overview-of-the-omega-decision-procedure">Overview of the OMEGA decision procedure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#bugs">Bugs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#short-description-of-the-tactics">Short description of the tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#positivstellensatz-refutations"><em>Positivstellensatz</em> refutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#lra-a-decision-procedure-for-linear-real-and-rational-arithmetic"><code class="docutils literal notranslate"><span class="pre">lra</span></code>: a decision procedure for linear real and rational arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#lia-a-tactic-for-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">lia</span></code>: a tactic for linear integer arithmetic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#high-level-view-of-lia">High level view of <code class="docutils literal notranslate"><span class="pre">lia</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#cutting-plane-proofs">Cutting plane proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#case-split">Case split</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#nra-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">nra</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#nia-a-proof-procedure-for-non-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">nia</span></code>: a proof procedure for non-linear integer arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#psatz-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">psatz</span></code>: a proof procedure for non-linear arithmetic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#generating-ml-code">Generating ML Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#extraction-options">Extraction Options</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#setting-the-target-language">Setting the target language</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#inlining-and-optimizations">Inlining and optimizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extra-elimination-of-useless-arguments">Extra elimination of useless arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#realizing-axioms">Realizing axioms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#realizing-inductive-types">Realizing inductive types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#avoiding-conflicts-with-existing-filenames">Avoiding conflicts with existing filenames</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#additional-settings">Additional settings</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#differences-between-coq-and-ml-type-systems">Differences between <span class="smallcaps">Coq</span> and ML type systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#some-examples">Some examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#a-detailed-example-euclidean-division">A detailed example: Euclidean division</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extraction-s-horror-museum">Extraction's horror museum</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#users-contributions">Users' Contributions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/program.html">Program</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#elaborating-programs">Elaborating programs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#syntactic-control-over-equalities">Syntactic control over equalities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-definition">Program Definition</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-fixpoint">Program Fixpoint</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-lemma">Program Lemma</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#solving-obligations">Solving obligations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#frequently-asked-questions">Frequently Asked Questions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/ring.html">The ring and field tactic families</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#what-does-this-tactic-do">What does this tactic do?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#the-variables-map">The variables map</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#is-it-automatic">Is it automatic?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#concrete-usage-in-coq">Concrete usage in Coq</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#adding-a-ring-structure">Adding a ring structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#how-does-it-work">How does it work?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#dealing-with-fields">Dealing with fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#adding-a-new-field-structure">Adding a new field structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#history-of-ring">History of ring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#discussion">Discussion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: tactics for proving equalities in integral domains</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/nsatz.html#more-about-nsatz">More about <code class="docutils literal notranslate"><span class="pre">nsatz</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#introduction-to-generalized-rewriting">Introduction to generalized rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#relations-and-morphisms">Relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#adding-new-relations-and-morphisms">Adding new relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-non-reflexive-relations">Rewriting and non reflexive relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-non-symmetric-relations">Rewriting and non symmetric relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-in-ambiguous-setoid-contexts">Rewriting in ambiguous setoid contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#commands-and-tactics">Commands and tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#first-class-setoids-and-morphisms">First class setoids and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#tactics-enabled-on-user-provided-relations">Tactics enabled on user provided relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#printing-relations-and-morphisms">Printing relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#deprecated-syntax-and-backward-incompatibilities">Deprecated syntax and backward incompatibilities</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#extensions">Extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#subrelations">Subrelations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#constant-unfolding">Constant unfolding</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#strategies-for-rewriting">Strategies for rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#usage">Usage</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-annotations">Proof annotations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#automatic-suggestion-of-proof-annotations">Automatic suggestion of proof annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-blocks-and-error-resilience">Proof blocks and error resilience</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#caveats">Caveats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#interactive-mode">Interactive mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#id2">Caveats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#batch-mode">Batch mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#limiting-the-number-of-parallel-workers">Limiting the number of parallel workers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Miscellaneous extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/miscellaneous-extensions.html#program-derivation">Program derivation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#general-presentation">General Presentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-monomorphic">Polymorphic, Monomorphic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulative-noncumulative">Cumulative, NonCumulative</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#an-example-of-a-proof-using-cumulativity">An example of a proof using cumulativity</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulativity-weak-constraints">Cumulativity Weak Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#global-and-local-universes">Global and local universes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#conversion-and-unification">Conversion and unification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#minimization">Minimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#explicit-universes">Explicit Universes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-definitions">Polymorphic definitions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/sprop.html">SProp (proof irrelevant propositions)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#basic-constructs">Basic constructs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#encodings-for-strict-propositions">Encodings for strict propositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#issues-with-non-cumulativity">Issues with non-cumulativity</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>The Gallina specification language</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/language/gallina-specification-language.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="the-gallina-specification-language">
<span id="gallinaspecificationlanguage"></span><h1>The Gallina specification language<a class="headerlink" href="#the-gallina-specification-language" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes Gallina, the specification language of Coq. It allows
developing mathematical theories and to prove specifications of programs. The
theories are built from axioms, hypotheses, parameters, lemmas, theorems and
definitions of constants, functions, predicates and sets. The syntax of logical
objects involved in theories is described in Section <a class="reference internal" href="#term"><span class="std std-ref">Terms</span></a>. The
language of commands, called <em>The Vernacular</em> is described in Section
<a class="reference internal" href="#vernacular"><span class="std std-ref">The Vernacular</span></a>.</p>
<p>In Coq, logical objects are typed to ensure their logical correctness.  The
rules implemented by the typing algorithm are described in Chapter <a class="reference internal" href="cic.html#calculusofinductiveconstructions"><span class="std std-ref">Calculus of Inductive Constructions</span></a>.</p>
<div class="section" id="about-the-grammars-in-the-manual">
<h2>About the grammars in the manual<a class="headerlink" href="#about-the-grammars-in-the-manual" title="Permalink to this headline">¶</a></h2>
<p>Grammars are presented in Backus-Naur form (BNF). Terminal symbols are
set in black <code class="docutils literal notranslate"><span class="pre">typewriter</span> <span class="pre">font</span></code>. In addition, there are special notations for
regular expressions.</p>
<p>An expression enclosed in square brackets <code class="docutils literal notranslate"><span class="pre">[…]</span></code> means at most one
occurrence of this expression (this corresponds to an optional
component).</p>
<p>The notation “<code class="docutils literal notranslate"><span class="pre">entry</span> <span class="pre">sep</span> <span class="pre">…</span> <span class="pre">sep</span> <span class="pre">entry</span></code>” stands for a non empty sequence
of expressions parsed by entry and separated by the literal “<code class="docutils literal notranslate"><span class="pre">sep</span></code>” <a class="footnote-reference brackets" href="#id6" id="id1">1</a>.</p>
<p>Similarly, the notation “<code class="docutils literal notranslate"><span class="pre">entry</span> <span class="pre">…</span> <span class="pre">entry</span></code>” stands for a non empty
sequence of expressions parsed by the “<code class="docutils literal notranslate"><span class="pre">entry</span></code>” entry, without any
separator between.</p>
<p>At the end, the notation “<code class="docutils literal notranslate"><span class="pre">[entry</span> <span class="pre">sep</span> <span class="pre">…</span> <span class="pre">sep</span> <span class="pre">entry]</span></code>” stands for a
possibly empty sequence of expressions parsed by the “<code class="docutils literal notranslate"><span class="pre">entry</span></code>” entry,
separated by the literal “<code class="docutils literal notranslate"><span class="pre">sep</span></code>”.</p>
</div>
<div class="section" id="lexical-conventions">
<span id="id2"></span><h2>Lexical conventions<a class="headerlink" href="#lexical-conventions" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>Blanks</dt><dd><p>Space, newline and horizontal tabulation are considered as blanks.
Blanks are ignored but they separate tokens.</p>
</dd>
<dt>Comments</dt><dd><p>Comments in Coq are enclosed between <code class="docutils literal notranslate"><span class="pre">(*</span></code> and <code class="docutils literal notranslate"><span class="pre">*)</span></code>, and can be nested.
They can contain any character. However, <a class="reference internal" href="#grammar-token-string"><code class="xref std std-token docutils literal notranslate"><span class="pre">string</span></code></a> literals must be
correctly closed. Comments are treated as blanks.</p>
</dd>
<dt>Identifiers and access identifiers</dt><dd><p>Identifiers, written <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>, are sequences of letters, digits, <code class="docutils literal notranslate"><span class="pre">_</span></code> and
<code class="docutils literal notranslate"><span class="pre">'</span></code>, that do not start with a digit or <code class="docutils literal notranslate"><span class="pre">'</span></code>. That is, they are
recognized by the following lexical class:</p>
<pre>
<strong id="grammar-token-coq-first_letter"><span id="grammar-token-first-letter"></span>first_letter     </strong> ::=  a..z ∣ A..Z ∣ _ ∣ unicode-letter
<strong id="grammar-token-coq-subsequent_letter"><span id="grammar-token-subsequent-letter"></span>subsequent_letter</strong> ::=  a..z ∣ A..Z ∣ 0..9 ∣ _ ∣ ' ∣ unicode-letter ∣ unicode-id-part
<strong id="grammar-token-coq-ident"><span id="grammar-token-ident"></span>ident            </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">first_letter</span></code>[<code class="xref docutils literal notranslate"><span class="pre">subsequent_letter</span></code>…<code class="xref docutils literal notranslate"><span class="pre">subsequent_letter</span></code>]
<strong id="grammar-token-coq-access_ident"><span id="grammar-token-access-ident"></span>access_ident     </strong> ::=  .<code class="xref docutils literal notranslate"><span class="pre">ident</span></code>
</pre>
<p>All characters are meaningful. In particular, identifiers are case-sensitive.
The entry <code class="docutils literal notranslate"><span class="pre">unicode-letter</span></code> non-exhaustively includes Latin,
Greek, Gothic, Cyrillic, Arabic, Hebrew, Georgian, Hangul, Hiragana
and Katakana characters, CJK ideographs, mathematical letter-like
symbols, hyphens, non-breaking space, … The entry <code class="docutils literal notranslate"><span class="pre">unicode-id-part</span></code>
non-exhaustively includes symbols for prime letters and subscripts.</p>
<p>Access identifiers, written <code class="xref std std-token docutils literal notranslate"><span class="pre">access_ident</span></code>, are identifiers prefixed by
<code class="docutils literal notranslate"><span class="pre">.</span></code> (dot) without blank. They are used in the syntax of qualified
identifiers.</p>
</dd>
<dt>Numerals</dt><dd><p>Numerals are sequences of digits with a potential fractional part
and exponent. Integers are numerals without fractional nor exponent
part and optionally preceded by a minus sign. Underscores <code class="docutils literal notranslate"><span class="pre">_</span></code> can
be used as comments in numerals.</p>
<pre>
<strong id="grammar-token-coq-digit"><span id="grammar-token-digit"></span>digit  </strong> ::=  0..9
<strong id="grammar-token-coq-num"><span id="grammar-token-num"></span>num    </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">digit</span></code>…<code class="xref docutils literal notranslate"><span class="pre">digit</span></code>
<strong id="grammar-token-coq-integer"><span id="grammar-token-integer"></span>integer</strong> ::=  [-]<code class="xref docutils literal notranslate"><span class="pre">num</span></code>
<strong id="grammar-token-coq-dot"><span id="grammar-token-dot"></span>dot    </strong> ::=  .
<strong id="grammar-token-coq-exp"><span id="grammar-token-exp"></span>exp    </strong> ::=  e | E
<strong id="grammar-token-coq-sign"><span id="grammar-token-sign"></span>sign   </strong> ::=  + | -
<strong id="grammar-token-coq-numeral"><span id="grammar-token-numeral"></span>numeral</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">num</span></code>[<code class="xref docutils literal notranslate"><span class="pre">dot</span></code> <code class="xref docutils literal notranslate"><span class="pre">num</span></code>][<code class="xref docutils literal notranslate"><span class="pre">exp</span></code>[<code class="xref docutils literal notranslate"><span class="pre">sign</span></code>]<code class="xref docutils literal notranslate"><span class="pre">num</span></code>]
</pre>
</dd>
<dt>Strings</dt><dd><p>Strings are delimited by <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> (double quote), and enclose a sequence of
any characters different from <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> or the sequence <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> to denote the
double quote character. In grammars, the entry for quoted strings is
<span class="inline-grammar-production"><span class="target" id="grammar-token-string"></span><code class="docutils literal notranslate"><span class="pre">string</span></code></span>.</p>
</dd>
<dt>Keywords</dt><dd><p>The following identifiers are reserved keywords, and cannot be
employed otherwise:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>_ as at cofix else end exists exists2 fix for
forall fun if IF in let match mod return
SProp Prop Set Type then using where with
</pre></div>
</div>
</dd>
<dt>Special tokens</dt><dd><p>The following sequences of characters are special tokens:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>! % &amp; &amp;&amp; ( () ) * + ++ , - -&gt; . .( ..
/ /\ : :: :&lt; := :&gt; ; &lt; &lt;- &lt;-&gt; &lt;: &lt;= &lt;&gt; =
=&gt; =_D &gt; &gt;-&gt; &gt;= ? ?= @ [ \/ ] ^ { | |-
|| } ~ #[
</pre></div>
</div>
<p>Lexical ambiguities are resolved according to the “longest match”
rule: when a sequence of non alphanumerical characters can be
decomposed into several different ways, then the first token is the
longest possible one (among all tokens defined at this moment), and so
on.</p>
</dd>
</dl>
</div>
<div class="section" id="terms">
<span id="term"></span><h2>Terms<a class="headerlink" href="#terms" title="Permalink to this headline">¶</a></h2>
<div class="section" id="syntax-of-terms">
<h3>Syntax of terms<a class="headerlink" href="#syntax-of-terms" title="Permalink to this headline">¶</a></h3>
<p>The following grammars describe the basic syntax of the terms of the
<em>Calculus of Inductive Constructions</em> (also called Cic). The formal
presentation of Cic is given in Chapter <a class="reference internal" href="cic.html#calculusofinductiveconstructions"><span class="std std-ref">Calculus of Inductive Constructions</span></a>. Extensions of this syntax
are given in Chapter <a class="reference internal" href="gallina-extensions.html#extensionsofgallina"><span class="std std-ref">Extensions of Gallina</span></a>. How to customize the syntax
is described in Chapter <a class="reference internal" href="../user-extensions/syntax-extensions.html#syntaxextensionsandinterpretationscopes"><span class="std std-ref">Syntax extensions and interpretation scopes</span></a>.</p>
<pre>
<strong id="grammar-token-coq-term"><span id="grammar-token-term"></span>term        </strong> ::=  forall <code class="xref docutils literal notranslate"><span class="pre">binders</span></code> , <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                  fun <code class="xref docutils literal notranslate"><span class="pre">binders</span></code> =&gt; <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                  fix <code class="xref docutils literal notranslate"><span class="pre">fix_bodies</span></code>
                  cofix <code class="xref docutils literal notranslate"><span class="pre">cofix_bodies</span></code>
                  let <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> [<code class="xref docutils literal notranslate"><span class="pre">binders</span></code>] [: <code class="xref docutils literal notranslate"><span class="pre">term</span></code>] := <code class="xref docutils literal notranslate"><span class="pre">term</span></code> in <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                  let fix <code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code> in <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                  let cofix <code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code> in <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                  let ( [<code class="xref docutils literal notranslate"><span class="pre">name</span></code> , … , <code class="xref docutils literal notranslate"><span class="pre">name</span></code>] ) [<code class="xref docutils literal notranslate"><span class="pre">dep_ret_type</span></code>] := <code class="xref docutils literal notranslate"><span class="pre">term</span></code> in <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                  let ' <code class="xref docutils literal notranslate"><span class="pre">pattern</span></code> [in <code class="xref docutils literal notranslate"><span class="pre">term</span></code>] := <code class="xref docutils literal notranslate"><span class="pre">term</span></code> [<code class="xref docutils literal notranslate"><span class="pre">return_type</span></code>] in <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                  if <code class="xref docutils literal notranslate"><span class="pre">term</span></code> [<code class="xref docutils literal notranslate"><span class="pre">dep_ret_type</span></code>] then <code class="xref docutils literal notranslate"><span class="pre">term</span></code> else <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                  <code class="xref docutils literal notranslate"><span class="pre">term</span></code> : <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                  <code class="xref docutils literal notranslate"><span class="pre">term</span></code> &lt;: <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                  <code class="xref docutils literal notranslate"><span class="pre">term</span></code> :&gt;
                  <code class="xref docutils literal notranslate"><span class="pre">term</span></code> -&gt; <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                  <code class="xref docutils literal notranslate"><span class="pre">term</span></code> <code class="xref docutils literal notranslate"><span class="pre">arg</span></code> … <code class="xref docutils literal notranslate"><span class="pre">arg</span></code>
                  &#64; <code class="xref docutils literal notranslate"><span class="pre">qualid</span></code> [<code class="xref docutils literal notranslate"><span class="pre">term</span></code> … <code class="xref docutils literal notranslate"><span class="pre">term</span></code>]
                  <code class="xref docutils literal notranslate"><span class="pre">term</span></code> % <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>
                  match <code class="xref docutils literal notranslate"><span class="pre">match_item</span></code> , … , <code class="xref docutils literal notranslate"><span class="pre">match_item</span></code> [<code class="xref docutils literal notranslate"><span class="pre">return_type</span></code>] with
                    [[|] <code class="xref docutils literal notranslate"><span class="pre">equation</span></code> | … | <code class="xref docutils literal notranslate"><span class="pre">equation</span></code>] end
                  <code class="xref docutils literal notranslate"><span class="pre">qualid</span></code>
                  <code class="xref docutils literal notranslate"><span class="pre">sort</span></code>
                  <code class="xref docutils literal notranslate"><span class="pre">num</span></code>
                  _
                  ( <code class="xref docutils literal notranslate"><span class="pre">term</span></code> )
<strong id="grammar-token-coq-arg"><span id="grammar-token-arg"></span>arg         </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                  ( <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> := <code class="xref docutils literal notranslate"><span class="pre">term</span></code> )
<strong id="grammar-token-coq-binders"><span id="grammar-token-binders"></span>binders     </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">binder</span></code> … <code class="xref docutils literal notranslate"><span class="pre">binder</span></code>
<strong id="grammar-token-coq-binder"><span id="grammar-token-binder"></span>binder      </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">name</span></code>
                  ( <code class="xref docutils literal notranslate"><span class="pre">name</span></code> … <code class="xref docutils literal notranslate"><span class="pre">name</span></code> : <code class="xref docutils literal notranslate"><span class="pre">term</span></code> )
                  ( <code class="xref docutils literal notranslate"><span class="pre">name</span></code> [: <code class="xref docutils literal notranslate"><span class="pre">term</span></code>] := <code class="xref docutils literal notranslate"><span class="pre">term</span></code> )
                  ' <code class="xref docutils literal notranslate"><span class="pre">pattern</span></code>
<strong id="grammar-token-coq-name"><span id="grammar-token-name"></span>name        </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> | _
<strong id="grammar-token-coq-qualid"><span id="grammar-token-qualid"></span>qualid      </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> | <code class="xref docutils literal notranslate"><span class="pre">qualid</span></code> <code class="xref docutils literal notranslate"><span class="pre">access_ident</span></code>
<strong id="grammar-token-coq-sort"><span id="grammar-token-sort"></span>sort        </strong> ::=  SProp | Prop | Set | Type
<strong id="grammar-token-coq-fix_bodies"><span id="grammar-token-fix-bodies"></span>fix_bodies  </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code>
                  <code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code> with <code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code> with … with <code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code> for <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>
<strong id="grammar-token-coq-cofix_bodies"><span id="grammar-token-cofix-bodies"></span>cofix_bodies</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code>
                  <code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code> with <code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code> with … with <code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code> for <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>
<strong id="grammar-token-coq-fix_body"><span id="grammar-token-fix-body"></span>fix_body    </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> <code class="xref docutils literal notranslate"><span class="pre">binders</span></code> [<code class="xref docutils literal notranslate"><span class="pre">annotation</span></code>] [: <code class="xref docutils literal notranslate"><span class="pre">term</span></code>] := <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
<strong id="grammar-token-coq-cofix_body"><span id="grammar-token-cofix-body"></span>cofix_body  </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> [<code class="xref docutils literal notranslate"><span class="pre">binders</span></code>] [: <code class="xref docutils literal notranslate"><span class="pre">term</span></code>] := <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
<strong id="grammar-token-coq-annotation"><span id="grammar-token-annotation"></span>annotation  </strong> ::=  { struct <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> }
<strong id="grammar-token-coq-match_item"><span id="grammar-token-match-item"></span>match_item  </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">term</span></code> [as <code class="xref docutils literal notranslate"><span class="pre">name</span></code>] [in <code class="xref docutils literal notranslate"><span class="pre">qualid</span></code> [<code class="xref docutils literal notranslate"><span class="pre">pattern</span></code> … <code class="xref docutils literal notranslate"><span class="pre">pattern</span></code>]]
<strong id="grammar-token-coq-dep_ret_type"><span id="grammar-token-dep-ret-type"></span>dep_ret_type</strong> ::=  [as <code class="xref docutils literal notranslate"><span class="pre">name</span></code>] <code class="xref docutils literal notranslate"><span class="pre">return_type</span></code>
<strong id="grammar-token-coq-return_type"><span id="grammar-token-return-type"></span>return_type </strong> ::=  return <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
<strong id="grammar-token-coq-equation"><span id="grammar-token-equation"></span>equation    </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">mult_pattern</span></code> | … | <code class="xref docutils literal notranslate"><span class="pre">mult_pattern</span></code> =&gt; <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
<strong id="grammar-token-coq-mult_pattern"><span id="grammar-token-mult-pattern"></span>mult_pattern</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">pattern</span></code> , … , <code class="xref docutils literal notranslate"><span class="pre">pattern</span></code>
<strong id="grammar-token-coq-pattern"><span id="grammar-token-pattern"></span>pattern     </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">qualid</span></code> <code class="xref docutils literal notranslate"><span class="pre">pattern</span></code> … <code class="xref docutils literal notranslate"><span class="pre">pattern</span></code>
                  &#64; <code class="xref docutils literal notranslate"><span class="pre">qualid</span></code> <code class="xref docutils literal notranslate"><span class="pre">pattern</span></code> … <code class="xref docutils literal notranslate"><span class="pre">pattern</span></code>
                  <code class="xref docutils literal notranslate"><span class="pre">pattern</span></code> as <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>
                  <code class="xref docutils literal notranslate"><span class="pre">pattern</span></code> % <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>
                  <code class="xref docutils literal notranslate"><span class="pre">qualid</span></code>
                  _
                  <code class="xref docutils literal notranslate"><span class="pre">num</span></code>
                  ( <code class="xref docutils literal notranslate"><span class="pre">or_pattern</span></code> , … , <code class="xref docutils literal notranslate"><span class="pre">or_pattern</span></code> )
<strong id="grammar-token-coq-or_pattern"><span id="grammar-token-or-pattern"></span>or_pattern  </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">pattern</span></code> | … | <code class="xref docutils literal notranslate"><span class="pre">pattern</span></code>
</pre>
</div>
<div class="section" id="types">
<h3>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<p>Coq terms are typed. Coq types are recognized by the same syntactic
class as <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>. We denote by <span class="inline-grammar-production"><span class="target" id="grammar-token-type"></span><code class="docutils literal notranslate"><span class="pre">type</span></code></span> the semantic subclass
of types inside the syntactic class <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.</p>
</div>
<div class="section" id="qualified-identifiers-and-simple-identifiers">
<span id="gallina-identifiers"></span><h3>Qualified identifiers and simple identifiers<a class="headerlink" href="#qualified-identifiers-and-simple-identifiers" title="Permalink to this headline">¶</a></h3>
<p><em>Qualified identifiers</em> (<code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code>) denote <em>global constants</em>
(definitions, lemmas, theorems, remarks or facts), <em>global variables</em>
(parameters or axioms), <em>inductive types</em> or <em>constructors of inductive
types</em>. <em>Simple identifiers</em> (or shortly <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>) are a syntactic subset
of qualified identifiers. Identifiers may also denote <em>local variables</em>,
while qualified identifiers do not.</p>
</div>
<div class="section" id="numerals">
<h3>Numerals<a class="headerlink" href="#numerals" title="Permalink to this headline">¶</a></h3>
<p>Numerals have no definite semantics in the calculus. They are mere
notations that can be bound to objects through the notation mechanism
(see Chapter <a class="reference internal" href="../user-extensions/syntax-extensions.html#syntaxextensionsandinterpretationscopes"><span class="std std-ref">Syntax extensions and interpretation scopes</span></a> for details).
Initially, numerals are bound to Peano’s representation of natural
numbers (see <a class="reference internal" href="coq-library.html#datatypes"><span class="std std-ref">Datatypes</span></a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Negative integers are not at the same level as <code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code>, for this
would make precedence unnatural.</p>
</div>
</div>
<div class="section" id="sorts">
<span id="index-0"></span><h3>Sorts<a class="headerlink" href="#sorts" title="Permalink to this headline">¶</a></h3>
<p>There are four sorts <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">SProp</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Set</span></span></code>  and <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code>.</p>
<ul class="simple">
<li><p><code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">SProp</span></span></code> is the universe of <em>definitionally irrelevant
propositions</em> (also called <em>strict propositions</em>).</p></li>
<li><p><code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code> is the universe of <em>logical propositions</em>. The logical propositions
themselves are typing the proofs. We denote propositions by <span class="inline-grammar-production"><span class="target" id="grammar-token-form"></span><code class="docutils literal notranslate"><span class="pre">form</span></code></span>.
This constitutes a semantic subclass of the syntactic class <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.</p></li>
<li><p><code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Set</span></span></code> is the universe of <em>program types</em> or <em>specifications</em>. The
specifications themselves are typing the programs. We denote
specifications by <span class="inline-grammar-production"><span class="target" id="grammar-token-specif"></span><code class="docutils literal notranslate"><span class="pre">specif</span></code></span>. This constitutes a semantic subclass of
the syntactic class <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.</p></li>
<li><p><code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code> is the type of sorts.</p></li>
</ul>
<p>More on sorts can be found in Section <a class="reference internal" href="cic.html#sorts"><span class="std std-ref">Sorts</span></a>.</p>
</div>
<div class="section" id="binders">
<span id="id3"></span><h3>Binders<a class="headerlink" href="#binders" title="Permalink to this headline">¶</a></h3>
<p>Various constructions such as <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">fun</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">fix</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">cofix</span></span></code>
<em>bind</em> variables. A binding is represented by an identifier. If the binding
variable is not used in the expression, the identifier can be replaced by the
symbol <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">_</span></span></code>. When the type of a bound variable cannot be synthesized by the
system, it can be specified with the notation <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span><span><span class="pre"> : </span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">)</span></span></span></code>. There is also
a notation for a sequence of binding variables sharing the same type:
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span><span><span class="pre"> : </span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">)</span></span></span></code>. A
binder can also be any pattern prefixed by a quote, e.g. <code class="code highlight coq docutils literal notranslate"><span class="error"><span class="pre">'</span></span><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">,</span></span><span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">)</span></span></code>.</p>
<p>Some constructions allow the binding of a variable to value. This is
called a “let-binder”. The entry <code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code> of the grammar accepts
either an assumption binder as defined above or a let-binder. The notation in
the latter case is <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span><span><span class="pre"> := </span></span><span class="hole"><span class="pre">term</span></span><span><span class="pre">)</span></span></span></code>. In a let-binder, only one
variable can be introduced at the same time. It is also possible to give
the type of the variable as follows:
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span><span><span class="pre"> : </span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre"> := </span></span><span class="hole"><span class="pre">term</span></span><span><span class="pre">)</span></span></span></code>.</p>
<p>Lists of <code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code> are allowed. In the case of <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">fun</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span></code>,
it is intended that at least one binder of the list is an assumption otherwise
fun and forall gets identical. Moreover, parentheses can be omitted in
the case of a single sequence of bindings sharing the same type (e.g.:
<code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">fun</span></span><span class="name variable"> </span><span class="operator"><span class="pre">(</span></span><span class="name variable"><span class="pre">x y z </span></span><span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">)</span></span><span class="name variable"> </span><span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">t</span></span></code> can be shortened in <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">fun</span></span><span class="name variable"><span class="pre"> x y z </span></span><span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A </span></span><span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">t</span></span></code>).</p>
</div>
<div class="section" id="abstractions">
<span id="index-1"></span><h3>Abstractions<a class="headerlink" href="#abstractions" title="Permalink to this headline">¶</a></h3>
<p>The expression <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">fun</span></span> <span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span class="pre">=&gt;</span></span> <span class="hole"><span class="pre">term</span></span></span></code> defines the
<em>abstraction</em> of the variable <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>, of type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, over the term
<code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>. It denotes a function of the variable <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> that evaluates to
the expression <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> (e.g. <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">fun</span></span> <span class="name variable"><span class="pre">x</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">x</span></span></code> denotes the identity
function on type <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code>). The keyword <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">fun</span></span></code> can be followed by several
binders as given in Section <a class="reference internal" href="#binders"><span class="std std-ref">Binders</span></a>. Functions over
several variables are equivalent to an iteration of one-variable
functions. For instance the expression
“fun <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><span class="math notranslate nohighlight">\(_{1}\)</span> … <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><span class="math notranslate nohighlight">\(_{n}\)</span>
: <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> =&gt; <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>”
denotes the same function as “ fun <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><span class="math notranslate nohighlight">\(_{1}\)</span> : <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> =&gt; …
fun <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><span class="math notranslate nohighlight">\(_{n}\)</span> : <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> =&gt; <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>”. If
a let-binder occurs in
the list of binders, it is expanded to a let-in definition (see
Section <a class="reference internal" href="#let-in"><span class="std std-ref">Let-in definitions</span></a>).</p>
</div>
<div class="section" id="products">
<span id="index-2"></span><h3>Products<a class="headerlink" href="#products" title="Permalink to this headline">¶</a></h3>
<p>The expression <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">forall </span></span><span class="hole"><span class="pre">ident</span></span><span><span class="pre"> : </span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">, </span></span><span class="hole"><span class="pre">term</span></span></span></code> denotes the
<em>product</em> of the variable <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> of type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, over the term <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.
As for abstractions, <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span></code> is followed by a binder list, and products
over several variables are equivalent to an iteration of one-variable
products. Note that <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> is intended to be a type.</p>
<p>If the variable <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> occurs in <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>, the product is called
<em>dependent product</em>. The intention behind a dependent product
<code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span><span class="name variable"><span class="pre"> x </span></span><span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">B</span></span></code> is twofold. It denotes either
the universal quantification of the variable <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code> of type <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code>
in the proposition <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> or the functional dependent product from
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> to <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> (a construction usually written
<span class="math notranslate nohighlight">\(\Pi_{x:A}.B\)</span> in set theory).</p>
<p>Non dependent product types have a special notation: <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">B</span></span></code> stands for
<code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span> <span class="name variable"><span class="pre">_</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">B</span></span></code>. The <em>non dependent product</em> is used both to denote
the propositional implication and function types.</p>
</div>
<div class="section" id="applications">
<h3>Applications<a class="headerlink" href="#applications" title="Permalink to this headline">¶</a></h3>
<p>The expression <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_0\)</span> <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_1\)</span> denotes the
application of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_0\)</span> to <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_1\)</span>.</p>
<p>The expression <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_0\)</span> <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_1\)</span> ...
<code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_n\)</span> denotes the application of the term
<code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_0\)</span> to the arguments <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_1\)</span> ... then
<code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_n\)</span>. It is equivalent to ( … ( <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_0\)</span>
<code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_1\)</span> ) … ) <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_n\)</span> : associativity is to the
left.</p>
<p>The notation <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="hole"><span class="pre">ident</span></span><span><span class="pre"> := </span></span><span class="hole"><span class="pre">term</span></span><span><span class="pre">)</span></span></span></code> for arguments is used for making
explicit the value of implicit arguments (see
Section <a class="reference internal" href="gallina-extensions.html#explicit-applications"><span class="std std-ref">Explicit applications</span></a>).</p>
</div>
<div class="section" id="type-cast">
<span id="index-3"></span><h3>Type cast<a class="headerlink" href="#type-cast" title="Permalink to this headline">¶</a></h3>
<p>The expression <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span><span><span class="pre"> : </span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> is a type cast expression. It enforces
the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> to be <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span><span><span class="pre"> &lt;: </span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> locally sets up the virtual machine for checking that
<code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> has type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term</span></span><span><span class="pre"> &lt;&lt;: </span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> uses native compilation for checking that <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>
has type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
</div>
<div class="section" id="inferable-subterms">
<span id="index-4"></span><h3>Inferable subterms<a class="headerlink" href="#inferable-subterms" title="Permalink to this headline">¶</a></h3>
<p>Expressions often contain redundant pieces of information. Subterms that can be
automatically inferred by Coq can be replaced by the symbol <code class="docutils literal notranslate"><span class="pre">_</span></code> and Coq will
guess the missing piece of information.</p>
</div>
<div class="section" id="let-in-definitions">
<span id="let-in"></span><span id="index-5"></span><h3>Let-in definitions<a class="headerlink" href="#let-in-definitions" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">in</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code>
denotes the local binding of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> to the variable
<code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> in <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>’. There is a syntactic sugar for let-in
definition of functions: <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <span class="hole"><span class="pre">ident</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">binder</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">:=</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">in</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code>
stands for <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span><span class="pre">fun</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">binder</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">=&gt;</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">in</span></span> <span class="hole"><span class="pre">term</span></span><span><span class="pre">’</span></span></span></code>.</p>
</div>
<div class="section" id="definition-by-case-analysis">
<span id="index-6"></span><h3>Definition by case analysis<a class="headerlink" href="#definition-by-case-analysis" title="Permalink to this headline">¶</a></h3>
<p>Objects of inductive types can be destructured by a case-analysis
construction called <em>pattern matching</em> expression. A pattern matching
expression is used to analyze the structure of an inductive object and
to apply specific treatments accordingly.</p>
<p>This paragraph describes the basic form of pattern matching. See
Section <a class="reference internal" href="gallina-extensions.html#mult-match"><span class="std std-ref">Multiple and nested pattern matching</span></a> and Chapter <a class="reference internal" href="../addendum/extended-pattern-matching.html#extendedpatternmatching"><span class="std std-ref">Extended pattern matching</span></a> for the description
of the general form. The basic form of pattern matching is characterized
by a single <code class="xref std std-token docutils literal notranslate"><span class="pre">match_item</span></code> expression, a <code class="xref std std-token docutils literal notranslate"><span class="pre">mult_pattern</span></code> restricted to a
single <code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code> and <code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code> restricted to the form
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">qualid</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code>.</p>
<p>The expression match &quot;<code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_0\)</span> <code class="xref std std-token docutils literal notranslate"><span class="pre">return_type</span></code> with
<code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code><span class="math notranslate nohighlight">\(_1\)</span> =&gt; <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_1\)</span> <span class="math notranslate nohighlight">\(|\)</span> … <span class="math notranslate nohighlight">\(|\)</span>
<code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code><span class="math notranslate nohighlight">\(_n\)</span> =&gt; <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_n\)</span> end&quot; denotes a
<em>pattern matching</em> over the term <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_0\)</span> (expected to be
of an inductive type <span class="math notranslate nohighlight">\(I\)</span>). The terms <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_1\)</span>…<code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_n\)</span> are the <em>branches</em> of the pattern matching
expression. Each of <code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code><span class="math notranslate nohighlight">\(_i\)</span> has a form <code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code>
<code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> where <code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code> must denote a constructor. There should be
exactly one branch for every constructor of <span class="math notranslate nohighlight">\(I\)</span>.</p>
<p>The <code class="xref std std-token docutils literal notranslate"><span class="pre">return_type</span></code> expresses the type returned by the whole match
expression. There are several cases. In the <em>non dependent</em> case, all
branches have the same type, and the <code class="xref std std-token docutils literal notranslate"><span class="pre">return_type</span></code> is the common type of
branches. In this case, <code class="xref std std-token docutils literal notranslate"><span class="pre">return_type</span></code> can usually be omitted as it can be
inferred from the type of the branches <a class="footnote-reference brackets" href="#id7" id="id4">2</a>.</p>
<p>In the <em>dependent</em> case, there are three subcases. In the first subcase,
the type in each branch may depend on the exact value being matched in
the branch. In this case, the whole pattern matching itself depends on
the term being matched. This dependency of the term being matched in the
return type is expressed with an “as <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>” clause where <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>
is dependent in the return type. For instance, in the following example:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">bool</span> : <span class="kt">Type</span> := true : bool | false : bool.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">eq</span> (<span class="nv">A</span>:<span class="kt">Type</span>) (<span class="nv">x</span>:A) : A -&gt; <span class="kt">Prop</span> := eq_refl : eq A x x.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">or</span> (<span class="nv">A</span>:<span class="kt">Prop</span>) (<span class="nv">B</span>:<span class="kt">Prop</span>) : <span class="kt">Prop</span> :=
  | or_introl : A -&gt; or A B
  | or_intror : B -&gt; or A B.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">bool_case</span> (<span class="nv">b</span>:bool) : or (eq bool b true) (eq bool b false) :=
  <span class="kr">match</span> b <span class="kr">as</span> x <span class="kr">return</span> or (eq bool x true) (eq bool x false) <span class="kr">with</span>
  | true =&gt; or_introl (eq bool true true) (eq bool true false) (eq_refl bool true)
  | false =&gt; or_intror (eq bool false true) (eq bool false false) (eq_refl bool false)
  <span class="kr">end</span>.</span></span></span></pre></div><p>the branches have respective types &quot;<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name"><span class="pre">true</span></span> <span class="name"><span class="pre">true</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name"><span class="pre">true</span></span> <span class="name"><span class="pre">false</span></span><span class="operator"><span class="pre">)</span></span></code>&quot;
and &quot;<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name"><span class="pre">false</span></span> <span class="name"><span class="pre">true</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name"><span class="pre">false</span></span> <span class="name"><span class="pre">false</span></span><span class="operator"><span class="pre">)</span></span></code>&quot; while the whole
pattern matching expression has type &quot;<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name"><span class="pre">b</span></span> <span class="name"><span class="pre">true</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name"><span class="pre">b</span></span> <span class="name"><span class="pre">false</span></span><span class="operator"><span class="pre">)</span></span></code>&quot;,
the identifier <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">b</span></span></code> being used to represent the dependency.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the term being matched is a variable, the <code class="docutils literal notranslate"><span class="pre">as</span></code> clause can be
omitted and the term being matched can serve itself as binding name in
the return type. For instance, the following alternative definition is
accepted and has the same meaning as the previous one.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">bool_case</span> (<span class="nv">b</span>:bool) : or (eq bool b true) (eq bool b false) :=
<span class="kr">match</span> b <span class="kr">return</span> or (eq bool b true) (eq bool b false) <span class="kr">with</span>
| true =&gt; or_introl (eq bool true true) (eq bool true false) (eq_refl bool true)
| false =&gt; or_intror (eq bool false true) (eq bool false false) (eq_refl bool false)
<span class="kr">end</span>.</span></span></span></pre></div></div>
<p>The second subcase is only relevant for annotated inductive types such
as the equality predicate (see Section <a class="reference internal" href="coq-library.html#coq-equality"><span class="std std-ref">Equality</span></a>),
the order predicate on natural numbers or the type of lists of a given
length (see Section <a class="reference internal" href="../addendum/extended-pattern-matching.html#matching-dependent"><span class="std std-ref">Matching objects of dependent types</span></a>). In this configuration, the
type of each branch can depend on the type dependencies specific to the
branch and the whole pattern matching expression has a type determined
by the specific dependencies in the type of the term being matched. This
dependency of the return type in the annotations of the inductive type
is expressed using a “<code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">in</span></span></code> <span class="math notranslate nohighlight">\(I\)</span> <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">_</span></span> <span class="operator"><span class="pre">…</span></span> <span class="name"><span class="pre">_</span></span></code> <code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code><span class="math notranslate nohighlight">\(_1\)</span> …
<code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code><span class="math notranslate nohighlight">\(_n\)</span>” clause, where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(I\)</span> is the inductive type of the term being matched;</p></li>
<li><p>the <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">_</span></span></code> are matching the parameters of the inductive type: the
return type is not dependent on them.</p></li>
<li><p>the <code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code><span class="math notranslate nohighlight">\(_i\)</span> are matching the annotations of the
inductive type: the return type is dependent on them</p></li>
<li><p>in the basic case which we describe below, each <code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code><span class="math notranslate nohighlight">\(_i\)</span>
is a name <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><span class="math notranslate nohighlight">\(_i\)</span>; see <a class="reference internal" href="../addendum/extended-pattern-matching.html#match-in-patterns"><span class="std std-ref">Patterns in in</span></a> for the
general case</p></li>
</ul>
<p>For instance, in the following example:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eq_sym</span> (<span class="nv">A</span>:<span class="kt">Type</span>) (<span class="nv">x</span> <span class="nv">y</span>:A) (<span class="nv">H</span>:eq A x y) : eq A y x :=
<span class="kr">match</span> H <span class="kr">in</span> eq _ _ z <span class="kr">return</span> eq A z x <span class="kr">with</span>
| eq_refl _ _ =&gt; eq_refl A x
<span class="kr">end</span>.</span></span></span></pre></div><p>the type of the branch is <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">x</span></span></code> because the third argument of
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span></code> is <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code> in the type of the pattern <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">eq_refl</span></span></code>. On the contrary, the
type of the whole pattern matching expression has type <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">y</span></span> <span class="name"><span class="pre">x</span></span></code> because the
third argument of eq is y in the type of H. This dependency of the case analysis
in the third argument of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span></code> is expressed by the identifier <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">z</span></span></code> in the
return type.</p>
<p>Finally, the third subcase is a combination of the first and second
subcase. In particular, it only applies to pattern matching on terms in
a type with annotations. For this third subcase, both the clauses <code class="docutils literal notranslate"><span class="pre">as</span></code> and
<code class="docutils literal notranslate"><span class="pre">in</span></code> are available.</p>
<p>There are specific notations for case analysis on types with one or two
constructors: <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">…</span> <span class="pre">then</span> <span class="pre">…</span> <span class="pre">else</span> <span class="pre">…</span></code> and <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">(…,…)</span> <span class="pre">:=</span> <span class="pre">…</span> <span class="pre">in</span> <span class="pre">…</span></code> (see
Sections <a class="reference internal" href="gallina-extensions.html#if-then-else"><span class="std std-ref">Pattern-matching on boolean values: the if expression</span></a> and <a class="reference internal" href="gallina-extensions.html#irrefutable-patterns"><span class="std std-ref">Irrefutable patterns: the destructuring let variants</span></a>).</p>
</div>
<div class="section" id="recursive-functions">
<span id="index-7"></span><h3>Recursive functions<a class="headerlink" href="#recursive-functions" title="Permalink to this headline">¶</a></h3>
<p>The expression “<code class="docutils literal notranslate"><span class="pre">fix</span></code> <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><span class="math notranslate nohighlight">\(_1\)</span> <code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code><span class="math notranslate nohighlight">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">:</span></code>
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">:=</span></code> <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">…</span> <span class="pre">with</span></code>
<code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><span class="math notranslate nohighlight">\(_n\)</span> <code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code><span class="math notranslate nohighlight">\(_n\)</span> : <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate nohighlight">\(_n\)</span>
<code class="docutils literal notranslate"><span class="pre">:=</span></code> <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code><span class="math notranslate nohighlight">\(_n\)</span> <code class="docutils literal notranslate"><span class="pre">for</span></code> <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><span class="math notranslate nohighlight">\(_i\)</span>” denotes the
<span class="math notranslate nohighlight">\(i\)</span>-th component of a block of functions defined by mutual structural
recursion. It is the local counterpart of the <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> command. When
<span class="math notranslate nohighlight">\(n=1\)</span>, the “<code class="docutils literal notranslate"><span class="pre">for</span></code> <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><span class="math notranslate nohighlight">\(_i\)</span>” clause is omitted.</p>
<p>The expression “<code class="docutils literal notranslate"><span class="pre">cofix</span></code> <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><span class="math notranslate nohighlight">\(_1\)</span> <code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code><span class="math notranslate nohighlight">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">:</span></code>
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">…</span> <span class="pre">with</span></code> <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><span class="math notranslate nohighlight">\(_n\)</span> <code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code><span class="math notranslate nohighlight">\(_n\)</span>
: <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> <code class="docutils literal notranslate"><span class="pre">for</span></code> <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><span class="math notranslate nohighlight">\(_i\)</span>” denotes the
<span class="math notranslate nohighlight">\(i\)</span>-th component of a block of terms defined by a mutual guarded
co-recursion. It is the local counterpart of the <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> command. When
<span class="math notranslate nohighlight">\(n=1\)</span>, the “<code class="docutils literal notranslate"><span class="pre">for</span></code> <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><span class="math notranslate nohighlight">\(_i\)</span>” clause is omitted.</p>
<p>The association of a single fixpoint and a local definition have a special
syntax: <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <span><span class="pre">fix</span></span> <span class="hole"><span class="pre">ident</span></span> <span class="hole"><span class="pre">binders</span></span> <span><span class="pre">:=</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">in</span></span></span></code> stands for
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span><span class="pre">fix</span></span> <span class="hole"><span class="pre">ident</span></span> <span class="hole"><span class="pre">binders</span></span> <span><span class="pre">:=</span></span> <span class="hole"><span class="pre">term</span></span> <span><span class="pre">in</span></span></span></code>. The same applies for co-fixpoints.</p>
</div>
</div>
<div class="section" id="the-vernacular">
<span id="vernacular"></span><h2>The Vernacular<a class="headerlink" href="#the-vernacular" title="Permalink to this headline">¶</a></h2>
<pre>
<strong id="grammar-token-coq-decorated-sentence"><span id="grammar-token-decorated-sentence"></span>decorated-sentence</strong> ::=  [ <code class="xref docutils literal notranslate"><span class="pre">decoration</span></code> … <code class="xref docutils literal notranslate"><span class="pre">decoration</span></code> ] <code class="xref docutils literal notranslate"><span class="pre">sentence</span></code>
<strong id="grammar-token-coq-sentence"><span id="grammar-token-sentence"></span>sentence          </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">assumption</span></code>
                        <code class="xref docutils literal notranslate"><span class="pre">definition</span></code>
                        <code class="xref docutils literal notranslate"><span class="pre">inductive</span></code>
                        <code class="xref docutils literal notranslate"><span class="pre">fixpoint</span></code>
                        <code class="xref docutils literal notranslate"><span class="pre">assertion</span></code> <code class="xref docutils literal notranslate"><span class="pre">proof</span></code>
<strong id="grammar-token-coq-assumption"><span id="grammar-token-assumption"></span>assumption        </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">assumption_keyword</span></code> <code class="xref docutils literal notranslate"><span class="pre">assums</span></code>.
<strong id="grammar-token-coq-assumption_keyword"><span id="grammar-token-assumption-keyword"></span>assumption_keyword</strong> ::=  Axiom | Conjecture
                        Parameter | Parameters
                        Variable | Variables
                        Hypothesis | Hypotheses
<strong id="grammar-token-coq-assums"><span id="grammar-token-assums"></span>assums            </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> … <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> : <code class="xref docutils literal notranslate"><span class="pre">term</span></code>
                        ( <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> … <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> : <code class="xref docutils literal notranslate"><span class="pre">term</span></code> ) … ( <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> … <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> : <code class="xref docutils literal notranslate"><span class="pre">term</span></code> )
<strong id="grammar-token-coq-definition"><span id="grammar-token-definition"></span>definition        </strong> ::=  [Local] Definition <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> [<code class="xref docutils literal notranslate"><span class="pre">binders</span></code>] [: <code class="xref docutils literal notranslate"><span class="pre">term</span></code>] := <code class="xref docutils literal notranslate"><span class="pre">term</span></code> .
                        Let <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> [<code class="xref docutils literal notranslate"><span class="pre">binders</span></code>] [: <code class="xref docutils literal notranslate"><span class="pre">term</span></code>] := <code class="xref docutils literal notranslate"><span class="pre">term</span></code> .
<strong id="grammar-token-coq-inductive"><span id="grammar-token-inductive"></span>inductive         </strong> ::=  Inductive <code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code> with … with <code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code> .
                        CoInductive <code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code> with … with <code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code> .
<strong id="grammar-token-coq-ind_body"><span id="grammar-token-ind-body"></span>ind_body          </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> [<code class="xref docutils literal notranslate"><span class="pre">binders</span></code>] : <code class="xref docutils literal notranslate"><span class="pre">term</span></code> :=
                        [[|] <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> [<code class="xref docutils literal notranslate"><span class="pre">binders</span></code>] [:<code class="xref docutils literal notranslate"><span class="pre">term</span></code>] | … | <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> [<code class="xref docutils literal notranslate"><span class="pre">binders</span></code>] [:<code class="xref docutils literal notranslate"><span class="pre">term</span></code>]]
<strong id="grammar-token-coq-fixpoint"><span id="grammar-token-fixpoint"></span>fixpoint          </strong> ::=  Fixpoint <code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code> with … with <code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code> .
                        CoFixpoint <code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code> with … with <code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code> .
<strong id="grammar-token-coq-assertion"><span id="grammar-token-assertion"></span>assertion         </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">assertion_keyword</span></code> <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> [<code class="xref docutils literal notranslate"><span class="pre">binders</span></code>] : <code class="xref docutils literal notranslate"><span class="pre">term</span></code> .
<strong id="grammar-token-coq-assertion_keyword"><span id="grammar-token-assertion-keyword"></span>assertion_keyword </strong> ::=  Theorem | Lemma
                        Remark | Fact
                        Corollary | Property | Proposition
                        Definition | Example
<strong id="grammar-token-coq-proof"><span id="grammar-token-proof"></span>proof             </strong> ::=  Proof . … Qed .
                        Proof . … Defined .
                        Proof . … Admitted .
<strong id="grammar-token-coq-decoration"><span id="grammar-token-decoration"></span>decoration        </strong> ::=  #[ <code class="xref docutils literal notranslate"><span class="pre">attributes</span></code> ]
<strong id="grammar-token-coq-attributes"><span id="grammar-token-attributes"></span>attributes        </strong> ::=  [<code class="xref docutils literal notranslate"><span class="pre">attribute</span></code>, … , <code class="xref docutils literal notranslate"><span class="pre">attribute</span></code>]
<strong id="grammar-token-coq-attribute"><span id="grammar-token-attribute"></span>attribute         </strong> ::=   <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>
                        <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> = <code class="xref docutils literal notranslate"><span class="pre">string</span></code>
                        <code class="xref docutils literal notranslate"><span class="pre">ident</span></code> ( <code class="xref docutils literal notranslate"><span class="pre">attributes</span></code> )
</pre>
<p>This grammar describes <em>The Vernacular</em> which is the language of
commands of Gallina. A sentence of the vernacular language, like in
many natural languages, begins with a capital letter and ends with a
dot.</p>
<p>Sentences may be <em>decorated</em> with so-called <em>attributes</em>,
which are described in the corresponding section (<a class="reference internal" href="#gallina-attributes"><span class="std std-ref">Attributes</span></a>).</p>
<p>The different kinds of command are described hereafter. They all suppose
that the terms occurring in the sentences are well-typed.</p>
<div class="section" id="assumptions">
<span id="gallina-assumptions"></span><h3>Assumptions<a class="headerlink" href="#assumptions" title="Permalink to this headline">¶</a></h3>
<p>Assumptions extend the environment with axioms, parameters, hypotheses
or variables. An assumption binds an <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> to a <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>. It is accepted
by Coq if and only if this <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is a correct type in the environment
preexisting the declaration and if <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> was not previously defined in
the same module. This <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is considered to be the type (or
specification, or statement) assumed by <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> and we say that <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>
has type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
<span class="target" id="axiom"></span><dl class="coq cmd">
<dt id="coq:cmd.parameter">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Parameter</span> <span class="hole">ident</span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmd.parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>This command links <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> to the name <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> as its specification in
the global context. The fact asserted by <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is thus assumed as a
postulate.</p>
<dl class="coq exn">
<dt id="coq:exn.ident-already-exists-axiom">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">ident</span> <span>already</span> <span>exists.</span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-axiom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Parameter</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code></dt>
<dd><p>Adds several parameters with specification <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
</dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Parameter</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Adds blocks of parameters with different specifications.</p>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.local-parameter">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Local</span> <span>Parameter</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.local-parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Such parameters are never made accessible through their unqualified name by
<a class="reference internal" href="gallina-extensions.html#coq:cmd.import" title="Import"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Import</span></code></a> and its variants. You have to explicitly give their fully
qualified name to refer to them.</p>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.parameters">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Parameters</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.parameters" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.axiom">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Axiom</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.axiom" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.axioms">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Axioms</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.axioms" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.conjecture">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Conjecture</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.conjecture" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.conjectures">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Conjectures</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.conjectures" title="Permalink to this definition">¶</a></dt>
<dd><p>These variants are synonyms of <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">Local</span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span class="pre">Parameter</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">(</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span class="pre">)</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.variable-outside-a-section">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Variable</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.variable-outside-a-section" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.variables-outside-a-section">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Variables</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.variables-outside-a-section" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.hypothesis-outside-a-section">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hypothesis</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.hypothesis-outside-a-section" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.hypotheses-outside-a-section">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hypotheses</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.hypotheses-outside-a-section" title="Permalink to this definition">¶</a></dt>
<dd><p>Outside of any section, these variants are synonyms of
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Local</span></span> <span><span class="pre">Parameter</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">(</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">ident</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span class="pre">)</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.
For their meaning inside a section, see <a class="reference internal" href="gallina-extensions.html#coq:cmd.variable" title="Variable"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variable</span></code></a> in
<a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>.</p>
<dl class="coq warn">
<dt id="coq:warn.ident-is-declared-as-a-local-axiom-local-declaration-scope">
<em class="property"><span class="sigannot">Warning</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">ident</span> <span>is</span> <span>declared</span> <span>as</span> <span>a</span> <span>local</span> <span>axiom</span> <span>[local-declaration,scope]</span></span></code><a class="headerlink" href="#coq:warn.ident-is-declared-as-a-local-axiom-local-declaration-scope" title="Permalink to this definition">¶</a></dt>
<dd><p>Warning generated when using <a class="reference internal" href="gallina-extensions.html#coq:cmd.variable" title="Variable"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variable</span></code></a> instead of
<a class="reference internal" href="#coq:cmdv.local-parameter" title="Local Parameter"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Local</span> <span class="pre">Parameter</span></code></a>.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is advised to use the commands <a class="reference internal" href="#coq:cmdv.axiom" title="Axiom"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Axiom</span></code></a>, <a class="reference internal" href="#coq:cmdv.conjecture" title="Conjecture"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Conjecture</span></code></a> and
<a class="reference internal" href="gallina-extensions.html#coq:cmdv.hypothesis" title="Hypothesis"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Hypothesis</span></code></a> (and their plural forms) for logical postulates (i.e. when
the assertion <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is of sort <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>), and to use the commands
<a class="reference internal" href="#coq:cmd.parameter" title="Parameter"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Parameter</span></code></a> and <a class="reference internal" href="gallina-extensions.html#coq:cmd.variable" title="Variable"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variable</span></code></a> (and their plural forms) in other cases
(corresponding to the declaration of an abstract mathematical entity).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Section <a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>.</p>
</div>
</div>
<div class="section" id="definitions">
<span id="gallina-definitions"></span><h3>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h3>
<p>Definitions extend the environment with associations of names to terms.
A definition can be seen as a way to give a meaning to a name or as a
way to abbreviate a term. In any case, the name can later be replaced at
any time by its definition.</p>
<p>The operation of unfolding a name into its definition is called
<span class="math notranslate nohighlight">\(\delta\)</span>-conversion (see Section <a class="reference internal" href="cic.html#delta-reduction"><span class="std std-ref">δ-reduction</span></a>). A
definition is accepted by the system if and only if the defined term is
well-typed in the current context of the definition and if the name is
not already used. The name defined by the definition is called a
<em>constant</em> and the term it refers to is its <em>body</em>. A definition has a
type which is the type of its body.</p>
<p>A formal presentation of constants and environments is given in
Section <a class="reference internal" href="cic.html#typing-rules"><span class="std std-ref">Typing rules</span></a>.</p>
<dl class="coq cmd">
<dt id="coq:cmd.definition">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Definition</span> <span class="hole">ident</span> <span>:=</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:cmd.definition" title="Permalink to this definition">¶</a></dt>
<dd><p>This command binds <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> to the name <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> in the environment,
provided that <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> is well-typed.</p>
<dl class="coq exn">
<dt id="coq:exn.ident-already-exists-definition">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">ident</span> <span>already</span> <span>exists.</span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Definition</span> <span class="hole">ident</span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>:=</span> <span class="hole">term</span></span></code></dt>
<dd><p>This variant checks that the type of <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code> is definitionally equal to
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, and registers <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> as being of type
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, and bound to value <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>.</p>
<dl class="coq exn">
<dt id="coq:exn.the-term-term-has-type-type-while-it-is-expected-to-have-type-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>The</span> <span>term</span> <span class="hole">term</span> <span>has</span> <span>type</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>while</span> <span>it</span> <span>is</span> <span>expected</span> <span>to</span> <span>have</span> <span>type</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a><span>'.</span></span></code><a class="headerlink" href="#coq:exn.the-term-term-has-type-type-while-it-is-expected-to-have-type-type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Definition</span> <span class="hole">ident</span> <span class="hole">binders</span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="hole">term</span></span></code></dt>
<dd><p>This is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Definition</span></span> <span class="hole"><span class="pre">ident</span></span><span><span class="pre"> : forall</span></span> <span class="hole"><span class="pre">binders</span></span><span><span class="pre">,</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre"> := fun</span></span> <span class="hole"><span class="pre">binders</span></span><span><span class="pre"> =&gt; </span></span><span class="hole"><span class="pre">term</span></span></span></code>.</p>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.local-definition">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Local</span> <span>Definition</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:cmdv.local-definition" title="Permalink to this definition">¶</a></dt>
<dd><p>Such definitions are never made accessible through their
unqualified name by <a class="reference internal" href="gallina-extensions.html#coq:cmd.import" title="Import"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Import</span></code></a> and its variants.
You have to explicitly give their fully qualified name to refer to them.</p>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.example">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Example</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:cmdv.example" title="Permalink to this definition">¶</a></dt>
<dd><p>This is equivalent to <a class="reference internal" href="#coq:cmd.definition" title="Definition"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Definition</span></code></a>.</p>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.let-outside-a-section">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Let</span> <span class="hole">ident</span> <span>:=</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:cmdv.let-outside-a-section" title="Permalink to this definition">¶</a></dt>
<dd><p>Outside of any section, this variant is a synonym of
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Local</span></span> <span><span class="pre">Definition</span></span> <span class="hole"><span class="pre">ident</span></span> <span><span class="pre">:=</span></span> <span class="hole"><span class="pre">term</span></span></span></code>.
For its meaning inside a section, see <a class="reference internal" href="gallina-extensions.html#coq:cmd.let" title="Let"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Let</span></code></a> in
<a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>.</p>
<dl class="coq warn">
<dt id="coq:warn.ident-is-declared-as-a-local-definition-local-declaration-scope">
<em class="property"><span class="sigannot">Warning</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">ident</span> <span>is</span> <span>declared</span> <span>as</span> <span>a</span> <span>local</span> <span>definition</span> <span>[local-declaration,scope]</span></span></code><a class="headerlink" href="#coq:warn.ident-is-declared-as-a-local-definition-local-declaration-scope" title="Permalink to this definition">¶</a></dt>
<dd><p>Warning generated when using <a class="reference internal" href="gallina-extensions.html#coq:cmd.let" title="Let"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Let</span></code></a> instead of
<a class="reference internal" href="#coq:cmdv.local-definition" title="Local Definition"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Local</span> <span class="pre">Definition</span></code></a>.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Section <a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>, commands <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.opaque" title="Opaque"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Opaque</span></code></a>,
<a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.transparent" title="Transparent"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Transparent</span></code></a>, and tactic <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.unfold" title="unfold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unfold</span></code></a>.</p>
</div>
</div>
<div class="section" id="inductive-definitions">
<span id="gallina-inductive-definitions"></span><h3>Inductive definitions<a class="headerlink" href="#inductive-definitions" title="Permalink to this headline">¶</a></h3>
<p>We gradually explain simple inductive types, simple annotated inductive
types, simple parametric inductive types, mutually inductive types. We
explain also co-inductive types.</p>
<div class="section" id="simple-inductive-types">
<h4>Simple inductive types<a class="headerlink" href="#simple-inductive-types" title="Permalink to this headline">¶</a></h4>
<dl class="coq cmd">
<dt id="coq:cmd.inductive">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Inductive</span> <span class="hole">ident</span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">sort</span></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <span class="hole">ident</span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat">| <span class="hole">ident</span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmd.inductive" title="Permalink to this definition">¶</a></dt>
<dd><p>This command defines a simple inductive type and its constructors.
The first <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is the name of the inductively defined type
and <code class="xref std std-token docutils literal notranslate"><span class="pre">sort</span></code> is the universe where it lives. The next <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>s
are the names of its constructors and <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> their respective types.
Depending on the universe where the inductive type <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> lives
(e.g. its type <code class="xref std std-token docutils literal notranslate"><span class="pre">sort</span></code>), Coq provides a number of destructors.
Destructors are named <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><code class="docutils literal notranslate"><span class="pre">_sind</span></code>,:token:<code class="docutils literal notranslate"><span class="pre">ident</span></code><code class="docutils literal notranslate"><span class="pre">_ind</span></code>,
<code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><code class="docutils literal notranslate"><span class="pre">_rec</span></code> or <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><code class="docutils literal notranslate"><span class="pre">_rect</span></code> which respectively
correspond to elimination principles on <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">SProp</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Set</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code>.
The type of the destructors expresses structural induction/recursion
principles over objects of type <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>.
The constant <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><code class="docutils literal notranslate"><span class="pre">_ind</span></code> is always provided,
whereas <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><code class="docutils literal notranslate"><span class="pre">_rec</span></code> and <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code><code class="docutils literal notranslate"><span class="pre">_rect</span></code> can be
impossible to derive (for example, when <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is a proposition).</p>
<dl class="coq exn">
<dt id="coq:exn.non-strictly-positive-occurrence-of-ident-in-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Non</span> <span>strictly</span> <span>positive</span> <span>occurrence</span> <span>of</span> <span class="hole">ident</span> <span>in</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.non-strictly-positive-occurrence-of-ident-in-type" title="Permalink to this definition">¶</a></dt>
<dd><p>The types of the constructors have to satisfy a <em>positivity condition</em>
(see Section <a class="reference internal" href="cic.html#positivity"><span class="std std-ref">Positivity Condition</span></a>). This condition ensures the soundness of
the inductive definition.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.the-conclusion-of-type-is-not-valid-it-must-be-built-from-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>The</span> <span>conclusion</span> <span>of</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>is</span> <span>not</span> <span>valid;</span> <span>it</span> <span>must</span> <span>be</span> <span>built</span> <span>from</span> <span class="hole">ident</span><span>.</span></span></code><a class="headerlink" href="#coq:exn.the-conclusion-of-type-is-not-valid-it-must-be-built-from-ident" title="Permalink to this definition">¶</a></dt>
<dd><p>The conclusion of the type of the constructors must be the inductive type
<code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> being defined (or <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> applied to arguments in
the case of annotated inductive types — cf. next section).</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The set of natural numbers is defined as:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">nat</span> : <span class="kt">Set</span> :=
| O : nat
| S : nat -&gt; nat.</span></span></span></pre></div><p>The type nat is defined as the least <code class="code highlight coq docutils literal notranslate"><span class="keyword type"><span class="pre">Set</span></span></code> containing <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> and closed by
the <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">S</span></span></code> constructor. The names <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">nat</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">S</span></span></code> are added to the
environment.</p>
<p>Now let us have a look at the elimination principles. They are three of them:
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">nat_ind</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">nat_rec</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">nat_rect</span></span></code>. The type of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">nat_ind</span></span></code> is:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chk0" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chk0"><span class="highlight"><span class="kn">Check</span> nat_ind.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">nat_ind
     : <span class="kr">forall</span> <span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>,
       P O -&gt;
       (<span class="kr">forall</span> <span class="nv">n</span> : nat, P n -&gt; P (S n)) -&gt;
       <span class="kr">forall</span> <span class="nv">n</span> : nat, P n</span></blockquote></div></div></small></span></pre></div><p>This is the well known structural induction principle over natural
numbers, i.e. the second-order form of Peano’s induction principle. It
allows proving some universal property of natural numbers (<code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">forall</span></span>
<span class="name variable"><span class="pre">n</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">n</span></span></code>) by induction on <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>.</p>
<p>The types of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">nat_rec</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">nat_rect</span></span></code> are similar, except that they pertain
to <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Set</span></span><span class="operator"><span class="pre">)</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Type</span></span><span class="operator"><span class="pre">)</span></span></code> respectively. They correspond to
primitive induction principles (allowing dependent types) respectively
over sorts <code class="docutils literal notranslate"><span class="pre">Set</span></code> and <code class="docutils literal notranslate"><span class="pre">Type</span></code>.</p>
</div>
<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Inductive</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <span class="hole">sort</span></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span></span></code></dt>
<dd><p>Constructors <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>s can come with <code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code> in which case,
the actual type of the constructor is <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">forall</span></span> <span class="hole"><span class="pre">binders</span></span><span><span class="pre">,</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code>.</p>
<p>In the case where inductive types have no annotations (next section
gives an example of such annotations), a constructor can be defined
by only giving the type of its arguments.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">nat</span> : <span class="kt">Set</span> := O | S (_:nat).</span></span></span></pre></div></div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="simple-annotated-inductive-types">
<h4>Simple annotated inductive types<a class="headerlink" href="#simple-annotated-inductive-types" title="Permalink to this headline">¶</a></h4>
<p>In an annotated inductive types, the universe where the inductive type
is defined is no longer a simple sort, but what is called an arity,
which is a type whose conclusion is a sort.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>As an example of annotated inductive types, let us define the
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code> predicate:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">even</span> : nat -&gt; <span class="kt">Prop</span> :=
| even_0 : even O
| even_SS : <span class="kr">forall</span> <span class="nv">n</span>:nat, even n -&gt; even (S (S n)).</span></span></span></pre></div><p>The type <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Prop</span></span></code> means that even is a unary predicate (inductively
defined) over natural numbers. The type of its two constructors are the
defining clauses of the predicate even. The type of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">even_ind</span></span></code> is:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chk1" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chk1"><span class="highlight"><span class="kn">Check</span> even_ind.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">even_ind
     : <span class="kr">forall</span> <span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>,
       P O -&gt;
       (<span class="kr">forall</span> <span class="nv">n</span> : nat, even n -&gt; P n -&gt; P (S (S n))) -&gt;
       <span class="kr">forall</span> <span class="nv">n</span> : nat, even n -&gt; P n</span></blockquote></div></div></small></span></pre></div><p>From a mathematical point of view it asserts that the natural numbers satisfying
the predicate even are exactly in the smallest set of naturals satisfying the
clauses <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">even_0</span></span></code> or <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">even_SS</span></span></code>. This is why, when we want to prove any
predicate <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> over elements of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code>, it is enough to prove it for <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code>
and to prove that if any natural number <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> satisfies <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> its double
successor <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">))</span></span></code> satisfies also <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code>. This is indeed analogous to the
structural induction principle we got for <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">nat</span></span></code>.</p>
</div>
</div>
<div class="section" id="parameterized-inductive-types">
<h4>Parameterized inductive types<a class="headerlink" href="#parameterized-inductive-types" title="Permalink to this headline">¶</a></h4>
<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Inductive</span> <span class="hole">ident</span> <span class="hole">binders</span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <span class="hole">ident</span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat">| <span class="hole">ident</span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>In the previous example, each constructor introduces a different
instance of the predicate <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code>. In some cases, all the constructors
introduce the same generic instance of the inductive definition, in
which case, instead of an annotation, we use a context of parameters
which are <code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code> shared by all the constructors of the definition.</p>
<p>Parameters differ from inductive type annotations in the fact that the
conclusion of each type of constructor invoke the inductive type with
the same values of parameters as its specification.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>A typical example is the definition of polymorphic lists:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">list</span> (<span class="nv">A</span>:<span class="kt">Set</span>) : <span class="kt">Set</span> :=
| nil : list A
| cons : A -&gt; list A -&gt; list A.</span></span></span></pre></div><p>In the type of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">nil</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">cons</span></span></code>, we write <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">list</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">)</span></span></code> and not
just <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">list</span></span></code>. The constructors <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">nil</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">cons</span></span></code> will have respectively
types:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chk2" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chk2"><span class="highlight"><span class="kn">Check</span> nil.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">nil
     : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Set</span>, list A</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chk3" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chk3"><span class="highlight"><span class="kn">Check</span> cons.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">cons
     : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Set</span>, A -&gt; list A -&gt; list A</span></blockquote></div></div></small></span></pre></div><p>Types of destructors are also quantified with <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">Set</span></span><span class="operator"><span class="pre">)</span></span></code>.</p>
<p>Once again, it is possible to specify only the type of the arguments
of the constructors, and to omit the type of the conclusion:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">list</span> (<span class="nv">A</span>:<span class="kt">Set</span>) : <span class="kt">Set</span> := nil | cons (_:A) (_:list A).</span></span></span></pre></div></div>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li><p>It is possible in the type of a constructor, to
invoke recursively the inductive definition on an argument which is not
the parameter itself.</p>
<p>One can define :</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">list2</span> (<span class="nv">A</span>:<span class="kt">Set</span>) : <span class="kt">Set</span> :=
| nil2 : list2 A
| cons2 : A -&gt; list2 (A*A) -&gt; list2 A.</span></span></span></pre></div><p>that can also be written by specifying only the type of the arguments:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">list2</span> (<span class="nv">A</span>:<span class="kt">Set</span>) : <span class="kt">Set</span> := nil2 | cons2 (_:A) (_:list2 (A*A)).</span></span></span></pre></div><p>But the following definition will give an error:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chk4" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chk4"><span class="highlight"><span class="kn">Fail</span> <span class="kn">Inductive</span> <span class="nf">listw</span> (<span class="nv">A</span>:<span class="kt">Set</span>) : <span class="kt">Set</span> :=
| nilw : listw (A*A)
| consw : A -&gt; listw (A*A) -&gt; listw (A*A).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
Last occurrence of <span class="s2">&quot;listw&quot;</span> must <span class="nb">have</span> <span class="s2">&quot;A&quot;</span> <span class="kr">as</span> <span class="mi">1</span>st argument <span class="kr">in</span>
 <span class="s2">&quot;listw (A * A)%type&quot;</span>.</span></blockquote></div></div></small></span></pre></div><p>because the conclusion of the type of constructors should be <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">listw</span></span> <span class="name"><span class="pre">A</span></span></code>
in both cases.</p>
</li>
<li><p>A parameterized inductive definition can be defined using annotations
instead of parameters but it will sometimes give a different (bigger)
sort for the inductive definition and will produce a less convenient
rule for case elimination.</p></li>
</ul>
</div>
<dl class="coq flag">
<dt id="coq:flag.uniform-inductive-parameters">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Uniform</span> <span>Inductive</span> <span>Parameters</span></span></code><a class="headerlink" href="#coq:flag.uniform-inductive-parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>When this option is set (it is off by default),
inductive definitions are abstracted over their parameters
before type checking constructors, allowing to write:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Set Uniform Inductive Parameters</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">list3</span> (<span class="nv">A</span>:<span class="kt">Set</span>) : <span class="kt">Set</span> :=
| nil3 : list3
| cons3 : A -&gt; list3 -&gt; list3.</span></span></span></pre></div><p>This behavior is essentially equivalent to starting a new section
and using <a class="reference internal" href="gallina-extensions.html#coq:cmd.context" title="Context"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Context</span></code></a> to give the uniform parameters, like so
(cf. <a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>):</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">list3</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">A</span>:<span class="kt">Set</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">list3</span> : <span class="kt">Set</span> :=
| nil3 : list3
| cons3 : A -&gt; list3 -&gt; list3.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">list3</span>.</span></span></span></pre></div></dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Section <a class="reference internal" href="cic.html#inductive-definitions"><span class="std std-ref">Inductive Definitions</span></a> and the <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> tactic.</p>
</div>
</div>
<div class="section" id="variants">
<h4>Variants<a class="headerlink" href="#variants" title="Permalink to this headline">¶</a></h4>
<dl class="coq cmd">
<dt id="coq:cmd.variant">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Variant</span> <span class="hole">ident</span> <span class="hole">binders</span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <span class="hole">ident</span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat">| <span class="hole">ident</span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmd.variant" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#coq:cmd.variant" title="Variant"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variant</span></code></a> command is identical to the <a class="reference internal" href="#coq:cmd.inductive" title="Inductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Inductive</span></code></a> command, except
that it disallows recursive definition of types (for instance, lists cannot
be defined using <a class="reference internal" href="#coq:cmd.variant" title="Variant"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variant</span></code></a>). No induction scheme is generated for
this variant, unless option <a class="reference internal" href="../user-extensions/proof-schemes.html#coq:flag.nonrecursive-elimination-schemes" title="Nonrecursive Elimination Schemes"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Nonrecursive</span> <span class="pre">Elimination</span> <span class="pre">Schemes</span></code></a> is on.</p>
<dl class="coq exn">
<dt id="coq:exn.the-num-th-argument-of-ident-must-be-ident-in-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>The</span> <span class="hole">num</span> <span>th</span> <span>argument</span> <span>of</span> <span class="hole">ident</span> <span>must</span> <span>be</span> <span class="hole">ident</span> <span>in</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.the-num-th-argument-of-ident-must-be-ident-in-type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="mutually-defined-inductive-types">
<h4>Mutually defined inductive types<a class="headerlink" href="#mutually-defined-inductive-types" title="Permalink to this headline">¶</a></h4>
<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Inductive</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This variant allows defining a block of mutually inductive types.
It has the same semantics as the above <a class="reference internal" href="#coq:cmd.inductive" title="Inductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Inductive</span></code></a> definition for each
<code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>. All <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> are simultaneously added to the environment.
Then well-typing of constructors can be checked. Each one of the <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code>
can be used on its own.</p>
<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Inductive</span> <span class="hole">ident</span> <span class="hole">binders</span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">ident</span> <span class="hole">binders</span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>In this variant, the inductive definitions are parameterized
with <code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code>. However, parameters correspond to a local context
in which the whole set of inductive declarations is done. For this
reason, the parameters must be strictly the same for each inductive types.</p>
</dd></dl>

</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The typical example of a mutual inductive data type is the one for trees and
forests. We assume given two types <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> as variables. It can
be declared the following way.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameters</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Set</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">tree</span> : <span class="kt">Set</span> := node : A -&gt; forest -&gt; tree

<span class="kr">with</span> forest : <span class="kt">Set</span> :=
| leaf : B -&gt; forest
| cons : tree -&gt; forest -&gt; forest.</span></span></span></pre></div><p>This declaration generates automatically six induction principles. They are
respectively called <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">tree_rec</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">tree_ind</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">tree_rect</span></span></code>,
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">forest_rec</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">forest_ind</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">forest_rect</span></span></code>. These ones are not the most
general ones but are just the induction principles corresponding to each
inductive part seen as a single inductive definition.</p>
<p>To illustrate this point on our example, we give the types of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">tree_rec</span></span></code>
and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">forest_rec</span></span></code>.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chk5" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chk5"><span class="highlight"><span class="kn">Check</span> tree_rec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">tree_rec
     : <span class="kr">forall</span> <span class="nv">P</span> : tree -&gt; <span class="kt">Set</span>,
       (<span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">f</span> : forest), P (node a f)) -&gt;
       <span class="kr">forall</span> <span class="nv">t</span> : tree, P t</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chk6" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chk6"><span class="highlight"><span class="kn">Check</span> forest_rec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">forest_rec
     : <span class="kr">forall</span> <span class="nv">P</span> : forest -&gt; <span class="kt">Set</span>,
       (<span class="kr">forall</span> <span class="nv">b</span> : B, P (leaf b)) -&gt;
       (<span class="kr">forall</span> (<span class="nv">t</span> : tree) (<span class="nv">f0</span> : forest),
        P f0 -&gt; P (cons t f0)) -&gt;
       <span class="kr">forall</span> <span class="nv">f1</span> : forest, P f1</span></blockquote></div></div></small></span></pre></div><p>Assume we want to parameterize our mutual inductive definitions with the
two type variables <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code>, the declaration should be
done the following way:</p>
<div class="highlight-coq notranslate"><div class="highlight"><pre><span></span><span class="kn">Inductive</span> <span class="nf">tree</span> <span class="o">(</span><span class="nv">A</span> <span class="nv">B</span><span class="o">:</span><span class="kt">Set</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Set</span> <span class="o">:=</span> <span class="n">node</span> <span class="o">:</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">forest</span> <span class="n">A</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">tree</span> <span class="n">A</span> <span class="n">B</span>

<span class="kr">with</span> <span class="n">forest</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">:</span><span class="kt">Set</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Set</span> <span class="o">:=</span>
<span class="o">|</span> <span class="n">leaf</span> <span class="o">:</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">forest</span> <span class="n">A</span> <span class="n">B</span>
<span class="o">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">tree</span> <span class="n">A</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">forest</span> <span class="n">A</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">forest</span> <span class="n">A</span> <span class="n">B</span><span class="o">.</span>
</pre></div>
</div>
<p>Assume we define an inductive definition inside a section
(cf. <a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>). When the section is closed, the variables
declared in the section and occurring free in the declaration are added as
parameters to the inductive definition.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>A generic command <a class="reference internal" href="../user-extensions/proof-schemes.html#coq:cmd.scheme" title="Scheme"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Scheme</span></code></a> is useful to build automatically various
mutual induction principles.</p>
</div>
</div>
<div class="section" id="co-inductive-types">
<span id="coinductive-types"></span><h4>Co-inductive types<a class="headerlink" href="#co-inductive-types" title="Permalink to this headline">¶</a></h4>
<p>The objects of an inductive type are well-founded with respect to the
constructors of the type. In other words, such objects contain only a
<em>finite</em> number of constructors. Co-inductive types arise from relaxing
this condition, and admitting types whose objects contain an infinity of
constructors. Infinite objects are introduced by a non-ending (but
effective) process of construction, defined in terms of the constructors
of the type.</p>
<dl class="coq cmd">
<dt id="coq:cmd.coinductive">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>CoInductive</span> <span class="hole">ident</span> <span class="hole">binders</span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <span class="hole">ident</span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat">| <span class="hole">ident</span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmd.coinductive" title="Permalink to this definition">¶</a></dt>
<dd><p>This command introduces a co-inductive type.
The syntax of the command is the same as the command <a class="reference internal" href="#coq:cmd.inductive" title="Inductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Inductive</span></code></a>.
No principle of induction is derived from the definition of a co-inductive
type, since such principles only make sense for inductive types.
For co-inductive types, the only elimination principle is case analysis.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<p>An example of a co-inductive type is the type of infinite sequences of
natural numbers, usually called streams.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">CoInductive</span> <span class="nf">Stream</span> : <span class="kt">Set</span> := Seq : nat -&gt; Stream -&gt; Stream.</span></span></span></pre></div><p>The usual destructors on streams <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">hd</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">Stream</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">nat</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">tl</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">Str</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">Str</span></span></code>
can be defined as follows:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">hd</span> (<span class="nv">x</span>:Stream) := <span class="kr">let</span> (<span class="nv">a</span>,s) := x <span class="kr">in</span> a.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">tl</span> (<span class="nv">x</span>:Stream) := <span class="kr">let</span> (<span class="nv">a</span>,s) := x <span class="kr">in</span> s.</span></span></span></pre></div></div>
<p>Definition of co-inductive predicates and blocks of mutually
co-inductive definitions are also allowed.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>An example of a co-inductive predicate is the extensional equality on
streams:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">CoInductive</span> <span class="nf">EqSt</span> : Stream -&gt; Stream -&gt; <span class="kt">Prop</span> :=
  eqst : <span class="kr">forall</span> <span class="nv">s1</span> <span class="nv">s2</span>:Stream,
           hd s1 = hd s2 -&gt; EqSt (tl s1) (tl s2) -&gt; EqSt s1 s2.</span></span></span></pre></div><p>In order to prove the extensional equality of two streams <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">s1</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">s2</span></span></code>
we have to construct an infinite proof of equality, that is, an infinite
object of type <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">EqSt</span></span> <span class="name"><span class="pre">s1</span></span> <span class="name"><span class="pre">s2</span></span><span class="operator"><span class="pre">)</span></span></code>. We will see how to introduce infinite
objects in Section <a class="reference internal" href="#cofixpoint"><span class="std std-ref">Definitions of recursive objects in co-inductive types</span></a>.</p>
</div>
<div class="section" id="caveat">
<h5>Caveat<a class="headerlink" href="#caveat" title="Permalink to this headline">¶</a></h5>
<p>The ability to define co-inductive types by constructors, hereafter called
<em>positive co-inductive types</em>, is known to break subject reduction. The story is
a bit long: this is due to dependent pattern-matching which implies
propositional η-equality, which itself would require full η-conversion for
subject reduction to hold, but full η-conversion is not acceptable as it would
make type-checking undecidable.</p>
<p>Since the introduction of primitive records in Coq 8.5, an alternative
presentation is available, called <em>negative co-inductive types</em>. This consists
in defining a co-inductive type as a primitive record type through its
projections. Such a technique is akin to the <em>co-pattern</em> style that can be
found in e.g. Agda, and preserves subject reduction.</p>
<p>The above example can be rewritten in the following way.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Set Primitive Projections</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">CoInductive</span> <span class="nf">Stream</span> : <span class="kt">Set</span> := Seq { hd : nat; tl : Stream }.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">CoInductive</span> <span class="nf">EqSt</span> (<span class="nv">s1</span> <span class="nv">s2</span>: Stream) : <span class="kt">Prop</span> := eqst {
  eqst_hd : hd s1 = hd s2;
  eqst_tl : EqSt (tl s1) (tl s2);
}.</span></span></span></pre></div><p>Some properties that hold over positive streams are lost when going to the
negative presentation, typically when they imply equality over streams.
For instance, propositional η-equality is lost when going to the negative
presentation. It is nonetheless logically consistent to recover it through an
axiom.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">Stream_eta</span> : <span class="kr">forall</span> <span class="nv">s</span>: Stream, s = Seq (hd s) (tl s).</span></span></span></pre></div><p>More generally, as in the case of positive coinductive types, it is consistent
to further identify extensional equality of coinductive types with propositional
equality:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">Stream_ext</span> : <span class="kr">forall</span> (<span class="nv">s1</span> <span class="nv">s2</span>: Stream), EqSt s1 s2 -&gt; s1 = s2.</span></span></span></pre></div><p>As of Coq 8.9, it is now advised to use negative co-inductive types rather than
their positive counterparts.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="gallina-extensions.html#primitive-projections"><span class="std std-ref">Primitive Projections</span></a> for more information about negative
records and primitive projections.</p>
</div>
</div>
</div>
</div>
<div class="section" id="definition-of-recursive-functions">
<h3>Definition of recursive functions<a class="headerlink" href="#definition-of-recursive-functions" title="Permalink to this headline">¶</a></h3>
<div class="section" id="definition-of-functions-by-recursion-over-inductive-objects">
<h4>Definition of functions by recursion over inductive objects<a class="headerlink" href="#definition-of-functions-by-recursion-over-inductive-objects" title="Permalink to this headline">¶</a></h4>
<p>This section describes the primitive form of definition by recursion over
inductive objects. See the <a class="reference internal" href="gallina-extensions.html#coq:cmd.function" title="Function"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Function</span></code></a> command for more advanced
constructions.</p>
<span class="target" id="fixpoint"></span><dl class="coq cmd">
<dt id="coq:cmd.fixpoint">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Fixpoint</span> <span class="hole">ident</span> <span class="hole">binders</span> <span class="repeat-wrapper"><span class="repeat"><span class="curlies">{<span>struct</span> <span class="hole">ident</span>}</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:cmd.fixpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>This command allows defining functions by pattern matching over inductive
objects using a fixed point construction. The meaning of this declaration is
to define <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> a recursive function with arguments specified by
the <code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code> such that <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> applied to arguments
corresponding to these <code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code> has type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, and is
equivalent to the expression <code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code>. The type of <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> is
consequently <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">forall</span></span> <span class="hole"><span class="pre">binders</span></span><span><span class="pre">,</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> and its value is equivalent
to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">fun</span></span> <span class="hole"><span class="pre">binders</span></span> <span><span class="pre">=&gt;</span></span> <span class="hole"><span class="pre">term</span></span></span></code>.</p>
<p>To be accepted, a <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> definition has to satisfy some syntactical
constraints on a special argument called the decreasing argument. They
are needed to ensure that the <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> definition always terminates.
The point of the <code class="docutils literal notranslate"><span class="notation"><span class="curlies"><span class="pre">{</span><span><span class="pre">struct</span></span> <span class="hole"><span class="pre">ident</span></span><span class="pre">}</span></span></span></code> annotation is to let the user tell the
system which argument decreases along the recursive calls.</p>
<p>The <code class="docutils literal notranslate"><span class="notation"><span class="curlies"><span class="pre">{</span><span><span class="pre">struct</span></span> <span class="hole"><span class="pre">ident</span></span><span class="pre">}</span></span></span></code> annotation may be left implicit, in this case the
system tries successively arguments from left to right until it finds one
that satisfies the decreasing condition.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Some fixpoints may have several arguments that fit as decreasing
arguments, and this choice influences the reduction of the fixpoint.
Hence an explicit annotation must be used if the leftmost decreasing
argument is not the desired one. Writing explicit annotations can also
speed up type checking of large mutual fixpoints.</p></li>
<li><p>In order to keep the strong normalization property, the fixed point
reduction will only be performed when the argument in position of the
decreasing argument (which type should be in an inductive definition)
starts with a constructor.</p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>One can define the addition function as :</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">add</span> (<span class="nv">n</span> <span class="nv">m</span>:nat) {<span class="nv">struct</span> <span class="nv">n</span>} : nat :=
<span class="kr">match</span> n <span class="kr">with</span>
| O =&gt; m
| S p =&gt; S (add p m)
<span class="kr">end</span>.</span></span></span></pre></div><p>The match operator matches a value (here <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>) with the various
constructors of its (inductive) type. The remaining arguments give the
respective values to be returned, as functions of the parameters of the
corresponding constructor. Thus here when <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> equals <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> we return
<code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span></code>, and when <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> equals <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">p</span></span><span class="operator"><span class="pre">)</span></span></code> we return <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">add</span></span> <span class="name"><span class="pre">p</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">))</span></span></code>.</p>
<p>The match operator is formally described in
Section <a class="reference internal" href="cic.html#match-construction"><span class="std std-ref">The match ... with ... end construction</span></a>.
The system recognizes that in the inductive call <code class="code highlight coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">add</span></span> <span class="name"><span class="pre">p</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">)</span></span></code> the first
argument actually decreases because it is a <em>pattern variable</em> coming
from <code class="code highlight coq docutils literal notranslate"><span class="keyword reserved"><span class="pre">match</span></span> <span class="name"><span class="pre">n</span></span> <span class="keyword reserved"><span class="pre">with</span></span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The following definition is not correct and generates an error message:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chk7" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chk7"><span class="highlight"><span class="kn">Fail</span> <span class="kn">Fixpoint</span> <span class="nf">wrongplus</span> (<span class="nv">n</span> <span class="nv">m</span>:nat) {<span class="nv">struct</span> <span class="nv">n</span>} : nat :=
<span class="kr">match</span> m <span class="kr">with</span>
| O =&gt; n
| S p =&gt; S (wrongplus n p)
<span class="kr">end</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
Recursive definition of wrongplus <span class="kr">is</span> ill-formed.
In environment
wrongplus : nat -&gt; nat -&gt; nat
n : nat
m : nat
p : nat
Recursive call to wrongplus has principal argument
equal to <span class="s2">&quot;n&quot;</span> instead of
a subterm of <span class="s2">&quot;n&quot;</span>.
Recursive definition <span class="kr">is</span>:
<span class="s2">&quot;fun n m : nat =&gt;</span>
<span class="s2"> match m with</span>
<span class="s2"> | 0 =&gt; n</span>
<span class="s2"> | S p =&gt; S (wrongplus n p)</span>
<span class="s2"> end&quot;</span>.</span></blockquote></div></div></small></span></pre></div><p>because the declared decreasing argument <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> does not actually
decrease in the recursive call. The function computing the addition over
the second argument should rather be written:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">plus</span> (<span class="nv">n</span> <span class="nv">m</span>:nat) {<span class="nv">struct</span> <span class="nv">m</span>} : nat :=
<span class="kr">match</span> m <span class="kr">with</span>
| O =&gt; n
| S p =&gt; S (plus n p)
<span class="kr">end</span>.</span></span></span></pre></div></div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The recursive call may not only be on direct subterms of the recursive
variable <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> but also on a deeper subterm and we can directly write
the function <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">mod2</span></span></code> which gives the remainder modulo 2 of a natural
number.</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">mod2</span> (<span class="nv">n</span>:nat) : nat :=
<span class="kr">match</span> n <span class="kr">with</span>
| O =&gt; O
| S p =&gt; <span class="kr">match</span> p <span class="kr">with</span>
         | O =&gt; S O
         | S q =&gt; mod2 q
         <span class="kr">end</span>
<span class="kr">end</span>.</span></span></span></pre></div></div>
<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Fixpoint</span> <span class="hole">ident</span> <span class="hole">binders</span> <span class="repeat-wrapper"><span class="repeat"><span class="curlies">{<span>struct</span> <span class="hole">ident</span>}</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">ident</span> <span class="hole">binders</span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="hole">term</span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This variant allows defining simultaneously several mutual fixpoints.
It is especially useful when defining functions over mutually defined
inductive types.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The size of trees and forests can be defined the following way:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">tree_size</span> (<span class="nv">t</span>:tree) : nat :=
<span class="kr">match</span> t <span class="kr">with</span>
| node a f =&gt; S (forest_size f)
<span class="kr">end</span>
<span class="kr">with</span> forest_size (f:forest) : nat :=
<span class="kr">match</span> f <span class="kr">with</span>
| leaf b =&gt; <span class="mi">1</span>
| cons t f&#39; =&gt; (tree_size t + forest_size f&#39;)
<span class="kr">end</span>.</span></span></span></pre></div></div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="definitions-of-recursive-objects-in-co-inductive-types">
<span id="cofixpoint"></span><h4>Definitions of recursive objects in co-inductive types<a class="headerlink" href="#definitions-of-recursive-objects-in-co-inductive-types" title="Permalink to this headline">¶</a></h4>
<dl class="coq cmd">
<dt id="coq:cmd.cofixpoint">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>CoFixpoint</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="hole">term</span></span></code><a class="headerlink" href="#coq:cmd.cofixpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>This command introduces a method for constructing an infinite object of a
coinductive type. For example, the stream containing all natural numbers can
be introduced applying the following method to the number <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> (see
Section <a class="reference internal" href="#coinductive-types"><span class="std std-ref">Co-inductive types</span></a> for the definition of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">Stream</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">hd</span></span></code>
and <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">tl</span></span></code>):</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">CoFixpoint</span> <span class="nf">from</span> (<span class="nv">n</span>:nat) : Stream := Seq n (<span class="kn">from</span> (S n)).</span></span></span></pre></div><p>Oppositely to recursive ones, there is no decreasing argument in a
co-recursive definition. To be admissible, a method of construction must
provide at least one extra constructor of the infinite object for each
iteration. A syntactical guard condition is imposed on co-recursive
definitions in order to ensure this: each recursive call in the
definition must be protected by at least one constructor, and only by
constructors. That is the case in the former definition, where the single
recursive call of <code class="code highlight coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">from</span></span></code> is guarded by an application of <code class="code highlight coq docutils literal notranslate"><span class="name"><span class="pre">Seq</span></span></code>.
On the contrary, the following recursive function does not satisfy the
guard condition:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chk8" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chk8"><span class="highlight"><span class="kn">Fail</span> <span class="kn">CoFixpoint</span> <span class="nf">filter</span> (<span class="nv">p</span>:nat -&gt; bool) (<span class="nv">s</span>:Stream) : Stream :=
  <span class="kr">if</span> p (hd s) <span class="kr">then</span> Seq (hd s) (filter p (tl s)) <span class="kr">else</span> filter p (tl s).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
Recursive definition of filter <span class="kr">is</span> ill-formed.
In environment
filter : (nat -&gt; bool) -&gt; Stream -&gt; Stream
p : nat -&gt; bool
s : Stream
Unguarded recursive call <span class="kr">in</span>
<span class="s2">&quot;filter p (tl s)&quot;</span>.
Recursive definition <span class="kr">is</span>:
<span class="s2">&quot;fun (p : nat -&gt; bool) (s : Stream) =&gt;</span>
<span class="s2"> if p (hd s)</span>
<span class="s2"> then {| hd := hd s; tl := filter p (tl s) |}</span>
<span class="s2"> else filter p (tl s)&quot;</span>.</span></blockquote></div></div></small></span></pre></div><p>The elimination of co-recursive definition is done lazily, i.e. the
definition is expanded only when it occurs at the head of an application
which is the argument of a case analysis expression. In any other
context, it is considered as a canonical expression which is completely
evaluated. We can test this using the command <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.eval" title="Eval"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Eval</span></code></a>, which computes
the normal forms of a term:</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chk9" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chk9"><span class="highlight"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (<span class="kn">from</span> <span class="mi">0</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">= (<span class="kr">cofix</span> <span class="kn">from</span> (n : nat) : Stream :=
     {| hd := n; tl := <span class="kn">from</span> (S n) |}) <span class="mi">0</span>
: Stream</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chka" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chka"><span class="highlight"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (hd (<span class="kn">from</span> <span class="mi">0</span>)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">= <span class="mi">0</span>
: nat</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chkb" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chkb"><span class="highlight"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (tl (<span class="kn">from</span> <span class="mi">0</span>)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">= (<span class="kr">cofix</span> <span class="kn">from</span> (n : nat) : Stream :=
     {| hd := n; tl := <span class="kn">from</span> (S n) |}) <span class="mi">1</span>
: Stream</span></blockquote></div></div></small></span></pre></div><dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>CoFixpoint</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="hole">term</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="hole">term</span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>As in the <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> command, it is possible to introduce a block of
mutually dependent methods.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="assertions-and-proofs">
<span id="assertions"></span><h3>Assertions and proofs<a class="headerlink" href="#assertions-and-proofs" title="Permalink to this headline">¶</a></h3>
<p>An assertion states a proposition (or a type) of which the proof (or an
inhabitant of the type) is interactively built using tactics. The interactive
proof mode is described in Chapter <a class="reference internal" href="../proof-engine/proof-handling.html#proofhandling"><span class="std std-ref">Proof handling</span></a> and the tactics in
Chapter <a class="reference internal" href="../proof-engine/tactics.html#tactics"><span class="std std-ref">Tactics</span></a>. The basic assertion command is:</p>
<dl class="coq cmd">
<dt id="coq:cmd.theorem">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Theorem</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmd.theorem" title="Permalink to this definition">¶</a></dt>
<dd><p>After the statement is asserted, Coq needs a proof. Once a proof of
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> under the assumptions represented by <code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code> is given and
validated, the proof is generalized into a proof of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">forall</span></span> <span class="hole"><span class="pre">binders</span></span><span><span class="pre">,</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> and
the theorem is bound to the name <code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code> in the environment.</p>
<dl class="coq exn">
<dt id="coq:exn.the-term-term-has-type-type-which-should-be-set-prop-or-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>The</span> <span>term</span> <span class="hole">term</span> <span>has</span> <span>type</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>which</span> <span>should</span> <span>be</span> <span>Set,</span> <span>Prop</span> <span>or</span> <span>Type.</span></span></code><a class="headerlink" href="#coq:exn.the-term-term-has-type-type-which-should-be-set-prop-or-type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.ident-already-exists-theorem">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span class="hole">ident</span> <span>already</span> <span>exists.</span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-theorem" title="Permalink to this definition">¶</a></dt>
<dd><p>The name you provided is already defined. You have then to choose
another name.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.nested-proofs-are-not-allowed-unless-you-turn-option-nested-proofs-allowed-on">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Nested</span> <span>proofs</span> <span>are</span> <span>not</span> <span>allowed</span> <span>unless</span> <span>you</span> <span>turn</span> <span>option</span> <span>Nested</span> <span>Proofs</span> <span>Allowed</span> <span>on.</span></span></code><a class="headerlink" href="#coq:exn.nested-proofs-are-not-allowed-unless-you-turn-option-nested-proofs-allowed-on" title="Permalink to this definition">¶</a></dt>
<dd><p>You are asserting a new statement while already being in proof editing mode.
This feature, called nested proofs, is disabled by default.
To activate it, turn option <a class="reference internal" href="../proof-engine/proof-handling.html#coq:flag.nested-proofs-allowed" title="Nested Proofs Allowed"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Nested</span> <span class="pre">Proofs</span> <span class="pre">Allowed</span></code></a> on.</p>
</dd></dl>

<dl class="coq cmdv">
<dt id="coq:cmdv.lemma">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Lemma</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.lemma" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.remark">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Remark</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.remark" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.fact">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Fact</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.fact" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.corollary">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Corollary</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.corollary" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.proposition">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Proposition</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.proposition" title="Permalink to this definition">¶</a></dt>
<dd><p>These commands are all synonyms of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Theorem</span></span> <span class="hole"><span class="pre">ident</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">binders</span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span class="pre">:</span></span> <span><span class="pre">type</span></span></span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Theorem</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This command is useful for theorems that are proved by simultaneous induction
over a mutually inductive assumption, or that assert mutually dependent
statements in some mutual co-inductive type. It is equivalent to
<a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> or <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> but using tactics to build the proof of
the statements (or the body of the specification, depending on the point of
view). The inductive or co-inductive types on which the induction or
coinduction has to be done is assumed to be non ambiguous and is guessed by
the system.</p>
<p>Like in a <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> or <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> definition, the induction hypotheses
have to be used on <em>structurally smaller</em> arguments (for a <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a>) or
be <em>guarded by a constructor</em> (for a <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a>). The verification that
recursive proof arguments are correct is done only at the time of registering
the lemma in the environment. To know if the use of induction hypotheses is
correct at some time of the interactive development of a proof, use the
command <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.guarded" title="Guarded"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Guarded</span></code></a>.</p>
<p>The command can be used also with <a class="reference internal" href="#coq:cmdv.lemma" title="Lemma"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Lemma</span></code></a>, <a class="reference internal" href="#coq:cmdv.remark" title="Remark"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Remark</span></code></a>, etc. instead of
<a class="reference internal" href="#coq:cmd.theorem" title="Theorem"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Theorem</span></code></a>.</p>
</dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Definition</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code></dt>
<dd><p>This allows defining a term of type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> using the proof editing
mode. It behaves as <a class="reference internal" href="#coq:cmd.theorem" title="Theorem"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Theorem</span></code></a> but is intended to be used in conjunction with
<a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a> in order to define a constant of which the computational
behavior is relevant.</p>
<p>The command can be used also with <a class="reference internal" href="#coq:cmdv.example" title="Example"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Example</span></code></a> instead of <a class="reference internal" href="#coq:cmd.definition" title="Definition"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Definition</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.opaque" title="Opaque"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Opaque</span></code></a>, <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.transparent" title="Transparent"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Transparent</span></code></a>, <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.unfold" title="unfold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unfold</span></code></a>.</p>
</div>
</dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Let</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Definition</span></span> <span class="hole"><span class="pre">ident</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">binders</span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> except that the definition is
turned into a let-in definition generalized over the declarations depending
on it after closing the current section.</p>
</dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Fixpoint</span> <span class="hole">ident</span> <span class="hole">binders</span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">ident</span> <span class="hole">binders</span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This generalizes the syntax of <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> so that one or more bodies
can be defined interactively using the proof editing mode (when a
body is omitted, its type is mandatory in the syntax). When the block
of proofs is completed, it is intended to be ended by <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a>.</p>
</dd></dl>

<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>CoFixpoint</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="hole">ident</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">binders</span></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This generalizes the syntax of <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> so that one or more bodies
can be defined interactively using the proof editing mode.</p>
</dd></dl>

<p>A proof starts by the keyword <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.proof" title="Proof"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Proof</span></code></a>. Then Coq enters the proof editing mode
until the proof is completed. The proof editing mode essentially contains
tactics that are described in chapter <a class="reference internal" href="../proof-engine/tactics.html#tactics"><span class="std std-ref">Tactics</span></a>. Besides tactics, there
are commands to manage the proof editing mode. They are described in Chapter
<a class="reference internal" href="../proof-engine/proof-handling.html#proofhandling"><span class="std std-ref">Proof handling</span></a>.</p>
<p>When the proof is completed it should be validated and put in the environment
using the keyword <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>Several statements can be simultaneously asserted provided option
<a class="reference internal" href="../proof-engine/proof-handling.html#coq:flag.nested-proofs-allowed" title="Nested Proofs Allowed"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Nested</span> <span class="pre">Proofs</span> <span class="pre">Allowed</span></code></a> was turned on.</p></li>
<li><p>Not only other assertions but any vernacular command can be given
while in the process of proving a given assertion. In this case, the
command is understood as if it would have been given before the
statements still to be proved. Nonetheless, this practice is discouraged
and may stop working in future versions.</p></li>
<li><p>Proofs ended by <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a> are declared opaque. Their content cannot be
unfolded (see <a class="reference internal" href="../proof-engine/tactics.html#performingcomputations"><span class="std std-ref">Performing computations</span></a>), thus
realizing some form of <em>proof-irrelevance</em>. To be able to unfold a
proof, the proof should be ended by <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a>.</p></li>
<li><p><a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.proof" title="Proof"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Proof</span></code></a> is recommended but can currently be omitted. On the opposite
side, <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a> (or <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a>) is mandatory to validate a proof.</p></li>
<li><p>One can also use <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.admitted" title="Admitted"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Admitted</span></code></a> in place of <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a> to turn the
current asserted statement into an axiom and exit the proof editing mode.</p></li>
</ol>
</div>
</div>
<div class="section" id="attributes">
<span id="gallina-attributes"></span><h3>Attributes<a class="headerlink" href="#attributes" title="Permalink to this headline">¶</a></h3>
<p>Any vernacular command can be decorated with a list of attributes, enclosed
between <code class="docutils literal notranslate"><span class="pre">#[</span></code> (hash and opening square bracket) and <code class="docutils literal notranslate"><span class="pre">]</span></code> (closing square bracket)
and separated by commas <code class="docutils literal notranslate"><span class="pre">,</span></code>. Multiple space-separated blocks may be provided.</p>
<p>Each attribute has a name (an identifier) and may have a value.
A value is either a <a class="reference internal" href="#grammar-token-string"><code class="xref std std-token docutils literal notranslate"><span class="pre">string</span></code></a> (in which case it is specified with an equal <code class="docutils literal notranslate"><span class="pre">=</span></code> sign),
or a list of attributes, enclosed within brackets.</p>
<p>Some attributes are specific to a command, and so are described with
that command. Currently, the following attributes are recognized by a
variety of commands:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">universes(monomorphic)</span></code>, <code class="docutils literal notranslate"><span class="pre">universes(polymorphic)</span></code></dt><dd><p>Equivalent to the <code class="docutils literal notranslate"><span class="pre">Monomorphic</span></code> and
<code class="docutils literal notranslate"><span class="pre">Polymorphic</span></code> flags (see <a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphicuniverses"><span class="std std-ref">Polymorphic Universes</span></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">program</span></code></dt><dd><p>Takes no value, equivalent to the <code class="docutils literal notranslate"><span class="pre">Program</span></code> flag
(see <a class="reference internal" href="../addendum/program.html#programs"><span class="std std-ref">Program</span></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">global</span></code>, <code class="docutils literal notranslate"><span class="pre">local</span></code></dt><dd><p>Take no value, equivalent to the <code class="docutils literal notranslate"><span class="pre">Global</span></code> and <code class="docutils literal notranslate"><span class="pre">Local</span></code> flags
(see <a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-locality-of-commands"><span class="std std-ref">Controlling the locality of commands</span></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">deprecated</span></code></dt><dd><p>Takes as value the optional attributes <code class="docutils literal notranslate"><span class="pre">since</span></code> and <code class="docutils literal notranslate"><span class="pre">note</span></code>;
both have a string value.</p>
<p>This attribute can trigger the following warnings:</p>
<dl class="coq warn">
<dt id="coq:warn.tactic-qualid-is-deprecated-since-string-string">
<em class="property"><span class="sigannot">Warning</span></em> <code class="sig-name descname"><span class="notation"><span>Tactic</span> <span class="hole">qualid</span> <span>is</span> <span>deprecated</span> <span>since</span> <a class="reference internal" href="#grammar-token-string"><span class="hole">string</span></a><span>.</span> <a class="reference internal" href="#grammar-token-string"><span class="hole">string</span></a><span>.</span></span></code><a class="headerlink" href="#coq:warn.tactic-qualid-is-deprecated-since-string-string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq warn">
<dt id="coq:warn.tactic-notation-qualid-is-deprecated-since-string-string">
<em class="property"><span class="sigannot">Warning</span></em> <code class="sig-name descname"><span class="notation"><span>Tactic</span> <span>Notation</span> <span class="hole">qualid</span> <span>is</span> <span>deprecated</span> <span>since</span> <a class="reference internal" href="#grammar-token-string"><span class="hole">string</span></a><span>.</span> <a class="reference internal" href="#grammar-token-string"><span class="hole">string</span></a><span>.</span></span></code><a class="headerlink" href="#coq:warn.tactic-notation-qualid-is-deprecated-since-string-string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require</span> Program.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">#[program] <span class="kn">Definition</span> <span class="nf">one</span> : nat := S _.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chkc" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chkc"><span class="highlight"><span class="kn">Next Obligation</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">nat</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">exact</span> O.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">#[deprecated(since=<span class="s2">&quot;8.9.0&quot;</span>, note=<span class="s2">&quot;Use idtac instead.&quot;</span>)]
<span class="kn">Ltac</span> <span class="nf">foo</span> := <span class="kp">idtac</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chkd" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chkd"><span class="highlight"><span class="kn">Goal</span> <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chke" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chke"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="gallina-specification-language-rst-chkf" style="display: none" type="checkbox"><label class="coq-input" for="gallina-specification-language-rst-chkf"><span class="highlight"><span class="bp">now</span> foo.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-responses"><blockquote class="coq-response"><span class="highlight">Tactic foo <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">9</span>.<span class="mi">0</span>.
Use <span class="kp">idtac</span> instead. [deprecated-tactic,deprecated]</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre></div></div>
<dl class="footnote brackets">
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>This is similar to the expression “<em>entry</em> <span class="math notranslate nohighlight">\(\{\)</span> sep <em>entry</em>
<span class="math notranslate nohighlight">\(\}\)</span>” in standard BNF, or “<em>entry</em> <span class="math notranslate nohighlight">\((\)</span> sep <em>entry</em>
<span class="math notranslate nohighlight">\()\)</span>*” in the syntax of regular expressions.</p>
</dd>
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id4">2</a></span></dt>
<dd><p>Except if the inductive type is empty in which case there is no
equation that can be used to infer the return type.</p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gallina-extensions.html" class="btn btn-neutral float-right" title="Extensions of Gallina" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../changes.html" class="btn btn-neutral float-left" title="Recent changes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>