<!DOCTYPE html>
<html><head><title>Equality.v</title><meta charset="utf-8"><meta content="Alectryon v0.2" name="generator"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet"><link href="https://unpkg.com/firacode/distr/fira_code.css" rel="stylesheet"><link href="alectryon.css" rel="stylesheet"><script src="alectryon.js"></script><style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-standalone alectryon-centered alectryon-coqdoc"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="sd">(************************************************************************)</span>
<span class="c">(*         *   The Coq Proof Assistant / The Coq Development Team       *)</span>
<span class="c">(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)</span>
<span class="c">(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)</span>
<span class="c">(*   \VV/  **************************************************************)</span>
<span class="c">(*    //   *    This file is distributed under the terms of the         *)</span>
<span class="c">(*         *     GNU Lesser General Public License Version 2.1          *)</span>
<span class="c">(*         *     (see LICENSE file for the text of the license)         *)</span>
<span class="sd">(************************************************************************)</span></span></span></pre><div class="doc">
Tactics related to (dependent) equality and proof irrelevance. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Export</span> JMeq.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Coq.Program.Tactics.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">is_ground_goal</span> := 
  <span class="kr">match goal with</span>
    |- ?T =&gt; is_ground T
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Try to find a contradiction. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Extern</span> <span class="mi">10</span> =&gt; is_ground_goal ; <span class="kp">progress</span> <span class="nb">exfalso</span> : <span class="nb">exfalso</span>.</span></span></span></pre><div class="doc">
We will use the <span class="inlinecode"><span class="id" title="var">block</span></span> definition to separate the goal from the 
   equalities generated by the tactic. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">block</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">a</span> : A) := a.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">block_goal</span> := <span class="kr">match goal with</span> [ |- ?T ] =&gt; <span class="nb">change</span> (block T) <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">unblock_goal</span> := <span class="nb">unfold</span> block <span class="kr">in</span> *.</span></span></span></pre><div class="doc">
Notation for heterogeneous equality. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot; x ~= y &quot;</span> := (@JMeq _ x _ y) (<span class="kn">at level</span> <span class="mi">70</span>, <span class="kn">no associativity</span>).</span></span></span></pre><div class="doc">
Do something on an heterogeneous equality appearing in the context. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">on_JMeq</span> tac :=
  <span class="kr">match goal with</span>
    | [ H : @JMeq ?x ?X ?y ?Y |- _ ] =&gt; tac H
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Try to apply <span class="inlinecode"><span class="id" title="var">JMeq_eq</span></span> to get back a regular equality when the two types are equal. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simpl_one_JMeq</span> :=
  on_JMeq <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">H</span> =&gt; <span class="nb">apply</span> JMeq_eq <span class="kr">in</span> H).</span></span></span></pre><div class="doc">
Repeat it for every possible hypothesis. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simpl_JMeq</span> := <span class="kp">repeat</span> simpl_one_JMeq.</span></span></span></pre><div class="doc">
Just simplify an h.eq. without clearing it. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simpl_one_dep_JMeq</span> :=
  on_JMeq
  <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">H</span> =&gt; <span class="kr">let</span> <span class="nv">H&#39;</span> := <span class="kp">fresh</span> <span class="s2">&quot;H&quot;</span> <span class="kr">in</span>
    <span class="nb">assert</span> (H&#39; := JMeq_eq H)).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Eqdep.</span></span></span></pre><div class="doc">
Simplify dependent equality using sigmas to equality of the second projections if possible.
   Uses UIP. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simpl_existT</span> :=
  <span class="kr">match goal with</span>
    [ H : existT _ ?x _ = existT _ ?x _ |- _ ] =&gt;
    <span class="kr">let</span> <span class="nv">Hi</span> := <span class="kp">fresh</span> H <span class="kr">in</span> <span class="nb">assert</span>(Hi:=inj_pairT2 _ _ _ _ _ H) ; <span class="nb">clear</span> H
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simpl_existTs</span> := <span class="kp">repeat</span> simpl_existT.</span></span></span></pre><div class="doc">
Tries to eliminate a call to <span class="inlinecode"><span class="id" title="var">eq_rect</span></span> (the substitution principle) by any means available. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">elim_eq_rect</span> :=
  <span class="kr">match goal with</span>
    | [ |- ?t ] =&gt;
      <span class="kr">match</span> t <span class="kr">with</span>
        | <span class="kp">context</span> [ @eq_rect _ _ _ _ _ ?p ] =&gt;
          <span class="kr">let</span> <span class="nv">P</span> := <span class="kp">fresh</span> <span class="s2">&quot;P&quot;</span> <span class="kr">in</span>
            <span class="nb">set</span> (P := p); <span class="nb">simpl</span> <span class="kr">in</span> P ;
	      ((<span class="nb">case</span> P ; <span class="nb">clear</span> P) || (<span class="nb">clearbody</span> P; <span class="nb">rewrite</span> (UIP_refl _ _ P); <span class="nb">clear</span> P))
        | <span class="kp">context</span> [ @eq_rect _ _ _ _ _ ?p _ ] =&gt;
          <span class="kr">let</span> <span class="nv">P</span> := <span class="kp">fresh</span> <span class="s2">&quot;P&quot;</span> <span class="kr">in</span>
            <span class="nb">set</span> (P := p); <span class="nb">simpl</span> <span class="kr">in</span> P ;
	      ((<span class="nb">case</span> P ; <span class="nb">clear</span> P) || (<span class="nb">clearbody</span> P; <span class="nb">rewrite</span> (UIP_refl _ _ P); <span class="nb">clear</span> P))
      <span class="kr">end</span>
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Rewrite using uniqueness of identity proofs <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">eq_refl</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simpl_uip</span> :=
  <span class="kr">match goal with</span>
    [ H : ?X = ?X |- _ ] =&gt; <span class="nb">rewrite</span> (UIP_refl _ _ H) <span class="kr">in</span> *; <span class="nb">clear</span> H
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Simplify equalities appearing in the context and goal. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simpl_eq</span> := <span class="nb">simpl</span> ; <span class="nb">unfold</span> eq_rec_r, eq_rec ; <span class="kp">repeat</span> (elim_eq_rect ; <span class="nb">simpl</span>) ; <span class="kp">repeat</span> (simpl_uip ; <span class="nb">simpl</span>).</span></span></span></pre><div class="doc">
Try to abstract a proof of equality, if no proof of the same equality is present in the context. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">abstract_eq_hyp</span> H&#39; p :=
  <span class="kr">let</span> <span class="nv">ty</span> := <span class="kp">type of</span> p <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">tyred</span> := <span class="kp">eval</span> <span class="nb">simpl</span> <span class="kr">in</span> ty <span class="kr">in</span>
    <span class="kr">match</span> tyred <span class="kr">with</span>
      ?X = ?Y =&gt;
      <span class="kr">match goal with</span>
        | [ H : X = Y |- _ ] =&gt; <span class="kp">fail</span> <span class="mi">1</span>
        | _ =&gt; <span class="nb">set</span> (H&#39;:=p) ; <span class="kp">try</span> (<span class="nb">change</span> p <span class="kr">with</span> H&#39;) ; <span class="nb">clearbody</span> H&#39; ; <span class="nb">simpl</span> <span class="kr">in</span> H&#39;
      <span class="kr">end</span>
    <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Apply the tactic tac to proofs of equality appearing as coercion arguments.
   Just redefine this tactic (using <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span> <span class="inlinecode"><span class="id" title="var">on_coerce_proof</span></span> <span class="inlinecode"><span class="id" title="var">tac</span></span> <span class="inlinecode">::=</span>) to handle custom coercion operators.
   
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">on_coerce_proof</span> tac T :=
  <span class="kr">match</span> T <span class="kr">with</span>
    | <span class="kp">context</span> [ eq_rect _ _ _ _ ?p ] =&gt; tac p
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">on_coerce_proof_gl</span> tac :=
  <span class="kr">match goal with</span>
    [ |- ?T ] =&gt; on_coerce_proof tac T
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Abstract proofs of equalities of coercions. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">abstract_eq_proof</span> := on_coerce_proof_gl <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">p</span> =&gt; <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;eqH&quot;</span> <span class="kr">in</span> abstract_eq_hyp H p).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">abstract_eq_proofs</span> := <span class="kp">repeat</span> abstract_eq_proof.</span></span></span></pre><div class="doc">
Factorize proofs, by using proof irrelevance so that two proofs of the same equality
   in the goal become convertible. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">pi_eq_proof_hyp</span> p :=
  <span class="kr">let</span> <span class="nv">ty</span> := <span class="kp">type of</span> p <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">tyred</span> := <span class="kp">eval</span> <span class="nb">simpl</span> <span class="kr">in</span> ty <span class="kr">in</span>
  <span class="kr">match</span> tyred <span class="kr">with</span>
    ?X = ?Y =&gt;
    <span class="kr">match goal with</span>
      | [ H : X = Y |- _ ] =&gt;
        <span class="kr">match</span> p <span class="kr">with</span>
          | H =&gt; <span class="kp">fail</span> <span class="mi">2</span>
          | _ =&gt; <span class="nb">rewrite</span> (UIP _ X Y p H)
        <span class="kr">end</span>
      | _ =&gt; <span class="kp">fail</span> <span class="s2">&quot; No hypothesis with same type &quot;</span>
    <span class="kr">end</span>
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Factorize proofs of equality appearing as coercion arguments. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">pi_eq_proof</span> := on_coerce_proof_gl pi_eq_proof_hyp.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">pi_eq_proofs</span> := <span class="kp">repeat</span> pi_eq_proof.</span></span></span></pre><div class="doc">
The two preceding tactics in sequence. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">clear_eq_proofs</span> :=
  abstract_eq_proofs ; pi_eq_proofs.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Rewrite</span> &lt;- eq_rect_eq : refl_id.</span></span></span></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">refl_id</span></span> database should be populated with lemmas of the form
   <span class="inlinecode"><span class="id" title="var">coerce_</span>√ó</span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">eq_refl</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk0" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">JMeq_eq_refl</span> {<span class="nv">A</span>} (<span class="nv">x</span> : A) : JMeq_eq (@JMeq_refl _ x) = eq_refl.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">JMeq_eq JMeq_refl = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk1" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">JMeq_eq JMeq_refl = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> UIP.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk2" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk2"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">UIP_refl_refl</span> <span class="nv">A</span> (<span class="nv">x</span> : A) :
  Eqdep.EqdepTheory.UIP_refl A x eq_refl = eq_refl.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">UIP_refl A x eq_refl = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk3" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">UIP_refl A x eq_refl = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> UIP_refl.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk4" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk4"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">inj_pairT2_refl</span> <span class="nv">A</span> (<span class="nv">x</span> : A) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">p</span> : P x) :
  Eqdep.EqdepTheory.inj_pairT2 A P x p p eq_refl = eq_refl.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inj_pairT2 A P x p p eq_refl = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk5" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk5"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inj_pairT2 A P x p p eq_refl = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> UIP_refl.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Rewrite</span> @JMeq_eq_refl @UIP_refl_refl @inj_pairT2_refl : refl_id.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">rewrite_refl_id</span> := <span class="nb">autorewrite with</span> refl_id.</span></span></span></pre><div class="doc">
Clear the context and goal of equality proofs. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">clear_eq_ctx</span> :=
  rewrite_refl_id ; clear_eq_proofs.</span></span></span></pre><div class="doc">
Reapeated elimination of <span class="inlinecode"><span class="id" title="var">eq_rect</span></span> applications.
   Abstracting equalities makes it run much faster than an naive implementation. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simpl_eqs</span> :=
  <span class="kp">repeat</span> (elim_eq_rect ; <span class="nb">simpl</span> ; clear_eq_ctx).</span></span></span></pre><div class="doc">
Clear unused reflexivity proofs. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">clear_refl_eq</span> :=
  <span class="kr">match goal with</span> [ H : ?X = ?X |- _ ] =&gt; <span class="nb">clear</span> H <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">clear_refl_eqs</span> := <span class="kp">repeat</span> clear_refl_eq.</span></span></span></pre><div class="doc">
Clear unused equality proofs. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">clear_eq</span> :=
  <span class="kr">match goal with</span> [ H : _ = _ |- _ ] =&gt; <span class="nb">clear</span> H <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">clear_eqs</span> := <span class="kp">repeat</span> clear_eq.</span></span></span></pre><div class="doc">
Combine all the tactics to simplify goals containing coercions. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simplify_eqs</span> :=
  <span class="nb">simpl</span> ; simpl_eqs ; clear_eq_ctx ; clear_refl_eqs ;
    <span class="kp">try</span> <span class="nb">subst</span> ; <span class="nb">simpl</span> ; <span class="kp">repeat</span> simpl_uip ; rewrite_refl_id.</span></span></span></pre><div class="doc">
A tactic that tries to remove trivial equality guards in induction hypotheses coming
   from <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> <span class="inlinecode"><span class="id" title="tactic">induction</span></span>/<span class="inlinecode"><span class="id" title="tactic">generalize_eqs</span></span> invocations. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simplify_IH_hyps</span> := <span class="kp">repeat</span>
  <span class="kr">match goal with</span>
    | [ hyp : <span class="kp">context</span> [ block _ ] |- _ ] =&gt; 
      specialize_eqs hyp
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
We split substitution tactics in the two directions depending on which 
   names we want to keep corresponding to the generalization performed by the
   <span class="inlinecode"><span class="id" title="tactic">generalize_eqs</span></span> tactic. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">subst_left_no_fail</span> :=
  <span class="kp">repeat</span> (<span class="kr">match goal with</span>
            [ H : ?X = ?Y |- _ ] =&gt; <span class="nb">subst</span> X
          <span class="kr">end</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">subst_right_no_fail</span> :=
  <span class="kp">repeat</span> (<span class="kr">match goal with</span>
            [ H : ?X = ?Y |- _ ] =&gt; <span class="nb">subst</span> Y
          <span class="kr">end</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">inject_left</span> H :=
  <span class="kp">progress</span> (<span class="nb">inversion</span> H ; subst_left_no_fail ; clear_dups) ; <span class="nb">clear</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">inject_right</span> H :=
  <span class="kp">progress</span> (<span class="nb">inversion</span> H ; subst_right_no_fail ; clear_dups) ; <span class="nb">clear</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">autoinjections_left</span> := <span class="kp">repeat</span> autoinjection <span class="kp">ltac</span>:(inject_left).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">autoinjections_right</span> := <span class="kp">repeat</span> autoinjection <span class="kp">ltac</span>:(inject_right).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simpl_depind</span> := subst_no_fail ; autoinjections ; <span class="kp">try</span> discriminates ; 
  simpl_JMeq ; simpl_existTs ; simplify_IH_hyps.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simpl_depind_l</span> := subst_left_no_fail ; autoinjections_left ; <span class="kp">try</span> discriminates ; 
  simpl_JMeq ; simpl_existTs ; simplify_IH_hyps.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simpl_depind_r</span> := subst_right_no_fail ; autoinjections_right ; <span class="kp">try</span> discriminates ; 
  simpl_JMeq ; simpl_existTs ; simplify_IH_hyps.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">blocked</span> t := block_goal ; t ; unblock_goal.</span></span></span></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">DependentEliminationPackage</span></span> provides the default dependent elimination principle to
   be used by the <span class="inlinecode"><span class="id" title="var">equations</span></span> resolver. It is especially useful to register the dependent elimination
   principles for things in <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> which are not automatically generated. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">DependentEliminationPackage</span> (<span class="nv">A</span> : <span class="kt">Type</span>) :=
  { elim_type : <span class="kt">Type</span> ; <span class="nb">elim</span> : elim_type }.</span></span></span></pre><div class="doc">
A higher-order tactic to apply a registered eliminator. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">elim_tac</span> tac p :=
  <span class="kr">let</span> <span class="nv">ty</span> := <span class="kp">type of</span> p <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">eliminator</span> := <span class="kp">eval</span> <span class="nb">simpl</span> <span class="kr">in</span> (@<span class="nb">elim</span> (_ : DependentEliminationPackage ty)) <span class="kr">in</span>
    tac p eliminator.</span></span></span></pre><div class="doc">
Specialization to do case analysis or induction.
   Note: the <span class="inlinecode"><span class="id" title="var">equations</span></span> tactic tries <span class="inlinecode"><span class="id" title="tactic">case</span></span> before <span class="inlinecode"><span class="id" title="var">elim_case</span></span>: there is no need to register
   generated induction principles. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">elim_case</span> p := elim_tac <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">p</span> <span class="nv">el</span> =&gt; <span class="nb">destruct</span> p <span class="nb">using</span> el) p.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">elim_ind</span> p := elim_tac <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">p</span> <span class="nv">el</span> =&gt; <span class="nb">induction</span> p <span class="nb">using</span> el) p.</span></span></span></pre><div class="doc">
Lemmas used by the simplifier, mainly rephrasings of <span class="inlinecode"><span class="id" title="var">eq_rect</span></span>, <span class="inlinecode"><span class="id" title="var">eq_ind</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk6" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk6"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">solution_left</span> <span class="nv">A</span> (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">t</span> : A) :
  B t -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, x = t -&gt; B x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">B t -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, x = t -&gt; B x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk7" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">B t -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, x = t -&gt; B x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span>; <span class="nb">subst</span>; <span class="bp">assumption</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk8" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk8"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">solution_right</span> <span class="nv">A</span> (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">t</span> : A) :
  B t -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, t = x -&gt; B x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">B t -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, t = x -&gt; B x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk9" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">B t -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, t = x -&gt; B x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span>; <span class="nb">subst</span>; <span class="bp">assumption</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chka" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chka"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">deletion</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">t</span> : A) : B -&gt; (t = t -&gt; B).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">B -&gt; t = t -&gt; B</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chkb" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chkb"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">B -&gt; t = t -&gt; B</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span>; <span class="bp">assumption</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chkc" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chkc"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">simplification_heq</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">x</span> <span class="nv">y</span> : A) :
  (x = y -&gt; B) -&gt; (JMeq x y -&gt; B).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(x = y -&gt; B) -&gt; x ~= y -&gt; B</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chkd" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chkd"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(x = y -&gt; B) -&gt; x ~= y -&gt; B</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span> H J; <span class="nb">apply</span> H; <span class="nb">apply</span> (JMeq_eq J).</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">conditional_eq</span> {<span class="nv">A</span>} (<span class="nv">x</span> <span class="nv">y</span> : A) := eq x y.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chke" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chke"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">simplification_existT2</span> <span class="nv">A</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) <span class="nv">B</span> (<span class="nv">p</span> : A) (<span class="nv">x</span> <span class="nv">y</span> : P p) :
  (x = y -&gt; B) -&gt; (conditional_eq (existT P p x) (existT P p y) -&gt; B).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P p</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(x = y -&gt; B) -&gt;
conditional_eq (existT P p x) (existT P p y) -&gt; B</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chkf" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chkf"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P p</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(x = y -&gt; B) -&gt;
conditional_eq (existT P p x) (existT P p y) -&gt; B</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk10" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk10"><span class="highlight"><span class="nb">intros</span> H E.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P p</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">conditional_eq (existT P p x) (existT P p y)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">B</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk11" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk11"><span class="highlight"><span class="nb">apply</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P p</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">conditional_eq (existT P p x) (existT P p y)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x = y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk12" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk12"><span class="highlight"><span class="nb">apply</span> inj_pair2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P p</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">conditional_eq (existT P p x) (existT P p y)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">existT P p x = existT P p y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk13" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk13"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">simplification_existT1</span> <span class="nv">A</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) <span class="nv">B</span> (<span class="nv">p</span> <span class="nv">q</span> : A) (<span class="nv">x</span> : P p) (<span class="nv">y</span> : P q) :
  (p = q -&gt; conditional_eq (existT P p x) (existT P q y) -&gt; B) -&gt; (existT P p x = existT P q y -&gt; B).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P p</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P q</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(p = q -&gt;
 conditional_eq (existT P p x) (existT P q y) -&gt; B) -&gt;
existT P p x = existT P q y -&gt; B</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk14" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk14"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P p</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P q</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(p = q -&gt;
 conditional_eq (existT P p x) (existT P q y) -&gt; B) -&gt;
existT P p x = existT P q y -&gt; B</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk15" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk15"><span class="highlight"><span class="nb">injection</span> <span class="mi">2</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P p</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">p = q -&gt;
conditional_eq (existT P p x) (existT P q y) -&gt; B</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">existT P p x = existT P q y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">existT (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; P x0) p x =
existT (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; P x0) q y -&gt; p = q -&gt; B</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk16" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk16"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">simplification_K</span> <span class="nv">A</span> (<span class="nv">x</span> : A) (<span class="nv">B</span> : x = x -&gt; <span class="kt">Type</span>) :
  B eq_refl -&gt; (<span class="kr">forall</span> <span class="nv">p</span> : x = x, B p).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x -&gt; <span class="kt">Type</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">B eq_refl -&gt; <span class="kr">forall</span> <span class="nv">p</span> : x = x, B p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk17" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk17"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x -&gt; <span class="kt">Type</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">B eq_refl -&gt; <span class="kr">forall</span> <span class="nv">p</span> : x = x, B p</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk18" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk18"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">B eq_refl</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">B p</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Equality-v-chk19" style="display: none" type="checkbox"><label class="coq-input" for="Equality-v-chk19"><span class="highlight"><span class="nb">rewrite</span> (UIP_refl A).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">B eq_refl</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">B eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Defined</span>.</span></span></span></pre><div class="doc">
This hint database and the following tactic can be used with <span class="inlinecode"><span class="id" title="var">autounfold</span></span> to 
   unfold everything to <span class="inlinecode"><span class="id" title="var">eq_rect</span></span>s. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Unfold</span> solution_left solution_right deletion simplification_heq
  simplification_existT1 simplification_existT2 simplification_K
  eq_rect_r eq_rec eq_ind : dep_elim.</span></span></span></pre><div class="doc">
Using these we can make a simplifier that will perform the unification
   steps needed to put the goal in normalised form (provided there are only
   constructor forms). Compare with the lemma 16 of the paper.
   We don't have a <span class="inlinecode"><span class="id" title="var">noCycle</span></span> procedure yet. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simplify_one_dep_elim_term</span> c :=
  <span class="kr">match</span> c <span class="kr">with</span>
    | @JMeq _ _ _ _ -&gt; _ =&gt; <span class="nb">refine</span> (simplification_heq _ _ _ _ _)
    | ?t = ?t -&gt; _ =&gt; <span class="nb">intros</span> _ || <span class="nb">refine</span> (simplification_K _ t _ _)
    | eq (existT _ _ _) (existT _ _ _) -&gt; _ =&gt;
        <span class="nb">refine</span> (simplification_existT1 _ _ _ _ _ _ _ _)
    | conditional_eq (existT _ _ _) (existT _ _ _) -&gt; _ =&gt;
        <span class="nb">refine</span> (simplification_existT2 _ _ _ _ _ _ _) ||
               (<span class="nb">unfold</span> conditional_eq; <span class="nb">intro</span>)
    | ?x = ?y -&gt; _ =&gt; <span class="c">(* variables case *)</span>
      (<span class="nb">unfold</span> x) || (<span class="nb">unfold</span> y) ||
      (<span class="kr">let</span> <span class="nv">hyp</span> := <span class="kp">fresh</span> <span class="kr">in</span> <span class="nb">intros</span> hyp ;
        <span class="nb">move</span> hyp <span class="nb">before</span> x ; revert_until hyp ; <span class="nb">generalize dependent</span> x ;
          <span class="nb">refine</span> (solution_left _ _ _ _)<span class="c">(*  ; intros until 0 *)</span>) ||
      (<span class="kr">let</span> <span class="nv">hyp</span> := <span class="kp">fresh</span> <span class="kr">in</span> <span class="nb">intros</span> hyp ;
        <span class="nb">move</span> hyp <span class="nb">before</span> y ; revert_until hyp ; <span class="nb">generalize dependent</span> y ;
          <span class="nb">refine</span> (solution_right _ _ _ _)<span class="c">(*  ; intros until 0 *)</span>)
    | ?f ?x = ?g ?y -&gt; _ =&gt; <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="kr">in</span> <span class="kp">progress</span> (<span class="nb">intros</span> H ; simple <span class="nb">injection</span> H; <span class="nb">clear</span> H)
    | ?t = ?u -&gt; _ =&gt; <span class="kr">let</span> <span class="nv">hyp</span> := <span class="kp">fresh</span> <span class="kr">in</span>
      <span class="nb">intros</span> hyp ; <span class="nb">exfalso</span> ; <span class="bp">discriminate</span>
    | ?x = ?y -&gt; _ =&gt; <span class="kr">let</span> <span class="nv">hyp</span> := <span class="kp">fresh</span> <span class="kr">in</span>
      <span class="nb">intros</span> hyp ; (<span class="kp">try</span> (<span class="nb">clear</span> hyp ; <span class="c">(* If non dependent, don&#39;t clear it! *)</span> <span class="kp">fail</span> <span class="mi">1</span>)) ;
        <span class="nb">case</span> hyp ; <span class="nb">clear</span> hyp
    | block ?T =&gt; <span class="kp">fail</span> <span class="mi">1</span> <span class="c">(* Do not put any part of the rhs in the hyps *)</span>
    | <span class="kr">forall</span> <span class="nv">x</span>, _ =&gt; <span class="nb">intro</span> x || (<span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> x <span class="kr">in</span> <span class="nb">rename</span> x <span class="nb">into</span> H ; <span class="nb">intro</span> x) <span class="c">(* Try to keep original names *)</span>
    | _ =&gt; <span class="nb">intro</span>
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simplify_one_dep_elim</span> :=
  <span class="kr">match goal with</span>
    | [ |- ?gl ] =&gt; simplify_one_dep_elim_term gl
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Repeat until no progress is possible. By construction, it should leave the goal with
   no remaining equalities generated by the <span class="inlinecode"><span class="id" title="tactic">generalize_eqs</span></span> tactic. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simplify_dep_elim</span> := <span class="kp">repeat</span> simplify_one_dep_elim.</span></span></span></pre><div class="doc">
Do dependent elimination of the last hypothesis, but not simplifying yet
   (used internally). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">destruct_last</span> :=
  on_last_hyp <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">id</span> =&gt; <span class="nb">simpl</span> <span class="kr">in</span> id ; generalize_eqs id ; <span class="nb">destruct</span> id).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">introduce</span> p := <span class="kp">first</span> [
  <span class="kr">match</span> p <span class="kr">with</span> _ =&gt; <span class="c">(* Already there, generalize dependent hyps *)</span>
    <span class="nb">generalize dependent</span> p ; <span class="nb">intros</span> p
  <span class="kr">end</span>
  | <span class="nb">intros until</span> p | <span class="nb">intros until</span> <span class="mi">1</span> | <span class="nb">intros</span> ].</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">do_case</span> p := introduce p ; (<span class="nb">destruct</span> p || elim_case p || (<span class="nb">case</span> p ; <span class="nb">clear</span> p)).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">do_ind</span> p := introduce p ; (<span class="nb">induction</span> p || elim_ind p).</span></span></span></pre><div class="doc">
The following tactics allow to do induction on an already instantiated inductive predicate
   by first generalizing it and adding the proper equalities to the context, in a maner similar to
   the BasicElim tactic of "Elimination with a motive" by Conor McBride. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The <span class="inlinecode"><span class="id" title="var">do_depelim</span></span> higher-order tactic takes an elimination tactic as argument and an hypothesis 
   and starts a dependent elimination using this tactic. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">is_introduced</span> H :=
  <span class="kr">match goal with</span>
    | [ H&#39; : _ |- _ ] =&gt; <span class="kr">match</span> H&#39; <span class="kr">with</span> H =&gt; <span class="kp">idtac</span> <span class="kr">end</span>
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;intro_block&quot;</span> hyp(H) :=
  (is_introduced H ; block_goal ; revert_until H ; block_goal) ||
    (<span class="kr">let</span> <span class="nv">H&#39;</span> := <span class="kp">fresh</span> H <span class="kr">in</span> <span class="nb">intros until</span> H&#39; ; block_goal) || (<span class="nb">intros</span> ; block_goal).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;intro_block_id&quot;</span> <span class="kn">ident</span>(H) :=
  (is_introduced H ; block_goal ; revert_until H; block_goal) ||
    (<span class="kr">let</span> <span class="nv">H&#39;</span> := <span class="kp">fresh</span> H <span class="kr">in</span> <span class="nb">intros until</span> H&#39; ; block_goal) || (<span class="nb">intros</span> ; block_goal).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">unblock_dep_elim</span> :=
  <span class="kr">match goal with</span>
    | |- block ?T =&gt; 
      <span class="kr">match</span> T <span class="kr">with</span> <span class="kp">context</span> [ block _ ] =&gt; 
        <span class="nb">change</span> T ; <span class="nb">intros</span> ; unblock_goal
      <span class="kr">end</span>
    | _ =&gt; unblock_goal
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simpl_dep_elim</span> := simplify_dep_elim ; simplify_IH_hyps ; unblock_dep_elim.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">do_intros</span> H :=
  (<span class="kp">try</span> <span class="nb">intros until</span> H) ; (intro_block_id H || intro_block H).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">do_depelim_nosimpl</span> tac H := do_intros H ; generalize_eqs H ; tac H.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">do_depelim</span> tac H := do_depelim_nosimpl tac H ; simpl_dep_elim.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">do_depind</span> tac H := 
  (<span class="kp">try</span> <span class="nb">intros until</span> H) ; intro_block H ;
  generalize_eqs_vars H ; tac H ; simpl_dep_elim.</span></span></span></pre><div class="doc">
To dependent elimination on some hyp. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">depelim</span> id := do_depelim <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; do_case hyp) id.</span></span></span></pre><div class="doc">
Used internally. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">depelim_nosimpl</span> id := do_depelim_nosimpl <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; do_case hyp) id.</span></span></span></pre><div class="doc">
To dependent induction on some hyp. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">depind</span> id := do_depind <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; do_ind hyp) id.</span></span></span></pre><div class="doc">
A variant where generalized variables should be given by the user. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">do_depelim&#39;</span> rev tac H :=
  (<span class="kp">try</span> <span class="nb">intros until</span> H) ; block_goal ; 
  (<span class="kp">try</span> revert_until H ; block_goal) ; 
  generalize_eqs H ; rev H ; tac H ; simpl_dep_elim.</span></span></span></pre><div class="doc">
Calls <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> on the generalized hypothesis, results should be similar to inversion.
   By default, we don't try to generalize the hyp by its variable indices.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;dependent&quot;</span> <span class="s2">&quot;destruction&quot;</span> <span class="kn">ident</span>(H) := 
  do_depelim&#39; <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; <span class="kp">idtac</span>) <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; do_case hyp) H.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;dependent&quot;</span> <span class="s2">&quot;destruction&quot;</span> <span class="kn">ident</span>(H) <span class="s2">&quot;using&quot;</span> <span class="kp">constr</span>(c) := 
  do_depelim&#39; <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; <span class="kp">idtac</span>) <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; <span class="nb">destruct</span> hyp <span class="nb">using</span> c) H.</span></span></span></pre><div class="doc">
This tactic also generalizes the goal by the given variables before the elimination. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;dependent&quot;</span> <span class="s2">&quot;destruction&quot;</span> <span class="kn">ident</span>(H) <span class="s2">&quot;generalizing&quot;</span> ne_hyp_list(l) := 
  do_depelim&#39; <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; <span class="nb">revert</span> l) <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; do_case hyp) H.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;dependent&quot;</span> <span class="s2">&quot;destruction&quot;</span> <span class="kn">ident</span>(H) <span class="s2">&quot;generalizing&quot;</span> ne_hyp_list(l) <span class="s2">&quot;using&quot;</span> <span class="kp">constr</span>(c) := 
  do_depelim&#39; <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; <span class="nb">revert</span> l) <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; <span class="nb">destruct</span> hyp <span class="nb">using</span> c) H.</span></span></span></pre><div class="doc">
Then we have wrappers for usual calls to induction. One can customize the induction tactic by 
   writing another wrapper calling do_depelim. We suppose the hyp has to be generalized before
   calling <span class="inlinecode"><span class="id" title="tactic">induction</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;dependent&quot;</span> <span class="s2">&quot;induction&quot;</span> <span class="kn">ident</span>(H) :=
  do_depind <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; do_ind hyp) H.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;dependent&quot;</span> <span class="s2">&quot;induction&quot;</span> <span class="kn">ident</span>(H) <span class="s2">&quot;using&quot;</span> <span class="kp">constr</span>(c) :=
  do_depind <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; <span class="nb">induction</span> hyp <span class="nb">using</span> c) H.</span></span></span></pre><div class="doc">
This tactic also generalizes the goal by the given variables before the induction. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;dependent&quot;</span> <span class="s2">&quot;induction&quot;</span> <span class="kn">ident</span>(H) <span class="s2">&quot;generalizing&quot;</span> ne_hyp_list(l) := 
  do_depelim&#39; <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; <span class="nb">revert</span> l) <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; do_ind hyp) H.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;dependent&quot;</span> <span class="s2">&quot;induction&quot;</span> <span class="kn">ident</span>(H) <span class="s2">&quot;generalizing&quot;</span> ne_hyp_list(l) <span class="s2">&quot;using&quot;</span> <span class="kp">constr</span>(c) := 
  do_depelim&#39; <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; <span class="nb">revert</span> l) <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; <span class="nb">induction</span> hyp <span class="nb">using</span> c) H.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;dependent&quot;</span> <span class="s2">&quot;induction&quot;</span> <span class="kn">ident</span>(H) <span class="s2">&quot;in&quot;</span> ne_hyp_list(l) :=
  do_depelim&#39; <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; <span class="kp">idtac</span>) <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; <span class="nb">induction</span> hyp <span class="kr">in</span> l) H.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;dependent&quot;</span> <span class="s2">&quot;induction&quot;</span> <span class="kn">ident</span>(H) <span class="s2">&quot;in&quot;</span> ne_hyp_list(l) <span class="s2">&quot;using&quot;</span> <span class="kp">constr</span>(c) := 
  do_depelim&#39; <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; <span class="kp">idtac</span>) <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">hyp</span> =&gt; <span class="nb">induction</span> hyp <span class="kr">in</span> l <span class="nb">using</span> c) H.</span></span></span></pre></article></body></html>