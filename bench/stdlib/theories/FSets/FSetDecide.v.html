<!DOCTYPE html>
<html><head><title>FSetDecide.v</title><meta charset="utf-8"><meta content="Alectryon v0.2" name="generator"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet"><link href="https://unpkg.com/firacode/distr/fira_code.css" rel="stylesheet"><link href="alectryon.css" rel="stylesheet"><script src="alectryon.js"></script><style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-standalone alectryon-centered"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="sd">(************************************************************************)</span>
<span class="c">(*         *   The Coq Proof Assistant / The Coq Development Team       *)</span>
<span class="c">(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)</span>
<span class="c">(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)</span>
<span class="c">(*   \VV/  **************************************************************)</span>
<span class="c">(*    //   *    This file is distributed under the terms of the         *)</span>
<span class="c">(*         *     GNU Lesser General Public License Version 2.1          *)</span>
<span class="c">(*         *     (see LICENSE file for the text of the license)         *)</span>
<span class="sd">(************************************************************************)</span>

<span class="sd">(**************************************************************)</span>
<span class="c">(* FSetDecide.v                                               *)</span>
<span class="c">(*                                                            *)</span>
<span class="c">(* Author: Aaron Bohannon                                     *)</span>
<span class="sd">(**************************************************************)</span>

<span class="sd">(** This file implements a decision procedure for a certain</span>
<span class="sd">    class of propositions involving finite sets.  *)</span>

</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Decidable Setoid DecidableTypeEx FSetFacts.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="sd">(** First, a version for Weak Sets in functorial presentation *)</span>

</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">WDecide_fun</span> (E : DecidableType)(<span class="kn">Import</span> M : WSfun E).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">F</span> := FSetFacts.WFacts_fun E M.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="sd">(** * Overview</span>
<span class="sd">    This functor defines the tactic [fsetdec], which will</span>
<span class="sd">    solve any valid goal of the form</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">    forall s1 ... sn,</span>
<span class="sd">    forall x1 ... xm,</span>
<span class="sd">    P1 -&gt; ... -&gt; Pk -&gt; P</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">    where [P]&#39;s are defined by the grammar:</span>
<span class="sd">&lt;&lt;</span>

<span class="sd">P ::=</span>
<span class="sd">| Q</span>
<span class="sd">| Empty F</span>
<span class="sd">| Subset F F&#39;</span>
<span class="sd">| Equal F F&#39;</span>

<span class="sd">Q ::=</span>
<span class="sd">| E.eq X X&#39;</span>
<span class="sd">| In X F</span>
<span class="sd">| Q /\ Q&#39;</span>
<span class="sd">| Q \/ Q&#39;</span>
<span class="sd">| Q -&gt; Q&#39;</span>
<span class="sd">| Q &lt;-&gt; Q&#39;</span>
<span class="sd">| ~ Q</span>
<span class="sd">| True</span>
<span class="sd">| False</span>

<span class="sd">F ::=</span>
<span class="sd">| S</span>
<span class="sd">| empty</span>
<span class="sd">| singleton X</span>
<span class="sd">| add X F</span>
<span class="sd">| remove X F</span>
<span class="sd">| union F F&#39;</span>
<span class="sd">| inter F F&#39;</span>
<span class="sd">| diff F F&#39;</span>

<span class="sd">X ::= x1 | ... | xm</span>
<span class="sd">S ::= s1 | ... | sn</span>

<span class="sd">&gt;&gt;</span>

<span class="sd">The tactic will also work on some goals that vary slightly from</span>
<span class="sd">the above form:</span>
<span class="sd">- The variables and hypotheses may be mixed in any order and may</span>
<span class="sd">  have already been introduced into the context.  Moreover,</span>
<span class="sd">  there may be additional, unrelated hypotheses mixed in (these</span>
<span class="sd">  will be ignored).</span>
<span class="sd">- A conjunction of hypotheses will be handled as easily as</span>
<span class="sd">  separate hypotheses, i.e., [P1 /\ P2 -&gt; P] can be solved iff</span>
<span class="sd">  [P1 -&gt; P2 -&gt; P] can be solved.</span>
<span class="sd">- [fsetdec] should solve any goal if the FSet-related hypotheses</span>
<span class="sd">  are contradictory.</span>
<span class="sd">- [fsetdec] will first perform any necessary zeta and beta</span>
<span class="sd">  reductions and will invoke [subst] to eliminate any Coq</span>
<span class="sd">  equalities between finite sets or their elements.</span>
<span class="sd">- If [E.eq] is convertible with Coq&#39;s equality, it will not</span>
<span class="sd">  matter which one is used in the hypotheses or conclusion.</span>
<span class="sd">- The tactic can solve goals where the finite sets or set</span>
<span class="sd">  elements are expressed by Coq terms that are more complicated</span>
<span class="sd">  than variables.  However, non-local definitions are not</span>
<span class="sd">  expanded, and Coq equalities between non-variable terms are</span>
<span class="sd">  not used.  For example, this goal will be solved:</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">    forall (f : t -&gt; t),</span>
<span class="sd">    forall (g : elt -&gt; elt),</span>
<span class="sd">    forall (s1 s2 : t),</span>
<span class="sd">    forall (x1 x2 : elt),</span>
<span class="sd">    Equal s1 (f s2) -&gt;</span>
<span class="sd">    E.eq x1 (g (g x2)) -&gt;</span>
<span class="sd">    In x1 s1 -&gt;</span>
<span class="sd">    In (g (g x2)) (f s2)</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">  This one will not be solved:</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">    forall (f : t -&gt; t),</span>
<span class="sd">    forall (g : elt -&gt; elt),</span>
<span class="sd">    forall (s1 s2 : t),</span>
<span class="sd">    forall (x1 x2 : elt),</span>
<span class="sd">    Equal s1 (f s2) -&gt;</span>
<span class="sd">    E.eq x1 (g x2) -&gt;</span>
<span class="sd">    In x1 s1 -&gt;</span>
<span class="sd">    g x2 = g (g x2) -&gt;</span>
<span class="sd">    In (g (g x2)) (f s2)</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">*)</span>

  <span class="sd">(** * Facts and Tactics for Propositional Logic</span>
<span class="sd">      These lemmas and tactics are in a module so that they do</span>
<span class="sd">      not affect the namespace if you import the enclosing</span>
<span class="sd">      module [Decide]. *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">FSetLogicalFacts</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Export</span> Decidable.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Export</span> Setoid.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** ** Lemmas and Tactics About Decidable Propositions *)</span>

    <span class="sd">(** ** Propositional Equivalences Involving Negation</span>
<span class="sd">        These are all written with the unfolded form of</span>
<span class="sd">        negation, since I am not sure if setoid rewriting will</span>
<span class="sd">        always perform conversion. *)</span>

    <span class="sd">(** ** Tactics for Negations *)</span>

</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fold&quot;</span> <span class="s2">&quot;any&quot;</span> <span class="s2">&quot;not&quot;</span> :=
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | H: <span class="kp">context</span> [?P -&gt; <span class="kt">False</span>] |- _ =&gt;
          <span class="nb">fold</span> (~ P) <span class="kr">in</span> H
        | |- <span class="kp">context</span> [?P -&gt; <span class="kt">False</span>] =&gt;
          <span class="nb">fold</span> (~ P)
        <span class="kr">end</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** [push not using db] will pushes all negations to the</span>
<span class="sd">        leaves of propositions in the goal, using the lemmas in</span>
<span class="sd">        [db] to assist in checking the decidability of the</span>
<span class="sd">        propositions involved.  If [using db] is omitted, then</span>
<span class="sd">        [core] will be used.  Additional versions are provided</span>
<span class="sd">        to manipulate the hypotheses or the hypotheses and goal</span>
<span class="sd">        together.</span>

<span class="sd">        XXX: This tactic and the similar subsequent ones should</span>
<span class="sd">        have been defined using [autorewrite]. However, dealing</span>
<span class="sd">        with multiples rewrite sites and side-conditions is</span>
<span class="sd">        done more cleverly with the following explicit</span>
<span class="sd">        analysis of goals. *)</span>

</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">or_not_l_iff</span> P Q tac :=
      (<span class="nb">rewrite</span> (or_not_l_iff_1 P Q) <span class="bp">by</span> tac) ||
      (<span class="nb">rewrite</span> (or_not_l_iff_2 P Q) <span class="bp">by</span> tac).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">or_not_r_iff</span> P Q tac :=
      (<span class="nb">rewrite</span> (or_not_r_iff_1 P Q) <span class="bp">by</span> tac) ||
      (<span class="nb">rewrite</span> (or_not_r_iff_2 P Q) <span class="bp">by</span> tac).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">or_not_l_iff_in</span> P Q H tac :=
      (<span class="nb">rewrite</span> (or_not_l_iff_1 P Q) <span class="kr">in</span> H <span class="bp">by</span> tac) ||
      (<span class="nb">rewrite</span> (or_not_l_iff_2 P Q) <span class="kr">in</span> H <span class="bp">by</span> tac).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">or_not_r_iff_in</span> P Q H tac :=
      (<span class="nb">rewrite</span> (or_not_r_iff_1 P Q) <span class="kr">in</span> H <span class="bp">by</span> tac) ||
      (<span class="nb">rewrite</span> (or_not_r_iff_2 P Q) <span class="kr">in</span> H <span class="bp">by</span> tac).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;push&quot;</span> <span class="s2">&quot;not&quot;</span> <span class="s2">&quot;using&quot;</span> <span class="kn">ident</span>(db) :=
      <span class="kr">let</span> <span class="nv">dec</span> := solve_decidable <span class="nb">using</span> db <span class="kr">in</span>
      <span class="nb">unfold</span> not, iff;
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | |- <span class="kp">context</span> [<span class="kt">True</span> -&gt; <span class="kt">False</span>] =&gt; <span class="nb">rewrite</span> not_true_iff
        | |- <span class="kp">context</span> [<span class="kt">False</span> -&gt; <span class="kt">False</span>] =&gt; <span class="nb">rewrite</span> not_false_iff
        | |- <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) -&gt; <span class="kt">False</span>] =&gt; <span class="nb">rewrite</span> (not_not_iff P) <span class="bp">by</span> dec
        | |- <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) -&gt; (?Q -&gt; <span class="kt">False</span>)] =&gt;
            <span class="nb">rewrite</span> (contrapositive P Q) <span class="bp">by</span> dec
        | |- <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) \/ ?Q] =&gt; or_not_l_iff P Q dec
        | |- <span class="kp">context</span> [?P \/ (?Q -&gt; <span class="kt">False</span>)] =&gt; or_not_r_iff P Q dec
        | |- <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) -&gt; ?Q] =&gt; <span class="nb">rewrite</span> (imp_not_l P Q) <span class="bp">by</span> dec
        | |- <span class="kp">context</span> [?P \/ ?Q -&gt; <span class="kt">False</span>] =&gt; <span class="nb">rewrite</span> (not_or_iff P Q)
        | |- <span class="kp">context</span> [?P /\ ?Q -&gt; <span class="kt">False</span>] =&gt; <span class="nb">rewrite</span> (not_and_iff P Q)
        | |- <span class="kp">context</span> [(?P -&gt; ?Q) -&gt; <span class="kt">False</span>] =&gt; <span class="nb">rewrite</span> (not_imp_iff P Q) <span class="bp">by</span> dec
        <span class="kr">end</span>);
      <span class="nb">fold</span> any not.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;push&quot;</span> <span class="s2">&quot;not&quot;</span> :=
      push not <span class="nb">using</span> core.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span>
      <span class="s2">&quot;push&quot;</span> <span class="s2">&quot;not&quot;</span> <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;|-&quot;</span> <span class="s2">&quot;using&quot;</span> <span class="kn">ident</span>(db) :=
      <span class="kr">let</span> <span class="nv">dec</span> := solve_decidable <span class="nb">using</span> db <span class="kr">in</span>
      <span class="nb">unfold</span> not, iff <span class="kr">in</span> * |-;
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | H: <span class="kp">context</span> [<span class="kt">True</span> -&gt; <span class="kt">False</span>] |- _ =&gt; <span class="nb">rewrite</span> not_true_iff <span class="kr">in</span> H
        | H: <span class="kp">context</span> [<span class="kt">False</span> -&gt; <span class="kt">False</span>] |- _ =&gt; <span class="nb">rewrite</span> not_false_iff <span class="kr">in</span> H
        | H: <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) -&gt; <span class="kt">False</span>] |- _ =&gt;
          <span class="nb">rewrite</span> (not_not_iff P) <span class="kr">in</span> H <span class="bp">by</span> dec
        | H: <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) -&gt; (?Q -&gt; <span class="kt">False</span>)] |- _ =&gt;
          <span class="nb">rewrite</span> (contrapositive P Q) <span class="kr">in</span> H <span class="bp">by</span> dec
        | H: <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) \/ ?Q] |- _ =&gt; or_not_l_iff_in P Q H dec
        | H: <span class="kp">context</span> [?P \/ (?Q -&gt; <span class="kt">False</span>)] |- _ =&gt; or_not_r_iff_in P Q H dec
        | H: <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) -&gt; ?Q] |- _ =&gt;
          <span class="nb">rewrite</span> (imp_not_l P Q) <span class="kr">in</span> H <span class="bp">by</span> dec
        | H: <span class="kp">context</span> [?P \/ ?Q -&gt; <span class="kt">False</span>] |- _ =&gt; <span class="nb">rewrite</span> (not_or_iff P Q) <span class="kr">in</span> H
        | H: <span class="kp">context</span> [?P /\ ?Q -&gt; <span class="kt">False</span>] |- _ =&gt; <span class="nb">rewrite</span> (not_and_iff P Q) <span class="kr">in</span> H
        | H: <span class="kp">context</span> [(?P -&gt; ?Q) -&gt; <span class="kt">False</span>] |- _ =&gt;
          <span class="nb">rewrite</span> (not_imp_iff P Q) <span class="kr">in</span> H <span class="bp">by</span> dec
        <span class="kr">end</span>);
      <span class="nb">fold</span> any not.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;push&quot;</span> <span class="s2">&quot;not&quot;</span> <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;|-&quot;</span>  :=
      push not <span class="kr">in</span> * |- <span class="nb">using</span> core.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;push&quot;</span> <span class="s2">&quot;not&quot;</span> <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;using&quot;</span> <span class="kn">ident</span>(db) :=
      push not <span class="nb">using</span> db; push not <span class="kr">in</span> * |- <span class="nb">using</span> db.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;push&quot;</span> <span class="s2">&quot;not&quot;</span> <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
      push not <span class="kr">in</span> * <span class="nb">using</span> core.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** A simple test case to see how this works.  *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk0" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_push</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>,
      decidable P -&gt;
      decidable Q -&gt;
      (~ <span class="kt">True</span>) -&gt;
      (~ <span class="kt">False</span>) -&gt;
      (~ ~ P) -&gt;
      (~ (P /\ Q) -&gt; ~ R) -&gt;
      ((P /\ Q) \/ ~ R) -&gt;
      (~ (P /\ Q) \/ R) -&gt;
      (R \/ ~ (P /\ Q)) -&gt;
      (~ R \/ (P /\ Q)) -&gt;
      (~ P -&gt; R) -&gt;
      (~ ((R -&gt; P) \/ (Q -&gt; R))) -&gt;
      (~ (P /\ R)) -&gt;
      (~ (P -&gt; R)) -&gt;
      <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>,
decidable P -&gt;
decidable Q -&gt;
~ <span class="kt">True</span> -&gt;
~ <span class="kt">False</span> -&gt;
~ ~ P -&gt;
(~ (P /\ Q) -&gt; ~ R) -&gt;
P /\ Q \/ ~ R -&gt;
~ (P /\ Q) \/ R -&gt;
R \/ ~ (P /\ Q) -&gt;
~ R \/ P /\ Q -&gt;
(~ P -&gt; R) -&gt;
~ ((R -&gt; P) \/ (Q -&gt; R)) -&gt;
~ (P /\ R) -&gt; ~ (P -&gt; R) -&gt; <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk1" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>,
decidable P -&gt;
decidable Q -&gt;
~ <span class="kt">True</span> -&gt;
~ <span class="kt">False</span> -&gt;
~ ~ P -&gt;
(~ (P /\ Q) -&gt; ~ R) -&gt;
P /\ Q \/ ~ R -&gt;
~ (P /\ Q) \/ R -&gt;
R \/ ~ (P /\ Q) -&gt;
~ R \/ P /\ Q -&gt;
(~ P -&gt; R) -&gt;
~ ((R -&gt; P) \/ (Q -&gt; R)) -&gt;
~ (P /\ R) -&gt; ~ (P -&gt; R) -&gt; <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk2" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk2"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">decidable P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">decidable Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ <span class="kt">True</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ ~ P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ (P /\ Q) -&gt; ~ R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P /\ Q \/ ~ R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ (P /\ Q) \/ R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R \/ ~ (P /\ Q)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ R \/ P /\ Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P -&gt; R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ ((R -&gt; P) \/ (Q -&gt; R))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ (P /\ R)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H12</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ (P -&gt; R)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk3" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk3"><span class="highlight">push not <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">decidable P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">decidable Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">True</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4, H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R -&gt; P /\ Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6, H7</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P /\ Q -&gt; R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R -&gt; P /\ Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P \/ R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ (R -&gt; P) /\ Q /\ ~ R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P -&gt; ~ R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H12</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P /\ ~ R</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">       <span class="c">(* note that ~(R-&gt;P) remains (since R isn&#39;t decidable) *)</span>
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">tauto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** [pull not using db] will pull as many negations as</span>
<span class="sd">        possible toward the top of the propositions in the goal,</span>
<span class="sd">        using the lemmas in [db] to assist in checking the</span>
<span class="sd">        decidability of the propositions involved.  If [using</span>
<span class="sd">        db] is omitted, then [core] will be used.  Additional</span>
<span class="sd">        versions are provided to manipulate the hypotheses or</span>
<span class="sd">        the hypotheses and goal together. *)</span>

</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pull&quot;</span> <span class="s2">&quot;not&quot;</span> <span class="s2">&quot;using&quot;</span> <span class="kn">ident</span>(db) :=
      <span class="kr">let</span> <span class="nv">dec</span> := solve_decidable <span class="nb">using</span> db <span class="kr">in</span>
      <span class="nb">unfold</span> not, iff;
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | |- <span class="kp">context</span> [<span class="kt">True</span> -&gt; <span class="kt">False</span>] =&gt; <span class="nb">rewrite</span> not_true_iff
        | |- <span class="kp">context</span> [<span class="kt">False</span> -&gt; <span class="kt">False</span>] =&gt; <span class="nb">rewrite</span> not_false_iff
        | |- <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) -&gt; <span class="kt">False</span>] =&gt; <span class="nb">rewrite</span> (not_not_iff P) <span class="bp">by</span> dec
        | |- <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) -&gt; (?Q -&gt; <span class="kt">False</span>)] =&gt;
          <span class="nb">rewrite</span> (contrapositive P Q) <span class="bp">by</span> dec
        | |- <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) \/ ?Q] =&gt; or_not_l_iff P Q dec
        | |- <span class="kp">context</span> [?P \/ (?Q -&gt; <span class="kt">False</span>)] =&gt; or_not_r_iff P Q dec
        | |- <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) -&gt; ?Q] =&gt; <span class="nb">rewrite</span> (imp_not_l P Q) <span class="bp">by</span> dec
        | |- <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) /\ (?Q -&gt; <span class="kt">False</span>)] =&gt;
          <span class="nb">rewrite</span> &lt;- (not_or_iff P Q)
        | |- <span class="kp">context</span> [?P -&gt; ?Q -&gt; <span class="kt">False</span>] =&gt; <span class="nb">rewrite</span> &lt;- (not_and_iff P Q)
        | |- <span class="kp">context</span> [?P /\ (?Q -&gt; <span class="kt">False</span>)] =&gt; <span class="nb">rewrite</span> &lt;- (not_imp_iff P Q) <span class="bp">by</span> dec
        | |- <span class="kp">context</span> [(?Q -&gt; <span class="kt">False</span>) /\ ?P] =&gt;
          <span class="nb">rewrite</span> &lt;- (not_imp_rev_iff P Q) <span class="bp">by</span> dec
        <span class="kr">end</span>);
      <span class="nb">fold</span> any not.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pull&quot;</span> <span class="s2">&quot;not&quot;</span> :=
      pull not <span class="nb">using</span> core.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span>
      <span class="s2">&quot;pull&quot;</span> <span class="s2">&quot;not&quot;</span> <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;|-&quot;</span> <span class="s2">&quot;using&quot;</span> <span class="kn">ident</span>(db) :=
      <span class="kr">let</span> <span class="nv">dec</span> := solve_decidable <span class="nb">using</span> db <span class="kr">in</span>
      <span class="nb">unfold</span> not, iff <span class="kr">in</span> * |-;
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | H: <span class="kp">context</span> [<span class="kt">True</span> -&gt; <span class="kt">False</span>] |- _ =&gt; <span class="nb">rewrite</span> not_true_iff <span class="kr">in</span> H
        | H: <span class="kp">context</span> [<span class="kt">False</span> -&gt; <span class="kt">False</span>] |- _ =&gt; <span class="nb">rewrite</span> not_false_iff <span class="kr">in</span> H
        | H: <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) -&gt; <span class="kt">False</span>] |- _ =&gt;
          <span class="nb">rewrite</span> (not_not_iff P) <span class="kr">in</span> H <span class="bp">by</span> dec
        | H: <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) -&gt; (?Q -&gt; <span class="kt">False</span>)] |- _ =&gt;
          <span class="nb">rewrite</span> (contrapositive P Q) <span class="kr">in</span> H <span class="bp">by</span> dec
        | H: <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) \/ ?Q] |- _ =&gt; or_not_l_iff_in P Q H dec
        | H: <span class="kp">context</span> [?P \/ (?Q -&gt; <span class="kt">False</span>)] |- _ =&gt; or_not_r_iff_in P Q H dec
        | H: <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) -&gt; ?Q] |- _ =&gt;
          <span class="nb">rewrite</span> (imp_not_l P Q) <span class="kr">in</span> H <span class="bp">by</span> dec
        | H: <span class="kp">context</span> [(?P -&gt; <span class="kt">False</span>) /\ (?Q -&gt; <span class="kt">False</span>)] |- _ =&gt;
          <span class="nb">rewrite</span> &lt;- (not_or_iff P Q) <span class="kr">in</span> H
        | H: <span class="kp">context</span> [?P -&gt; ?Q -&gt; <span class="kt">False</span>] |- _ =&gt;
          <span class="nb">rewrite</span> &lt;- (not_and_iff P Q) <span class="kr">in</span> H
        | H: <span class="kp">context</span> [?P /\ (?Q -&gt; <span class="kt">False</span>)] |- _ =&gt;
          <span class="nb">rewrite</span> &lt;- (not_imp_iff P Q) <span class="kr">in</span> H <span class="bp">by</span> dec
        | H: <span class="kp">context</span> [(?Q -&gt; <span class="kt">False</span>) /\ ?P] |- _ =&gt;
          <span class="nb">rewrite</span> &lt;- (not_imp_rev_iff P Q) <span class="kr">in</span> H <span class="bp">by</span> dec
        <span class="kr">end</span>);
      <span class="nb">fold</span> any not.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pull&quot;</span> <span class="s2">&quot;not&quot;</span> <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;|-&quot;</span>  :=
      pull not <span class="kr">in</span> * |- <span class="nb">using</span> core.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pull&quot;</span> <span class="s2">&quot;not&quot;</span> <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;using&quot;</span> <span class="kn">ident</span>(db) :=
      pull not <span class="nb">using</span> db; pull not <span class="kr">in</span> * |- <span class="nb">using</span> db.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pull&quot;</span> <span class="s2">&quot;not&quot;</span> <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
      pull not <span class="kr">in</span> * <span class="nb">using</span> core.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** A simple test case to see how this works.  *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk4" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk4"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_pull</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>,
      decidable P -&gt;
      decidable Q -&gt;
      (~ <span class="kt">True</span>) -&gt;
      (~ <span class="kt">False</span>) -&gt;
      (~ ~ P) -&gt;
      (~ (P /\ Q) -&gt; ~ R) -&gt;
      ((P /\ Q) \/ ~ R) -&gt;
      (~ (P /\ Q) \/ R) -&gt;
      (R \/ ~ (P /\ Q)) -&gt;
      (~ R \/ (P /\ Q)) -&gt;
      (~ P -&gt; R) -&gt;
      (~ (R -&gt; P) /\ ~ (Q -&gt; R)) -&gt;
      (~ P \/ ~ R) -&gt;
      (P /\ ~ R) -&gt;
      (~ R /\ P) -&gt;
      <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>,
decidable P -&gt;
decidable Q -&gt;
~ <span class="kt">True</span> -&gt;
~ <span class="kt">False</span> -&gt;
~ ~ P -&gt;
(~ (P /\ Q) -&gt; ~ R) -&gt;
P /\ Q \/ ~ R -&gt;
~ (P /\ Q) \/ R -&gt;
R \/ ~ (P /\ Q) -&gt;
~ R \/ P /\ Q -&gt;
(~ P -&gt; R) -&gt;
~ (R -&gt; P) /\ ~ (Q -&gt; R) -&gt;
~ P \/ ~ R -&gt; P /\ ~ R -&gt; ~ R /\ P -&gt; <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk5" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk5"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">R</span> : <span class="kt">Prop</span>,
decidable P -&gt;
decidable Q -&gt;
~ <span class="kt">True</span> -&gt;
~ <span class="kt">False</span> -&gt;
~ ~ P -&gt;
(~ (P /\ Q) -&gt; ~ R) -&gt;
P /\ Q \/ ~ R -&gt;
~ (P /\ Q) \/ R -&gt;
R \/ ~ (P /\ Q) -&gt;
~ R \/ P /\ Q -&gt;
(~ P -&gt; R) -&gt;
~ (R -&gt; P) /\ ~ (Q -&gt; R) -&gt;
~ P \/ ~ R -&gt; P /\ ~ R -&gt; ~ R /\ P -&gt; <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk6" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk6"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">decidable P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">decidable Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ <span class="kt">True</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ ~ P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ (P /\ Q) -&gt; ~ R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P /\ Q \/ ~ R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ (P /\ Q) \/ R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R \/ ~ (P /\ Q)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ R \/ P /\ Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P -&gt; R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ (R -&gt; P) /\ ~ (Q -&gt; R)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P \/ ~ R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H12</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P /\ ~ R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H13</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ R /\ P</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk7" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk7"><span class="highlight">pull not <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q, R</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">decidable P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">decidable Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">True</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4, H5</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R -&gt; P /\ Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6, H7</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P /\ Q -&gt; R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">R -&gt; P /\ Q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P \/ R</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ ((R -&gt; P) \/ (Q -&gt; R))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ (P /\ R)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H12, H13</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ (P -&gt; R)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">tauto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">FSetLogicalFacts</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Import</span> FSetLogicalFacts.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
  <span class="sd">(** * Auxiliary Tactics</span>
<span class="sd">      Again, these lemmas and tactics are in a module so that</span>
<span class="sd">      they do not affect the namespace if you import the</span>
<span class="sd">      enclosing module [Decide].  *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">FSetDecideAuxiliary</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** ** Generic Tactics</span>
<span class="sd">        We begin by defining a few generic, useful tactics. *)</span>

    <span class="sd">(** remove logical hypothesis inter-dependencies (fix #2136). *)</span>

</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">no_logical_interdep</span> :=
      <span class="kr">match goal with</span>
        | H : ?P |- _ =&gt;
          <span class="kr">match</span> <span class="kp">type of</span> P <span class="kr">with</span>
            | <span class="kt">Prop</span> =&gt;
              <span class="kr">match goal with</span> H&#39; : <span class="kp">context</span> [ H ] |- _ =&gt; <span class="nb">clear dependent</span> H&#39; <span class="kr">end</span>
            | _ =&gt; <span class="kp">fail</span>
          <span class="kr">end</span>; no_logical_interdep
        | _ =&gt; <span class="kp">idtac</span>
      <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">abstract_term</span> t :=
      <span class="kr">tryif</span> (<span class="nb">is_var</span> t) <span class="kr">then</span> <span class="kp">fail</span> <span class="s2">&quot;no need to abstract a variable&quot;</span>
      <span class="kr">else</span> (<span class="kr">let</span> <span class="nv">x</span> := <span class="kp">fresh</span> <span class="s2">&quot;x&quot;</span> <span class="kr">in</span> <span class="nb">set</span> (x := t) <span class="kr">in</span> *; <span class="kp">try</span> <span class="nb">clearbody</span> x).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">abstract_elements</span> :=
      <span class="kp">repeat</span>
        (<span class="kr">match goal with</span>
           | |- <span class="kp">context</span> [ singleton ?t ] =&gt; abstract_term t
           | _ : <span class="kp">context</span> [ singleton ?t ] |- _ =&gt; abstract_term t
           | |- <span class="kp">context</span> [ add ?t _ ] =&gt; abstract_term t
           | _ : <span class="kp">context</span> [ add ?t _ ] |- _ =&gt; abstract_term t
           | |- <span class="kp">context</span> [ remove ?t _ ] =&gt; abstract_term t
           | _ : <span class="kp">context</span> [ remove ?t _ ] |- _ =&gt; abstract_term t
           | |- <span class="kp">context</span> [ In ?t _ ] =&gt; abstract_term t
           | _ : <span class="kp">context</span> [ In ?t _ ] |- _ =&gt; abstract_term t
         <span class="kr">end</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** [prop P holds by t] succeeds (but does not modify the</span>
<span class="sd">        goal or context) if the proposition [P] can be proved by</span>
<span class="sd">        [t] in the current context.  Otherwise, the tactic</span>
<span class="sd">        fails. *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;prop&quot;</span> <span class="kp">constr</span>(P) <span class="s2">&quot;holds&quot;</span> <span class="s2">&quot;by&quot;</span> tactic(t) :=
      <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="kr">in</span>
      <span class="nb">assert</span> P <span class="kr">as</span> H <span class="bp">by</span> t;
      <span class="nb">clear</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** This tactic acts just like [assert ... by ...] but will</span>
<span class="sd">        fail if the context already contains the proposition. *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;assert&quot;</span> <span class="s2">&quot;new&quot;</span> <span class="kp">constr</span>(e) <span class="s2">&quot;by&quot;</span> tactic(t) :=
      <span class="kr">match goal with</span>
      | H: e |- _ =&gt; <span class="kp">fail</span> <span class="mi">1</span>
      | _ =&gt; <span class="nb">assert</span> e <span class="bp">by</span> t
      <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** [subst++] is similar to [subst] except that</span>
<span class="sd">        - it never fails (as [subst] does on recursive</span>
<span class="sd">          equations),</span>
<span class="sd">        - it substitutes locally defined variable for their</span>
<span class="sd">          definitions,</span>
<span class="sd">        - it performs beta reductions everywhere, which may</span>
<span class="sd">          arise after substituting a locally defined function</span>
<span class="sd">          for its definition.</span>
<span class="sd">        *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;subst&quot;</span> <span class="s2">&quot;++&quot;</span> :=
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | x : _ |- _ =&gt; <span class="nb">subst</span> x
        <span class="kr">end</span>);
      <span class="nb">cbv</span> zeta beta <span class="kr">in</span> *.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** [decompose records] calls [decompose record H] on every</span>
<span class="sd">        relevant hypothesis [H]. *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;decompose&quot;</span> <span class="s2">&quot;records&quot;</span> :=
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | H: _ |- _ =&gt; <span class="kp">progress</span> (<span class="nb">decompose record</span> H); <span class="nb">clear</span> H
        <span class="kr">end</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** ** Discarding Irrelevant Hypotheses</span>
<span class="sd">        We will want to clear the context of any</span>
<span class="sd">        non-FSet-related hypotheses in order to increase the</span>
<span class="sd">        speed of the tactic.  To do this, we will need to be</span>
<span class="sd">        able to decide which are relevant.  We do this by making</span>
<span class="sd">        a simple inductive definition classifying the</span>
<span class="sd">        propositions of interest. *)</span>

</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">FSet_elt_Prop</span> : <span class="kt">Prop</span> -&gt; <span class="kt">Prop</span> :=
    | eq_Prop : <span class="kr">forall</span> (<span class="nv">S</span> : <span class="kt">Type</span>) (<span class="nv">x</span> <span class="nv">y</span> : S),
        FSet_elt_Prop (x = y)
    | eq_elt_prop : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>,
        FSet_elt_Prop (E.eq x y)
    | In_elt_prop : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">s</span>,
        FSet_elt_Prop (In x s)
    | True_elt_prop :
        FSet_elt_Prop <span class="kt">True</span>
    | False_elt_prop :
        FSet_elt_Prop <span class="kt">False</span>
    | conj_elt_prop : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span>,
        FSet_elt_Prop P -&gt;
        FSet_elt_Prop Q -&gt;
        FSet_elt_Prop (P /\ Q)
    | disj_elt_prop : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span>,
        FSet_elt_Prop P -&gt;
        FSet_elt_Prop Q -&gt;
        FSet_elt_Prop (P \/ Q)
    | impl_elt_prop : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span>,
        FSet_elt_Prop P -&gt;
        FSet_elt_Prop Q -&gt;
        FSet_elt_Prop (P -&gt; Q)
    | not_elt_prop : <span class="kr">forall</span> <span class="nv">P</span>,
        FSet_elt_Prop P -&gt;
        FSet_elt_Prop (~ P).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">FSet_Prop</span> : <span class="kt">Prop</span> -&gt; <span class="kt">Prop</span> :=
    | elt_FSet_Prop : <span class="kr">forall</span> <span class="nv">P</span>,
        FSet_elt_Prop P -&gt;
        FSet_Prop P
    | Empty_FSet_Prop : <span class="kr">forall</span> <span class="nv">s</span>,
        FSet_Prop (Empty s)
    | Subset_FSet_Prop : <span class="kr">forall</span> <span class="nv">s1</span> <span class="nv">s2</span>,
        FSet_Prop (Subset s1 s2)
    | Equal_FSet_Prop : <span class="kr">forall</span> <span class="nv">s1</span> <span class="nv">s2</span>,
        FSet_Prop (Equal s1 s2).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** Here is the tactic that will throw away hypotheses that</span>
<span class="sd">        are not useful (for the intended scope of the [fsetdec]</span>
<span class="sd">        tactic). *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Constructors</span> FSet_elt_Prop FSet_Prop : FSet_Prop.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">discard_nonFSet</span> :=
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | H : <span class="kp">context</span> [ @Logic.eq ?T ?x ?y ] |- _ =&gt;
          <span class="kr">tryif</span> (<span class="nb">change</span> T <span class="kr">with</span> E.t <span class="kr">in</span> H) <span class="kr">then</span> <span class="kp">fail</span>
          <span class="kr">else</span> <span class="kr">tryif</span> (<span class="nb">change</span> T <span class="kr">with</span> t <span class="kr">in</span> H) <span class="kr">then</span> <span class="kp">fail</span>
          <span class="kr">else</span> <span class="nb">clear</span> H
        | H : ?P |- _ =&gt;
          <span class="kr">tryif</span> prop (FSet_Prop P) holds <span class="bp">by</span>
            (<span class="nb">auto</span> <span class="mi">100</span> <span class="kr">with</span> FSet_Prop)
          <span class="kr">then</span> <span class="kp">fail</span>
          <span class="kr">else</span> <span class="nb">clear</span> H
        <span class="kr">end</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** ** Turning Set Operators into Propositional Connectives</span>
<span class="sd">        The lemmas from [FSetFacts] will be used to break down</span>
<span class="sd">        set operations into propositional formulas built over</span>
<span class="sd">        the predicates [In] and [E.eq] applied only to</span>
<span class="sd">        variables.  We are going to use them with [autorewrite].</span>
<span class="sd">        *)</span>

</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Rewrite</span>
      F.empty_iff F.singleton_iff F.add_iff F.remove_iff
      F.union_iff F.inter_iff F.diff_iff
    : set_simpl.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk8" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk8"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">eq_refl_iff</span> (<span class="nv">x</span> : E.t) : E.eq x x &lt;-&gt; <span class="kt">True</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">E.t</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">E.eq x x &lt;-&gt; <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk9" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">E.t</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">E.eq x x &lt;-&gt; <span class="kt">True</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">now</span> <span class="nb">split</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Rewrite</span> eq_refl_iff : set_eq_simpl.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** ** Decidability of FSet Propositions *)</span>

    <span class="sd">(** [In] is decidable. *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chka" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chka"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">dec_In</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">s</span>,
      decidable (In x s).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : elt) (<span class="nv">s</span> : t), decidable (In x s)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chkb" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chkb"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : elt) (<span class="nv">s</span> : t), decidable (In x s)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">red</span>; <span class="nb">intros</span>; <span class="nb">generalize</span> (F.mem_iff s x); <span class="nb">case</span> (mem x s); <span class="nb">intuition</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** [E.eq] is decidable. *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chkc" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chkc"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">dec_eq</span> : <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : E.t),
      decidable (E.eq x y).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : E.t, decidable (E.eq x y)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chkd" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chkd"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : E.t, decidable (E.eq x y)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">red</span>; <span class="nb">intros</span> x y; <span class="nb">destruct</span> (E.eq_dec x y); <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** The hint database [FSet_decidability] will be given to</span>
<span class="sd">        the [push_neg] tactic from the module [Negation]. *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> dec_In dec_eq : FSet_decidability.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** ** Normalizing Propositions About Equality</span>
<span class="sd">        We have to deal with the fact that [E.eq] may be</span>
<span class="sd">        convertible with Coq&#39;s equality.  Thus, we will find the</span>
<span class="sd">        following tactics useful to replace one form with the</span>
<span class="sd">        other everywhere. *)</span>

    <span class="sd">(** The next tactic, [Logic_eq_to_E_eq], mentions the term</span>
<span class="sd">        [E.t]; thus, we must ensure that [E.t] is used in favor</span>
<span class="sd">        of any other convertible but syntactically distinct</span>
<span class="sd">        term. *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">change_to_E_t</span> :=
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | H : ?T |- _ =&gt;
          <span class="kp">progress</span> (<span class="nb">change</span> T <span class="kr">with</span> E.t <span class="kr">in</span> H);
          <span class="kp">repeat</span> (
            <span class="kr">match goal with</span>
            | J : _ |- _ =&gt; <span class="kp">progress</span> (<span class="nb">change</span> T <span class="kr">with</span> E.t <span class="kr">in</span> J)
            | |- _ =&gt; <span class="kp">progress</span> (<span class="nb">change</span> T <span class="kr">with</span> E.t)
            <span class="kr">end</span> )
        | H : <span class="kr">forall</span> <span class="nv">x</span> : ?T, _ |- _ =&gt;
          <span class="kp">progress</span> (<span class="nb">change</span> T <span class="kr">with</span> E.t <span class="kr">in</span> H);
          <span class="kp">repeat</span> (
            <span class="kr">match goal with</span>
            | J : _ |- _ =&gt; <span class="kp">progress</span> (<span class="nb">change</span> T <span class="kr">with</span> E.t <span class="kr">in</span> J)
            | |- _ =&gt; <span class="kp">progress</span> (<span class="nb">change</span> T <span class="kr">with</span> E.t)
            <span class="kr">end</span> )
       <span class="kr">end</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** These two tactics take us from Coq&#39;s built-in equality</span>
<span class="sd">        to [E.eq] (and vice versa) when possible. *)</span>

</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">Logic_eq_to_E_eq</span> :=
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | H: _ |- _ =&gt;
          <span class="kp">progress</span> (<span class="nb">change</span> (@Logic.eq E.t) <span class="kr">with</span> E.eq <span class="kr">in</span> H)
        | |- _ =&gt;
          <span class="kp">progress</span> (<span class="nb">change</span> (@Logic.eq E.t) <span class="kr">with</span> E.eq)
        <span class="kr">end</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">E_eq_to_Logic_eq</span> :=
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | H: _ |- _ =&gt;
          <span class="kp">progress</span> (<span class="nb">change</span> E.eq <span class="kr">with</span> (@Logic.eq E.t) <span class="kr">in</span> H)
        | |- _ =&gt;
          <span class="kp">progress</span> (<span class="nb">change</span> E.eq <span class="kr">with</span> (@Logic.eq E.t))
        <span class="kr">end</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** This tactic works like the built-in tactic [subst], but</span>
<span class="sd">        at the level of set element equality (which may not be</span>
<span class="sd">        the convertible with Coq&#39;s equality). *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">substFSet</span> :=
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | H: E.eq ?x ?x |- _ =&gt; <span class="nb">clear</span> H
        | H: E.eq ?x ?y |- _ =&gt; <span class="nb">rewrite</span> H <span class="kr">in</span> *; <span class="nb">clear</span> H
        <span class="kr">end</span>);
      <span class="nb">autorewrite with</span> set_eq_simpl <span class="kr">in</span> *.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** ** Considering Decidability of Base Propositions</span>
<span class="sd">        This tactic adds assertions about the decidability of</span>
<span class="sd">        [E.eq] and [In] to the context.  This is necessary for</span>
<span class="sd">        the completeness of the [fsetdec] tactic.  However, in</span>
<span class="sd">        order to minimize the cost of proof search, we should be</span>
<span class="sd">        careful to not add more than we need.  Once negations</span>
<span class="sd">        have been pushed to the leaves of the propositions, we</span>
<span class="sd">        only need to worry about decidability for those base</span>
<span class="sd">        propositions that appear in a negated form. *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">assert_decidability</span> :=
      <span class="sd">(** We actually don&#39;t want these rules to fire if the</span>
<span class="sd">          syntactic context in the patterns below is trivially</span>
<span class="sd">          empty, but we&#39;ll just do some clean-up at the</span>
<span class="sd">          afterward.  *)</span>
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | H: <span class="kp">context</span> [~ E.eq ?x ?y] |- _ =&gt;
          <span class="nb">assert</span> new (E.eq x y \/ ~ E.eq x y) <span class="bp">by</span> (<span class="nb">apply</span> dec_eq)
        | H: <span class="kp">context</span> [~ In ?x ?s] |- _ =&gt;
          <span class="nb">assert</span> new (In x s \/ ~ In x s) <span class="bp">by</span> (<span class="nb">apply</span> dec_In)
        | |- <span class="kp">context</span> [~ E.eq ?x ?y] =&gt;
          <span class="nb">assert</span> new (E.eq x y \/ ~ E.eq x y) <span class="bp">by</span> (<span class="nb">apply</span> dec_eq)
        | |- <span class="kp">context</span> [~ In ?x ?s] =&gt;
          <span class="nb">assert</span> new (In x s \/ ~ In x s) <span class="bp">by</span> (<span class="nb">apply</span> dec_In)
        <span class="kr">end</span>);
      <span class="sd">(** Now we eliminate the useless facts we added (because</span>
<span class="sd">          they would likely be very harmful to performance). *)</span>
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | _: ~ ?P, H : ?P \/ ~ ?P |- _ =&gt; <span class="nb">clear</span> H
        <span class="kr">end</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** ** Handling [Empty], [Subset], and [Equal]</span>
<span class="sd">        This tactic instantiates universally quantified</span>
<span class="sd">        hypotheses (which arise from the unfolding of [Empty],</span>
<span class="sd">        [Subset], and [Equal]) for each of the set element</span>
<span class="sd">        expressions that is involved in some membership or</span>
<span class="sd">        equality fact.  Then it throws away those hypotheses,</span>
<span class="sd">        which should no longer be needed. *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">inst_FSet_hypotheses</span> :=
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | H : <span class="kr">forall</span> <span class="nv">a</span> : E.t, _,
          _ : <span class="kp">context</span> [ In ?x _ ] |- _ =&gt;
          <span class="kr">let</span> <span class="nv">P</span> := <span class="kp">type of</span> (H x) <span class="kr">in</span>
          <span class="nb">assert</span> new P <span class="bp">by</span> (<span class="bp">exact</span> (H x))
        | H : <span class="kr">forall</span> <span class="nv">a</span> : E.t, _
          |- <span class="kp">context</span> [ In ?x _ ] =&gt;
          <span class="kr">let</span> <span class="nv">P</span> := <span class="kp">type of</span> (H x) <span class="kr">in</span>
          <span class="nb">assert</span> new P <span class="bp">by</span> (<span class="bp">exact</span> (H x))
        | H : <span class="kr">forall</span> <span class="nv">a</span> : E.t, _,
          _ : <span class="kp">context</span> [ E.eq ?x _ ] |- _ =&gt;
          <span class="kr">let</span> <span class="nv">P</span> := <span class="kp">type of</span> (H x) <span class="kr">in</span>
          <span class="nb">assert</span> new P <span class="bp">by</span> (<span class="bp">exact</span> (H x))
        | H : <span class="kr">forall</span> <span class="nv">a</span> : E.t, _
          |- <span class="kp">context</span> [ E.eq ?x _ ] =&gt;
          <span class="kr">let</span> <span class="nv">P</span> := <span class="kp">type of</span> (H x) <span class="kr">in</span>
          <span class="nb">assert</span> new P <span class="bp">by</span> (<span class="bp">exact</span> (H x))
        | H : <span class="kr">forall</span> <span class="nv">a</span> : E.t, _,
          _ : <span class="kp">context</span> [ E.eq _ ?x ] |- _ =&gt;
          <span class="kr">let</span> <span class="nv">P</span> := <span class="kp">type of</span> (H x) <span class="kr">in</span>
          <span class="nb">assert</span> new P <span class="bp">by</span> (<span class="bp">exact</span> (H x))
        | H : <span class="kr">forall</span> <span class="nv">a</span> : E.t, _
          |- <span class="kp">context</span> [ E.eq _ ?x ] =&gt;
          <span class="kr">let</span> <span class="nv">P</span> := <span class="kp">type of</span> (H x) <span class="kr">in</span>
          <span class="nb">assert</span> new P <span class="bp">by</span> (<span class="bp">exact</span> (H x))
        <span class="kr">end</span>);
      <span class="kp">repeat</span> (
        <span class="kr">match goal with</span>
        | H : <span class="kr">forall</span> <span class="nv">a</span> : E.t, _ |- _ =&gt;
          <span class="nb">clear</span> H
        <span class="kr">end</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** ** The Core [fsetdec] Auxiliary Tactics *)</span>

    <span class="sd">(** Here is the crux of the proof search.  Recursion through</span>
<span class="sd">        [intuition]!  (This will terminate if I correctly</span>
<span class="sd">        understand the behavior of [intuition].) *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">fsetdec_rec</span> := <span class="kp">progress</span> substFSet; <span class="nb">intuition</span> fsetdec_rec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="sd">(** If we add [unfold Empty, Subset, Equal in *; intros;] to</span>
<span class="sd">        the beginning of this tactic, it will satisfy the same</span>
<span class="sd">        specification as the [fsetdec] tactic; however, it will</span>
<span class="sd">        be much slower than necessary without the pre-processing</span>
<span class="sd">        done by the wrapper tactic [fsetdec]. *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">fsetdec_body</span> :=
      <span class="nb">autorewrite with</span> set_eq_simpl <span class="kr">in</span> *;
      inst_FSet_hypotheses;
      <span class="nb">autorewrite with</span> set_simpl set_eq_simpl <span class="kr">in</span> *;
      push not <span class="kr">in</span> * <span class="nb">using</span> FSet_decidability;
      substFSet;
      assert_decidability;
      <span class="nb">auto</span>;
      (<span class="nb">intuition</span> fsetdec_rec) ||
      <span class="kp">fail</span> <span class="mi">1</span>
        <span class="s2">&quot;because the goal is beyond the scope of this tactic&quot;</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">FSetDecideAuxiliary</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Import</span> FSetDecideAuxiliary.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
  <span class="sd">(** * The [fsetdec] Tactic</span>
<span class="sd">      Here is the top-level tactic (the only one intended for</span>
<span class="sd">      clients of this library).  It&#39;s specification is given at</span>
<span class="sd">      the top of the file. *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">fsetdec</span> :=
    <span class="sd">(** We first unfold any occurrences of [iff]. *)</span>
    <span class="nb">unfold</span> iff <span class="kr">in</span> *;
    <span class="sd">(** We fold occurrences of [not] because it is better for</span>
<span class="sd">        [intros] to leave us with a goal of [~ P] than a goal of</span>
<span class="sd">        [False]. *)</span>
    <span class="nb">fold</span> any not; <span class="nb">intros</span>;
    <span class="sd">(** We don&#39;t care about the value of elements : complex ones are</span>
<span class="sd">        abstracted as new variables (avoiding potential dependencies,</span>
<span class="sd">        see bug #2464) *)</span>
    abstract_elements;
    <span class="sd">(** We remove dependencies to logical hypothesis. This way,</span>
<span class="sd">        later &quot;clear&quot; will work nicely (see bug #2136) *)</span>
    no_logical_interdep;
    <span class="sd">(** Now we decompose conjunctions, which will allow the</span>
<span class="sd">        [discard_nonFSet] and [assert_decidability] tactics to</span>
<span class="sd">        do a much better job. *)</span>
    <span class="nb">decompose</span> records;
    discard_nonFSet;
    <span class="sd">(** We unfold these defined propositions on finite sets.  If</span>
<span class="sd">        our goal was one of them, then have one more item to</span>
<span class="sd">        introduce now. *)</span>
    <span class="nb">unfold</span> Empty, Subset, Equal <span class="kr">in</span> *; <span class="nb">intros</span>;
    <span class="sd">(** We now want to get rid of all uses of [=] in favor of</span>
<span class="sd">        [E.eq].  However, the best way to eliminate a [=] is in</span>
<span class="sd">        the context is with [subst], so we will try that first.</span>
<span class="sd">        In fact, we may as well convert uses of [E.eq] into [=]</span>
<span class="sd">        when possible before we do [subst] so that we can even</span>
<span class="sd">        more mileage out of it.  Then we will convert all</span>
<span class="sd">        remaining uses of [=] back to [E.eq] when possible.  We</span>
<span class="sd">        use [change_to_E_t] to ensure that we have a canonical</span>
<span class="sd">        name for set elements, so that [Logic_eq_to_E_eq] will</span>
<span class="sd">        work properly.  *)</span>
    change_to_E_t; E_eq_to_Logic_eq; <span class="nb">subst</span>++; Logic_eq_to_E_eq;
    <span class="sd">(** The next optimization is to swap a negated goal with a</span>
<span class="sd">        negated hypothesis when possible.  Any swap will improve</span>
<span class="sd">        performance by eliminating the total number of</span>
<span class="sd">        negations, but we will get the maximum benefit if we</span>
<span class="sd">        swap the goal with a hypotheses mentioning the same set</span>
<span class="sd">        element, so we try that first.  If we reach the fourth</span>
<span class="sd">        branch below, we attempt any swap.  However, to maintain</span>
<span class="sd">        completeness of this tactic, we can only perform such a</span>
<span class="sd">        swap with a decidable proposition; hence, we first test</span>
<span class="sd">        whether the hypothesis is an [FSet_elt_Prop], noting</span>
<span class="sd">        that any [FSet_elt_Prop] is decidable. *)</span>
    pull not <span class="nb">using</span> FSet_decidability;
    <span class="nb">unfold</span> not <span class="kr">in</span> *;
    <span class="kr">match goal with</span>
    | H: (In ?x ?r) -&gt; <span class="kt">False</span> |- (In ?x ?s) -&gt; <span class="kt">False</span> =&gt;
      <span class="bp">contradict</span> H; fsetdec_body
    | H: (In ?x ?r) -&gt; <span class="kt">False</span> |- (E.eq ?x ?y) -&gt; <span class="kt">False</span> =&gt;
      <span class="bp">contradict</span> H; fsetdec_body
    | H: (In ?x ?r) -&gt; <span class="kt">False</span> |- (E.eq ?y ?x) -&gt; <span class="kt">False</span> =&gt;
      <span class="bp">contradict</span> H; fsetdec_body
    | H: ?P -&gt; <span class="kt">False</span> |- ?Q -&gt; <span class="kt">False</span> =&gt;
      <span class="kr">tryif</span> prop (FSet_elt_Prop P) holds <span class="bp">by</span>
        (<span class="nb">auto</span> <span class="mi">100</span> <span class="kr">with</span> FSet_Prop)
      <span class="kr">then</span> (<span class="bp">contradict</span> H; fsetdec_body)
      <span class="kr">else</span> fsetdec_body
    | |- _ =&gt;
      fsetdec_body
    <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
  <span class="sd">(** * Examples *)</span>

</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">FSetDecideTestCases</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chke" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chke"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_eq_trans_1</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">s</span>,
      E.eq x y -&gt;
      ~ ~ E.eq z y -&gt;
      In x s -&gt;
      In z s.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : E.t) (<span class="nv">s</span> : t),
E.eq x y -&gt; ~ ~ E.eq z y -&gt; In x s -&gt; In z s</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chkf" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chkf"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : E.t) (<span class="nv">s</span> : t),
E.eq x y -&gt; ~ ~ E.eq z y -&gt; In x s -&gt; In z s</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk10" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk10"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_eq_trans_2</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">r</span> <span class="nv">s</span>,
      In x (singleton y) -&gt;
      ~ In z r -&gt;
      ~ ~ In z (add y r) -&gt;
      In x s -&gt;
      In z s.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : elt) (<span class="nv">r</span> <span class="nv">s</span> : t),
In x (singleton y) -&gt;
~ In z r -&gt; ~ ~ In z (add y r) -&gt; In x s -&gt; In z s</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk11" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk11"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : elt) (<span class="nv">r</span> <span class="nv">s</span> : t),
In x (singleton y) -&gt;
~ In z r -&gt; ~ ~ In z (add y r) -&gt; In x s -&gt; In z s</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk12" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk12"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_eq_neq_trans_1</span> : <span class="kr">forall</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">s</span>,
      E.eq x w -&gt;
      ~ ~ E.eq x y -&gt;
      ~ E.eq y z -&gt;
      In w s -&gt;
      In w (remove z s).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : E.t) (<span class="nv">s</span> : t),
E.eq x w -&gt;
~ ~ E.eq x y -&gt;
~ E.eq y z -&gt; In w s -&gt; In w (remove z s)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk13" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk13"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : E.t) (<span class="nv">s</span> : t),
E.eq x w -&gt;
~ ~ E.eq x y -&gt;
~ E.eq y z -&gt; In w s -&gt; In w (remove z s)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk14" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk14"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_eq_neq_trans_2</span> : <span class="kr">forall</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">r1</span> <span class="nv">r2</span> <span class="nv">s</span>,
      In x (singleton w) -&gt;
      ~ In x r1 -&gt;
      In x (add y r1) -&gt;
      In y r2 -&gt;
      In y (remove z r2) -&gt;
      In w s -&gt;
      In w (remove z s).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : elt) (<span class="nv">r1</span> <span class="nv">r2</span> <span class="nv">s</span> : t),
In x (singleton w) -&gt;
~ In x r1 -&gt;
In x (add y r1) -&gt;
In y r2 -&gt;
In y (remove z r2) -&gt; In w s -&gt; In w (remove z s)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk15" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk15"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : elt) (<span class="nv">r1</span> <span class="nv">r2</span> <span class="nv">s</span> : t),
In x (singleton w) -&gt;
~ In x r1 -&gt;
In x (add y r1) -&gt;
In y r2 -&gt;
In y (remove z r2) -&gt; In w s -&gt; In w (remove z s)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk16" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk16"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_In_singleton</span> : <span class="kr">forall</span> <span class="nv">x</span>,
      In x (singleton x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : elt, In x (singleton x)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk17" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk17"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : elt, In x (singleton x)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk18" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk18"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_add_In</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">s</span>,
      In x (add y s) -&gt;
      ~ E.eq x y -&gt;
      In x s.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : elt) (<span class="nv">s</span> : t),
In x (add y s) -&gt; ~ E.eq x y -&gt; In x s</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk19" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk19"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : elt) (<span class="nv">s</span> : t),
In x (add y s) -&gt; ~ E.eq x y -&gt; In x s</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk1a" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk1a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_Subset_add_remove</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">s</span>,
      s [&lt;=] (add x (remove x s)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : elt) (<span class="nv">s</span> : t), s [&lt;=] add x (remove x s)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk1b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : elt) (<span class="nv">s</span> : t), s [&lt;=] add x (remove x s)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk1c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_eq_disjunction</span> : <span class="kr">forall</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>,
      In w (add x (add y (singleton z))) -&gt;
      E.eq w x \/ E.eq w y \/ E.eq w z.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : elt,
In w (add x (add y (singleton z))) -&gt;
E.eq w x \/ E.eq w y \/ E.eq w z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk1d" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk1d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : elt,
In w (add x (add y (singleton z))) -&gt;
E.eq w x \/ E.eq w y \/ E.eq w z</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk1e"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_not_In_disj</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> <span class="nv">s4</span>,
      ~ In x (union s1 (union s2 (union s3 (add y s4)))) -&gt;
      ~ (In x s1 \/ In x s4 \/ E.eq y x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : elt) (<span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> <span class="nv">s4</span> : t),
~ In x (union s1 (union s2 (union s3 (add y s4)))) -&gt;
~ (In x s1 \/ In x s4 \/ E.eq y x)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk1f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : elt) (<span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> <span class="nv">s4</span> : t),
~ In x (union s1 (union s2 (union s3 (add y s4)))) -&gt;
~ (In x s1 \/ In x s4 \/ E.eq y x)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk20" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk20"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_not_In_conj</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> <span class="nv">s4</span>,
      ~ In x (union s1 (union s2 (union s3 (add y s4)))) -&gt;
      ~ In x s1 /\ ~ In x s4 /\ ~ E.eq y x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : elt) (<span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> <span class="nv">s4</span> : t),
~ In x (union s1 (union s2 (union s3 (add y s4)))) -&gt;
~ In x s1 /\ ~ In x s4 /\ ~ E.eq y x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk21" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk21"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : elt) (<span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> <span class="nv">s4</span> : t),
~ In x (union s1 (union s2 (union s3 (add y s4)))) -&gt;
~ In x s1 /\ ~ In x s4 /\ ~ E.eq y x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk22" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk22"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_iff_conj</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">s</span> <span class="nv">s&#39;</span>,
    (In a s&#39; &lt;-&gt; E.eq x a \/ In a s) -&gt;
    (In a s&#39; &lt;-&gt; In a (add x s)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : elt) (<span class="nv">x</span> : E.t) (<span class="nv">s</span> <span class="nv">s&#39;</span> : t),
In a s&#39; &lt;-&gt; E.eq x a \/ In a s -&gt;
In a s&#39; &lt;-&gt; In a (add x s)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk23" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk23"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : elt) (<span class="nv">x</span> : E.t) (<span class="nv">s</span> <span class="nv">s&#39;</span> : t),
In a s&#39; &lt;-&gt; E.eq x a \/ In a s -&gt;
In a s&#39; &lt;-&gt; In a (add x s)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk24" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk24"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_set_ops_1</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">q</span> <span class="nv">r</span> <span class="nv">s</span>,
      (singleton x) [&lt;=] s -&gt;
      Empty (union q r) -&gt;
      Empty (inter (diff s q) (diff s r)) -&gt;
      ~ In x s.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : elt) (<span class="nv">q</span> <span class="nv">r</span> <span class="nv">s</span> : t),
singleton x [&lt;=] s -&gt;
Empty (union q r) -&gt;
Empty (inter (diff s q) (diff s r)) -&gt; ~ In x s</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk25" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk25"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : elt) (<span class="nv">q</span> <span class="nv">r</span> <span class="nv">s</span> : t),
singleton x [&lt;=] s -&gt;
Empty (union q r) -&gt;
Empty (inter (diff s q) (diff s r)) -&gt; ~ In x s</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk26" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk26"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">eq_chain_test</span> : <span class="kr">forall</span> <span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">x3</span> <span class="nv">x4</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> <span class="nv">s4</span>,
      Empty s1 -&gt;
      In x2 (add x1 s1) -&gt;
      In x3 s2 -&gt;
      ~ In x3 (remove x2 s2) -&gt;
      ~ In x4 s3 -&gt;
      In x4 (add x3 s3) -&gt;
      In x1 s4 -&gt;
      Subset (add x4 s4) s4.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">x3</span> <span class="nv">x4</span> : elt) (<span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> <span class="nv">s4</span> : t),
Empty s1 -&gt;
In x2 (add x1 s1) -&gt;
In x3 s2 -&gt;
~ In x3 (remove x2 s2) -&gt;
~ In x4 s3 -&gt;
In x4 (add x3 s3) -&gt; In x1 s4 -&gt; add x4 s4 [&lt;=] s4</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk27" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk27"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">x3</span> <span class="nv">x4</span> : elt) (<span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">s3</span> <span class="nv">s4</span> : t),
Empty s1 -&gt;
In x2 (add x1 s1) -&gt;
In x3 s2 -&gt;
~ In x3 (remove x2 s2) -&gt;
~ In x4 s3 -&gt;
In x4 (add x3 s3) -&gt; In x1 s4 -&gt; add x4 s4 [&lt;=] s4</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk28" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk28"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_too_complex</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">r</span> <span class="nv">s</span>,
      E.eq x y -&gt;
      (In x (singleton y) -&gt; r [&lt;=] s) -&gt;
      In z r -&gt;
      In z s.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : E.t) (<span class="nv">z</span> : elt) (<span class="nv">r</span> <span class="nv">s</span> : t),
E.eq x y -&gt;
(In x (singleton y) -&gt; r [&lt;=] s) -&gt; In z r -&gt; In z s</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk29" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk29"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : E.t) (<span class="nv">z</span> : elt) (<span class="nv">r</span> <span class="nv">s</span> : t),
E.eq x y -&gt;
(In x (singleton y) -&gt; r [&lt;=] s) -&gt; In z r -&gt; In z s</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">      <span class="sd">(** [fsetdec] is not intended to solve this directly. *)</span>
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros until</span> s; <span class="nb">intros</span> Heq H Hr; <span class="nb">lapply</span> H; fsetdec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk2a" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk2a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">function_test_1</span> :
      <span class="kr">forall</span> (<span class="nv">f</span> : t -&gt; t),
      <span class="kr">forall</span> (<span class="nv">g</span> : elt -&gt; elt),
      <span class="kr">forall</span> (<span class="nv">s1</span> <span class="nv">s2</span> : t),
      <span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x2</span> : elt),
      Equal s1 (f s2) -&gt;
      E.eq x1 (g (g x2)) -&gt;
      In x1 s1 -&gt;
      In (g (g x2)) (f s2).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">f</span> : t -&gt; t) (<span class="nv">g</span> : elt -&gt; elt) (<span class="nv">s1</span> <span class="nv">s2</span> : t)
  (<span class="nv">x1</span> <span class="nv">x2</span> : elt),
s1 [=] f s2 -&gt;
E.eq x1 (g (g x2)) -&gt; In x1 s1 -&gt; In (g (g x2)) (f s2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk2b" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk2b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">f</span> : t -&gt; t) (<span class="nv">g</span> : elt -&gt; elt) (<span class="nv">s1</span> <span class="nv">s2</span> : t)
  (<span class="nv">x1</span> <span class="nv">x2</span> : elt),
s1 [=] f s2 -&gt;
E.eq x1 (g (g x2)) -&gt; In x1 s1 -&gt; In (g (g x2)) (f s2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk2c" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk2c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">function_test_2</span> :
      <span class="kr">forall</span> (<span class="nv">f</span> : t -&gt; t),
      <span class="kr">forall</span> (<span class="nv">g</span> : elt -&gt; elt),
      <span class="kr">forall</span> (<span class="nv">s1</span> <span class="nv">s2</span> : t),
      <span class="kr">forall</span> (<span class="nv">x1</span> <span class="nv">x2</span> : elt),
      Equal s1 (f s2) -&gt;
      E.eq x1 (g x2) -&gt;
      In x1 s1 -&gt;
      g x2 = g (g x2) -&gt;
      In (g (g x2)) (f s2).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">f</span> : t -&gt; t) (<span class="nv">g</span> : elt -&gt; elt) (<span class="nv">s1</span> <span class="nv">s2</span> : t)
  (<span class="nv">x1</span> <span class="nv">x2</span> : elt),
s1 [=] f s2 -&gt;
E.eq x1 (g x2) -&gt;
In x1 s1 -&gt; g x2 = g (g x2) -&gt; In (g (g x2)) (f s2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk2d" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk2d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">f</span> : t -&gt; t) (<span class="nv">g</span> : elt -&gt; elt) (<span class="nv">s1</span> <span class="nv">s2</span> : t)
  (<span class="nv">x1</span> <span class="nv">x2</span> : elt),
s1 [=] f s2 -&gt;
E.eq x1 (g x2) -&gt;
In x1 s1 -&gt; g x2 = g (g x2) -&gt; In (g (g x2)) (f s2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">      <span class="sd">(** [fsetdec] is not intended to solve this directly. *)</span>
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk2e"><span class="highlight"><span class="nb">intros until</span> <span class="mi">3</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t -&gt; t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">elt -&gt; elt</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">elt</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 [=] f s2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">E.eq x1 (g x2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x1 s1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">g x2 = g (g x2) -&gt; In (g (g x2)) (f s2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk2f" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk2f"><span class="highlight"><span class="nb">intros</span> g_eq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t -&gt; t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">elt -&gt; elt</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">elt</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 [=] f s2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">E.eq x1 (g x2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x1 s1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">g_eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">g x2 = g (g x2)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In (g (g x2)) (f s2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk30" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk30"><span class="highlight"><span class="nb">rewrite</span> &lt;- g_eq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t -&gt; t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">elt -&gt; elt</span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">elt</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">s1 [=] f s2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">E.eq x1 (g x2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">In x1 s1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">g_eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">g x2 = g (g x2)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In (g x2) (f s2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk31" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk31"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_baydemir</span> :
      <span class="kr">forall</span> (<span class="nv">f</span> : t -&gt; t),
      <span class="kr">forall</span> (<span class="nv">s</span> : t),
      <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : elt),
      In x (add y (f s)) -&gt;
      ~ E.eq x y -&gt;
      In x (f s).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">f</span> : t -&gt; t) (<span class="nv">s</span> : t) (<span class="nv">x</span> <span class="nv">y</span> : elt),
In x (add y (f s)) -&gt; ~ E.eq x y -&gt; In x (f s)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="FSetDecide-v-chk32" style="display: none" type="checkbox"><label class="coq-input" for="FSetDecide-v-chk32"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">f</span> : t -&gt; t) (<span class="nv">s</span> : t) (<span class="nv">x</span> <span class="nv">y</span> : elt),
In x (add y (f s)) -&gt; ~ E.eq x y -&gt; In x (f s)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">fsetdec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">FSetDecideTestCases</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">WDecide_fun</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> FSetInterface.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="sd">(** Now comes variants for self-contained weak sets and for full sets.</span>
<span class="sd">    For these variants, only one argument is necessary. Thanks to</span>
<span class="sd">    the subtyping [WS&lt;=S], the [Decide] functor which is meant to be</span>
<span class="sd">    used on modules [(M:S)] can simply be an alias of [WDecide]. *)</span>

</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">WDecide</span> (M:WS) := !WDecide_fun M.E M.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">Decide</span> := WDecide.</span></span><span class="coq-wsp">
</span></span></pre></article></body></html>