<!DOCTYPE html>
<html><head><title>FMapInterface.v</title><meta charset="utf-8"><meta content="Alectryon v0.2" name="generator"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet"><link href="https://unpkg.com/firacode/distr/fira_code.css" rel="stylesheet"><link href="alectryon.css" rel="stylesheet"><script src="alectryon.js"></script><style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-standalone alectryon-centered alectryon-coqdoc"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="sd">(************************************************************************)</span>
<span class="c">(*         *   The Coq Proof Assistant / The Coq Development Team       *)</span>
<span class="c">(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)</span>
<span class="c">(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)</span>
<span class="c">(*   \VV/  **************************************************************)</span>
<span class="c">(*    //   *    This file is distributed under the terms of the         *)</span>
<span class="c">(*         *     GNU Lesser General Public License Version 2.1          *)</span>
<span class="c">(*         *     (see LICENSE file for the text of the license)         *)</span>
<span class="sd">(************************************************************************)</span></span></span></pre><div class="doc">
<a name="lab1"></a><h1 class="section">Finite map library</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
This file proposes interfaces for finite maps 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Export</span> Bool DecidableType OrderedType.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Set Implicit Arguments</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Unset Strict Implicit</span>.</span></span></span></pre><div class="doc">
When compared with Ocaml Map, this signature has been split in
    several parts :

<div class="paragraph"> </div>
<ul class="doclist">
<li> The first parts <span class="inlinecode"><span class="id" title="var">WSfun</span></span> and <span class="inlinecode"><span class="id" title="var">WS</span></span> propose signatures for weak
     maps, which are maps with no ordering on the key type nor the
     data type.  <span class="inlinecode"><span class="id" title="var">WSfun</span></span> and <span class="inlinecode"><span class="id" title="var">WS</span></span> are almost identical, apart from the
     fact that <span class="inlinecode"><span class="id" title="var">WSfun</span></span> is expressed in a functorial way whereas <span class="inlinecode"><span class="id" title="var">WS</span></span>
     is self-contained. For obtaining an instance of such signatures,
     a decidable equality on keys in enough (see for example
     <span class="inlinecode"><span class="id" title="var">FMapWeakList</span></span>). These signatures contain the usual operators
     (add, find, ...). The only function that asks for more is
     <span class="inlinecode"><span class="id" title="var">equal</span></span>, whose first argument should be a comparison on data.

<div class="paragraph"> </div>
</li>
<li> Then comes <span class="inlinecode"><span class="id" title="var">Sfun</span></span> and <span class="inlinecode"><span class="id" title="var">S</span></span>, that extend <span class="inlinecode"><span class="id" title="var">WSfun</span></span> and <span class="inlinecode"><span class="id" title="var">WS</span></span> to the
     case where the key type is ordered. The main novelty is that
     <span class="inlinecode"><span class="id" title="var">elements</span></span> is required to produce sorted lists.

<div class="paragraph"> </div>
</li>
<li> Finally, <span class="inlinecode"><span class="id" title="var">Sord</span></span> extends <span class="inlinecode"><span class="id" title="var">S</span></span> with a complete comparison function. For
     that, the data type should have a decidable total ordering as well.

</li>
</ul>
<div class="paragraph"> </div>

   If unsure, what you're looking for is probably <span class="inlinecode"><span class="id" title="var">S</span></span>: apart from <span class="inlinecode"><span class="id" title="var">Sord</span></span>,
   all other signatures are subsets of <span class="inlinecode"><span class="id" title="var">S</span></span>.

<div class="paragraph"> </div>

   Some additional differences with Ocaml:

<div class="paragraph"> </div>
<ul class="doclist">
<li> no <span class="inlinecode"><span class="id" title="var">iter</span></span> function, useless since Coq is purely functional

</li>
<li> <span class="inlinecode"><span class="id" title="var">option</span></span> types are used instead of <span class="inlinecode"><span class="id" title="var">Not_found</span></span> exceptions

</li>
<li> more functions are provided: <span class="inlinecode"><span class="id" title="var">elements</span></span> and <span class="inlinecode"><span class="id" title="var">cardinal</span></span> and <span class="inlinecode"><span class="id" title="var">map2</span></span>
</li>
</ul>
<div class="paragraph"> </div>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Cmp</span> (<span class="nv">elt</span>:<span class="kt">Type</span>)(<span class="nv">cmp</span>:elt-&gt;elt-&gt;bool) <span class="nv">e1</span> <span class="nv">e2</span> := cmp e1 e2 = true.</span></span></span></pre><div class="doc">
<a name="lab2"></a><h2 class="section">Weak signature for maps</h2>
<div class="paragraph"> </div>

    No requirements for an ordering on keys nor elements, only decidability
    of equality on keys. First, a functorial signature: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module Type</span> <span class="nf">WSfun</span> (E : DecidableType).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">key</span> := E.t.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Transparent</span> key : core.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">t</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>.</span></span></span></pre><div class="doc">
the abstract type of maps 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">Types</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">elt</span>:<span class="kt">Type</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">empty</span> : t elt.</span></span></span></pre><div class="doc">
The empty map. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">    </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">is_empty</span> : t elt -&gt; bool.</span></span></span></pre><div class="doc">
Test whether a map is empty or not. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">    </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">add</span> : key -&gt; elt -&gt; t elt -&gt; t elt.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">add</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> returns a map containing the same bindings as <span class="inlinecode"><span class="id" title="var">m</span></span>,
	plus a binding of <span class="inlinecode"><span class="id" title="var">x</span></span> to <span class="inlinecode"><span class="id" title="var">y</span></span>. If <span class="inlinecode"><span class="id" title="var">x</span></span> was already bound in <span class="inlinecode"><span class="id" title="var">m</span></span>,
	its previous binding disappears. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">    </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">find</span> : key -&gt; t elt -&gt; option elt.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">find</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> returns the current binding of <span class="inlinecode"><span class="id" title="var">x</span></span> in <span class="inlinecode"><span class="id" title="var">m</span></span>,
	or <span class="inlinecode"><span class="id" title="var">None</span></span> if no such binding exists. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">    </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">remove</span> : key -&gt; t elt -&gt; t elt.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">remove</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> returns a map containing the same bindings as <span class="inlinecode"><span class="id" title="var">m</span></span>,
	except for <span class="inlinecode"><span class="id" title="var">x</span></span> which is unbound in the returned map. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">    </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">mem</span> : key -&gt; t elt -&gt; bool.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">mem</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> returns <span class="inlinecode"><span class="id" title="var">true</span></span> if <span class="inlinecode"><span class="id" title="var">m</span></span> contains a binding for <span class="inlinecode"><span class="id" title="var">x</span></span>,
	and <span class="inlinecode"><span class="id" title="var">false</span></span> otherwise. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">    </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">elt&#39;</span> <span class="nv">elt&#39;&#39;</span> : <span class="kt">Type</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">map</span> : (elt -&gt; elt&#39;) -&gt; t elt -&gt; t elt&#39;.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">map</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> returns a map with same domain as <span class="inlinecode"><span class="id" title="var">m</span></span>, where the associated
	value a of all bindings of <span class="inlinecode"><span class="id" title="var">m</span></span> has been replaced by the result of the
	application of <span class="inlinecode"><span class="id" title="var">f</span></span> to <span class="inlinecode"><span class="id" title="var">a</span></span>. Since Coq is purely functional, the order
        in which the bindings are passed to <span class="inlinecode"><span class="id" title="var">f</span></span> is irrelevant. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">    </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">mapi</span> : (key -&gt; elt -&gt; elt&#39;) -&gt; t elt -&gt; t elt&#39;.</span></span></span></pre><div class="doc">
Same as <span class="inlinecode"><span class="id" title="var">map</span></span>, but the function receives as arguments both the
	key and the associated value for each binding of the map. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">    </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">map2</span> :
     (option elt -&gt; option elt&#39; -&gt; option elt&#39;&#39;) -&gt; t elt -&gt; t elt&#39; -&gt;  t elt&#39;&#39;.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">map2</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">m'</span></span> creates a new map whose bindings belong to the ones
        of either <span class="inlinecode"><span class="id" title="var">m</span></span> or <span class="inlinecode"><span class="id" title="var">m'</span></span>. The presence and value for a key <span class="inlinecode"><span class="id" title="var">k</span></span> is
        determined by <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">e</span></span> <span class="inlinecode"><span class="id" title="var">e'</span></span> where <span class="inlinecode"><span class="id" title="var">e</span></span> and <span class="inlinecode"><span class="id" title="var">e'</span></span> are the (optional) bindings
        of <span class="inlinecode"><span class="id" title="var">k</span></span> in <span class="inlinecode"><span class="id" title="var">m</span></span> and <span class="inlinecode"><span class="id" title="var">m'</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">    </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">elements</span> : t elt -&gt; list (key*elt).</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">elements</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> returns an assoc list corresponding to the bindings
        of <span class="inlinecode"><span class="id" title="var">m</span></span>, in any order. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">    </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">cardinal</span> : t elt -&gt; nat.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">cardinal</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> returns the number of bindings in <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">    </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">fold</span> : <span class="kr">forall</span> <span class="nv">A</span>: <span class="kt">Type</span>, (key -&gt; elt -&gt; A -&gt; A) -&gt; t elt -&gt; A -&gt; A.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="tactic">fold</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> computes <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">kN</span></span> <span class="inlinecode"><span class="id" title="var">dN</span></span> <span class="inlinecode">...</span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">k1</span></span> <span class="inlinecode"><span class="id" title="var">d1</span></span> <span class="inlinecode"><span class="id" title="var">a</span>)...)</span>,
	where <span class="inlinecode"><span class="id" title="var">k1</span></span> ... <span class="inlinecode"><span class="id" title="var">kN</span></span> are the keys of all bindings in <span class="inlinecode"><span class="id" title="var">m</span></span>
	(in any order), and <span class="inlinecode"><span class="id" title="var">d1</span></span> ... <span class="inlinecode"><span class="id" title="var">dN</span></span> are the associated data. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">    </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">equal</span> : (elt -&gt; elt -&gt; bool) -&gt; t elt -&gt; t elt -&gt; bool.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">equal</span></span> <span class="inlinecode"><span class="id" title="var">cmp</span></span> <span class="inlinecode"><span class="id" title="var">m1</span></span> <span class="inlinecode"><span class="id" title="var">m2</span></span> tests whether the maps <span class="inlinecode"><span class="id" title="var">m1</span></span> and <span class="inlinecode"><span class="id" title="var">m2</span></span> are equal,
      that is, contain equal keys and associate them with equal data.
      <span class="inlinecode"><span class="id" title="var">cmp</span></span> is the equality predicate used to compare the data associated
      with the keys. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">    </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">Spec</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">m</span> <span class="nv">m&#39;</span> <span class="nv">m&#39;&#39;</span> : t elt.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : key.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : elt.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">MapsTo</span> : key -&gt; elt -&gt; t elt -&gt; <span class="kt">Prop</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">In</span> (<span class="nv">k</span>:key)(<span class="nv">m</span>: t elt) : <span class="kt">Prop</span> := <span class="kr">exists</span> <span class="nv">e</span>:elt, MapsTo k e m.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Empty</span> <span class="nv">m</span> := <span class="kr">forall</span> (<span class="nv">a</span> : key)(<span class="nv">e</span>:elt) , ~ MapsTo a e m.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eq_key</span> (<span class="nv">p</span> <span class="nv">p&#39;</span>:key*elt) := E.eq (fst p) (fst p&#39;).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eq_key_elt</span> (<span class="nv">p</span> <span class="nv">p&#39;</span>:key*elt) :=
          E.eq (fst p) (fst p&#39;) /\ (snd p) = (snd p&#39;).</span></span></span></pre><div class="doc">
Specification of <span class="inlinecode"><span class="id" title="var">MapsTo</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">      </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">MapsTo_1</span> : E.eq x y -&gt; MapsTo x e m -&gt; MapsTo y e m.</span></span></span></pre><div class="doc">
Specification of <span class="inlinecode"><span class="id" title="var">mem</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">      </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">mem_1</span> : In x m -&gt; mem x m = true.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">mem_2</span> : mem x m = true -&gt; In x m.</span></span></span></pre><div class="doc">
Specification of <span class="inlinecode"><span class="id" title="var">empty</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">      </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">empty_1</span> : Empty empty.</span></span></span></pre><div class="doc">
Specification of <span class="inlinecode"><span class="id" title="var">is_empty</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">      </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">is_empty_1</span> : Empty m -&gt; is_empty m = true.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">is_empty_2</span> : is_empty m = true -&gt; Empty m.</span></span></span></pre><div class="doc">
Specification of <span class="inlinecode"><span class="id" title="var">add</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">      </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">add_1</span> : E.eq x y -&gt; MapsTo y e (add x e m).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">add_2</span> : ~ E.eq x y -&gt; MapsTo y e m -&gt; MapsTo y e (add x e&#39; m).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">add_3</span> : ~ E.eq x y -&gt; MapsTo y e (add x e&#39; m) -&gt; MapsTo y e m.</span></span></span></pre><div class="doc">
Specification of <span class="inlinecode"><span class="id" title="var">remove</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">      </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">remove_1</span> : E.eq x y -&gt; ~ In y (remove x m).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">remove_2</span> : ~ E.eq x y -&gt; MapsTo y e m -&gt; MapsTo y e (remove x m).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">remove_3</span> : MapsTo y e (remove x m) -&gt; MapsTo y e m.</span></span></span></pre><div class="doc">
Specification of <span class="inlinecode"><span class="id" title="var">find</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">      </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">find_1</span> : MapsTo x e m -&gt; find x m = Some e.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">find_2</span> : find x m = Some e -&gt; MapsTo x e m.</span></span></span></pre><div class="doc">
Specification of <span class="inlinecode"><span class="id" title="var">elements</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">      </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">elements_1</span> :
        MapsTo x e m -&gt; InA eq_key_elt (x,e) (elements m).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">elements_2</span> :
        InA eq_key_elt (x,e) (elements m) -&gt; MapsTo x e m.</span></span></span></pre><div class="doc">
When compared with ordered maps, here comes the only
         property that is really weaker: 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">      </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">elements_3w</span> : NoDupA eq_key (elements m).</span></span></span></pre><div class="doc">
Specification of <span class="inlinecode"><span class="id" title="var">cardinal</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">      </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">cardinal_1</span> : cardinal m = length (elements m).</span></span></span></pre><div class="doc">
Specification of <span class="inlinecode"><span class="id" title="tactic">fold</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">      </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">fold_1</span> :
	<span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">i</span> : A) (<span class="nv">f</span> : key -&gt; elt -&gt; A -&gt; A),
        <span class="nb">fold</span> f m i = fold_left (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">p</span> =&gt; f (fst p) (snd p) a) (elements m) i.</span></span></span></pre><div class="doc">
Equality of maps 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">    </span></span></pre><div class="doc">
Caveat: there are at least three distinct equality predicates on maps.
<ul class="doclist">
<li> The simplest (and maybe most natural) way is to consider keys up to
        their equivalence <span class="inlinecode"><span class="id" title="var">E.eq</span></span>, but elements up to Leibniz equality, in
        the spirit of <span class="inlinecode"><span class="id" title="var">eq_key_elt</span></span> above. This leads to predicate <span class="inlinecode"><span class="id" title="var">Equal</span></span>.

</li>
<li> Unfortunately, this <span class="inlinecode"><span class="id" title="var">Equal</span></span> predicate can't be used to describe
        the <span class="inlinecode"><span class="id" title="var">equal</span></span> function, since this function (for compatibility with
        ocaml) expects a boolean comparison <span class="inlinecode"><span class="id" title="var">cmp</span></span> that may identify more
        elements than Leibniz. So logical specification of <span class="inlinecode"><span class="id" title="var">equal</span></span> is done
        via another predicate <span class="inlinecode"><span class="id" title="var">Equivb</span></span>
</li>
<li> This predicate <span class="inlinecode"><span class="id" title="var">Equivb</span></span> is quite ad-hoc with its boolean <span class="inlinecode"><span class="id" title="var">cmp</span></span>,
        it can be generalized in a <span class="inlinecode"><span class="id" title="var">Equiv</span></span> expecting a more general
        (possibly non-decidable) equality predicate on elements 
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">     </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Equal</span> <span class="nv">m</span> <span class="nv">m&#39;</span> := <span class="kr">forall</span> <span class="nv">y</span>, find y m = find y m&#39;.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Equiv</span> (<span class="nv">eq_elt</span>:elt-&gt;elt-&gt;<span class="kt">Prop</span>) <span class="nv">m</span> <span class="nv">m&#39;</span> :=
         (<span class="kr">forall</span> <span class="nv">k</span>, In k m &lt;-&gt; In k m&#39;) /\
         (<span class="kr">forall</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">e&#39;</span>, MapsTo k e m -&gt; MapsTo k e&#39; m&#39; -&gt; eq_elt e e&#39;).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Equivb</span> (<span class="nv">cmp</span>: elt-&gt;elt-&gt;bool) := Equiv (Cmp cmp).</span></span></span></pre><div class="doc">
Specification of <span class="inlinecode"><span class="id" title="var">equal</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">     </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">cmp</span> : elt -&gt; elt -&gt; bool.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">equal_1</span> : Equivb cmp m m&#39; -&gt; equal cmp m m&#39; = true.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">equal_2</span> : equal cmp m m&#39; = true -&gt; Equivb cmp m m&#39;.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Spec</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Types</span>.</span></span></span></pre><div class="doc">
Specification of <span class="inlinecode"><span class="id" title="var">map</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">      </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">map_1</span> : <span class="kr">forall</span> (<span class="nv">elt</span> <span class="nv">elt&#39;</span>:<span class="kt">Type</span>)(<span class="nv">m</span>: t elt)(<span class="nv">x</span>:key)(<span class="nv">e</span>:elt)(<span class="nv">f</span>:elt-&gt;elt&#39;),
        MapsTo x e m -&gt; MapsTo x (f e) (map f m).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">map_2</span> : <span class="kr">forall</span> (<span class="nv">elt</span> <span class="nv">elt&#39;</span>:<span class="kt">Type</span>)(<span class="nv">m</span>: t elt)(<span class="nv">x</span>:key)(<span class="nv">f</span>:elt-&gt;elt&#39;),
        In x (map f m) -&gt; In x m.</span></span></span></pre><div class="doc">
Specification of <span class="inlinecode"><span class="id" title="var">mapi</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">      </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">mapi_1</span> : <span class="kr">forall</span> (<span class="nv">elt</span> <span class="nv">elt&#39;</span>:<span class="kt">Type</span>)(<span class="nv">m</span>: t elt)(<span class="nv">x</span>:key)(<span class="nv">e</span>:elt)
        (<span class="nv">f</span>:key-&gt;elt-&gt;elt&#39;), MapsTo x e m -&gt;
        <span class="kr">exists</span> <span class="nv">y</span>, E.eq y x /\ MapsTo x (f y e) (mapi f m).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">mapi_2</span> : <span class="kr">forall</span> (<span class="nv">elt</span> <span class="nv">elt&#39;</span>:<span class="kt">Type</span>)(<span class="nv">m</span>: t elt)(<span class="nv">x</span>:key)
        (<span class="nv">f</span>:key-&gt;elt-&gt;elt&#39;), In x (mapi f m) -&gt; In x m.</span></span></span></pre><div class="doc">
Specification of <span class="inlinecode"><span class="id" title="var">map2</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">      </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">map2_1</span> : <span class="kr">forall</span> (<span class="nv">elt</span> <span class="nv">elt&#39;</span> <span class="nv">elt&#39;&#39;</span>:<span class="kt">Type</span>)(<span class="nv">m</span>: t elt)(<span class="nv">m&#39;</span>: t elt&#39;)
	(<span class="nv">x</span>:key)(<span class="nv">f</span>:option elt-&gt;option elt&#39;-&gt;option elt&#39;&#39;),
	In x m \/ In x m&#39; -&gt;
        find x (map2 f m m&#39;) = f (find x m) (find x m&#39;).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">     </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">map2_2</span> : <span class="kr">forall</span> (<span class="nv">elt</span> <span class="nv">elt&#39;</span> <span class="nv">elt&#39;&#39;</span>:<span class="kt">Type</span>)(<span class="nv">m</span>: t elt)(<span class="nv">m&#39;</span>: t elt&#39;)
	(<span class="nv">x</span>:key)(<span class="nv">f</span>:option elt-&gt;option elt&#39;-&gt;option elt&#39;&#39;),
        In x (map2 f m m&#39;) -&gt; In x m \/ In x m&#39;.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Immediate</span> MapsTo_1 mem_2 is_empty_2
    map_2 mapi_2 add_3 remove_3 find_2
    : map.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> mem_1 is_empty_1 is_empty_2 add_1 add_2 remove_1
    remove_2 find_1 fold_1 map_1 mapi_1 mapi_2
    : map.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">WSfun</span>.</span></span></span></pre><div class="doc">
<a name="lab3"></a><h2 class="section">Static signature for Weak Maps</h2>
<div class="paragraph"> </div>

    Similar to <span class="inlinecode"><span class="id" title="var">WSfun</span></span> but expressed in a self-contained way. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module Type</span> <span class="nf">WS</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Declare Module</span> <span class="nf">E</span> : DecidableType.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Include</span> WSfun E.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">WS</span>.</span></span></span></pre><div class="doc">
<a name="lab4"></a><h2 class="section">Maps on ordered keys, functorial signature</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module Type</span> <span class="nf">Sfun</span> (E : OrderedType).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Include</span> WSfun E.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">elt</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">elt</span>:<span class="kt">Type</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lt_key</span> (<span class="nv">p</span> <span class="nv">p&#39;</span>:key*elt) := E.lt (fst p) (fst p&#39;).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">   <span class="c">(* Additional specification of [elements] *)</span>
</span></span><span class="coq-wsp">   </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">elements_3</span> : <span class="kr">forall</span> <span class="nv">m</span>, sort lt_key (elements m).</span></span></span></pre><div class="doc">
Remark: since <span class="inlinecode"><span class="id" title="tactic">fold</span></span> is specified via <span class="inlinecode"><span class="id" title="var">elements</span></span>, this stronger
   specification of <span class="inlinecode"><span class="id" title="var">elements</span></span> has an indirect impact on <span class="inlinecode"><span class="id" title="tactic">fold</span></span>,
   which can now be proved to receive elements in increasing order. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">elt</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Sfun</span>.</span></span></span></pre><div class="doc">
<a name="lab5"></a><h2 class="section">Maps on ordered keys, self-contained signature</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module Type</span> <span class="nf">S</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Declare Module</span> <span class="nf">E</span> : OrderedType.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Include</span> Sfun E.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">S</span>.</span></span></span></pre><div class="doc">
<a name="lab6"></a><h2 class="section">Maps with ordering both on keys and datas</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module Type</span> <span class="nf">Sord</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Declare Module</span> <span class="nf">Data</span> : OrderedType.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Declare Module</span> <span class="nf">MapS</span> : S.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Import</span> MapS.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">t</span> := MapS.t Data.t.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">eq</span> : t -&gt; t -&gt; <span class="kt">Prop</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">lt</span> : t -&gt; t -&gt; <span class="kt">Prop</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">eq_refl</span> : <span class="kr">forall</span> <span class="nv">m</span> : t, eq m m.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">eq_sym</span> : <span class="kr">forall</span> <span class="nv">m1</span> <span class="nv">m2</span> : t, eq m1 m2 -&gt; eq m2 m1.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">eq_trans</span> : <span class="kr">forall</span> <span class="nv">m1</span> <span class="nv">m2</span> <span class="nv">m3</span> : t, eq m1 m2 -&gt; eq m2 m3 -&gt; eq m1 m3.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">lt_trans</span> : <span class="kr">forall</span> <span class="nv">m1</span> <span class="nv">m2</span> <span class="nv">m3</span> : t, lt m1 m2 -&gt; lt m2 m3 -&gt; lt m1 m3.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">lt_not_eq</span> : <span class="kr">forall</span> <span class="nv">m1</span> <span class="nv">m2</span> : t, lt m1 m2 -&gt; ~ eq m1 m2.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">cmp</span> <span class="nv">e</span> <span class="nv">e&#39;</span> := <span class="kr">match</span> Data.<span class="nb">compare</span> e e&#39; <span class="kr">with</span> EQ _ =&gt; true | _ =&gt; false <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">eq_1</span> : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">m&#39;</span>, Equivb cmp m m&#39; -&gt; eq m m&#39;.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">eq_2</span> : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">m&#39;</span>, eq m m&#39; -&gt; Equivb cmp m m&#39;.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">compare</span> : <span class="kr">forall</span> <span class="nv">m1</span> <span class="nv">m2</span>, Compare lt eq m1 m2.</span></span></span></pre><div class="doc">
Total ordering between maps. <span class="inlinecode"><span class="id" title="var">Data.compare</span></span> is a total ordering
      used to compare data associated with equal keys in the two maps. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Sord</span>.</span></span></span></pre></article></body></html>