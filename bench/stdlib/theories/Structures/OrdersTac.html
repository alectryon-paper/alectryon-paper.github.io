<!DOCTYPE html>
<html><head><title>OrdersTac.v</title><meta charset="utf-8"><meta content="Alectryon v0.2" name="generator"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet"><link href="https://unpkg.com/firacode/distr/fira_code.css" rel="stylesheet"><link href="alectryon.css" rel="stylesheet"><script src="alectryon.js"></script><style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-standalone alectryon-centered alectryon-coqdoc"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="sd">(************************************************************************)</span>
<span class="c">(*         *   The Coq Proof Assistant / The Coq Development Team       *)</span>
<span class="c">(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)</span>
<span class="c">(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)</span>
<span class="c">(*   \VV/  **************************************************************)</span>
<span class="c">(*    //   *    This file is distributed under the terms of the         *)</span>
<span class="c">(*         *     GNU Lesser General Public License Version 2.1          *)</span>
<span class="c">(*         *     (see LICENSE file for the text of the license)         *)</span>
<span class="sd">(************************************************************************)</span>

</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Setoid Morphisms Basics Equalities Orders.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Set Implicit Arguments</span>.</span></span></span></pre><div class="doc">
<a name="lab1"></a><h1 class="section">The order tactic</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
This tactic is designed to solve systems of (in)equations
    involving <span class="inlinecode"><span class="id" title="var">eq</span></span>, <span class="inlinecode"><span class="id" title="var">lt</span></span>, <span class="inlinecode"><span class="id" title="var">le</span></span> and <span class="inlinecode">¬¨<span class="id" title="var">eq</span></span> on some type. This tactic is
    domain-agnostic; it will only use equivalence+order axioms, and
    not analyze elements of the domain. Hypothesis or goal of the form
    <span class="inlinecode">¬¨<span class="id" title="var">lt</span></span> or <span class="inlinecode">¬¨<span class="id" title="var">le</span></span> are initially turned into <span class="inlinecode"><span class="id" title="var">le</span></span> and <span class="inlinecode"><span class="id" title="var">lt</span></span>, other
    parts of the goal are ignored. This initial preparation of the
    goal is the only moment where totality is used. In particular,
    the core of the tactic only proceeds by saturation of transitivity
    and similar properties, and does not perform case splitting.
    The tactic will fail if it doesn't solve the goal. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
An abstract vision of the predicates. This allows a one-line
    statement for interesting transitivity properties: for instance
    <span class="inlinecode"><span class="id" title="var">trans_ord</span></span> <span class="inlinecode"><span class="id" title="var">OLE</span></span> <span class="inlinecode"><span class="id" title="var">OLE</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">OLE</span></span> will imply later
    <span class="inlinecode"><span class="id" title="var">le</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">le</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">le</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span>.

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">ord</span> : <span class="kt">Set</span> := OEQ | OLT | OLE.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">trans_ord</span> <span class="nv">o</span> <span class="nv">o&#39;</span> :=
 <span class="kr">match</span> o, o&#39; <span class="kr">with</span>
 | OEQ, _ =&gt; o&#39;
 | _, OEQ =&gt; o
 | OLE, OLE =&gt; OLE
 | _, _ =&gt; OLT
 <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Local</span> <span class="kn">Infix</span> <span class="s2">&quot;+&quot;</span> := trans_ord.</span></span></span></pre><div class="doc">
<a name="lab2"></a><h2 class="section">The tactic requirements : a total order</h2>
<div class="paragraph"> </div>

   We need :
<ul class="doclist">
<li> an equivalence <span class="inlinecode"><span class="id" title="var">eq</span></span>,

</li>
<li> a strict order <span class="inlinecode"><span class="id" title="var">lt</span></span> total and compatible with <span class="inlinecode"><span class="id" title="var">eq</span></span>,

</li>
<li> a larger order <span class="inlinecode"><span class="id" title="var">le</span></span> synonym for <span class="inlinecode"><span class="id" title="var">lt</span>‚à®<span class="id" title="var">eq</span></span>.

</li>
</ul>
<div class="paragraph"> </div>

   This used to be provided here via a <span class="inlinecode"><span class="id" title="var">TotalOrder</span></span>, but
   for technical reasons related to extraction, we now ask
   for two separate parts: relations in a <span class="inlinecode"><span class="id" title="var">EqLtLe</span></span> + properties in
   <span class="inlinecode"><span class="id" title="var">IsTotalOrder</span></span>. Note that <span class="inlinecode"><span class="id" title="var">TotalOrder</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">EqLtLe</span></span> <span class="inlinecode">&lt;+</span> <span class="inlinecode"><span class="id" title="var">IsTotalOrder</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module Type</span> <span class="nf">IsTotalOrder</span> (O:EqLtLe) :=
 IsEq O &lt;+ IsStrOrder O &lt;+ LeIsLtEq O &lt;+ LtIsTotal O.</span></span></span></pre><div class="doc">
<a name="lab3"></a><h2 class="section">Properties that will be used by the <span class="inlinecode"><span class="id" title="var">order</span></span> tactic</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">OrderFacts</span> (<span class="kn">Import</span> O:EqLtLe)(P:IsTotalOrder O).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Include</span> EqLtLeNotation O.</span></span></span></pre><div class="doc">
Reflexivity rules 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk0" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">eq_refl</span> : <span class="kr">forall</span> <span class="nv">x</span>, x==x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : t, x == x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk1" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : t, x == x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk2" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk2"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">le_refl</span> : <span class="kr">forall</span> <span class="nv">x</span>, x&lt;=x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : t, x &lt;= x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk3" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : t, x &lt;= x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span>; <span class="nb">rewrite</span> P.le_lteq; <span class="nb">right</span>; <span class="bp">reflexivity</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk4" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk4"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">lt_irrefl</span> : <span class="kr">forall</span> <span class="nv">x</span>, ~ x&lt;x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : t, ~ x &lt; x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk5" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk5"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : t, ~ x &lt; x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk6" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk6"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ x &lt; x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> StrictOrder_Irreflexive.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Symmetry rules 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk7" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk7"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">eq_sym</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x==y -&gt; y==x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : t, x == y -&gt; y == x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk8" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk8"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : t, x == y -&gt; y == x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto with</span> *.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk9" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk9"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">le_antisym</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x&lt;=y -&gt; y&lt;=x -&gt; x==y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : t, x &lt;= y -&gt; y &lt;= x -&gt; x == y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chka" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chka"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : t, x &lt;= y -&gt; y &lt;= x -&gt; x == y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"> </span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chkb" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chkb"><span class="highlight"><span class="nb">intros</span> x y; <span class="nb">rewrite</span> <span class="mi">2</span> P.le_lteq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt; y \/ x == y -&gt; y &lt; x \/ y == x -&gt; x == y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chkc" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chkc"><span class="highlight"><span class="nb">intuition</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y &lt; x</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x == y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">elim</span> (StrictOrder_Irreflexive x); <span class="nb">transitivity</span> y; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chkd" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chkd"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">neq_sym</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, ~x==y -&gt; ~y==x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : t, x ~= y -&gt; y ~= x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chke" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chke"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : t, x ~= y -&gt; y ~= x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto using</span> eq_sym.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Transitivity rules : first, a generic formulation, then instances
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">subst_eqns</span> :=
 <span class="kr">match goal with</span>
   | H : _==_ |- _ =&gt; (<span class="nb">rewrite</span> H || <span class="nb">rewrite</span> &lt;- H); <span class="nb">clear</span> H; subst_eqns
   | _ =&gt; <span class="kp">idtac</span>
 <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">interp_ord</span> <span class="nv">o</span> :=
 <span class="kr">match</span> o <span class="kr">with</span> OEQ =&gt; O.eq | OLT =&gt; O.lt | OLE =&gt; O.le <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Local Notation</span> <span class="s2">&quot;#&quot;</span> := interp_ord.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chkf" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chkf"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">trans</span> : <span class="kr">forall</span> <span class="nv">o</span> <span class="nv">o&#39;</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, #o x y -&gt; #o&#39; y z -&gt; #(o+o&#39;) x z.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">o</span> <span class="nv">o&#39;</span> : ord) (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : t),
# o x y -&gt; # o&#39; y z -&gt; # (o + o&#39;) x z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk10" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk10"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">o</span> <span class="nv">o&#39;</span> : ord) (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : t),
# o x y -&gt; # o&#39; y z -&gt; # (o + o&#39;) x z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> o, o&#39;; <span class="nb">simpl</span>; <span class="nb">intros</span> x y z;
<span class="nb">rewrite</span> ?P.le_lteq; <span class="nb">intuition</span> <span class="nb">auto</span>;
subst_eqns; <span class="nb">eauto using</span> (StrictOrder_Transitive x y z) <span class="kr">with</span> *.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eq_trans</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : x==y -&gt; y==z -&gt; x==z := @trans OEQ OEQ x y z.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">le_trans</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : x&lt;=y -&gt; y&lt;=z -&gt; x&lt;=z := @trans OLE OLE x y z.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lt_trans</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : x&lt;y -&gt; y&lt;z -&gt; x&lt;z := @trans OLT OLT x y z.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">le_lt_trans</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : x&lt;=y -&gt; y&lt;z -&gt; x&lt;z := @trans OLE OLT x y z.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lt_le_trans</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : x&lt;y -&gt; y&lt;=z -&gt; x&lt;z := @trans OLT OLE x y z.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eq_lt</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : x==y -&gt; y&lt;z -&gt; x&lt;z := @trans OEQ OLT x y z.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lt_eq</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : x&lt;y -&gt; y==z -&gt; x&lt;z := @trans OLT OEQ x y z.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eq_le</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : x==y -&gt; y&lt;=z -&gt; x&lt;=z := @trans OEQ OLE x y z.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">le_eq</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : x&lt;=y -&gt; y==z -&gt; x&lt;=z := @trans OLE OEQ x y z.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk11" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk11"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">eq_neq</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, x==y -&gt; ~y==z -&gt; ~x==z.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : t, x == y -&gt; y ~= z -&gt; x ~= z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk12" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk12"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : t, x == y -&gt; y ~= z -&gt; x ~= z</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eauto using</span> eq_trans, eq_sym.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk13" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk13"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">neq_eq</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, ~x==y -&gt; y==z -&gt; ~x==z.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : t, x ~= y -&gt; y == z -&gt; x ~= z</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk14" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk14"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : t, x ~= y -&gt; y == z -&gt; x ~= z</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eauto using</span> eq_trans, eq_sym.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
(double) negation rules 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk15" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk15"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">not_neq_eq</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, ~~x==y -&gt; x==y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : t, ~ x ~= y -&gt; x == y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk16" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk16"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : t, ~ x ~= y -&gt; x == y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk17" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk17"><span class="highlight"><span class="nb">intros</span> x y H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ x ~= y</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x == y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> (P.lt_total x y) <span class="kr">as</span> [H&#39;|[H&#39;|H&#39;]]; <span class="nb">auto</span>;
 <span class="nb">destruct</span> H; <span class="nb">intro</span> H; <span class="nb">rewrite</span> H <span class="kr">in</span> H&#39;; <span class="nb">eapply</span> lt_irrefl; <span class="nb">eauto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk18" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk18"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">not_ge_lt</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, ~y&lt;=x -&gt; x&lt;y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : t, ~ y &lt;= x -&gt; x &lt; y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk19" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk19"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : t, ~ y &lt;= x -&gt; x &lt; y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk1a" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk1a"><span class="highlight"><span class="nb">intros</span> x y H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ y &lt;= x</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt; y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk1b"><span class="highlight"><span class="nb">destruct</span> (P.lt_total x y); <span class="nb">auto</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ y &lt;= x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x == y \/ y &lt; x</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt; y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk1c"><span class="highlight"><span class="nb">destruct</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x == y \/ y &lt; x</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">y &lt;= x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk1d" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk1d"><span class="highlight"><span class="nb">rewrite</span> P.le_lteq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x == y \/ y &lt; x</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">y &lt; x \/ y == x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intuition</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk1e"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">not_gt_le</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, ~y&lt;x -&gt; x&lt;=y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : t, ~ y &lt; x -&gt; x &lt;= y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk1f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : t, ~ y &lt; x -&gt; x &lt;= y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk20" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk20"><span class="highlight"><span class="nb">intros</span> x y H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ y &lt; x</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt;= y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk21" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk21"><span class="highlight"><span class="nb">rewrite</span> P.le_lteq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">t</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ y &lt; x</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt; y \/ x == y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">generalize</span> (P.lt_total x y); <span class="nb">intuition</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk22" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk22"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">le_neq_lt</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x&lt;=y -&gt; ~x==y -&gt; x&lt;y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : t, x &lt;= y -&gt; x ~= y -&gt; x &lt; y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="OrdersTac-v-chk23" style="display: none" type="checkbox"><label class="coq-input" for="OrdersTac-v-chk23"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : t, x &lt;= y -&gt; x ~= y -&gt; x &lt; y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto using</span> not_ge_lt, le_antisym.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">OrderFacts</span>.</span></span></span></pre><div class="doc">
<a name="lab4"></a><h2 class="section"><span class="inlinecode"><span class="id" title="var">MakeOrderTac</span></span> : The functor providing the order tactic.</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">MakeOrderTac</span> (<span class="kn">Import</span> O:EqLtLe)(P:IsTotalOrder O).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Include</span> OrderFacts O P.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Include</span> EqLtLeNotation O.</span></span></span></pre><div class="doc">
order_eq : replace x by y in all (in)equations hyps thanks
   to equality EQ (where eq has been hidden in order to avoid
   self-rewriting), then discard EQ. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">order_rewr</span> x <span class="nb">eqn</span> :=
 <span class="c">(* NB: we could use the real rewrite here, but proofs would be uglier. *)</span>
 <span class="kr">let</span> <span class="nv">rewr</span> <span class="nv">H</span> <span class="nv">t</span> := <span class="nb">generalize</span> t; <span class="nb">clear</span> H; <span class="nb">intro</span> H
 <span class="kr">in</span>
 <span class="kr">match goal with</span>
 | H : x == _ |- _ =&gt; rewr H (eq_trans (eq_sym <span class="nb">eqn</span>) H); order_rewr x <span class="nb">eqn</span>
 | H : _ == x |- _ =&gt; rewr H (eq_trans H <span class="nb">eqn</span>); order_rewr x <span class="nb">eqn</span>
 | H : ~x == _ |- _ =&gt; rewr H (eq_neq (eq_sym <span class="nb">eqn</span>) H); order_rewr x <span class="nb">eqn</span>
 | H : ~_ == x |- _ =&gt; rewr H (neq_eq H <span class="nb">eqn</span>); order_rewr x <span class="nb">eqn</span>
 | H : x &lt; _ |- _ =&gt; rewr H (eq_lt (eq_sym <span class="nb">eqn</span>) H); order_rewr x <span class="nb">eqn</span>
 | H : _ &lt; x |- _ =&gt; rewr H (lt_eq H <span class="nb">eqn</span>); order_rewr x <span class="nb">eqn</span>
 | H : x &lt;= _ |- _ =&gt; rewr H (eq_le (eq_sym <span class="nb">eqn</span>) H); order_rewr x <span class="nb">eqn</span>
 | H : _ &lt;= x |- _ =&gt; rewr H (le_eq H <span class="nb">eqn</span>); order_rewr x <span class="nb">eqn</span>
 | _ =&gt; <span class="nb">clear</span> <span class="nb">eqn</span>
<span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">order_eq</span> x y <span class="nb">eqn</span> :=
 <span class="kr">match</span> x <span class="kr">with</span>
 | y =&gt; <span class="nb">clear</span> <span class="nb">eqn</span>
 | _ =&gt; <span class="nb">change</span> (interp_ord OEQ x y) <span class="kr">in</span> <span class="nb">eqn</span>; order_rewr x <span class="nb">eqn</span>
 <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Goal preparation : We turn all negative hyps into positive ones
  and try to prove False from the inverse of the current goal.
  These steps require totality of our order. After this preparation,
  order only deals with the context, and tries to prove False.
  Hypotheses of the form <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">‚Üí</span> <span class="inlinecode"><span class="id" title="var">False</span></span> are also folded in <span class="inlinecode">¬¨<span class="id" title="var">A</span></span>
  for convenience (i.e. cope with the mess left by intuition). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">order_prepare</span> :=
 <span class="kr">match goal with</span>
 | H : ?A -&gt; <span class="kt">False</span> |- _ =&gt; <span class="nb">change</span> (~A) <span class="kr">in</span> H; order_prepare
 | H : ~(?R ?x ?y) |- _ =&gt;
   <span class="kr">match</span> R <span class="kr">with</span>
   | eq =&gt; <span class="kp">fail</span> <span class="mi">1</span> <span class="c">(* if already using [eq], we leave it this ways *)</span>
   | _ =&gt; (<span class="nb">change</span> (~x==y) <span class="kr">in</span> H ||
           <span class="nb">apply</span> not_gt_le <span class="kr">in</span> H ||
           <span class="nb">apply</span> not_ge_lt <span class="kr">in</span> H ||
           <span class="nb">clear</span> H || <span class="kp">fail</span> <span class="mi">1</span>); order_prepare
   <span class="kr">end</span>
 | H : ?R ?x ?y |- _ =&gt;
   <span class="kr">match</span> R <span class="kr">with</span>
   | eq =&gt; <span class="kp">fail</span> <span class="mi">1</span>
   | lt =&gt; <span class="kp">fail</span> <span class="mi">1</span>
   | le =&gt; <span class="kp">fail</span> <span class="mi">1</span>
   | _ =&gt; (<span class="nb">change</span> (x==y) <span class="kr">in</span> H ||
           <span class="nb">change</span> (x&lt;y) <span class="kr">in</span> H ||
           <span class="nb">change</span> (x&lt;=y) <span class="kr">in</span> H ||
           <span class="nb">clear</span> H || <span class="kp">fail</span> <span class="mi">1</span>); order_prepare
   <span class="kr">end</span>
 | |- ~ _ =&gt; <span class="nb">intro</span>; order_prepare
 | |- _ ?x ?x =&gt;
   <span class="bp">exact</span> (eq_refl x) || <span class="bp">exact</span> (le_refl x) || <span class="nb">exfalso</span>
 | _ =&gt;
   (<span class="nb">apply</span> not_neq_eq; <span class="nb">intro</span>) ||
   (<span class="nb">apply</span> not_ge_lt; <span class="nb">intro</span>) ||
   (<span class="nb">apply</span> not_gt_le; <span class="nb">intro</span>) || <span class="nb">exfalso</span>
 <span class="kr">end</span>.</span></span></span></pre><div class="doc">
We now try to prove False from the various <span class="inlinecode">&lt;</span> <span class="inlinecode">‚â§</span> <span class="inlinecode">==</span> <span class="inlinecode">!=</span> hypothesis 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">order_loop</span> :=
 <span class="kr">match goal with</span>
 <span class="c">(* First, successful situations *)</span>
 | H : ?x &lt; ?x |- _ =&gt; <span class="bp">exact</span> (lt_irrefl H)
 | H : ~ ?x == ?x |- _ =&gt; <span class="bp">exact</span> (H (eq_refl x))
 <span class="c">(* Second, useless hyps *)</span>
 | H : ?x &lt;= ?x |- _ =&gt; <span class="nb">clear</span> H; order_loop
 <span class="c">(* Third, we eliminate equalities *)</span>
 | H : ?x == ?y |- _ =&gt; order_eq x y H; order_loop
 <span class="c">(* Simultaneous le and ge is eq *)</span>
 | H1 : ?x &lt;= ?y, H2 : ?y &lt;= ?x |- _ =&gt;
     <span class="nb">generalize</span> (le_antisym H1 H2); <span class="nb">clear</span> H1 H2; <span class="nb">intro</span>; order_loop
 <span class="c">(* Simultaneous le and ~eq is lt *)</span>
 | H1: ?x &lt;= ?y, H2: ~ ?x == ?y |- _ =&gt;
     <span class="nb">generalize</span> (le_neq_lt H1 H2); <span class="nb">clear</span> H1 H2; <span class="nb">intro</span>; order_loop
 | H1: ?x &lt;= ?y, H2: ~ ?y == ?x |- _ =&gt;
     <span class="nb">generalize</span> (le_neq_lt H1 (neq_sym H2)); <span class="nb">clear</span> H1 H2; <span class="nb">intro</span>; order_loop
 <span class="c">(* Transitivity of lt and le *)</span>
 | H1 : ?x &lt; ?y, H2 : ?y &lt; ?z |- _ =&gt;
    <span class="kr">match goal with</span>
      | H : x &lt; z |- _ =&gt; <span class="kp">fail</span> <span class="mi">1</span>
      | _ =&gt; <span class="nb">generalize</span> (lt_trans H1 H2); <span class="nb">intro</span>; order_loop
    <span class="kr">end</span>
 | H1 : ?x &lt;= ?y, H2 : ?y &lt; ?z |- _ =&gt;
    <span class="kr">match goal with</span>
      | H : x &lt; z |- _ =&gt; <span class="kp">fail</span> <span class="mi">1</span>
      | _ =&gt; <span class="nb">generalize</span> (le_lt_trans H1 H2); <span class="nb">intro</span>; order_loop
    <span class="kr">end</span>
 | H1 : ?x &lt; ?y, H2 : ?y &lt;= ?z |- _ =&gt;
    <span class="kr">match goal with</span>
      | H : x &lt; z |- _ =&gt; <span class="kp">fail</span> <span class="mi">1</span>
      | _ =&gt; <span class="nb">generalize</span> (lt_le_trans H1 H2); <span class="nb">intro</span>; order_loop
    <span class="kr">end</span>
 | H1 : ?x &lt;= ?y, H2 : ?y &lt;= ?z |- _ =&gt;
    <span class="kr">match goal with</span>
      | H : x &lt;= z |- _ =&gt; <span class="kp">fail</span> <span class="mi">1</span>
      | _ =&gt; <span class="nb">generalize</span> (le_trans H1 H2); <span class="nb">intro</span>; order_loop
    <span class="kr">end</span>
 | _ =&gt; <span class="kp">idtac</span>
<span class="kr">end</span>.</span></span></span></pre><div class="doc">
The complete tactic. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">order</span> :=
 <span class="nb">intros</span>; order_prepare; order_loop; <span class="kp">fail</span> <span class="s2">&quot;Order tactic unsuccessful&quot;</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">MakeOrderTac</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">OTF_to_OrderTac</span> (OTF:OrderedTypeFull).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">TO</span> := OTF_to_TotalOrder OTF.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Include</span> !MakeOrderTac OTF TO.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">OTF_to_OrderTac</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">OT_to_OrderTac</span> (OT:OrderedType).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">OTF</span> := OT_to_Full OT.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"> </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Include</span> !OTF_to_OrderTac OTF.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">OT_to_OrderTac</span>.</span></span></span></pre></article></body></html>