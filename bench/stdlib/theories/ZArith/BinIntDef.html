<!DOCTYPE html>
<html><head><title>BinIntDef.v</title><meta charset="utf-8"><meta content="Alectryon v0.2" name="generator"><link href="alectryon.css" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script><style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-standalone alectryon-centered alectryon-coqdoc"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* -*- coding: utf-8 -*- *)</span>
<span class="sd">(************************************************************************)</span>
<span class="c">(*         *   The Coq Proof Assistant / The Coq Development Team       *)</span>
<span class="c">(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)</span>
<span class="c">(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)</span>
<span class="c">(*   \VV/  **************************************************************)</span>
<span class="c">(*    //   *    This file is distributed under the terms of the         *)</span>
<span class="c">(*         *     GNU Lesser General Public License Version 2.1          *)</span>
<span class="c">(*         *     (see LICENSE file for the text of the license)         *)</span>
<span class="sd">(************************************************************************)</span>

</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Export</span> BinNums.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> BinPos BinNat.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Local Open Scope</span> Z_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Local Notation</span> <span class="s2">&quot;0&quot;</span> := Z0.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Local Notation</span> <span class="s2">&quot;1&quot;</span> := (Zpos <span class="mi">1</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Local Notation</span> <span class="s2">&quot;2&quot;</span> := (Zpos <span class="mi">2</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="sd">(***********************************************************)</span></span></span></pre><div class="doc">
<a name="lab1"></a><h1 class="section">Binary Integers, Definitions of Operations</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="sd">(***********************************************************)</span></span></span></pre><div class="doc">
Initial author: Pierre Cr√©gut, CNET, Lannion, France 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">Z</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">t</span> := Z.</span></span></span></pre><div class="doc">
<a name="lab2"></a><h2 class="section">Nicer names <span class="inlinecode"><span class="id" title="var">Z.pos</span></span> and <span class="inlinecode"><span class="id" title="var">Z.neg</span></span> for constructors</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">pos</span> := Zpos.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">neg</span> := Zneg.</span></span></span></pre><div class="doc">
<a name="lab3"></a><h2 class="section">Constants</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">zero</span> := <span class="mi">0</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">one</span> := <span class="mi">1</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">two</span> := <span class="mi">2</span>.</span></span></span></pre><div class="doc">
<a name="lab4"></a><h2 class="section">Doubling and variants</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">double</span> <span class="nv">x</span> :=
  <span class="kr">match</span> x <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; <span class="mi">0</span>
    | pos p =&gt; pos p~<span class="mi">0</span>
    | neg p =&gt; neg p~<span class="mi">0</span>
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">succ_double</span> <span class="nv">x</span> :=
  <span class="kr">match</span> x <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; <span class="mi">1</span>
    | pos p =&gt; pos p~<span class="mi">1</span>
    | neg p =&gt; neg (Pos.pred_double p)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">pred_double</span> <span class="nv">x</span> :=
  <span class="kr">match</span> x <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; neg <span class="mi">1</span>
    | neg p =&gt; neg p~<span class="mi">1</span>
    | pos p =&gt; pos (Pos.pred_double p)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab5"></a><h2 class="section">Subtraction of positive into Z</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">pos_sub</span> (<span class="nv">x</span> <span class="nv">y</span>:positive) {<span class="nv">struct</span> <span class="nv">y</span>} : Z :=
  <span class="kr">match</span> x, y <span class="kr">with</span>
    | p~<span class="mi">1</span>, q~<span class="mi">1</span> =&gt; double (pos_sub p q)
    | p~<span class="mi">1</span>, q~<span class="mi">0</span> =&gt; succ_double (pos_sub p q)
    | p~<span class="mi">1</span>, <span class="mi">1</span> =&gt; pos p~<span class="mi">0</span>
    | p~<span class="mi">0</span>, q~<span class="mi">1</span> =&gt; pred_double (pos_sub p q)
    | p~<span class="mi">0</span>, q~<span class="mi">0</span> =&gt; double (pos_sub p q)
    | p~<span class="mi">0</span>, <span class="mi">1</span> =&gt; pos (Pos.pred_double p)
    | <span class="mi">1</span>, q~<span class="mi">1</span> =&gt; neg q~<span class="mi">0</span>
    | <span class="mi">1</span>, q~<span class="mi">0</span> =&gt; neg (Pos.pred_double q)
    | <span class="mi">1</span>, <span class="mi">1</span> =&gt; Z0
  <span class="kr">end</span>%positive.</span></span></span></pre><div class="doc">
<a name="lab6"></a><h2 class="section">Addition</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">add</span> <span class="nv">x</span> <span class="nv">y</span> :=
  <span class="kr">match</span> x, y <span class="kr">with</span>
    | <span class="mi">0</span>, y =&gt; y
    | x, <span class="mi">0</span> =&gt; x
    | pos x&#39;, pos y&#39; =&gt; pos (x&#39; + y&#39;)
    | pos x&#39;, neg y&#39; =&gt; pos_sub x&#39; y&#39;
    | neg x&#39;, pos y&#39; =&gt; pos_sub y&#39; x&#39;
    | neg x&#39;, neg y&#39; =&gt; neg (x&#39; + y&#39;)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;+&quot;</span> := add : Z_scope.</span></span></span></pre><div class="doc">
<a name="lab7"></a><h2 class="section">Opposite</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">opp</span> <span class="nv">x</span> :=
  <span class="kr">match</span> x <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; <span class="mi">0</span>
    | pos x =&gt; neg x
    | neg x =&gt; pos x
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;- x&quot;</span> := (opp x) : Z_scope.</span></span></span></pre><div class="doc">
<a name="lab8"></a><h2 class="section">Successor</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">succ</span> <span class="nv">x</span> := x + <span class="mi">1</span>.</span></span></span></pre><div class="doc">
<a name="lab9"></a><h2 class="section">Predecessor</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">pred</span> <span class="nv">x</span> := x + neg <span class="mi">1</span>.</span></span></span></pre><div class="doc">
<a name="lab10"></a><h2 class="section">Subtraction</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">sub</span> <span class="nv">m</span> <span class="nv">n</span> := m + -n.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;-&quot;</span> := sub : Z_scope.</span></span></span></pre><div class="doc">
<a name="lab11"></a><h2 class="section">Multiplication</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">mul</span> <span class="nv">x</span> <span class="nv">y</span> :=
  <span class="kr">match</span> x, y <span class="kr">with</span>
    | <span class="mi">0</span>, _ =&gt; <span class="mi">0</span>
    | _, <span class="mi">0</span> =&gt; <span class="mi">0</span>
    | pos x&#39;, pos y&#39; =&gt; pos (x&#39; * y&#39;)
    | pos x&#39;, neg y&#39; =&gt; neg (x&#39; * y&#39;)
    | neg x&#39;, pos y&#39; =&gt; neg (x&#39; * y&#39;)
    | neg x&#39;, neg y&#39; =&gt; pos (x&#39; * y&#39;)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;*&quot;</span> := mul : Z_scope.</span></span></span></pre><div class="doc">
<a name="lab12"></a><h2 class="section">Power function</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">pow_pos</span> (<span class="nv">z</span>:Z) := Pos.iter (mul z) <span class="mi">1</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">pow</span> <span class="nv">x</span> <span class="nv">y</span> :=
  <span class="kr">match</span> y <span class="kr">with</span>
    | pos p =&gt; pow_pos x p
    | <span class="mi">0</span> =&gt; <span class="mi">1</span>
    | neg _ =&gt; <span class="mi">0</span>
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;^&quot;</span> := pow : Z_scope.</span></span></span></pre><div class="doc">
<a name="lab13"></a><h2 class="section">Square</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">square</span> <span class="nv">x</span> :=
  <span class="kr">match</span> x <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; <span class="mi">0</span>
    | pos p =&gt; pos (Pos.square p)
    | neg p =&gt; pos (Pos.square p)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab14"></a><h2 class="section">Comparison</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">compare</span> <span class="nv">x</span> <span class="nv">y</span> :=
  <span class="kr">match</span> x, y <span class="kr">with</span>
    | <span class="mi">0</span>, <span class="mi">0</span> =&gt; Eq
    | <span class="mi">0</span>, pos y&#39; =&gt; Lt
    | <span class="mi">0</span>, neg y&#39; =&gt; Gt
    | pos x&#39;, <span class="mi">0</span> =&gt; Gt
    | pos x&#39;, pos y&#39; =&gt; (x&#39; ?= y&#39;)%positive
    | pos x&#39;, neg y&#39; =&gt; Gt
    | neg x&#39;, <span class="mi">0</span> =&gt; Lt
    | neg x&#39;, pos y&#39; =&gt; Lt
    | neg x&#39;, neg y&#39; =&gt; CompOpp ((x&#39; ?= y&#39;)%positive)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;?=&quot;</span> := <span class="nb">compare</span> (<span class="kn">at level</span> <span class="mi">70</span>, <span class="kn">no associativity</span>) : Z_scope.</span></span></span></pre><div class="doc">
<a name="lab15"></a><h2 class="section">Sign function</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">sgn</span> <span class="nv">z</span> :=
  <span class="kr">match</span> z <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; <span class="mi">0</span>
    | pos p =&gt; <span class="mi">1</span>
    | neg p =&gt; neg <span class="mi">1</span>
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Boolean equality and comparisons 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">leb</span> <span class="nv">x</span> <span class="nv">y</span> :=
  <span class="kr">match</span> x ?= y <span class="kr">with</span>
    | Gt =&gt; false
    | _ =&gt; true
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ltb</span> <span class="nv">x</span> <span class="nv">y</span> :=
  <span class="kr">match</span> x ?= y <span class="kr">with</span>
    | Lt =&gt; true
    | _ =&gt; false
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Nota: <span class="inlinecode"><span class="id" title="var">geb</span></span> and <span class="inlinecode"><span class="id" title="var">gtb</span></span> are provided for compatibility,
  but <span class="inlinecode"><span class="id" title="var">leb</span></span> and <span class="inlinecode"><span class="id" title="var">ltb</span></span> should rather be used instead, since
  more results will be available on them. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">geb</span> <span class="nv">x</span> <span class="nv">y</span> :=
  <span class="kr">match</span> x ?= y <span class="kr">with</span>
    | Lt =&gt; false
    | _ =&gt; true
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">gtb</span> <span class="nv">x</span> <span class="nv">y</span> :=
  <span class="kr">match</span> x ?= y <span class="kr">with</span>
    | Gt =&gt; true
    | _ =&gt; false
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">eqb</span> <span class="nv">x</span> <span class="nv">y</span> :=
  <span class="kr">match</span> x, y <span class="kr">with</span>
    | <span class="mi">0</span>, <span class="mi">0</span> =&gt; true
    | pos p, pos q =&gt; Pos.eqb p q
    | neg p, neg q =&gt; Pos.eqb p q
    | _, _ =&gt; false
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;=?&quot;</span> := eqb (<span class="kn">at level</span> <span class="mi">70</span>, <span class="kn">no associativity</span>) : Z_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;&lt;=?&quot;</span> := leb (<span class="kn">at level</span> <span class="mi">70</span>, <span class="kn">no associativity</span>) : Z_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;&lt;?&quot;</span> := ltb (<span class="kn">at level</span> <span class="mi">70</span>, <span class="kn">no associativity</span>) : Z_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;&gt;=?&quot;</span> := geb (<span class="kn">at level</span> <span class="mi">70</span>, <span class="kn">no associativity</span>) : Z_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;&gt;?&quot;</span> := gtb (<span class="kn">at level</span> <span class="mi">70</span>, <span class="kn">no associativity</span>) : Z_scope.</span></span></span></pre><div class="doc">
<a name="lab16"></a><h2 class="section">Minimum and maximum</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">max</span> <span class="nv">n</span> <span class="nv">m</span> :=
  <span class="kr">match</span> n ?= m <span class="kr">with</span>
    | Eq | Gt =&gt; n
    | Lt =&gt; m
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">min</span> <span class="nv">n</span> <span class="nv">m</span> :=
  <span class="kr">match</span> n ?= m <span class="kr">with</span>
    | Eq | Lt =&gt; n
    | Gt =&gt; m
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab17"></a><h2 class="section">Absolute value</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">abs</span> <span class="nv">z</span> :=
  <span class="kr">match</span> z <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; <span class="mi">0</span>
    | pos p =&gt; pos p
    | neg p =&gt; pos p
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab18"></a><h2 class="section">Conversions</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
From <span class="inlinecode"><span class="id" title="var">Z</span></span> to <span class="inlinecode"><span class="id" title="var">nat</span></span> via absolute value 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">abs_nat</span> (<span class="nv">z</span>:Z) : nat :=
  <span class="kr">match</span> z <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; <span class="mi">0</span>%nat
    | pos p =&gt; Pos.to_nat p
    | neg p =&gt; Pos.to_nat p
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
From <span class="inlinecode"><span class="id" title="var">Z</span></span> to <span class="inlinecode"><span class="id" title="var">N</span></span> via absolute value 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">abs_N</span> (<span class="nv">z</span>:Z) : N :=
  <span class="kr">match</span> z <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; <span class="mi">0</span>%N
    | pos p =&gt; N.pos p
    | neg p =&gt; N.pos p
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
From <span class="inlinecode"><span class="id" title="var">Z</span></span> to <span class="inlinecode"><span class="id" title="var">nat</span></span> by rounding negative numbers to 0 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">to_nat</span> (<span class="nv">z</span>:Z) : nat :=
  <span class="kr">match</span> z <span class="kr">with</span>
    | pos p =&gt; Pos.to_nat p
    | _ =&gt; O
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
From <span class="inlinecode"><span class="id" title="var">Z</span></span> to <span class="inlinecode"><span class="id" title="var">N</span></span> by rounding negative numbers to 0 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">to_N</span> (<span class="nv">z</span>:Z) : N :=
  <span class="kr">match</span> z <span class="kr">with</span>
    | pos p =&gt; N.pos p
    | _ =&gt; <span class="mi">0</span>%N
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
From <span class="inlinecode"><span class="id" title="var">nat</span></span> to <span class="inlinecode"><span class="id" title="var">Z</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">of_nat</span> (<span class="nv">n</span>:nat) : Z :=
  <span class="kr">match</span> n <span class="kr">with</span>
   | O =&gt; <span class="mi">0</span>
   | S n =&gt; pos (Pos.of_succ_nat n)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
From <span class="inlinecode"><span class="id" title="var">N</span></span> to <span class="inlinecode"><span class="id" title="var">Z</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">of_N</span> (<span class="nv">n</span>:N) : Z :=
  <span class="kr">match</span> n <span class="kr">with</span>
    | <span class="mi">0</span>%N =&gt; <span class="mi">0</span>
    | N.pos p =&gt; pos p
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
From <span class="inlinecode"><span class="id" title="var">Z</span></span> to <span class="inlinecode"><span class="id" title="var">positive</span></span> by rounding nonpositive numbers to 1 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">to_pos</span> (<span class="nv">z</span>:Z) : positive :=
  <span class="kr">match</span> z <span class="kr">with</span>
    | pos p =&gt; p
    | _ =&gt; <span class="mi">1</span>%positive
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Conversion with a decimal representation for printing/parsing 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">of_uint</span> (<span class="nv">d</span>:Decimal.uint) := of_N (Pos.of_uint d).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">of_int</span> (<span class="nv">d</span>:Decimal.int) :=
  <span class="kr">match</span> d <span class="kr">with</span>
  | Decimal.Pos d =&gt; of_uint d
  | Decimal.Neg d =&gt; opp (of_uint d)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">to_int</span> <span class="nv">n</span> :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; Decimal.Pos Decimal.zero
  | pos p =&gt; Decimal.Pos (Pos.to_uint p)
  | neg p =&gt; Decimal.Neg (Pos.to_uint p)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab19"></a><h2 class="section">Iteration of a function</h2>
<div class="paragraph"> </div>

    By convention, iterating a negative number of times is identity.

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">iter</span> (<span class="nv">n</span>:Z) {<span class="nv">A</span>} (<span class="nv">f</span>:A -&gt; A) (<span class="nv">x</span>:A) :=
  <span class="kr">match</span> n <span class="kr">with</span>
    | pos p =&gt; Pos.iter f x p
    | _ =&gt; x
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab20"></a><h2 class="section">Euclidean divisions for binary integers</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
Concerning the many possible variants of integer divisions,
    see the headers of the generic files <span class="inlinecode"><span class="id" title="var">ZDivFloor</span></span>, <span class="inlinecode"><span class="id" title="var">ZDivTrunc</span></span>,
    <span class="inlinecode"><span class="id" title="var">ZDivEucl</span></span>, and the article by R. Boute mentioned there.
    We provide here two flavours, Floor and Trunc, while
    the Euclid convention can be found in file Zeuclid.v
    For non-zero b, they all satisfy <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span>*(<span class="id" title="var">a</span>/<span class="id" title="var">b</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode">(<span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">mod</span></span> <span class="inlinecode"><span class="id" title="var">b</span>)</span>
    and <span class="inlinecode"></span> <span class="inlinecode">|<span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">mod</span></span> <span class="inlinecode"><span class="id" title="var">b</span>|</span> <span class="inlinecode">&lt;</span> <span class="inlinecode">|<span class="id" title="var">b</span>|</span> <span class="inlinecode"></span>, but the sign of the modulo will differ
    when <span class="inlinecode"><span class="id" title="var">a</span>&lt;0</span> and/or <span class="inlinecode"><span class="id" title="var">b</span>&lt;0</span>.

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab21"></a><h2 class="section">Floor division</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">div_eucl</span></span> provides a Truncated-Toward-Bottom (a.k.a Floor)
  Euclidean division. Its projections are named <span class="inlinecode"><span class="id" title="var">div</span></span> (noted "/")
  and <span class="inlinecode"><span class="id" title="var">modulo</span></span> (noted with an infix "mod").
  These functions correspond to the `div` and `mod` of Haskell.
  This is the historical convention of Coq.

<div class="paragraph"> </div>

  The main properties of this convention are :
<ul class="doclist">
<li> we have <span class="inlinecode"><span class="id" title="var">sgn</span></span> <span class="inlinecode">(<span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">mod</span></span> <span class="inlinecode"><span class="id" title="var">b</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sgn</span></span> <span class="inlinecode">(<span class="id" title="var">b</span>)</span>
</li>
<li> <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> is the greatest integer smaller or equal to the exact
      fraction <span class="inlinecode"><span class="id" title="var">a</span>/<span class="id" title="var">b</span></span>.

</li>
<li> there is no easy sign rule.

</li>
</ul>
<div class="paragraph"> </div>

  In addition, note that we arbitrary take <span class="inlinecode"><span class="id" title="var">a</span>/0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> and <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">mod</span></span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>.

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
First, a division for positive numbers. Even if the second
   argument is a Z, the answer is arbitrary is it isn't a Zpos. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">pos_div_eucl</span> (<span class="nv">a</span>:positive) (<span class="nv">b</span>:Z) : Z * Z :=
  <span class="kr">match</span> a <span class="kr">with</span>
    | xH =&gt; <span class="kr">if</span> <span class="mi">2</span> &lt;=? b <span class="kr">then</span> (<span class="mi">0</span>, <span class="mi">1</span>) <span class="kr">else</span> (<span class="mi">1</span>, <span class="mi">0</span>)
    | xO a&#39; =&gt;
      <span class="kr">let</span> (<span class="nv">q</span>, r) := pos_div_eucl a&#39; b <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">r&#39;</span> := <span class="mi">2</span> * r <span class="kr">in</span>
      <span class="kr">if</span> r&#39; &lt;? b <span class="kr">then</span> (<span class="mi">2</span> * q, r&#39;) <span class="kr">else</span> (<span class="mi">2</span> * q + <span class="mi">1</span>, r&#39; - b)
    | xI a&#39; =&gt;
      <span class="kr">let</span> (<span class="nv">q</span>, r) := pos_div_eucl a&#39; b <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">r&#39;</span> := <span class="mi">2</span> * r + <span class="mi">1</span> <span class="kr">in</span>
      <span class="kr">if</span> r&#39; &lt;? b <span class="kr">then</span> (<span class="mi">2</span> * q, r&#39;) <span class="kr">else</span> (<span class="mi">2</span> * q + <span class="mi">1</span>, r&#39; - b)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Then the general euclidean division 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">div_eucl</span> (<span class="nv">a</span> <span class="nv">b</span>:Z) : Z * Z :=
  <span class="kr">match</span> a, b <span class="kr">with</span>
    | <span class="mi">0</span>, _ =&gt; (<span class="mi">0</span>, <span class="mi">0</span>)
    | _, <span class="mi">0</span> =&gt; (<span class="mi">0</span>, <span class="mi">0</span>)
    | pos a&#39;, pos _ =&gt; pos_div_eucl a&#39; b
    | neg a&#39;, pos _ =&gt;
      <span class="kr">let</span> (<span class="nv">q</span>, r) := pos_div_eucl a&#39; b <span class="kr">in</span>
	<span class="kr">match</span> r <span class="kr">with</span>
	  | <span class="mi">0</span> =&gt; (- q, <span class="mi">0</span>)
	  | _ =&gt; (- (q + <span class="mi">1</span>), b - r)
	<span class="kr">end</span>
    | neg a&#39;, neg b&#39; =&gt;
      <span class="kr">let</span> (<span class="nv">q</span>, r) := pos_div_eucl a&#39; (pos b&#39;) <span class="kr">in</span> (q, - r)
    | pos a&#39;, neg b&#39; =&gt;
      <span class="kr">let</span> (<span class="nv">q</span>, r) := pos_div_eucl a&#39; (pos b&#39;) <span class="kr">in</span>
	<span class="kr">match</span> r <span class="kr">with</span>
	  | <span class="mi">0</span> =&gt; (- q, <span class="mi">0</span>)
	  | _ =&gt; (- (q + <span class="mi">1</span>), b + r)
	<span class="kr">end</span>
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">div</span> (<span class="nv">a</span> <span class="nv">b</span>:Z) : Z := <span class="kr">let</span> (<span class="nv">q</span>, _) := div_eucl a b <span class="kr">in</span> q.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">modulo</span> (<span class="nv">a</span> <span class="nv">b</span>:Z) : Z := <span class="kr">let</span> (<span class="nv">_</span>, r) := div_eucl a b <span class="kr">in</span> r.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;/&quot;</span> := div : Z_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;mod&quot;</span> := modulo (<span class="kn">at level</span> <span class="mi">40</span>, <span class="kn">no associativity</span>) : Z_scope.</span></span></span></pre><div class="doc">
<a name="lab22"></a><h2 class="section">Trunc Division</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">quotrem</span></span> provides a Truncated-Toward-Zero Euclidean division.
  Its projections are named <span class="inlinecode"><span class="id" title="var">quot</span></span> (noted "√∑") and <span class="inlinecode"><span class="id" title="var">rem</span></span>.
  These functions correspond to the `quot` and `rem` of Haskell.
  This division convention is used in most programming languages,
  e.g. Ocaml.

<div class="paragraph"> </div>

  With this convention:
<ul class="doclist">
<li> we have <span class="inlinecode"><span class="id" title="var">sgn</span>(<span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">rem</span></span> <span class="inlinecode"><span class="id" title="var">b</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sgn</span>(<span class="id" title="var">a</span>)</span>
</li>
<li> sign rule for division: <span class="inlinecode"><span class="id" title="var">quot</span></span> <span class="inlinecode">(-<span class="id" title="var">a</span>)</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">quot</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">(-<span class="id" title="var">b</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode">-(<span class="id" title="var">quot</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span>)</span>
</li>
<li> and for modulo: <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">rem</span></span> <span class="inlinecode">(-<span class="id" title="var">b</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">rem</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> and <span class="inlinecode">(-<span class="id" title="var">a</span>)</span> <span class="inlinecode"><span class="id" title="var">rem</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode">-(<span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">rem</span></span> <span class="inlinecode"><span class="id" title="var">b</span>)</span>
</li>
</ul>
<div class="paragraph"> </div>

 Note that we arbitrary take here <span class="inlinecode"><span class="id" title="var">quot</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> and <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">rem</span></span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span>.

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">quotrem</span> (<span class="nv">a</span> <span class="nv">b</span>:Z) : Z * Z :=
  <span class="kr">match</span> a, b <span class="kr">with</span>
   | <span class="mi">0</span>,  _ =&gt; (<span class="mi">0</span>, <span class="mi">0</span>)
   | _, <span class="mi">0</span>  =&gt; (<span class="mi">0</span>, a)
   | pos a, pos b =&gt;
     <span class="kr">let</span> (<span class="nv">q</span>, r) := N.pos_div_eucl a (N.pos b) <span class="kr">in</span> (of_N q, of_N r)
   | neg a, pos b =&gt;
     <span class="kr">let</span> (<span class="nv">q</span>, r) := N.pos_div_eucl a (N.pos b) <span class="kr">in</span> (-of_N q, - of_N r)
   | pos a, neg b =&gt;
     <span class="kr">let</span> (<span class="nv">q</span>, r) := N.pos_div_eucl a (N.pos b) <span class="kr">in</span> (-of_N q, of_N r)
   | neg a, neg b =&gt;
     <span class="kr">let</span> (<span class="nv">q</span>, r) := N.pos_div_eucl a (N.pos b) <span class="kr">in</span> (of_N q, - of_N r)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">quot</span> <span class="nv">a</span> <span class="nv">b</span> := fst (quotrem a b).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">rem</span> <span class="nv">a</span> <span class="nv">b</span> := snd (quotrem a b).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;√∑&quot;</span> := quot (<span class="kn">at level</span> <span class="mi">40</span>, <span class="kn">left associativity</span>) : Z_scope.</span></span></span></pre><div class="doc">
No infix notation for rem, otherwise it becomes a keyword 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab23"></a><h2 class="section">Parity functions</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">even</span> <span class="nv">z</span> :=
  <span class="kr">match</span> z <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; true
    | pos (xO _) =&gt; true
    | neg (xO _) =&gt; true
    | _ =&gt; false
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">odd</span> <span class="nv">z</span> :=
  <span class="kr">match</span> z <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; false
    | pos (xO _) =&gt; false
    | neg (xO _) =&gt; false
    | _ =&gt; true
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab24"></a><h2 class="section">Division by two</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">div2</span></span> performs rounding toward bottom, it is hence a particular
   case of <span class="inlinecode"><span class="id" title="var">div</span></span>, and for all relative number <span class="inlinecode"><span class="id" title="var">n</span></span> we have:
   <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">2</span> <span class="inlinecode">√ó</span> <span class="inlinecode"><span class="id" title="var">div2</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode">1</span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode">0</span>.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">div2</span> <span class="nv">z</span> :=
 <span class="kr">match</span> z <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; <span class="mi">0</span>
   | pos <span class="mi">1</span> =&gt; <span class="mi">0</span>
   | pos p =&gt; pos (Pos.div2 p)
   | neg p =&gt; neg (Pos.div2_up p)
 <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">quot2</span></span> performs rounding toward zero, it is hence a particular
   case of <span class="inlinecode"><span class="id" title="var">quot</span></span>, and for all relative number <span class="inlinecode"><span class="id" title="var">n</span></span> we have:
   <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">2</span> <span class="inlinecode">√ó</span> <span class="inlinecode"><span class="id" title="var">quot2</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><span class="id" title="var">sgn</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode">0</span>.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">quot2</span> (<span class="nv">z</span>:Z) :=
  <span class="kr">match</span> z <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; <span class="mi">0</span>
    | pos <span class="mi">1</span> =&gt; <span class="mi">0</span>
    | pos p =&gt; pos (Pos.div2 p)
    | neg <span class="mi">1</span> =&gt; <span class="mi">0</span>
    | neg p =&gt; neg (Pos.div2 p)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
NB: <span class="inlinecode"><span class="id" title="var">Z.quot2</span></span> used to be named <span class="inlinecode"><span class="id" title="var">Z.div2</span></span> in Coq &lt;= 8.3 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<a name="lab25"></a><h1 class="section">Base-2 logarithm</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">log2</span> <span class="nv">z</span> :=
  <span class="kr">match</span> z <span class="kr">with</span>
    | pos (p~<span class="mi">1</span>) =&gt; pos (Pos.size p)
    | pos (p~<span class="mi">0</span>) =&gt; pos (Pos.size p)
    | _ =&gt; <span class="mi">0</span>
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab26"></a><h2 class="section">Square root</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">sqrtrem</span> <span class="nv">n</span> :=
 <span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; (<span class="mi">0</span>, <span class="mi">0</span>)
  | pos p =&gt;
    <span class="kr">match</span> Pos.sqrtrem p <span class="kr">with</span>
     | (s, IsPos r) =&gt; (pos s, pos r)
     | (s, _) =&gt; (pos s, <span class="mi">0</span>)
    <span class="kr">end</span>
  | neg _ =&gt; (<span class="mi">0</span>,<span class="mi">0</span>)
 <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">sqrt</span> <span class="nv">n</span> :=
 <span class="kr">match</span> n <span class="kr">with</span>
  | pos p =&gt; pos (Pos.sqrt p)
  | _ =&gt; <span class="mi">0</span>
 <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab27"></a><h2 class="section">Greatest Common Divisor</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">gcd</span> <span class="nv">a</span> <span class="nv">b</span> :=
  <span class="kr">match</span> a,b <span class="kr">with</span>
    | <span class="mi">0</span>, _ =&gt; abs b
    | _, <span class="mi">0</span> =&gt; abs a
    | pos a, pos b =&gt; pos (Pos.gcd a b)
    | pos a, neg b =&gt; pos (Pos.gcd a b)
    | neg a, pos b =&gt; pos (Pos.gcd a b)
    | neg a, neg b =&gt; pos (Pos.gcd a b)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
A generalized gcd, also computing division of a and b by gcd. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ggcd</span> <span class="nv">a</span> <span class="nv">b</span> : Z*(Z*Z) :=
  <span class="kr">match</span> a,b <span class="kr">with</span>
    | <span class="mi">0</span>, _ =&gt; (abs b,(<span class="mi">0</span>, sgn b))
    | _, <span class="mi">0</span> =&gt; (abs a,(sgn a, <span class="mi">0</span>))
    | pos a, pos b =&gt;
       <span class="kr">let</span> &#39;(g,(aa,bb)) := Pos.ggcd a b <span class="kr">in</span> (pos g, (pos aa, pos bb))
    | pos a, neg b =&gt;
       <span class="kr">let</span> &#39;(g,(aa,bb)) := Pos.ggcd a b <span class="kr">in</span> (pos g, (pos aa, neg bb))
    | neg a, pos b =&gt;
       <span class="kr">let</span> &#39;(g,(aa,bb)) := Pos.ggcd a b <span class="kr">in</span> (pos g, (neg aa, pos bb))
    | neg a, neg b =&gt;
       <span class="kr">let</span> &#39;(g,(aa,bb)) := Pos.ggcd a b <span class="kr">in</span> (pos g, (neg aa, neg bb))
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab28"></a><h2 class="section">Bitwise functions</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
When accessing the bits of negative numbers, all functions
  below will use the two's complement representation. For instance,
  <span class="inlinecode">-1</span> will correspond to an infinite stream of true bits. If this
  isn't what you're looking for, you can use <span class="inlinecode"><span class="id" title="var">abs</span></span> first and then
  access the bits of the absolute value.

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">testbit</span></span> : accessing the <span class="inlinecode"><span class="id" title="var">n</span></span>-th bit of a number <span class="inlinecode"><span class="id" title="var">a</span></span>.
    For negative <span class="inlinecode"><span class="id" title="var">n</span></span>, we arbitrarily answer <span class="inlinecode"><span class="id" title="var">false</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">testbit</span> <span class="nv">a</span> <span class="nv">n</span> :=
 <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; odd a
   | pos p =&gt;
     <span class="kr">match</span> a <span class="kr">with</span>
       | <span class="mi">0</span> =&gt; false
       | pos a =&gt; Pos.testbit a (N.pos p)
       | neg a =&gt; negb (N.testbit (Pos.pred_N a) (N.pos p))
     <span class="kr">end</span>
   | neg _ =&gt; false
 <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Shifts

<div class="paragraph"> </div>

   Nota: a shift to the right by <span class="inlinecode">-<span class="id" title="var">n</span></span> will be a shift to the left
   by <span class="inlinecode"><span class="id" title="var">n</span></span>, and vice-versa.

<div class="paragraph"> </div>

   For fulfilling the two's complement convention, shifting to
   the right a negative number should correspond to a division
   by 2 with rounding toward bottom, hence the use of <span class="inlinecode"><span class="id" title="var">div2</span></span>
   instead of <span class="inlinecode"><span class="id" title="var">quot2</span></span>.

</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">shiftl</span> <span class="nv">a</span> <span class="nv">n</span> :=
 <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; a
   | pos p =&gt; Pos.iter (mul <span class="mi">2</span>) a p
   | neg p =&gt; Pos.iter div2 a p
 <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">shiftr</span> <span class="nv">a</span> <span class="nv">n</span> := shiftl a (-n).</span></span></span></pre><div class="doc">
Bitwise operations <span class="inlinecode"><span class="id" title="var">lor</span></span> <span class="inlinecode"><span class="id" title="var">land</span></span> <span class="inlinecode"><span class="id" title="var">ldiff</span></span> <span class="inlinecode"><span class="id" title="var">lxor</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lor</span> <span class="nv">a</span> <span class="nv">b</span> :=
 <span class="kr">match</span> a, b <span class="kr">with</span>
   | <span class="mi">0</span>, _ =&gt; b
   | _, <span class="mi">0</span> =&gt; a
   | pos a, pos b =&gt; pos (Pos.lor a b)
   | neg a, pos b =&gt; neg (N.succ_pos (N.ldiff (Pos.pred_N a) (N.pos b)))
   | pos a, neg b =&gt; neg (N.succ_pos (N.ldiff (Pos.pred_N b) (N.pos a)))
   | neg a, neg b =&gt; neg (N.succ_pos (N.land (Pos.pred_N a) (Pos.pred_N b)))
 <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">land</span> <span class="nv">a</span> <span class="nv">b</span> :=
 <span class="kr">match</span> a, b <span class="kr">with</span>
   | <span class="mi">0</span>, _ =&gt; <span class="mi">0</span>
   | _, <span class="mi">0</span> =&gt; <span class="mi">0</span>
   | pos a, pos b =&gt; of_N (Pos.land a b)
   | neg a, pos b =&gt; of_N (N.ldiff (N.pos b) (Pos.pred_N a))
   | pos a, neg b =&gt; of_N (N.ldiff (N.pos a) (Pos.pred_N b))
   | neg a, neg b =&gt; neg (N.succ_pos (N.lor (Pos.pred_N a) (Pos.pred_N b)))
 <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ldiff</span> <span class="nv">a</span> <span class="nv">b</span> :=
 <span class="kr">match</span> a, b <span class="kr">with</span>
   | <span class="mi">0</span>, _ =&gt; <span class="mi">0</span>
   | _, <span class="mi">0</span> =&gt; a
   | pos a, pos b =&gt; of_N (Pos.ldiff a b)
   | neg a, pos b =&gt; neg (N.succ_pos (N.lor (Pos.pred_N a) (N.pos b)))
   | pos a, neg b =&gt; of_N (N.land (N.pos a) (Pos.pred_N b))
   | neg a, neg b =&gt; of_N (N.ldiff (Pos.pred_N b) (Pos.pred_N a))
 <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lxor</span> <span class="nv">a</span> <span class="nv">b</span> :=
 <span class="kr">match</span> a, b <span class="kr">with</span>
   | <span class="mi">0</span>, _ =&gt; b
   | _, <span class="mi">0</span> =&gt; a
   | pos a, pos b =&gt; of_N (Pos.lxor a b)
   | neg a, pos b =&gt; neg (N.succ_pos (N.lxor (Pos.pred_N a) (N.pos b)))
   | pos a, neg b =&gt; neg (N.succ_pos (N.lxor (N.pos a) (Pos.pred_N b)))
   | neg a, neg b =&gt; of_N (N.lxor (Pos.pred_N a) (Pos.pred_N b))
 <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Numeral Notation</span> <span class="nf">Z</span> of_int to_int : Z_scope.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Z</span>.</span></span></span></pre><div class="doc">
Re-export the notation for those who just <span class="inlinecode"><span class="id" title="keyword">Import</span></span> <span class="inlinecode"><span class="id" title="var">BinIntDef</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Numeral Notation</span> <span class="nf">Z</span> Z.of_int Z.to_int : Z_scope.</span></span></span></pre></article></body></html>