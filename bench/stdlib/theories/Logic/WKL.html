<!DOCTYPE html>
<html><head><title>WKL.v</title><meta charset="utf-8"><meta content="Alectryon v0.2" name="generator"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet"><link href="https://unpkg.com/firacode/distr/fira_code.css" rel="stylesheet"><link href="alectryon.css" rel="stylesheet"><script src="alectryon.js"></script><style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-standalone alectryon-centered alectryon-coqdoc"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="sd">(************************************************************************)</span>
<span class="c">(*         *   The Coq Proof Assistant / The Coq Development Team       *)</span>
<span class="c">(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)</span>
<span class="c">(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)</span>
<span class="c">(*   \VV/  **************************************************************)</span>
<span class="c">(*    //   *    This file is distributed under the terms of the         *)</span>
<span class="c">(*         *     GNU Lesser General Public License Version 2.1          *)</span>
<span class="c">(*         *     (see LICENSE file for the text of the license)         *)</span>
<span class="sd">(************************************************************************)</span></span></span></pre><div class="doc">
A constructive proof of a version of Weak K√∂nig's Lemma over a
    decidable predicate in the formulation of which infinite paths are
    treated as predicates. The representation of paths as relations
    avoid the need for classical logic and unique choice. The
    decidability condition is sufficient to ensure that some required
    instance of double negation for disjunction of finite paths holds.

<div class="paragraph"> </div>

    The idea of the proof comes from the proof of the weak K√∂nig's
    lemma from separation in second-order arithmetic.

<div class="paragraph"> </div>

    Notice that we do not start from a tree but just from an arbitrary
    predicate. Original Weak Konig's Lemma is the instantiation of
    the lemma to a tree 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> WeakFan List.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Import</span> ListNotations.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Omega.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">is_path_from</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> means that there exists a path of length <span class="inlinecode"><span class="id" title="var">n</span></span>
    from <span class="inlinecode"><span class="id" title="var">l</span></span> on which <span class="inlinecode"><span class="id" title="var">P</span></span> does not hold 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">is_path_from</span> (<span class="nv">P</span>:list bool -&gt; <span class="kt">Prop</span>) : nat -&gt; list bool -&gt; <span class="kt">Prop</span> :=
| here l : ~ P l -&gt; is_path_from P <span class="mi">0</span> l
| next_left l n : ~ P l -&gt; is_path_from P n (true::l) -&gt; is_path_from P (S n) l
| next_right l n : ~ P l -&gt; is_path_from P n (false::l) -&gt; is_path_from P (S n) l.</span></span></span></pre><div class="doc">
We give the characterization of is_path_from in terms of a more common arithmetical formula 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk0" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk0"><span class="highlight"><span class="kn">Proposition</span> <span class="nf">is_path_from_characterization</span> <span class="nv">P</span> <span class="nv">n</span> <span class="nv">l</span> :
  is_path_from P n l &lt;-&gt; <span class="kr">exists</span> <span class="nv">l&#39;</span>, length l&#39; = n /\ <span class="kr">forall</span> <span class="nv">n&#39;</span>, n&#39;&lt;=n -&gt; ~ P (rev (firstn n&#39; l&#39;) ++ l).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">l&#39;</span> : list bool,
   length l&#39; = n /\
   (<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
    n&#39; &lt;= n -&gt; ~ P (rev (firstn n&#39; l&#39;) ++ l)))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk1" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">l&#39;</span> : list bool,
   length l&#39; = n /\
   (<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
    n&#39; &lt;= n -&gt; ~ P (rev (firstn n&#39; l&#39;) ++ l)))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk2" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk2"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">l&#39;</span> : list bool,
   length l&#39; = n /\
   (<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
    n&#39; &lt;= n -&gt; ~ P (rev (firstn n&#39; l&#39;) ++ l)))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk3" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk3"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n l -&gt;
<span class="kr">exists</span> <span class="nv">l&#39;</span> : list bool,
  length l&#39; = n /\
  (<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
   n&#39; &lt;= n -&gt; ~ P (rev (firstn n&#39; l&#39;) ++ l))</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk4" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk4"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">exists</span> <span class="nv">l&#39;</span> : list bool,
   length l&#39; = n /\
   (<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
    n&#39; &lt;= n -&gt; ~ P (rev (firstn n&#39; l&#39;) ++ l))) -&gt;
is_path_from P n l</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk5" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk5"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n l -&gt;
<span class="kr">exists</span> <span class="nv">l&#39;</span> : list bool,
  length l&#39; = n /\
  (<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
   n&#39; &lt;= n -&gt; ~ P (rev (firstn n&#39; l&#39;) ++ l))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk6" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk6"><span class="highlight"><span class="nb">induction</span> <span class="mi">1</span> <span class="kr">as</span> [|* HP _ (l&#39;&amp;Hl&#39;&amp;HPl&#39;)|* HP _ (l&#39;&amp;Hl&#39;&amp;HPl&#39;)].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">l&#39;</span> : list bool,
  length l&#39; = <span class="mi">0</span> /\
  (<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
   n&#39; &lt;= <span class="mi">0</span> -&gt; ~ P (rev (firstn n&#39; l&#39;) ++ l))</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk7" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk7"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">l&#39;0</span> : list bool,
  length l&#39;0 = S n /\
  (<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
   n&#39; &lt;= S n -&gt; ~ P (rev (firstn n&#39; l&#39;0) ++ l))</span></div></blockquote><input class="coq-extra-goal-toggle" id="WKL-v-chk8" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk8"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">l&#39;0</span> : list bool,
  length l&#39;0 = S n /\
  (<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
   n&#39; &lt;= S n -&gt; ~ P (rev (firstn n&#39; l&#39;0) ++ l))</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk9" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk9"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">l&#39;</span> : list bool,
  length l&#39; = <span class="mi">0</span> /\
  (<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
   n&#39; &lt;= <span class="mi">0</span> -&gt; ~ P (rev (firstn n&#39; l&#39;) ++ l))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chka" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chka"><span class="highlight"><span class="kr">exists</span> [].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length [] = <span class="mi">0</span> /\
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= <span class="mi">0</span> -&gt; ~ P (rev (firstn n&#39; []) ++ l))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkb" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkb"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length [] = <span class="mi">0</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chkc" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chkc"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= <span class="mi">0</span> -&gt; ~ P (rev (firstn n&#39; []) ++ l)</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkd" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkd"><span class="highlight"><span class="bp">reflexivity</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= <span class="mi">0</span> -&gt; ~ P (rev (firstn n&#39; []) ++ l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chke" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chke"><span class="highlight"><span class="nb">intros</span> n &lt;-%le_n_0_eq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn <span class="mi">0</span> []) ++ l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkf" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkf"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">l&#39;0</span> : list bool,
  length l&#39;0 = S n /\
  (<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
   n&#39; &lt;= S n -&gt; ~ P (rev (firstn n&#39; l&#39;0) ++ l))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk10" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk10"><span class="highlight"><span class="kr">exists</span> (<span class="nv">true</span> :: l&#39;).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length (true :: l&#39;) = S n /\
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= S n -&gt; ~ P (rev (firstn n&#39; (true :: l&#39;)) ++ l))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk11" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk11"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length (true :: l&#39;) = S n</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk12" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk12"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= S n -&gt; ~ P (rev (firstn n&#39; (true :: l&#39;)) ++ l)</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk13" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk13"><span class="highlight"><span class="nb">apply</span> eq_S, Hl&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= S n -&gt; ~ P (rev (firstn n&#39; (true :: l&#39;)) ++ l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk14" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk14"><span class="highlight"><span class="nb">intros</span> [|] H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> &lt;= S n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn <span class="mi">0</span> (true :: l&#39;)) ++ l)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk15" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n0 &lt;= S n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk15"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn (S n0) (true :: l&#39;)) ++ l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk16" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk16"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> &lt;= S n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn <span class="mi">0</span> (true :: l&#39;)) ++ l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk17" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk17"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n0 &lt;= S n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn (S n0) (true :: l&#39;)) ++ l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk18" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk18"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n0 &lt;= S n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P ((rev (firstn n0 l&#39;) ++ [true]) ++ l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk19" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk19"><span class="highlight"><span class="nb">rewrite</span> &lt;- app_assoc.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n0 &lt;= S n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn n0 l&#39;) ++ [true] ++ l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> HPl&#39;, le_S_n, H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk1a" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk1a"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">l&#39;0</span> : list bool,
  length l&#39;0 = S n /\
  (<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
   n&#39; &lt;= S n -&gt; ~ P (rev (firstn n&#39; l&#39;0) ++ l))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk1b"><span class="highlight"><span class="kr">exists</span> (<span class="nv">false</span> :: l&#39;).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length (false :: l&#39;) = S n /\
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= S n -&gt; ~ P (rev (firstn n&#39; (false :: l&#39;)) ++ l))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk1c"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length (false :: l&#39;) = S n</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk1d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk1d"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= S n -&gt; ~ P (rev (firstn n&#39; (false :: l&#39;)) ++ l)</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk1e"><span class="highlight"><span class="nb">apply</span> eq_S, Hl&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= S n -&gt; ~ P (rev (firstn n&#39; (false :: l&#39;)) ++ l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk1f"><span class="highlight"><span class="nb">intros</span> [|] H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> &lt;= S n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn <span class="mi">0</span> (false :: l&#39;)) ++ l)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk20" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n0 &lt;= S n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk20"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn (S n0) (false :: l&#39;)) ++ l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk21" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk21"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> &lt;= S n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn <span class="mi">0</span> (false :: l&#39;)) ++ l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk22" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk22"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n0 &lt;= S n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn (S n0) (false :: l&#39;)) ++ l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk23" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk23"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n0 &lt;= S n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P ((rev (firstn n0 l&#39;) ++ [false]) ++ l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk24" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk24"><span class="highlight"><span class="nb">rewrite</span> &lt;- app_assoc.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= n -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n0 &lt;= S n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn n0 l&#39;) ++ [false] ++ l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> HPl&#39;, le_S_n, H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk25" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk25"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">exists</span> <span class="nv">l&#39;</span> : list bool,
   length l&#39; = n /\
   (<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
    n&#39; &lt;= n -&gt; ~ P (rev (firstn n&#39; l&#39;) ++ l))) -&gt;
is_path_from P n l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk26" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk26"><span class="highlight"><span class="nb">intros</span> (l&#39;&amp; &lt;- &amp;HPl&#39;).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length l&#39; -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (length l&#39;) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk27" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk27"><span class="highlight"><span class="nb">induction</span> l&#39; <span class="kr">as</span> [|[|]] <span class="kr">in</span> l, HPl&#39; |- *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length [] -&gt;
~ P (rev (firstn n&#39; []) ++ l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (length []) l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk28" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (true :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (true :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk28"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (length (true :: l&#39;)) l</span></div></blockquote><input class="coq-extra-goal-toggle" id="WKL-v-chk29" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (false :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (false :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk29"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (length (false :: l&#39;)) l</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk2a" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk2a"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length [] -&gt;
~ P (rev (firstn n&#39; []) ++ l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (length []) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk2b" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk2b"><span class="highlight"><span class="nb">constructor</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length [] -&gt;
~ P (rev (firstn n&#39; []) ++ l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk2c" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk2c"><span class="highlight"><span class="nb">apply</span> (HPl&#39; <span class="mi">0</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length [] -&gt;
~ P (rev (firstn n&#39; []) ++ l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt;= length []</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> le_0_n.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk2d" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk2d"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (true :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (true :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (length (true :: l&#39;)) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk2e"><span class="highlight"><span class="nb">eapply</span> next_left.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (true :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (true :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk2f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (true :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (true :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk2f"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P
  ((<span class="kr">fix</span> length (l0 : list bool) : nat :=
      <span class="kr">match</span> l0 <span class="kr">with</span>
      | [] =&gt; <span class="mi">0</span>
      | _ :: l&#39;0 =&gt; S (length l&#39;0)
      <span class="kr">end</span>) l&#39;) (true :: l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk30" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk30"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (true :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (true :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> (HPl&#39; <span class="mi">0</span>), le_0_n.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk31" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk31"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (true :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (true :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P
  ((<span class="kr">fix</span> length (l0 : list bool) : nat :=
      <span class="kr">match</span> l0 <span class="kr">with</span>
      | [] =&gt; <span class="mi">0</span>
      | _ :: l&#39;0 =&gt; S (length l&#39;0)
      <span class="kr">end</span>) l&#39;) (true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk32" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk32"><span class="highlight"><span class="nb">fold</span> (length l&#39;).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (true :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (true :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (length l&#39;) (true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk33" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk33"><span class="highlight"><span class="nb">apply</span> IHl&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (true :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (true :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length l&#39; -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk34" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk34"><span class="highlight"><span class="nb">intros</span> n&#39; H%le_n_S.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
n&#39;0 &lt;= length (true :: l&#39;) -&gt;
~ P (rev (firstn n&#39;0 (true :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
 n&#39;0 &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39;0 l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n&#39; &lt;= S (length l&#39;)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk35" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk35"><span class="highlight"><span class="nb">apply</span> HPl&#39; <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
n&#39;0 &lt;= length (true :: l&#39;) -&gt;
~ P (rev (firstn n&#39;0 (true :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
 n&#39;0 &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39;0 l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P (rev (firstn (S n&#39;) (true :: l&#39;)) ++ l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk36" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk36"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
n&#39;0 &lt;= length (true :: l&#39;) -&gt;
~ P (rev (firstn n&#39;0 (true :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
 n&#39;0 &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39;0 l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P ((rev (firstn n&#39; l&#39;) ++ [true]) ++ l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk37" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk37"><span class="highlight"><span class="nb">rewrite</span> &lt;- app_assoc <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
n&#39;0 &lt;= length (true :: l&#39;) -&gt;
~ P (rev (firstn n&#39;0 (true :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
 n&#39;0 &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39;0 l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P (rev (firstn n&#39; l&#39;) ++ [true] ++ l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn n&#39; l&#39;) ++ true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk38" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk38"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (false :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (false :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (length (false :: l&#39;)) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk39" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk39"><span class="highlight"><span class="nb">apply</span> next_right.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (false :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (false :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk3a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (false :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (false :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk3a"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P
  ((<span class="kr">fix</span> length (l0 : list bool) : nat :=
      <span class="kr">match</span> l0 <span class="kr">with</span>
      | [] =&gt; <span class="mi">0</span>
      | _ :: l&#39;0 =&gt; S (length l&#39;0)
      <span class="kr">end</span>) l&#39;) (false :: l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk3b" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk3b"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (false :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (false :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> (HPl&#39; <span class="mi">0</span>), le_0_n.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk3c" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk3c"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (false :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (false :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P
  ((<span class="kr">fix</span> length (l0 : list bool) : nat :=
      <span class="kr">match</span> l0 <span class="kr">with</span>
      | [] =&gt; <span class="mi">0</span>
      | _ :: l&#39;0 =&gt; S (length l&#39;0)
      <span class="kr">end</span>) l&#39;) (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk3d" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk3d"><span class="highlight"><span class="nb">fold</span> (length l&#39;).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (false :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (false :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (length l&#39;) (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk3e" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk3e"><span class="highlight"><span class="nb">apply</span> IHl&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length (false :: l&#39;) -&gt;
~ P (rev (firstn n&#39; (false :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
 n&#39; &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39; l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;</span> : nat,
n&#39; &lt;= length l&#39; -&gt;
~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk3f" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk3f"><span class="highlight"><span class="nb">intros</span> n&#39; H%le_n_S.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
n&#39;0 &lt;= length (false :: l&#39;) -&gt;
~ P (rev (firstn n&#39;0 (false :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
 n&#39;0 &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39;0 l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n&#39; &lt;= S (length l&#39;)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk40" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk40"><span class="highlight"><span class="nb">apply</span> HPl&#39; <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
n&#39;0 &lt;= length (false :: l&#39;) -&gt;
~ P (rev (firstn n&#39;0 (false :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
 n&#39;0 &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39;0 l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P (rev (firstn (S n&#39;) (false :: l&#39;)) ++ l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk41" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk41"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
n&#39;0 &lt;= length (false :: l&#39;) -&gt;
~ P (rev (firstn n&#39;0 (false :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
 n&#39;0 &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39;0 l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P ((rev (firstn n&#39; l&#39;) ++ [false]) ++ l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk42" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk42"><span class="highlight"><span class="nb">rewrite</span> &lt;- app_assoc <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l, l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
n&#39;0 &lt;= length (false :: l&#39;) -&gt;
~ P (rev (firstn n&#39;0 (false :: l&#39;)) ++ l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
(<span class="kr">forall</span> <span class="nv">n&#39;0</span> : nat,
 n&#39;0 &lt;= length l&#39; -&gt;
 ~ P (rev (firstn n&#39;0 l&#39;) ++ l0)) -&gt;
is_path_from P (length l&#39;) l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P (rev (firstn n&#39; l&#39;) ++ [false] ++ l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P (rev (firstn n&#39; l&#39;) ++ false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">infinite_from</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> means that we can find arbitrary long paths
    along which <span class="inlinecode"><span class="id" title="var">P</span></span> does not hold above <span class="inlinecode"><span class="id" title="var">l</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">infinite_from</span> (<span class="nv">P</span>:list bool -&gt; <span class="kt">Prop</span>) <span class="nv">l</span> := <span class="kr">forall</span> <span class="nv">n</span>, is_path_from P n l.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">has_infinite_path</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> means that there is an infinite path
    (represented as a predicate) along which <span class="inlinecode"><span class="id" title="var">P</span></span> does not hold at all 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">has_infinite_path</span> (<span class="nv">P</span>:list bool -&gt; <span class="kt">Prop</span>) :=
  <span class="kr">exists</span> (<span class="nv">X</span>:nat -&gt; <span class="kt">Prop</span>), <span class="kr">forall</span> <span class="nv">l</span>, approx X l -&gt; ~ P l.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">inductively_barred_at</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> means that <span class="inlinecode"><span class="id" title="var">P</span></span> eventually holds above
    <span class="inlinecode"><span class="id" title="var">l</span></span> after at most <span class="inlinecode"><span class="id" title="var">n</span></span> steps upwards 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">inductively_barred_at</span> (<span class="nv">P</span>:list bool -&gt; <span class="kt">Prop</span>) : nat -&gt; list bool -&gt; <span class="kt">Prop</span> :=
| now_at l n : P l -&gt; inductively_barred_at P n l
| propagate_at l n :
    inductively_barred_at P n (true::l) -&gt;
    inductively_barred_at P n (false::l) -&gt;
    inductively_barred_at P (S n) l.</span></span></span></pre><div class="doc">
The proof proceeds by building a set <span class="inlinecode"><span class="id" title="var">Y</span></span> of finite paths
   approximating either the smallest unbarred infinite path in <span class="inlinecode"><span class="id" title="var">P</span></span>, if
   there is one (taking <span class="inlinecode"><span class="id" title="var">true</span></span>&gt;<span class="inlinecode"><span class="id" title="var">false</span></span>), or the path
   true::true::... if <span class="inlinecode"><span class="id" title="var">P</span></span> happens to be inductively_barred 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">Y</span> <span class="nv">P</span> (<span class="nv">l</span>:list bool) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; <span class="kt">True</span>
  | b::l =&gt;
      Y P l /\
      <span class="kr">if</span> b <span class="kr">then</span> <span class="kr">exists</span> <span class="nv">n</span>, inductively_barred_at P n (false::l) <span class="kr">else</span> infinite_from P (false::l)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Compare_dec Le Lt.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk43" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk43"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">is_path_from_restrict</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">n</span> <span class="nv">n&#39;</span> <span class="nv">l</span>, n &lt;= n&#39; -&gt;
  is_path_from P n&#39; l -&gt; is_path_from P n l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>) (<span class="nv">n</span> <span class="nv">n&#39;</span> : nat)
  (<span class="nv">l</span> : list bool),
n &lt;= n&#39; -&gt; is_path_from P n&#39; l -&gt; is_path_from P n l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk44" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk44"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>) (<span class="nv">n</span> <span class="nv">n&#39;</span> : nat)
  (<span class="nv">l</span> : list bool),
n &lt;= n&#39; -&gt; is_path_from P n&#39; l -&gt; is_path_from P n l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk45" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk45"><span class="highlight"><span class="nb">intros</span> * Hle H; <span class="nb">induction</span> H <span class="kr">in</span> n, Hle, H |- * ; <span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk46" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n0 (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHis_path_from</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n1 &lt;= n0 -&gt;
is_path_from P n1 (true :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk46"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n l</span></div></blockquote><input class="coq-extra-goal-toggle" id="WKL-v-chk47" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n0 (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHis_path_from</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n1 &lt;= n0 -&gt;
is_path_from P n1 (false :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk47"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n l</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk48" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk48"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk49" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk49"><span class="highlight"><span class="nb">apply</span> le_n_0_eq <span class="kr">in</span> Hle <span class="kr">as</span> &lt;-.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P <span class="mi">0</span> l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk4a" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk4a"><span class="highlight"><span class="nb">apply</span> here.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk4b" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk4b"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n0 (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHis_path_from</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n1 &lt;= n0 -&gt;
is_path_from P n1 (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk4c" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk4c"><span class="highlight"><span class="nb">destruct</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> &lt;= S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n0 (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHis_path_from</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
n &lt;= n0 -&gt;
is_path_from P n (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P <span class="mi">0</span> l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk4d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n0 (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHis_path_from</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n1 &lt;= n0 -&gt;
is_path_from P n1 (true :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk4d"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (S n) l</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk4e" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk4e"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> &lt;= S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n0 (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHis_path_from</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
n &lt;= n0 -&gt;
is_path_from P n (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P <span class="mi">0</span> l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk4f" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk4f"><span class="highlight"><span class="nb">apply</span> here.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> &lt;= S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n0 (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHis_path_from</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
n &lt;= n0 -&gt;
is_path_from P n (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk50" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk50"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n0 (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHis_path_from</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n1 &lt;= n0 -&gt;
is_path_from P n1 (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> next_left; <span class="nb">auto using</span> le_S_n.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk51" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk51"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n0 (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHis_path_from</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n1 &lt;= n0 -&gt;
is_path_from P n1 (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk52" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk52"><span class="highlight"><span class="nb">destruct</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> &lt;= S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n0 (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHis_path_from</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
n &lt;= n0 -&gt;
is_path_from P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P <span class="mi">0</span> l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk53" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n0 (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHis_path_from</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n1 &lt;= n0 -&gt;
is_path_from P n1 (false :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk53"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (S n) l</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk54" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk54"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> &lt;= S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n0 (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHis_path_from</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
n &lt;= n0 -&gt;
is_path_from P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P <span class="mi">0</span> l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk55" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk55"><span class="highlight"><span class="nb">apply</span> here.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> &lt;= S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n0 (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHis_path_from</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
n &lt;= n0 -&gt;
is_path_from P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk56" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk56"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n &lt;= S n0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n0 (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHis_path_from</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n1 &lt;= n0 -&gt;
is_path_from P n1 (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> next_right; <span class="nb">auto using</span> le_S_n.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk57" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk57"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">inductively_barred_at_monotone</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">l</span> <span class="nv">n</span> <span class="nv">n&#39;</span>, n&#39; &lt;= n -&gt;
  inductively_barred_at P n&#39; l -&gt; inductively_barred_at P n l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>) (<span class="nv">l</span> : list bool)
  (<span class="nv">n</span> <span class="nv">n&#39;</span> : nat),
n&#39; &lt;= n -&gt;
inductively_barred_at P n&#39; l -&gt;
inductively_barred_at P n l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk58" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk58"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>) (<span class="nv">l</span> : list bool)
  (<span class="nv">n</span> <span class="nv">n&#39;</span> : nat),
n&#39; &lt;= n -&gt;
inductively_barred_at P n&#39; l -&gt;
inductively_barred_at P n l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk59" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk59"><span class="highlight"><span class="nb">intros</span> * Hle Hbar.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n&#39; &lt;= n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n&#39; l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P n l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk5a" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk5a"><span class="highlight"><span class="nb">induction</span> Hbar <span class="kr">in</span> n, l, Hle, Hbar |- *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n0 &lt;= n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P n l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk5b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n0 &lt;= n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n0 (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n0 (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHHbar1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n0 &lt;= n1 -&gt;
inductively_barred_at P n1 (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHHbar2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n0 &lt;= n1 -&gt;
inductively_barred_at P n1 (false :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk5b"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P n l</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk5c" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk5c"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n0 &lt;= n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P n l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> now_at; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk5d" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk5d"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n0 &lt;= n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n0 (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n0 (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHHbar1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n0 &lt;= n1 -&gt;
inductively_barred_at P n1 (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHHbar2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n0 &lt;= n1 -&gt;
inductively_barred_at P n1 (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P n l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk5e" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk5e"><span class="highlight"><span class="nb">destruct</span> n; [<span class="nb">apply</span> le_Sn_0 <span class="kr">in</span> Hle; <span class="bp">contradiction</span>|].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n0 &lt;= S n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n0 (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n0 (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHHbar1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n0 &lt;= n1 -&gt;
inductively_barred_at P n1 (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHHbar2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n0 &lt;= n1 -&gt;
inductively_barred_at P n1 (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk5f" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk5f"><span class="highlight"><span class="nb">apply</span> le_S_n <span class="kr">in</span> Hle.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, n0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n0 &lt;= n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n0 (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n0 (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHHbar1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n0 &lt;= n1 -&gt;
inductively_barred_at P n1 (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHHbar2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">n1</span> : nat,
n0 &lt;= n1 -&gt;
inductively_barred_at P n1 (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> propagate_at; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">demorgan_or</span> (<span class="nv">P</span>:list bool -&gt; <span class="kt">Prop</span>) <span class="nv">l</span> <span class="nv">l&#39;</span> := ~ (P l /\ P l&#39;) -&gt; ~ P l \/ ~ P l&#39;.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">demorgan_inductively_barred_at</span> <span class="nv">P</span> :=
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">l</span>, demorgan_or (inductively_barred_at P n) (true::l) (false::l).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk60" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk60"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">inductively_barred_at_imp_is_path_from</span> :
  <span class="kr">forall</span> <span class="nv">P</span>, demorgan_inductively_barred_at P -&gt; <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">l</span>,
  ~ inductively_barred_at P n l -&gt; is_path_from P n l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
demorgan_inductively_barred_at P -&gt;
<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list bool),
~ inductively_barred_at P n l -&gt; is_path_from P n l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk61" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk61"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
demorgan_inductively_barred_at P -&gt;
<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list bool),
~ inductively_barred_at P n l -&gt; is_path_from P n l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk62" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk62"><span class="highlight"><span class="nb">intros</span> P Hdemorgan; <span class="nb">induction</span> n; <span class="nb">intros</span> l H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdemorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P <span class="mi">0</span> l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P <span class="mi">0</span> l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk63" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdemorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
~ inductively_barred_at P n l0 -&gt;
is_path_from P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P (S n) l</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk63"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (S n) l</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk64" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk64"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdemorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P <span class="mi">0</span> l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P <span class="mi">0</span> l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk65" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk65"><span class="highlight"><span class="nb">apply</span> here.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdemorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P <span class="mi">0</span> l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk66" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk66"><span class="highlight"><span class="nb">intro</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdemorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P <span class="mi">0</span> l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk67" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk67"><span class="highlight"><span class="nb">apply</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdemorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P <span class="mi">0</span> l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P <span class="mi">0</span> l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk68" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk68"><span class="highlight"><span class="nb">apply</span> now_at.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdemorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P <span class="mi">0</span> l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk69" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk69"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdemorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
~ inductively_barred_at P n l0 -&gt;
is_path_from P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P (S n) l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk6a" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk6a"><span class="highlight"><span class="nb">assert</span> (H0:~ (inductively_barred_at P n (true::l) /\ inductively_barred_at P n (false::l)))
  <span class="bp">by</span> <span class="nb">firstorder using</span> inductively_barred_at.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdemorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
~ inductively_barred_at P n l0 -&gt;
is_path_from P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P (S n) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(inductively_barred_at P n (true :: l) /\
 inductively_barred_at P n (false :: l))</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk6b" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk6b"><span class="highlight"><span class="nb">assert</span> (HnP:~ P l) <span class="bp">by</span> <span class="nb">firstorder using</span> inductively_barred_at.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdemorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
~ inductively_barred_at P n l0 -&gt;
is_path_from P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P (S n) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(inductively_barred_at P n (true :: l) /\
 inductively_barred_at P n (false :: l))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HnP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> Hdemorgan <span class="kr">in</span> H0 <span class="kr">as</span> [H0|H0]; <span class="nb">apply</span> IHn <span class="kr">in</span> H0; <span class="nb">auto using</span> is_path_from.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk6c" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk6c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">is_path_from_imp_inductively_barred_at</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">n</span> <span class="nv">l</span>,
   is_path_from P n l -&gt; inductively_barred_at P n l -&gt; <span class="kt">False</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>) (<span class="nv">n</span> : nat)
  (<span class="nv">l</span> : list bool),
is_path_from P n l -&gt;
inductively_barred_at P n l -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk6d" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk6d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>) (<span class="nv">n</span> : nat)
  (<span class="nv">l</span> : list bool),
is_path_from P n l -&gt;
inductively_barred_at P n l -&gt; <span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk6e" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk6e"><span class="highlight"><span class="nb">intros</span> P; <span class="nb">induction</span> n; <span class="nb">intros</span> l H1 H2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P <span class="mi">0</span> l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P <span class="mi">0</span> l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk6f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
is_path_from P n l0 -&gt; inductively_barred_at P n l0 -&gt; <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P (S n) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P (S n) l</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk6f"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk70" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk70"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P <span class="mi">0</span> l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P <span class="mi">0</span> l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk71" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk71"><span class="highlight"><span class="nb">inversion_clear</span> H1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P <span class="mi">0</span> l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk72" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk72"><span class="highlight"><span class="nb">inversion_clear</span> H2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk73" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk73"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
is_path_from P n l0 -&gt; inductively_barred_at P n l0 -&gt; <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P (S n) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P (S n) l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk74" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk74"><span class="highlight"><span class="nb">inversion_clear</span> H1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
is_path_from P n l0 -&gt; inductively_barred_at P n l0 -&gt; <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P (S n) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk75" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
is_path_from P n l0 -&gt; inductively_barred_at P n l0 -&gt; <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P (S n) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (false :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk75"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk76" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk76"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
is_path_from P n l0 -&gt; inductively_barred_at P n l0 -&gt; <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P (S n) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk77" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk77"><span class="highlight"><span class="nb">inversion_clear</span> H2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
is_path_from P n l0 -&gt; inductively_barred_at P n l0 -&gt; <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk78" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
is_path_from P n l0 -&gt; inductively_barred_at P n l0 -&gt; <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk78"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk79" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk79"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
is_path_from P n l0 -&gt; inductively_barred_at P n l0 -&gt; <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk7a" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk7a"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
is_path_from P n l0 -&gt; inductively_barred_at P n l0 -&gt; <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> IHn <span class="kr">with</span> (true::l); <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk7b" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk7b"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
is_path_from P n l0 -&gt; inductively_barred_at P n l0 -&gt; <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P (S n) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk7c" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk7c"><span class="highlight"><span class="nb">inversion_clear</span> H2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
is_path_from P n l0 -&gt; inductively_barred_at P n l0 -&gt; <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk7d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
is_path_from P n l0 -&gt; inductively_barred_at P n l0 -&gt; <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk7d"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk7e" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk7e"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
is_path_from P n l0 -&gt; inductively_barred_at P n l0 -&gt; <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk7f" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk7f"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
is_path_from P n l0 -&gt; inductively_barred_at P n l0 -&gt; <span class="kt">False</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> IHn <span class="kr">with</span> (false::l); <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk80" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk80"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">find_left_path</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">l</span> <span class="nv">n</span>,
  is_path_from P (S n) l -&gt; inductively_barred_at P n (false :: l) -&gt; is_path_from P n (true :: l).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>) (<span class="nv">l</span> : list bool)
  (<span class="nv">n</span> : nat),
is_path_from P (S n) l -&gt;
inductively_barred_at P n (false :: l) -&gt;
is_path_from P n (true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk81" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk81"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>) (<span class="nv">l</span> : list bool)
  (<span class="nv">n</span> : nat),
is_path_from P (S n) l -&gt;
inductively_barred_at P n (false :: l) -&gt;
is_path_from P n (true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk82" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk82"><span class="highlight"><span class="nb">inversion</span> <span class="mi">1</span>; <span class="nb">subst</span>; <span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P (S n) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (true :: l)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk83" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P (S n) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk83"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (true :: l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk84" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk84"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P (S n) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk85" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk85"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P (S n) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk86" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk86"><span class="highlight"><span class="nb">exfalso</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P (S n) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P n (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eauto using</span> is_path_from_imp_inductively_barred_at.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk87" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk87"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">Y_unique</span> : <span class="kr">forall</span> <span class="nv">P</span>, demorgan_inductively_barred_at P -&gt;
  <span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span>, length l1 = length l2 -&gt; Y P l1 -&gt; Y P l2 -&gt; l1 = l2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
demorgan_inductively_barred_at P -&gt;
<span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list bool,
length l1 = length l2 -&gt; Y P l1 -&gt; Y P l2 -&gt; l1 = l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk88" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk88"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
demorgan_inductively_barred_at P -&gt;
<span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list bool,
length l1 = length l2 -&gt; Y P l1 -&gt; Y P l2 -&gt; l1 = l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk89" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk89"><span class="highlight"><span class="nb">intros</span> * DeMorgan.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list bool,
length l1 = length l2 -&gt; Y P l1 -&gt; Y P l2 -&gt; l1 = l2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk8a" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk8a"><span class="highlight"><span class="nb">induction</span> l1, l2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length [] = length [] -&gt; Y P [] -&gt; Y P [] -&gt; [] = []</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk8b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk8b"><hr></label><div class="goal-conclusion"><span class="highlight">length [] = length (b :: l2) -&gt;
Y P [] -&gt; Y P (b :: l2) -&gt; [] = b :: l2</span></div></blockquote><input class="coq-extra-goal-toggle" id="WKL-v-chk8c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l2</span> : list bool,
length l1 = length l2 -&gt;
Y P l1 -&gt; Y P l2 -&gt; l1 = l2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk8c"><hr></label><div class="goal-conclusion"><span class="highlight">length (a :: l1) = length [] -&gt;
Y P (a :: l1) -&gt; Y P [] -&gt; a :: l1 = []</span></div></blockquote><input class="coq-extra-goal-toggle" id="WKL-v-chk8d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
length l1 = length l0 -&gt;
Y P l1 -&gt; Y P l0 -&gt; l1 = l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk8d"><hr></label><div class="goal-conclusion"><span class="highlight">length (a :: l1) = length (b :: l2) -&gt;
Y P (a :: l1) -&gt; Y P (b :: l2) -&gt; a :: l1 = b :: l2</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk8e" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk8e"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length [] = length [] -&gt; Y P [] -&gt; Y P [] -&gt; [] = []</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk8f" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk8f"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length [] = length (b :: l2) -&gt;
Y P [] -&gt; Y P (b :: l2) -&gt; [] = b :: l2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk90" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk90"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l2</span> : list bool,
length l1 = length l2 -&gt;
Y P l1 -&gt; Y P l2 -&gt; l1 = l2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length (a :: l1) = length [] -&gt;
Y P (a :: l1) -&gt; Y P [] -&gt; a :: l1 = []</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk91" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk91"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
length l1 = length l0 -&gt;
Y P l1 -&gt; Y P l0 -&gt; l1 = l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length (a :: l1) = length (b :: l2) -&gt;
Y P (a :: l1) -&gt; Y P (b :: l2) -&gt; a :: l1 = b :: l2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk92" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk92"><span class="highlight"><span class="nb">intros</span> [= H] (HY1,H1) (HY2,H2).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
length l1 = length l0 -&gt;
Y P l1 -&gt; Y P l0 -&gt; l1 = l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l1 = length l2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span>
 <span class="kr">exists</span> <span class="nv">n</span> : nat,
   inductively_barred_at P n (false :: l1)
<span class="kr">else</span> infinite_from P (false :: l1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> b
<span class="kr">then</span>
 <span class="kr">exists</span> <span class="nv">n</span> : nat,
   inductively_barred_at P n (false :: l2)
<span class="kr">else</span> infinite_from P (false :: l2)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a :: l1 = b :: l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk93" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk93"><span class="highlight"><span class="nb">pose proof</span> (IHl1 l2 H HY1 HY2).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
length l1 = length l0 -&gt;
Y P l1 -&gt; Y P l0 -&gt; l1 = l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l1 = length l2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span>
 <span class="kr">exists</span> <span class="nv">n</span> : nat,
   inductively_barred_at P n (false :: l1)
<span class="kr">else</span> infinite_from P (false :: l1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> b
<span class="kr">then</span>
 <span class="kr">exists</span> <span class="nv">n</span> : nat,
   inductively_barred_at P n (false :: l2)
<span class="kr">else</span> infinite_from P (false :: l2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">l1 = l2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a :: l1 = b :: l2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk94" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk94"><span class="highlight"><span class="nb">clear</span> HY1 HY2 H IHl1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span>
 <span class="kr">exists</span> <span class="nv">n</span> : nat,
   inductively_barred_at P n (false :: l1)
<span class="kr">else</span> infinite_from P (false :: l1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> b
<span class="kr">then</span>
 <span class="kr">exists</span> <span class="nv">n</span> : nat,
   inductively_barred_at P n (false :: l2)
<span class="kr">else</span> infinite_from P (false :: l2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">l1 = l2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a :: l1 = b :: l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk95" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk95"><span class="highlight"><span class="nb">subst</span> l1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span>
 <span class="kr">exists</span> <span class="nv">n</span> : nat,
   inductively_barred_at P n (false :: l2)
<span class="kr">else</span> infinite_from P (false :: l2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> b
<span class="kr">then</span>
 <span class="kr">exists</span> <span class="nv">n</span> : nat,
   inductively_barred_at P n (false :: l2)
<span class="kr">else</span> infinite_from P (false :: l2)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a :: l2 = b :: l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk96" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk96"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span>
 <span class="kr">exists</span> <span class="nv">n</span> : nat,
   inductively_barred_at P n (false :: l2)
<span class="kr">else</span> infinite_from P (false :: l2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> b
<span class="kr">then</span>
 <span class="kr">exists</span> <span class="nv">n</span> : nat,
   inductively_barred_at P n (false :: l2)
<span class="kr">else</span> infinite_from P (false :: l2)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a = b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk97" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk97"><span class="highlight"><span class="nb">destruct</span> a, b; <span class="kp">try</span> <span class="bp">reflexivity</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">n</span> : nat,
  inductively_barred_at P n (false :: l2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P (false :: l2)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true = false</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chk98" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P (false :: l2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">n</span> : nat,
  inductively_barred_at P n (false :: l2)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chk98"><hr></label><div class="goal-conclusion"><span class="highlight">false = true</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk99" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk99"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">n</span> : nat,
  inductively_barred_at P n (false :: l2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P (false :: l2)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true = false</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk9a" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk9a"><span class="highlight"><span class="nb">destruct</span> H1 <span class="kr">as</span> (n,Hbar).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P (false :: l2)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">true = false</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> (is_path_from_imp_inductively_barred_at _ _ _ (H2 n) Hbar).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk9b" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk9b"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P (false :: l2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">n</span> : nat,
  inductively_barred_at P n (false :: l2)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false = true</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk9c" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk9c"><span class="highlight"><span class="nb">destruct</span> H2 <span class="kr">as</span> (n,Hbar).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P (false :: l2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l2)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">false = true</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> (is_path_from_imp_inductively_barred_at _ _ _ (H1 n) Hbar).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">X</span></span> is the translation of <span class="inlinecode"><span class="id" title="var">Y</span></span> as a predicate 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">X</span> <span class="nv">P</span> <span class="nv">n</span> := <span class="kr">exists</span> <span class="nv">l</span>, length l = n /\ Y P (true::l).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk9d" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk9d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">Y_approx</span> : <span class="kr">forall</span> <span class="nv">P</span>, demorgan_inductively_barred_at P -&gt;
  <span class="kr">forall</span> <span class="nv">l</span>, approx (X P) l -&gt; Y P l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
demorgan_inductively_barred_at P -&gt;
<span class="kr">forall</span> <span class="nv">l</span> : list bool, approx (X P) l -&gt; Y P l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk9e" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk9e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
demorgan_inductively_barred_at P -&gt;
<span class="kr">forall</span> <span class="nv">l</span> : list bool, approx (X P) l -&gt; Y P l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk9f" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk9f"><span class="highlight"><span class="nb">intros</span> P DeMorgan.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list bool, approx (X P) l -&gt; Y P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chka0" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chka0"><span class="highlight"><span class="nb">induction</span> l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">approx (X P) [] -&gt; Y P []</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chka1" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chka1"><hr></label><div class="goal-conclusion"><span class="highlight">approx (X P) (a :: l) -&gt; Y P (a :: l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chka2" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chka2"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">approx (X P) [] -&gt; Y P []</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chka3" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chka3"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">approx (X P) (a :: l) -&gt; Y P (a :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chka4" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chka4"><span class="highlight"><span class="nb">intros</span> (H,Hb).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a <span class="kr">then</span> X P (length l) <span class="kr">else</span> ~ X P (length l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Y P (a :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chka5" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chka5"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a <span class="kr">then</span> X P (length l) <span class="kr">else</span> ~ X P (length l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Y P l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chka6" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a <span class="kr">then</span> X P (length l) <span class="kr">else</span> ~ X P (length l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chka6"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span>
 <span class="kr">exists</span> <span class="nv">n</span> : nat,
   inductively_barred_at P n (false :: l)
<span class="kr">else</span> infinite_from P (false :: l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chka7" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chka7"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a <span class="kr">then</span> X P (length l) <span class="kr">else</span> ~ X P (length l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Y P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chka8" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chka8"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a <span class="kr">then</span> X P (length l) <span class="kr">else</span> ~ X P (length l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span>
 <span class="kr">exists</span> <span class="nv">n</span> : nat,
   inductively_barred_at P n (false :: l)
<span class="kr">else</span> infinite_from P (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chka9" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chka9"><span class="highlight"><span class="nb">unfold</span> X <span class="kr">in</span> Hb.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span>
 <span class="kr">exists</span> <span class="nv">l0</span> : list bool,
   length l0 = length l /\ Y P (true :: l0)
<span class="kr">else</span>
 ~
 (<span class="kr">exists</span> <span class="nv">l0</span> : list bool,
    length l0 = length l /\ Y P (true :: l0))</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span>
 <span class="kr">exists</span> <span class="nv">n</span> : nat,
   inductively_barred_at P n (false :: l)
<span class="kr">else</span> infinite_from P (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkaa" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkaa"><span class="highlight"><span class="nb">destruct</span> a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">l0</span> : list bool,
  length l0 = length l /\ Y P (true :: l0)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">n</span> : nat, inductively_barred_at P n (false :: l)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chkab" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(<span class="kr">exists</span> <span class="nv">l0</span> : list bool,
   length l0 = length l /\ Y P (true :: l0))</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chkab"><hr></label><div class="goal-conclusion"><span class="highlight">infinite_from P (false :: l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkac" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkac"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">l0</span> : list bool,
  length l0 = length l /\ Y P (true :: l0)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">n</span> : nat, inductively_barred_at P n (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkad" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkad"><span class="highlight"><span class="nb">destruct</span> Hb <span class="kr">as</span> (l&#39;,(Hl&#39;,(HYl&#39;,HY))).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = length l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HYl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">n</span> : nat,
  inductively_barred_at P n (false :: l&#39;)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">n</span> : nat, inductively_barred_at P n (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">rewrite</span> &lt;- (Y_unique P DeMorgan l&#39; l Hl&#39;); <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkae" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkae"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(<span class="kr">exists</span> <span class="nv">l0</span> : list bool,
   length l0 = length l /\ Y P (true :: l0))</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">infinite_from P (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkaf" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkaf"><span class="highlight"><span class="nb">intro</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(<span class="kr">exists</span> <span class="nv">l0</span> : list bool,
   length l0 = length l /\ Y P (true :: l0))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkb0" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkb0"><span class="highlight"><span class="nb">apply</span> inductively_barred_at_imp_is_path_from.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(<span class="kr">exists</span> <span class="nv">l0</span> : list bool,
   length l0 = length l /\ Y P (true :: l0))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">demorgan_inductively_barred_at P</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chkb1" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(<span class="kr">exists</span> <span class="nv">l0</span> : list bool,
   length l0 = length l /\ Y P (true :: l0))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chkb1"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred_at P n (false :: l)</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkb2" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkb2"><span class="highlight"><span class="bp">assumption</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(<span class="kr">exists</span> <span class="nv">l0</span> : list bool,
   length l0 = length l /\ Y P (true :: l0))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred_at P n (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">firstorder</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Main theorem 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkb3" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkb3"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">PreWeakKonigsLemma</span> : <span class="kr">forall</span> <span class="nv">P</span>,
  demorgan_inductively_barred_at P -&gt; infinite_from P [] -&gt; has_infinite_path P.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
demorgan_inductively_barred_at P -&gt;
infinite_from P [] -&gt; has_infinite_path P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkb4" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkb4"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
demorgan_inductively_barred_at P -&gt;
infinite_from P [] -&gt; has_infinite_path P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkb5" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkb5"><span class="highlight"><span class="nb">intros</span> P DeMorgan Hinf.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">has_infinite_path P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkb6" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkb6"><span class="highlight"><span class="kr">exists</span> (<span class="nv">X</span> <span class="nv">P</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list bool, approx (X P) l -&gt; ~ P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkb7" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkb7"><span class="highlight"><span class="nb">intros</span> l Hl.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkb8" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkb8"><span class="highlight"><span class="nb">assert</span> (infinite_from P l).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">infinite_from P l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chkb9" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P l</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chkb9"><hr></label><div class="goal-conclusion"><span class="highlight">~ P l</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkba" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkba"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">infinite_from P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkbb" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkbb"><span class="highlight"><span class="nb">induction</span> l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) []</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">infinite_from P []</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chkbc" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) (a :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; infinite_from P l</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chkbc"><hr></label><div class="goal-conclusion"><span class="highlight">infinite_from P (a :: l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkbd" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkbd"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) []</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">infinite_from P []</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkbe" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkbe"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) (a :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; infinite_from P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">infinite_from P (a :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkbf" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkbf"><span class="highlight"><span class="nb">destruct</span> Hl <span class="kr">as</span> (Hl,Ha).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ha</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a <span class="kr">then</span> X P (length l) <span class="kr">else</span> ~ X P (length l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; infinite_from P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">infinite_from P (a :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkc0" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkc0"><span class="highlight"><span class="nb">intros</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ha</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a <span class="kr">then</span> X P (length l) <span class="kr">else</span> ~ X P (length l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; infinite_from P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (a :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkc1" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkc1"><span class="highlight"><span class="nb">pose proof</span> (IHl Hl) <span class="kr">as</span> IHl&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ha</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a <span class="kr">then</span> X P (length l) <span class="kr">else</span> ~ X P (length l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; infinite_from P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (a :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkc2" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkc2"><span class="highlight"><span class="nb">clear</span> IHl.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ha</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a <span class="kr">then</span> X P (length l) <span class="kr">else</span> ~ X P (length l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (a :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkc3" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkc3"><span class="highlight"><span class="nb">apply</span> Y_approx <span class="kr">in</span> Hl; [|<span class="bp">assumption</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ha</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a <span class="kr">then</span> X P (length l) <span class="kr">else</span> ~ X P (length l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (a :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkc4" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkc4"><span class="highlight"><span class="nb">destruct</span> a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ha</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">X P (length l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (true :: l)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chkc5" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ha</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ X P (length l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P l</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chkc5"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (false :: l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkc6" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkc6"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ha</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">X P (length l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkc7" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkc7"><span class="highlight"><span class="nb">destruct</span> Ha <span class="kr">as</span> (l&#39;&amp;Hl&#39;&amp;HY&#39;&amp;n&#39;&amp;Hbar).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = length l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n&#39; (false :: l&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkc8" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkc8"><span class="highlight"><span class="nb">rewrite</span> (Y_unique _ DeMorgan _ _ Hl&#39; HY&#39; Hl) <span class="kr">in</span> Hbar.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = length l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n&#39; (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkc9" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkc9"><span class="highlight"><span class="nb">destruct</span> (le_lt_dec n n&#39;) <span class="kr">as</span> [Hle|Hlt].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = length l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n&#39; (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= n&#39;</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (true :: l)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chkca" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = length l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n&#39; (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hlt</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n&#39; &lt; n</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chkca"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (true :: l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkcb" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkcb"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = length l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n&#39; (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= n&#39;</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkcc" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkcc"><span class="highlight"><span class="nb">specialize</span> (IHl&#39; (S n&#39;)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = length l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n&#39; (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P (S n&#39;) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= n&#39;</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">        </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkcd" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkcd"><span class="highlight"><span class="nb">apply</span> is_path_from_restrict <span class="kr">with</span> n&#39;; [<span class="bp">assumption</span>|].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = length l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n&#39; (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P (S n&#39;) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hle</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n &lt;= n&#39;</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n&#39; (true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">        </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> find_left_path; <span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkce" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkce"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = length l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n&#39; (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hlt</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n&#39; &lt; n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkcf" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkcf"><span class="highlight"><span class="nb">specialize</span> (IHl&#39; (S n)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = length l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n&#39; (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P (S n) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hlt</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n&#39; &lt; n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">        </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkd0" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkd0"><span class="highlight"><span class="nb">apply</span> inductively_barred_at_monotone <span class="kr">with</span> (n:=n) <span class="kr">in</span> Hbar; [|<span class="nb">apply</span> lt_le_weak, Hlt].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = length l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n', n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P (S n) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hlt</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n&#39; &lt; n</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (true :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">        </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> find_left_path; <span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkd1" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkd1"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ha</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ X P (length l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">is_path_from P n (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> inductively_barred_at_imp_is_path_from; <span class="nb">firstorder</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkd2" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkd2"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkd3" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkd3"><span class="highlight"><span class="nb">specialize</span> (H <span class="mi">0</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P <span class="mi">0</span> l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkd4" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkd4"><span class="highlight"><span class="nb">inversion</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">DeMorgan</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">is_path_from P <span class="mi">0</span> l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">l0 = l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkd5" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkd5"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">inductively_barred_at_decidable</span> :
  <span class="kr">forall</span> <span class="nv">P</span>, (<span class="kr">forall</span> <span class="nv">l</span>, P l \/ ~ P l) -&gt; <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">l</span>, inductively_barred_at P n l \/ ~ inductively_barred_at P n l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
(<span class="kr">forall</span> <span class="nv">l</span> : list bool, P l \/ ~ P l) -&gt;
<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list bool),
inductively_barred_at P n l \/
~ inductively_barred_at P n l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkd6" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkd6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
(<span class="kr">forall</span> <span class="nv">l</span> : list bool, P l \/ ~ P l) -&gt;
<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list bool),
inductively_barred_at P n l \/
~ inductively_barred_at P n l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkd7" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkd7"><span class="highlight"><span class="nb">intros</span> P HP.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list bool, P l \/ ~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list bool),
inductively_barred_at P n l \/
~ inductively_barred_at P n l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkd8" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkd8"><span class="highlight"><span class="nb">induction</span> n; <span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P <span class="mi">0</span> l \/
~ inductively_barred_at P <span class="mi">0</span> l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chkd9" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chkd9"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l \/
~ inductively_barred_at P (S n) l</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkda" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkda"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P <span class="mi">0</span> l \/
~ inductively_barred_at P <span class="mi">0</span> l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkdb" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkdb"><span class="highlight"><span class="nb">destruct</span> (HP l).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P <span class="mi">0</span> l \/
~ inductively_barred_at P <span class="mi">0</span> l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chkdc" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chkdc"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P <span class="mi">0</span> l \/
~ inductively_barred_at P <span class="mi">0</span> l</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkdd" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkdd"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P <span class="mi">0</span> l \/
~ inductively_barred_at P <span class="mi">0</span> l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkde" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkde"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P <span class="mi">0</span> l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> now_at, H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkdf" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkdf"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P <span class="mi">0</span> l \/
~ inductively_barred_at P <span class="mi">0</span> l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chke0" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chke0"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred_at P <span class="mi">0</span> l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chke1" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chke1"><span class="highlight"><span class="nb">inversion</span> <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l1</span> : list bool, P l1 \/ ~ P l1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P <span class="mi">0</span> l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = <span class="mi">0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">l0 = l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chke2" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chke2"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l \/
~ inductively_barred_at P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chke3" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chke3"><span class="highlight"><span class="nb">destruct</span> (HP l).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l \/
~ inductively_barred_at P (S n) l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chke4" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chke4"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l \/
~ inductively_barred_at P (S n) l</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chke5" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chke5"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l \/
~ inductively_barred_at P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chke6" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chke6"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> now_at, H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chke7" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chke7"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l \/
~ inductively_barred_at P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chke8" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chke8"><span class="highlight"><span class="nb">destruct</span> (IHn (true::l)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l \/
~ inductively_barred_at P (S n) l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chke9" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P n (true :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chke9"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l \/
~ inductively_barred_at P (S n) l</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkea" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkea"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l \/
~ inductively_barred_at P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkeb" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkeb"><span class="highlight"><span class="nb">destruct</span> (IHn (false::l)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l \/
~ inductively_barred_at P (S n) l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chkec" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chkec"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l \/
~ inductively_barred_at P (S n) l</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chked" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chked"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l \/
~ inductively_barred_at P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkee" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkee"><span class="highlight"><span class="nb">left</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> propagate_at; <span class="bp">assumption</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkef" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkef"><span class="highlight">}</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l \/
~ inductively_barred_at P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkf0" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkf0"><span class="highlight">{</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l \/
~ inductively_barred_at P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkf1" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkf1"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred_at P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion_clear</span> <span class="mi">1</span>; <span class="nb">auto</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">}</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkf2" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkf2"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P n (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred_at P (S n) l \/
~ inductively_barred_at P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkf3" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkf3"><span class="highlight"><span class="nb">right</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
inductively_barred_at P n l0 \/ ~ inductively_barred_at P n l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P n (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred_at P (S n) l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion_clear</span> <span class="mi">1</span>; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkf4" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkf4"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">inductively_barred_at_is_path_from_decidable</span> :
  <span class="kr">forall</span> <span class="nv">P</span>, (<span class="kr">forall</span> <span class="nv">l</span>, P l \/ ~ P l) -&gt; demorgan_inductively_barred_at P.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
(<span class="kr">forall</span> <span class="nv">l</span> : list bool, P l \/ ~ P l) -&gt;
demorgan_inductively_barred_at P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkf5" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkf5"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
(<span class="kr">forall</span> <span class="nv">l</span> : list bool, P l \/ ~ P l) -&gt;
demorgan_inductively_barred_at P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkf6" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkf6"><span class="highlight"><span class="nb">intros</span> P Hdec n l H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(inductively_barred_at P n (true :: l) /\
 inductively_barred_at P n (false :: l))</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred_at P n (true :: l) \/
~ inductively_barred_at P n (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkf7" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkf7"><span class="highlight"><span class="nb">destruct</span> (inductively_barred_at_decidable P Hdec n (true::l)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(inductively_barred_at P n (true :: l) /\
 inductively_barred_at P n (false :: l))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred_at P n (true :: l) \/
~ inductively_barred_at P n (false :: l)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chkf8" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(inductively_barred_at P n (true :: l) /\
 inductively_barred_at P n (false :: l))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P n (true :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chkf8"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred_at P n (true :: l) \/
~ inductively_barred_at P n (false :: l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkf9" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkf9"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(inductively_barred_at P n (true :: l) /\
 inductively_barred_at P n (false :: l))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred_at P n (true :: l) \/
~ inductively_barred_at P n (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkfa" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkfa"><span class="highlight"><span class="nb">destruct</span> (inductively_barred_at_decidable P Hdec n (false::l)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(inductively_barred_at P n (true :: l) /\
 inductively_barred_at P n (false :: l))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred_at P n (true :: l) \/
~ inductively_barred_at P n (false :: l)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WKL-v-chkfb" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(inductively_barred_at P n (true :: l) /\
 inductively_barred_at P n (false :: l))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WKL-v-chkfb"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred_at P n (true :: l) \/
~ inductively_barred_at P n (false :: l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkfc" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkfc"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(inductively_barred_at P n (true :: l) /\
 inductively_barred_at P n (false :: l))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred_at P n (true :: l) \/
~ inductively_barred_at P n (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkfd" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkfd"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(inductively_barred_at P n (true :: l) /\
 inductively_barred_at P n (false :: l))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred_at P n (true :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P n (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred_at P n (true :: l) \/
~ inductively_barred_at P n (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkfe" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkfe"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool, P l0 \/ ~ P l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(inductively_barred_at P n (true :: l) /\
 inductively_barred_at P n (false :: l))</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred_at P n (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred_at P n (true :: l) \/
~ inductively_barred_at P n (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Main corollary 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chkff" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chkff"><span class="highlight"><span class="kn">Corollary</span> <span class="nf">WeakKonigsLemma</span> : <span class="kr">forall</span> <span class="nv">P</span>, (<span class="kr">forall</span> <span class="nv">l</span>, P l \/ ~ P l) -&gt;
  infinite_from P [] -&gt; has_infinite_path P.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
(<span class="kr">forall</span> <span class="nv">l</span> : list bool, P l \/ ~ P l) -&gt;
infinite_from P [] -&gt; has_infinite_path P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk100" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk100"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
(<span class="kr">forall</span> <span class="nv">l</span> : list bool, P l \/ ~ P l) -&gt;
infinite_from P [] -&gt; has_infinite_path P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk101" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk101"><span class="highlight"><span class="nb">intros</span> P Hdec Hinf.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list bool, P l \/ ~ P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">has_infinite_path P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WKL-v-chk102" style="display: none" type="checkbox"><label class="coq-input" for="WKL-v-chk102"><span class="highlight"><span class="nb">apply</span> inductively_barred_at_is_path_from_decidable <span class="kr">in</span> Hdec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hdec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">demorgan_inductively_barred_at P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hinf</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">infinite_from P []</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">has_infinite_path P</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> PreWeakKonigsLemma; <span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></article></body></html>