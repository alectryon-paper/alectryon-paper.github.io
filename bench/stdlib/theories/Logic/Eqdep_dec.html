<!DOCTYPE html>
<html><head><title>Eqdep_dec.v</title><meta charset="utf-8"><meta content="Alectryon v0.2" name="generator"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet"><link href="https://unpkg.com/firacode/distr/fira_code.css" rel="stylesheet"><link href="alectryon.css" rel="stylesheet"><script src="alectryon.js"></script><style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-standalone alectryon-centered alectryon-coqdoc"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="sd">(************************************************************************)</span>
<span class="c">(*         *   The Coq Proof Assistant / The Coq Development Team       *)</span>
<span class="c">(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)</span>
<span class="c">(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)</span>
<span class="c">(*   \VV/  **************************************************************)</span>
<span class="c">(*    //   *    This file is distributed under the terms of the         *)</span>
<span class="c">(*         *     GNU Lesser General Public License Version 2.1          *)</span>
<span class="c">(*         *     (see LICENSE file for the text of the license)         *)</span>
<span class="sd">(************************************************************************)</span>

<span class="c">(* Created by Bruno Barras, Jan 1998 *)</span>
<span class="c">(* Made a module instance for EqdepFacts by Hugo Herbelin, Mar 2006 *)</span></span></span></pre><div class="doc">
We prove that there is only one proof of <span class="inlinecode"><span class="id" title="var">x</span>=<span class="id" title="var">x</span></span>, i.e <span class="inlinecode"><span class="id" title="var">eq_refl</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.
    This holds if the equality upon the set of <span class="inlinecode"><span class="id" title="var">x</span></span> is decidable.
    A corollary of this theorem is the equality of the right projections
    of two equal dependent pairs.

<div class="paragraph"> </div>

    Author:   Thomas Kleymann |&lt;tms@dcs.ed.ac.uk&gt;| in Lego
              adapted to Coq by B. Barras

<div class="paragraph"> </div>

    Credit:   Proofs up to <span class="inlinecode"><span class="id" title="var">K_dec</span></span> follow an outline by Michael Hedberg

<div class="paragraph"> </div>

Table of contents:

<div class="paragraph"> </div>

1. Streicher's K and injectivity of dependent pair hold on decidable types

<div class="paragraph"> </div>

1.1. Definition of the functor that builds properties of dependent equalities
     from a proof of decidability of equality for a set in Type

<div class="paragraph"> </div>

1.2. Definition of the functor that builds properties of dependent equalities
     from a proof of decidability of equality for a set in Set

<div class="paragraph"> </div>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="sd">(************************************************************************)</span></span></span></pre><div class="doc">
<a name="lab1"></a><h1 class="section">Streicher's K and injectivity of dependent pair hold on decidable types</h1>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Set Implicit Arguments</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* Set Universe Polymorphism. *)</span>

</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">EqdepDec</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">A</span> : <span class="kt">Type</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Let</span> <span class="nf">comp</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">y&#39;</span>:A) (<span class="nv">eq1</span>:x = y) (<span class="nv">eq2</span>:x = y&#39;) : y = y&#39; :=
    eq_ind _ (<span class="kr">fun</span> <span class="nv">a</span> =&gt; a = y&#39;) eq2 _ eq1.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk0" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk0"><span class="highlight"><span class="kn">Remark</span> <span class="nf">trans_sym_eq</span> : <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span>:A) (<span class="nv">u</span>:x = y), comp u u = eq_refl y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x = y) (<span class="nv">eq2</span> : x = y&#39;) =&gt;
eq_ind x (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A, x = y -&gt; x = y&#39; -&gt; y = y&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">u</span> : x = y), comp u u = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk1" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x = y) (<span class="nv">eq2</span> : x = y&#39;) =&gt;
eq_ind x (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A, x = y -&gt; x = y&#39; -&gt; y = y&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">u</span> : x = y), comp u u = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk2" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk2"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A,
x0 = y0 -&gt; x0 = y&#39; -&gt; y0 = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">comp u u = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">case</span> u; <span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">x</span> : A.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Variable</span> <span class="nv">eq_dec</span> : <span class="kr">forall</span> <span class="nv">y</span>:A, x = y \/ x &lt;&gt; y.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Let</span> <span class="nf">nu</span> (<span class="nv">y</span>:A) (<span class="nv">u</span>:x = y) : x = y :=
    <span class="kr">match</span> eq_dec y <span class="kr">with</span>
      | or_introl eqxy =&gt; eqxy
      | or_intror neqxy =&gt; False_ind _ (neqxy u)
    <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk3" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk3"><span class="highlight"><span class="kn">Let</span> <span class="nf">nu_constant</span> : <span class="kr">forall</span> (<span class="nv">y</span>:A) (<span class="nv">u</span> <span class="nv">v</span>:x = y), nu u = nu v.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A, x0 = y -&gt; x0 = y&#39; -&gt; y = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y \/ x &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> : x = y) =&gt;
<span class="kr">match</span> eq_dec y <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y), nu u = nu v</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk4" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk4"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A,
x0 = y0 -&gt; x0 = y&#39; -&gt; y0 = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u0</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u0)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">u, v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nu u = nu v</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk5" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk5"><span class="highlight"><span class="nb">unfold</span> nu.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A,
x0 = y0 -&gt; x0 = y&#39; -&gt; y0 = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u0</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u0)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">u, v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> eq_dec y <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y) (neqxy u)
<span class="kr">end</span> =
<span class="kr">match</span> eq_dec y <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y) (neqxy v)
<span class="kr">end</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk6" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk6"><span class="highlight"><span class="nb">destruct</span> (eq_dec y) <span class="kr">as</span> [Heq|Hneq].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A,
x0 = y0 -&gt; x0 = y&#39; -&gt; y0 = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u0</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u0)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">u, v, Heq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Heq = Heq</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Eqdep-dec-v-chk7" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y0)
  (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A,
x0 = y0 -&gt; x0 = y&#39; -&gt; y0 = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u0</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u0)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">u, v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hneq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;&gt; y</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Eqdep-dec-v-chk7"><hr></label><div class="goal-conclusion"><span class="highlight">False_ind (x = y) (Hneq u) =
False_ind (x = y) (Hneq v)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk8" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk8"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A,
x0 = y0 -&gt; x0 = y&#39; -&gt; y0 = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u0</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u0)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">u, v, Heq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Heq = Heq</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk9" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk9"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A,
x0 = y0 -&gt; x0 = y&#39; -&gt; y0 = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u0</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u0)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">u, v</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hneq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;&gt; y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">False_ind (x = y) (Hneq u) =
False_ind (x = y) (Hneq v)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">case</span> Hneq; <span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">

</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Let</span> <span class="nf">nu_inv</span> (<span class="nv">y</span>:A) (<span class="nv">v</span>:x = y) : x = y := comp (nu (eq_refl x)) v.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">

</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chka" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chka"><span class="highlight"><span class="kn">Remark</span> <span class="nf">nu_left_inv_on</span> : <span class="kr">forall</span> (<span class="nv">y</span>:A) (<span class="nv">u</span>:x = y), nu_inv (nu u) = u.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A, x0 = y -&gt; x0 = y&#39; -&gt; y = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y \/ x &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> : x = y) =&gt;
<span class="kr">match</span> eq_dec y <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">v</span> : x = y) =&gt; comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> : x = y), nu_inv (nu u) = u</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chkb" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chkb"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A, x0 = y -&gt; x0 = y&#39; -&gt; y = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y \/ x &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> : x = y) =&gt;
<span class="kr">match</span> eq_dec y <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">v</span> : x = y) =&gt; comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> : x = y), nu_inv (nu u) = u</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chkc" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chkc"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A,
x0 = y0 -&gt; x0 = y&#39; -&gt; y0 = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u0</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u0)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u0</span> <span class="nv">v</span> : x = y0),
nu u0 = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nu_inv (nu u) = u</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chkd" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chkd"><span class="highlight"><span class="nb">case</span> u; <span class="nb">unfold</span> nu_inv.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A,
x0 = y0 -&gt; x0 = y&#39; -&gt; y0 = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u0</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u0)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u0</span> <span class="nv">v</span> : x = y0),
nu u0 = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">comp (nu eq_refl) (nu eq_refl) = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> trans_sym_eq.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">

</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chke" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chke"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">eq_proofs_unicity_on</span> : <span class="kr">forall</span> (<span class="nv">y</span>:A) (<span class="nv">p1</span> <span class="nv">p2</span>:x = y), p1 = p2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A, x0 = y -&gt; x0 = y&#39; -&gt; y = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y \/ x &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> : x = y) =&gt;
<span class="kr">match</span> eq_dec y <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">v</span> : x = y) =&gt; comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">p1</span> <span class="nv">p2</span> : x = y), p1 = p2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chkf" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chkf"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A, x0 = y -&gt; x0 = y&#39; -&gt; y = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y \/ x &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> : x = y) =&gt;
<span class="kr">match</span> eq_dec y <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">v</span> : x = y) =&gt; comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">p1</span> <span class="nv">p2</span> : x = y), p1 = p2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk10" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk10"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A,
x0 = y0 -&gt; x0 = y&#39; -&gt; y0 = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1, p2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">p1 = p2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk11" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk11"><span class="highlight"><span class="nb">elim</span> nu_left_inv_on <span class="kr">with</span> (u := p1).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A,
x0 = y0 -&gt; x0 = y&#39; -&gt; y0 = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1, p2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nu_inv (nu p1) = p2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk12" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk12"><span class="highlight"><span class="nb">elim</span> nu_left_inv_on <span class="kr">with</span> (u := p2).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A,
x0 = y0 -&gt; x0 = y&#39; -&gt; y0 = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1, p2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nu_inv (nu p1) = nu_inv (nu p2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk13" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk13"><span class="highlight"><span class="nb">elim</span> nu_constant <span class="kr">with</span> y p1 p2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;</span> : A,
x0 = y0 -&gt; x0 = y&#39; -&gt; y0 = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1, p2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nu_inv (nu p1) = nu_inv (nu p1)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk14" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk14"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">K_dec_on</span> :
    <span class="kr">forall</span> <span class="nv">P</span>:x = x -&gt; <span class="kt">Prop</span>, P (eq_refl x) -&gt; <span class="kr">forall</span> <span class="nv">p</span>:x = x, P p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A, x0 = y -&gt; x0 = y&#39; -&gt; y = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y \/ x &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> : x = y) =&gt;
<span class="kr">match</span> eq_dec y <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">v</span> : x = y) =&gt; comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : x = x -&gt; <span class="kt">Prop</span>,
P eq_refl -&gt; <span class="kr">forall</span> <span class="nv">p</span> : x = x, P p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk15" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk15"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A, x0 = y -&gt; x0 = y&#39; -&gt; y = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y \/ x &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> : x = y) =&gt;
<span class="kr">match</span> eq_dec y <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">v</span> : x = y) =&gt; comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : x = x -&gt; <span class="kt">Prop</span>,
P eq_refl -&gt; <span class="kr">forall</span> <span class="nv">p</span> : x = x, P p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk16" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk16"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A, x0 = y -&gt; x0 = y&#39; -&gt; y = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y \/ x &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> : x = y) =&gt;
<span class="kr">match</span> eq_dec y <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">v</span> : x = y) =&gt; comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P eq_refl</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk17" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk17"><span class="highlight"><span class="nb">elim</span> eq_proofs_unicity_on <span class="kr">with</span> x (eq_refl x) p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A, x0 = y -&gt; x0 = y&#39; -&gt; y = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y \/ x &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> : x = y) =&gt;
<span class="kr">match</span> eq_dec y <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">v</span> : x = y) =&gt; comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P eq_refl</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The corollary 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Let</span> <span class="nf">proj</span> (<span class="nv">P</span>:A -&gt; <span class="kt">Prop</span>) (<span class="nv">exP</span>:ex P) (<span class="nv">def</span>:P x) : P x :=
    <span class="kr">match</span> exP <span class="kr">with</span>
      | ex_intro _ x&#39; prf =&gt;
        <span class="kr">match</span> eq_dec x&#39; <span class="kr">with</span>
          | or_introl eqprf =&gt; eq_ind x&#39; P prf x (eq_sym eqprf)
          | _ =&gt; def
        <span class="kr">end</span>
    <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">

</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk18" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk18"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">inj_right_pair_on</span> :
    <span class="kr">forall</span> (<span class="nv">P</span>:A -&gt; <span class="kt">Prop</span>) (<span class="nv">y</span> <span class="nv">y&#39;</span>:P x),
      ex_intro P x y = ex_intro P x y&#39; -&gt; y = y&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A, x0 = y -&gt; x0 = y&#39; -&gt; y = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y \/ x &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> : x = y) =&gt;
<span class="kr">match</span> eq_dec y <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">v</span> : x = y) =&gt; comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">proj</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">exP</span> : <span class="kr">exists</span> <span class="nv">y</span>, P y)
  (<span class="nv">def</span> : P x) =&gt;
<span class="kr">match</span> exP <span class="kr">with</span>
| ex_intro _ x&#39; prf =&gt;
    <span class="kr">match</span> eq_dec x&#39; <span class="kr">with</span>
    | or_introl eqprf =&gt;
        eq_ind x&#39; P prf x (eq_sym eqprf)
    | or_intror _ =&gt; def
    <span class="kr">end</span>
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">exists</span> <span class="nv">y</span>, P y) -&gt; P x -&gt; P x</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">y</span> <span class="nv">y&#39;</span> : P x),
ex_intro P x y = ex_intro P x y&#39; -&gt; y = y&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk19" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk19"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A) (<span class="nv">eq1</span> : x0 = y) (<span class="nv">eq2</span> : x0 = y&#39;) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;) eq2 y eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A, x0 = y -&gt; x0 = y&#39; -&gt; y = y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y \/ x &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> : x = y) =&gt;
<span class="kr">match</span> eq_dec y <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">v</span> : x = y) =&gt; comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : A, x = y -&gt; x = y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">proj</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">exP</span> : <span class="kr">exists</span> <span class="nv">y</span>, P y)
  (<span class="nv">def</span> : P x) =&gt;
<span class="kr">match</span> exP <span class="kr">with</span>
| ex_intro _ x&#39; prf =&gt;
    <span class="kr">match</span> eq_dec x&#39; <span class="kr">with</span>
    | or_introl eqprf =&gt;
        eq_ind x&#39; P prf x (eq_sym eqprf)
    | or_intror _ =&gt; def
    <span class="kr">end</span>
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">exists</span> <span class="nv">y</span>, P y) -&gt; P x -&gt; P x</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">y</span> <span class="nv">y&#39;</span> : P x),
ex_intro P x y = ex_intro P x y&#39; -&gt; y = y&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk1a" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk1a"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;0) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;0) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A,
x0 = y0 -&gt; x0 = y&#39;0 -&gt; y0 = y&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">proj</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">exP</span> : <span class="kr">exists</span> <span class="nv">y</span>, P0 y)
  (<span class="nv">def</span> : P0 x) =&gt;
<span class="kr">match</span> exP <span class="kr">with</span>
| ex_intro _ x&#39; prf =&gt;
    <span class="kr">match</span> eq_dec x&#39; <span class="kr">with</span>
    | or_introl eqprf =&gt;
        eq_ind x&#39; P0 prf x (eq_sym eqprf)
    | or_intror _ =&gt; def
    <span class="kr">end</span>
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">exists</span> <span class="nv">y</span>, P0 y) -&gt; P0 x -&gt; P0 x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, y'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x y = ex_intro P x y&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y = y&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk1b"><span class="highlight"><span class="nb">cut</span> (proj (ex_intro P x y) y = proj (ex_intro P x y&#39;) y).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;0) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;0) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A,
x0 = y0 -&gt; x0 = y&#39;0 -&gt; y0 = y&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">proj</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">exP</span> : <span class="kr">exists</span> <span class="nv">y</span>, P0 y)
  (<span class="nv">def</span> : P0 x) =&gt;
<span class="kr">match</span> exP <span class="kr">with</span>
| ex_intro _ x&#39; prf =&gt;
    <span class="kr">match</span> eq_dec x&#39; <span class="kr">with</span>
    | or_introl eqprf =&gt;
        eq_ind x&#39; P0 prf x (eq_sym eqprf)
    | or_intror _ =&gt; def
    <span class="kr">end</span>
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">exists</span> <span class="nv">y</span>, P0 y) -&gt; P0 x -&gt; P0 x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, y'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x y = ex_intro P x y&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">proj (ex_intro P x y) y = proj (ex_intro P x y&#39;) y -&gt;
y = y&#39;</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Eqdep-dec-v-chk1c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A) (<span class="nv">eq1</span> : x0 = y0)
  (<span class="nv">eq2</span> : x0 = y&#39;0) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;0) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A,
x0 = y0 -&gt; x0 = y&#39;0 -&gt; y0 = y&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">proj</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">exP</span> : <span class="kr">exists</span> <span class="nv">y</span>, P0 y)
  (<span class="nv">def</span> : P0 x) =&gt;
<span class="kr">match</span> exP <span class="kr">with</span>
| ex_intro _ x&#39; prf =&gt;
    <span class="kr">match</span> eq_dec x&#39; <span class="kr">with</span>
    | or_introl eqprf =&gt;
        eq_ind x&#39; P0 prf x (eq_sym eqprf)
    | or_intror _ =&gt; def
    <span class="kr">end</span>
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">exists</span> <span class="nv">y</span>, P0 y) -&gt; P0 x -&gt; P0 x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, y'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x y = ex_intro P x y&#39;</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Eqdep-dec-v-chk1c"><hr></label><div class="goal-conclusion"><span class="highlight">proj (ex_intro P x y) y = proj (ex_intro P x y&#39;) y</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk1d" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk1d"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;0) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;0) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A,
x0 = y0 -&gt; x0 = y&#39;0 -&gt; y0 = y&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">proj</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">exP</span> : <span class="kr">exists</span> <span class="nv">y</span>, P0 y)
  (<span class="nv">def</span> : P0 x) =&gt;
<span class="kr">match</span> exP <span class="kr">with</span>
| ex_intro _ x&#39; prf =&gt;
    <span class="kr">match</span> eq_dec x&#39; <span class="kr">with</span>
    | or_introl eqprf =&gt;
        eq_ind x&#39; P0 prf x (eq_sym eqprf)
    | or_intror _ =&gt; def
    <span class="kr">end</span>
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">exists</span> <span class="nv">y</span>, P0 y) -&gt; P0 x -&gt; P0 x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, y'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x y = ex_intro P x y&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">proj (ex_intro P x y) y = proj (ex_intro P x y&#39;) y -&gt;
y = y&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk1e"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;0) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;0) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A,
x0 = y0 -&gt; x0 = y&#39;0 -&gt; y0 = y&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">proj</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">exP</span> : <span class="kr">exists</span> <span class="nv">y</span>, P0 y)
  (<span class="nv">def</span> : P0 x) =&gt;
<span class="kr">match</span> exP <span class="kr">with</span>
| ex_intro _ x&#39; prf =&gt;
    <span class="kr">match</span> eq_dec x&#39; <span class="kr">with</span>
    | or_introl eqprf =&gt;
        eq_ind x&#39; P0 prf x (eq_sym eqprf)
    | or_intror _ =&gt; def
    <span class="kr">end</span>
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">exists</span> <span class="nv">y</span>, P0 y) -&gt; P0 x -&gt; P0 x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, y'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x y = ex_intro P x y&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> eq_dec x <span class="kr">with</span>
| or_introl eqprf =&gt; eq_ind x P y x (eq_sym eqprf)
| or_intror _ =&gt; y
<span class="kr">end</span> =
<span class="kr">match</span> eq_dec x <span class="kr">with</span>
| or_introl eqprf =&gt; eq_ind x P y&#39; x (eq_sym eqprf)
| or_intror _ =&gt; y
<span class="kr">end</span> -&gt; y = y&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk1f"><span class="highlight"><span class="nb">destruct</span> (eq_dec x) <span class="kr">as</span> [Heq|Hneq].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;0) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;0) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A,
x0 = y0 -&gt; x0 = y&#39;0 -&gt; y0 = y&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">proj</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">exP</span> : <span class="kr">exists</span> <span class="nv">y</span>, P0 y)
  (<span class="nv">def</span> : P0 x) =&gt;
<span class="kr">match</span> exP <span class="kr">with</span>
| ex_intro _ x&#39; prf =&gt;
    <span class="kr">match</span> eq_dec x&#39; <span class="kr">with</span>
    | or_introl eqprf =&gt;
        eq_ind x&#39; P0 prf x (eq_sym eqprf)
    | or_intror _ =&gt; def
    <span class="kr">end</span>
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">exists</span> <span class="nv">y</span>, P0 y) -&gt; P0 x -&gt; P0 x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, y'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x y = ex_intro P x y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eq_ind x P y x (eq_sym Heq) =
eq_ind x P y&#39; x (eq_sym Heq) -&gt; y = y&#39;</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Eqdep-dec-v-chk20" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A) (<span class="nv">eq1</span> : x0 = y0)
  (<span class="nv">eq2</span> : x0 = y&#39;0) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;0) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A,
x0 = y0 -&gt; x0 = y&#39;0 -&gt; y0 = y&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">proj</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">exP</span> : <span class="kr">exists</span> <span class="nv">y</span>, P0 y)
  (<span class="nv">def</span> : P0 x) =&gt;
<span class="kr">match</span> exP <span class="kr">with</span>
| ex_intro _ x&#39; prf =&gt;
    <span class="kr">match</span> eq_dec x&#39; <span class="kr">with</span>
    | or_introl eqprf =&gt;
        eq_ind x&#39; P0 prf x (eq_sym eqprf)
    | or_intror _ =&gt; def
    <span class="kr">end</span>
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">exists</span> <span class="nv">y</span>, P0 y) -&gt; P0 x -&gt; P0 x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, y'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x y = ex_intro P x y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hneq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;&gt; x</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Eqdep-dec-v-chk20"><hr></label><div class="goal-conclusion"><span class="highlight">y = y -&gt; y = y&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk21" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk21"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;0) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;0) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A,
x0 = y0 -&gt; x0 = y&#39;0 -&gt; y0 = y&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">proj</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">exP</span> : <span class="kr">exists</span> <span class="nv">y</span>, P0 y)
  (<span class="nv">def</span> : P0 x) =&gt;
<span class="kr">match</span> exP <span class="kr">with</span>
| ex_intro _ x&#39; prf =&gt;
    <span class="kr">match</span> eq_dec x&#39; <span class="kr">with</span>
    | or_introl eqprf =&gt;
        eq_ind x&#39; P0 prf x (eq_sym eqprf)
    | or_intror _ =&gt; def
    <span class="kr">end</span>
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">exists</span> <span class="nv">y</span>, P0 y) -&gt; P0 x -&gt; P0 x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, y'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x y = ex_intro P x y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eq_ind x P y x (eq_sym Heq) =
eq_ind x P y&#39; x (eq_sym Heq) -&gt; y = y&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">elim</span> Heq <span class="nb">using</span> K_dec_on; <span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk22" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk22"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;0) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;0) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A,
x0 = y0 -&gt; x0 = y&#39;0 -&gt; y0 = y&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">proj</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">exP</span> : <span class="kr">exists</span> <span class="nv">y</span>, P0 y)
  (<span class="nv">def</span> : P0 x) =&gt;
<span class="kr">match</span> exP <span class="kr">with</span>
| ex_intro _ x&#39; prf =&gt;
    <span class="kr">match</span> eq_dec x&#39; <span class="kr">with</span>
    | or_introl eqprf =&gt;
        eq_ind x&#39; P0 prf x (eq_sym eqprf)
    | or_intror _ =&gt; def
    <span class="kr">end</span>
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">exists</span> <span class="nv">y</span>, P0 y) -&gt; P0 x -&gt; P0 x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, y'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x y = ex_intro P x y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hneq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;&gt; x</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y = y -&gt; y = y&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk23" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk23"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;0) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;0) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A,
x0 = y0 -&gt; x0 = y&#39;0 -&gt; y0 = y&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">proj</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">exP</span> : <span class="kr">exists</span> <span class="nv">y</span>, P0 y)
  (<span class="nv">def</span> : P0 x) =&gt;
<span class="kr">match</span> exP <span class="kr">with</span>
| ex_intro _ x&#39; prf =&gt;
    <span class="kr">match</span> eq_dec x&#39; <span class="kr">with</span>
    | or_introl eqprf =&gt;
        eq_ind x&#39; P0 prf x (eq_sym eqprf)
    | or_intror _ =&gt; def
    <span class="kr">end</span>
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">exists</span> <span class="nv">y</span>, P0 y) -&gt; P0 x -&gt; P0 x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, y'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x y = ex_intro P x y&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hneq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x &lt;&gt; x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">y = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y = y&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">        </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">case</span> Hneq; <span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk24" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk24"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;0) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;0) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A,
x0 = y0 -&gt; x0 = y&#39;0 -&gt; y0 = y&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">proj</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">exP</span> : <span class="kr">exists</span> <span class="nv">y</span>, P0 y)
  (<span class="nv">def</span> : P0 x) =&gt;
<span class="kr">match</span> exP <span class="kr">with</span>
| ex_intro _ x&#39; prf =&gt;
    <span class="kr">match</span> eq_dec x&#39; <span class="kr">with</span>
    | or_introl eqprf =&gt;
        eq_ind x&#39; P0 prf x (eq_sym eqprf)
    | or_intror _ =&gt; def
    <span class="kr">end</span>
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">exists</span> <span class="nv">y</span>, P0 y) -&gt; P0 x -&gt; P0 x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, y'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x y = ex_intro P x y&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">proj (ex_intro P x y) y = proj (ex_intro P x y&#39;) y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk25" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk25"><span class="highlight"><span class="nb">case</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">comp</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A) (<span class="nv">eq1</span> : x0 = y0) (<span class="nv">eq2</span> : x0 = y&#39;0) =&gt;
eq_ind x0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a = y&#39;0) eq2 y0 eq1</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">y&#39;0</span> : A,
x0 = y0 -&gt; x0 = y&#39;0 -&gt; y0 = y&#39;0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 \/ x &lt;&gt; y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> : x = y0) =&gt;
<span class="kr">match</span> eq_dec y0 <span class="kr">with</span>
| or_introl eqxy =&gt; eqxy
| or_intror neqxy =&gt; False_ind (x = y0) (neqxy u)
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_constant</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> (<span class="nv">y0</span> : A) (<span class="nv">u</span> <span class="nv">v</span> : x = y0),
nu u = nu v</span></span></span></div><div class="goal-hyp"><span class="hyp-names">nu_inv</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">v</span> : x = y0) =&gt;
comp (nu eq_refl) v</span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : A, x = y0 -&gt; x = y0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">proj</span><span><span class="hyp-body"><span class="hyp-punct">:=</span><span class="highlight"><span class="kr">fun</span> (<span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">exP</span> : <span class="kr">exists</span> <span class="nv">y</span>, P0 y)
  (<span class="nv">def</span> : P0 x) =&gt;
<span class="kr">match</span> exP <span class="kr">with</span>
| ex_intro _ x&#39; prf =&gt;
    <span class="kr">match</span> eq_dec x&#39; <span class="kr">with</span>
    | or_introl eqprf =&gt;
        eq_ind x&#39; P0 prf x (eq_sym eqprf)
    | or_intror _ =&gt; def
    <span class="kr">end</span>
<span class="kr">end</span></span></span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">P0</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">exists</span> <span class="nv">y</span>, P0 y) -&gt; P0 x -&gt; P0 x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, y'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x y = ex_intro P x y&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">proj (ex_intro P x y) y = proj (ex_intro P x y) y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">EqdepDec</span>.</span></span></span></pre><div class="doc">
Now we prove the versions that require decidable equality for the entire type
    rather than just on the given element.  The rest of the file uses this total
    decidable equality.  We could do everything using decidable equality at a point
    (because the induction rule for <span class="inlinecode"><span class="id" title="var">eq</span></span> is really an induction rule for
    <span class="inlinecode">{</span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">}</span>), but we don't currently, because changing everything
    would break backward compatibility and no-one has yet taken the time to define
    the pointed versions, and then re-define the non-pointed versions in terms of
    those. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk26" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk26"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">eq_proofs_unicity</span> <span class="nv">A</span> (<span class="nv">eq_dec</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, x = y \/ x &lt;&gt; y) (<span class="nv">x</span> : A)
: <span class="kr">forall</span> (<span class="nv">y</span>:A) (<span class="nv">p1</span> <span class="nv">p2</span>:x = y), p1 = p2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A, x0 = y \/ x0 &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">p1</span> <span class="nv">p2</span> : x = y), p1 = p2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> (@eq_proofs_unicity_on A x (eq_dec x)).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk27" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk27"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">K_dec</span> <span class="nv">A</span> (<span class="nv">eq_dec</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, x = y \/ x &lt;&gt; y) (<span class="nv">x</span> : A)
: <span class="kr">forall</span> <span class="nv">P</span>:x = x -&gt; <span class="kt">Prop</span>, P (eq_refl x) -&gt; <span class="kr">forall</span> <span class="nv">p</span>:x = x, P p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A, x0 = y \/ x0 &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : x = x -&gt; <span class="kt">Prop</span>,
P eq_refl -&gt; <span class="kr">forall</span> <span class="nv">p</span> : x = x, P p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> (@K_dec_on A x (eq_dec x)).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk28" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk28"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">inj_right_pair</span> <span class="nv">A</span> (<span class="nv">eq_dec</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, x = y \/ x &lt;&gt; y) (<span class="nv">x</span> : A)
: <span class="kr">forall</span> (<span class="nv">P</span>:A -&gt; <span class="kt">Prop</span>) (<span class="nv">y</span> <span class="nv">y&#39;</span>:P x),
    ex_intro P x y = ex_intro P x y&#39; -&gt; y = y&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A, x0 = y \/ x0 &lt;&gt; y</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">y</span> <span class="nv">y&#39;</span> : P x),
ex_intro P x y = ex_intro P x y&#39; -&gt; y = y&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> (@inj_right_pair_on A x (eq_dec x)).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> EqdepFacts.</span></span></span></pre><div class="doc">
We deduce axiom <span class="inlinecode"><span class="id" title="var">K</span></span> for (decidable) types 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk29" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk29"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">K_dec_type</span> :
  <span class="kr">forall</span> <span class="nv">A</span>:<span class="kt">Type</span>,
    (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>:A, {x = y} + {x &lt;&gt; y}) -&gt;
    <span class="kr">forall</span> (<span class="nv">x</span>:A) (<span class="nv">P</span>:x = x -&gt; <span class="kt">Prop</span>), P (eq_refl x) -&gt; <span class="kr">forall</span> <span class="nv">p</span>:x = x, P p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">P</span> : x = x -&gt; <span class="kt">Prop</span>),
P eq_refl -&gt; <span class="kr">forall</span> <span class="nv">p</span> : x = x, P p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk2a" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk2a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">P</span> : x = x -&gt; <span class="kt">Prop</span>),
P eq_refl -&gt; <span class="kr">forall</span> <span class="nv">p</span> : x = x, P p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk2b" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk2b"><span class="highlight"><span class="nb">intros</span> A eq_dec x P H p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A, {x0 = y} + {x0 &lt;&gt; y}</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P eq_refl</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk2c" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk2c"><span class="highlight"><span class="nb">elim</span> p <span class="nb">using</span> K_dec; <span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x1</span> <span class="nv">y0</span> : A, {x1 = y0} + {x1 &lt;&gt; y0}</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P eq_refl</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x0 = y \/ x0 &lt;&gt; y</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Eqdep-dec-v-chk2d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A, {x0 = y} + {x0 &lt;&gt; y}</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P eq_refl</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Eqdep-dec-v-chk2d"><hr></label><div class="goal-conclusion"><span class="highlight">P eq_refl</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk2e"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x1</span> <span class="nv">y0</span> : A, {x1 = y0} + {x1 &lt;&gt; y0}</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P eq_refl</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x0 = y \/ x0 &lt;&gt; y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">case</span> (eq_dec x0 y); [<span class="nb">left</span>|<span class="nb">right</span>]; <span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk2f" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk2f"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A, {x0 = y} + {x0 &lt;&gt; y}</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P eq_refl</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = x</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk30" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk30"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">K_dec_set</span> :
  <span class="kr">forall</span> <span class="nv">A</span>:<span class="kt">Set</span>,
    (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>:A, {x = y} + {x &lt;&gt; y}) -&gt;
    <span class="kr">forall</span> (<span class="nv">x</span>:A) (<span class="nv">P</span>:x = x -&gt; <span class="kt">Prop</span>), P (eq_refl x) -&gt; <span class="kr">forall</span> <span class="nv">p</span>:x = x, P p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Set</span>,
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">P</span> : x = x -&gt; <span class="kt">Prop</span>),
P eq_refl -&gt; <span class="kr">forall</span> <span class="nv">p</span> : x = x, P p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> <span class="kr">fun</span> <span class="nv">A</span> =&gt; K_dec_type (A:=A).</span></span></span></pre><div class="doc">
We deduce the <span class="inlinecode"><span class="id" title="var">eq_rect_eq</span></span> axiom for (decidable) types 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk31" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk31"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">eq_rect_eq_dec</span> :
  <span class="kr">forall</span> <span class="nv">A</span>:<span class="kt">Type</span>,
    (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>:A, {x = y} + {x &lt;&gt; y}) -&gt;
    <span class="kr">forall</span> (<span class="nv">p</span>:A) (<span class="nv">Q</span>:A -&gt; <span class="kt">Type</span>) (<span class="nv">x</span>:Q p) (<span class="nv">h</span>:p = p), x = eq_rect p Q x p h.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : A) (<span class="nv">Q</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">x</span> : Q p) (<span class="nv">h</span> : p = p),
x = eq_rect p Q x p h</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk32" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk32"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}) -&gt;
<span class="kr">forall</span> (<span class="nv">p</span> : A) (<span class="nv">Q</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">x</span> : Q p) (<span class="nv">h</span> : p = p),
x = eq_rect p Q x p h</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk33" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk33"><span class="highlight"><span class="nb">intros</span> A eq_dec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">p</span> : A) (<span class="nv">Q</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">x</span> : Q p) (<span class="nv">h</span> : p = p),
x = eq_rect p Q x p h</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> (Streicher_K__eq_rect_eq A (K_dec_type eq_dec)).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
We deduce the injectivity of dependent equality for decidable types 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk34" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk34"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">eq_dep_eq_dec</span> :
  <span class="kr">forall</span> <span class="nv">A</span>:<span class="kt">Type</span>,
    (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>:A, {x = y} + {x &lt;&gt; y}) -&gt;
     <span class="kr">forall</span> (<span class="nv">P</span>:A-&gt;<span class="kt">Type</span>) (<span class="nv">p</span>:A) (<span class="nv">x</span> <span class="nv">y</span>:P p), eq_dep A P p x p y -&gt; x = y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}) -&gt;
<span class="kr">forall</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">p</span> : A) (<span class="nv">x</span> <span class="nv">y</span> : P p),
eq_dep A P p x p y -&gt; x = y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> (<span class="kr">fun</span> <span class="nv">A</span> <span class="nv">eq_dec</span> =&gt; eq_rect_eq__eq_dep_eq A (eq_rect_eq_dec eq_dec)).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk35" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk35"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">UIP_dec</span> :
  <span class="kr">forall</span> (<span class="nv">A</span>:<span class="kt">Type</span>),
    (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>:A, {x = y} + {x &lt;&gt; y}) -&gt;
    <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span>:A) (<span class="nv">p1</span> <span class="nv">p2</span>:x = y), p1 = p2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">p1</span> <span class="nv">p2</span> : x = y), p1 = p2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> (<span class="kr">fun</span> <span class="nv">A</span> <span class="nv">eq_dec</span> =&gt; eq_dep_eq__UIP A (eq_dep_eq_dec eq_dec)).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Unset Implicit Arguments</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="sd">(************************************************************************)</span></span></span></pre><div class="doc">
<a name="lab2"></a><h2 class="section">Definition of the functor that builds properties of dependent equalities on decidable sets in Type</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The signature of decidable sets in <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module Type</span> <span class="nf">DecidableType</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Monomorphic</span> <span class="kn">Parameter</span> <span class="nv">U</span>:<span class="kt">Type</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">eq_dec</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>:U, {x = y} + {x &lt;&gt; y}.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">DecidableType</span>.</span></span></span></pre><div class="doc">
The module <span class="inlinecode"><span class="id" title="var">DecidableEqDep</span></span> collects equality properties for decidable
    set in <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">DecidableEqDep</span> (M:DecidableType).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Import</span> M.</span></span></span></pre><div class="doc">
Invariance by Substitution of Reflexive Equality Proofs 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk36" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk36"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">eq_rect_eq</span> :
    <span class="kr">forall</span> (<span class="nv">p</span>:U) (<span class="nv">Q</span>:U -&gt; <span class="kt">Type</span>) (<span class="nv">x</span>:Q p) (<span class="nv">h</span>:p = p), x = eq_rect p Q x p h.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">p</span> : U) (<span class="nv">Q</span> : U -&gt; <span class="kt">Type</span>) (<span class="nv">x</span> : Q p) (<span class="nv">h</span> : p = p),
x = eq_rect p Q x p h</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> eq_rect_eq_dec eq_dec.</span></span></span></pre><div class="doc">
Injectivity of Dependent Equality 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk37" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk37"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">eq_dep_eq</span> :
    <span class="kr">forall</span> (<span class="nv">P</span>:U-&gt;<span class="kt">Type</span>) (<span class="nv">p</span>:U) (<span class="nv">x</span> <span class="nv">y</span>:P p), eq_dep U P p x p y -&gt; x = y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : U -&gt; <span class="kt">Type</span>) (<span class="nv">p</span> : U) (<span class="nv">x</span> <span class="nv">y</span> : P p),
eq_dep U P p x p y -&gt; x = y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> (eq_rect_eq__eq_dep_eq U eq_rect_eq).</span></span></span></pre><div class="doc">
Uniqueness of Identity Proofs (UIP) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk38" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk38"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">UIP</span> : <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span>:U) (<span class="nv">p1</span> <span class="nv">p2</span>:x = y), p1 = p2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : U) (<span class="nv">p1</span> <span class="nv">p2</span> : x = y), p1 = p2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> (eq_dep_eq__UIP U eq_dep_eq).</span></span></span></pre><div class="doc">
Uniqueness of Reflexive Identity Proofs 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk39" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk39"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">UIP_refl</span> : <span class="kr">forall</span> (<span class="nv">x</span>:U) (<span class="nv">p</span>:x = x), p = eq_refl x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : U) (<span class="nv">p</span> : x = x), p = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> (UIP__UIP_refl U UIP).</span></span></span></pre><div class="doc">
Streicher's axiom K 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk3a" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk3a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">Streicher_K</span> :
    <span class="kr">forall</span> (<span class="nv">x</span>:U) (<span class="nv">P</span>:x = x -&gt; <span class="kt">Prop</span>), P (eq_refl x) -&gt; <span class="kr">forall</span> <span class="nv">p</span>:x = x, P p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : U) (<span class="nv">P</span> : x = x -&gt; <span class="kt">Prop</span>),
P eq_refl -&gt; <span class="kr">forall</span> <span class="nv">p</span> : x = x, P p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> (K_dec_type eq_dec).</span></span></span></pre><div class="doc">
Injectivity of equality on dependent pairs in <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk3b" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk3b"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">inj_pairT2</span> :
    <span class="kr">forall</span> (<span class="nv">P</span>:U -&gt; <span class="kt">Type</span>) (<span class="nv">p</span>:U) (<span class="nv">x</span> <span class="nv">y</span>:P p),
      existT P p x = existT P p y -&gt; x = y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : U -&gt; <span class="kt">Type</span>) (<span class="nv">p</span> : U) (<span class="nv">x</span> <span class="nv">y</span> : P p),
existT P p x = existT P p y -&gt; x = y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> eq_dep_eq__inj_pairT2 U eq_dep_eq.</span></span></span></pre><div class="doc">
Proof-irrelevance on subsets of decidable sets 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk3c" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk3c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">inj_pairP2</span> :
    <span class="kr">forall</span> (<span class="nv">P</span>:U -&gt; <span class="kt">Prop</span>) (<span class="nv">x</span>:U) (<span class="nv">p</span> <span class="nv">q</span>:P x),
      ex_intro P x p = ex_intro P x q -&gt; p = q.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : U -&gt; <span class="kt">Prop</span>) (<span class="nv">x</span> : U) (<span class="nv">p</span> <span class="nv">q</span> : P x),
ex_intro P x p = ex_intro P x q -&gt; p = q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk3d" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk3d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : U -&gt; <span class="kt">Prop</span>) (<span class="nv">x</span> : U) (<span class="nv">p</span> <span class="nv">q</span> : P x),
ex_intro P x p = ex_intro P x q -&gt; p = q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk3e" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk3e"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">U -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">U</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x p = ex_intro P x q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">p = q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk3f" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk3f"><span class="highlight"><span class="nb">apply</span> inj_right_pair <span class="kr">with</span> (A:=U).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">U -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">U</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x p = ex_intro P x q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : U, x0 = y \/ x0 &lt;&gt; y</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Eqdep-dec-v-chk40" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">U -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">U</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x p = ex_intro P x q</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Eqdep-dec-v-chk40"><hr></label><div class="goal-conclusion"><span class="highlight">ex_intro P x p = ex_intro P x q</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk41" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk41"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">U -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">U</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x p = ex_intro P x q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : U, x0 = y \/ x0 &lt;&gt; y</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">intros</span> x0 y0; <span class="nb">case</span> (eq_dec x0 y0); [<span class="nb">left</span>|<span class="nb">right</span>]; <span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk42" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk42"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">U -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">U</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P x</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">ex_intro P x p = ex_intro P x q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ex_intro P x p = ex_intro P x q</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">DecidableEqDep</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="sd">(************************************************************************)</span></span></span></pre><div class="doc">
<a name="lab3"></a><h2 class="section">Definition of the functor that builds properties of dependent equalities on decidable sets in Set</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --></pre><div class="doc">
The signature of decidable sets in <span class="inlinecode"><span class="id" title="keyword">Set</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module Type</span> <span class="nf">DecidableSet</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">U</span>:<span class="kt">Set</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">eq_dec</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>:U, {x = y} + {x &lt;&gt; y}.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">DecidableSet</span>.</span></span></span></pre><div class="doc">
The module <span class="inlinecode"><span class="id" title="var">DecidableEqDepSet</span></span> collects equality properties for decidable
    set in <span class="inlinecode"><span class="id" title="keyword">Set</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">DecidableEqDepSet</span> (M:DecidableSet).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Import</span> M.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">N</span>:=DecidableEqDep(M).</span></span></span></pre><div class="doc">
Invariance by Substitution of Reflexive Equality Proofs 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk43" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk43"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">eq_rect_eq</span> :
    <span class="kr">forall</span> (<span class="nv">p</span>:U) (<span class="nv">Q</span>:U -&gt; <span class="kt">Type</span>) (<span class="nv">x</span>:Q p) (<span class="nv">h</span>:p = p), x = eq_rect p Q x p h.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">p</span> : U) (<span class="nv">Q</span> : U -&gt; <span class="kt">Type</span>) (<span class="nv">x</span> : Q p) (<span class="nv">h</span> : p = p),
x = eq_rect p Q x p h</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> eq_rect_eq_dec eq_dec.</span></span></span></pre><div class="doc">
Injectivity of Dependent Equality 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk44" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk44"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">eq_dep_eq</span> :
    <span class="kr">forall</span> (<span class="nv">P</span>:U-&gt;<span class="kt">Type</span>) (<span class="nv">p</span>:U) (<span class="nv">x</span> <span class="nv">y</span>:P p), eq_dep U P p x p y -&gt; x = y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : U -&gt; <span class="kt">Type</span>) (<span class="nv">p</span> : U) (<span class="nv">x</span> <span class="nv">y</span> : P p),
eq_dep U P p x p y -&gt; x = y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> (eq_rect_eq__eq_dep_eq U eq_rect_eq).</span></span></span></pre><div class="doc">
Uniqueness of Identity Proofs (UIP) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk45" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk45"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">UIP</span> : <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span>:U) (<span class="nv">p1</span> <span class="nv">p2</span>:x = y), p1 = p2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : U) (<span class="nv">p1</span> <span class="nv">p2</span> : x = y), p1 = p2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> (eq_dep_eq__UIP U eq_dep_eq).</span></span></span></pre><div class="doc">
Uniqueness of Reflexive Identity Proofs 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk46" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk46"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">UIP_refl</span> : <span class="kr">forall</span> (<span class="nv">x</span>:U) (<span class="nv">p</span>:x = x), p = eq_refl x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : U) (<span class="nv">p</span> : x = x), p = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> (UIP__UIP_refl U UIP).</span></span></span></pre><div class="doc">
Streicher's axiom K 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk47" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk47"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">Streicher_K</span> :
    <span class="kr">forall</span> (<span class="nv">x</span>:U) (<span class="nv">P</span>:x = x -&gt; <span class="kt">Prop</span>), P (eq_refl x) -&gt; <span class="kr">forall</span> <span class="nv">p</span>:x = x, P p.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : U) (<span class="nv">P</span> : x = x -&gt; <span class="kt">Prop</span>),
P eq_refl -&gt; <span class="kr">forall</span> <span class="nv">p</span> : x = x, P p</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> (K_dec_type eq_dec).</span></span></span></pre><div class="doc">
Proof-irrelevance on subsets of decidable sets 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk48" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk48"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">inj_pairP2</span> :
    <span class="kr">forall</span> (<span class="nv">P</span>:U -&gt; <span class="kt">Prop</span>) (<span class="nv">x</span>:U) (<span class="nv">p</span> <span class="nv">q</span>:P x),
      ex_intro P x p = ex_intro P x q -&gt; p = q.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : U -&gt; <span class="kt">Prop</span>) (<span class="nv">x</span> : U) (<span class="nv">p</span> <span class="nv">q</span> : P x),
ex_intro P x p = ex_intro P x q -&gt; p = q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> N.inj_pairP2.</span></span></span></pre><div class="doc">
Injectivity of equality on dependent pairs in <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk49" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk49"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">inj_pair2</span> :
    <span class="kr">forall</span> (<span class="nv">P</span>:U -&gt; <span class="kt">Type</span>) (<span class="nv">p</span>:U) (<span class="nv">x</span> <span class="nv">y</span>:P p),
      existT P p x = existT P p y -&gt; x = y.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : U -&gt; <span class="kt">Type</span>) (<span class="nv">p</span> : U) (<span class="nv">x</span> <span class="nv">y</span> : P p),
existT P p x = existT P p y -&gt; x = y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Proof</span> eq_dep_eq__inj_pair2 U N.eq_dep_eq.</span></span></span></pre><div class="doc">
Injectivity of equality on dependent pairs with second component
      in <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight">  </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">inj_pairT2</span> := inj_pair2.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">End</span> <span class="nf">DecidableEqDepSet</span>.</span></span></span></pre><div class="doc">
From decidability to inj_pair2 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk4a" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk4a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">inj_pair2_eq_dec</span> : <span class="kr">forall</span> <span class="nv">A</span>:<span class="kt">Type</span>, (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>:A, {x=y}+{x&lt;&gt;y}) -&gt;
   ( <span class="kr">forall</span> (<span class="nv">P</span>:A -&gt; <span class="kt">Type</span>) (<span class="nv">p</span>:A) (<span class="nv">x</span> <span class="nv">y</span>:P p), existT P p x = existT P p y -&gt; x = y ).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}) -&gt;
<span class="kr">forall</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">p</span> : A) (<span class="nv">x</span> <span class="nv">y</span> : P p),
existT P p x = existT P p y -&gt; x = y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk4b" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk4b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}) -&gt;
<span class="kr">forall</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">p</span> : A) (<span class="nv">x</span> <span class="nv">y</span> : P p),
existT P p x = existT P p y -&gt; x = y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk4c" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk4c"><span class="highlight"><span class="nb">intros</span> A eq_dec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">p</span> : A) (<span class="nv">x</span> <span class="nv">y</span> : P p),
existT P p x = existT P p y -&gt; x = y</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk4d" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk4d"><span class="highlight"><span class="nb">apply</span> eq_dep_eq__inj_pair2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Eq_dep_eq A</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk4e" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk4e"><span class="highlight"><span class="nb">apply</span> eq_rect_eq__eq_dep_eq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Eq_rect_eq A</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk4f" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk4f"><span class="highlight"><span class="nb">unfold</span> Eq_rect_eq, Eq_rect_eq_on.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, {x = y} + {x &lt;&gt; y}</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">p</span> : A) (<span class="nv">Q</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">x</span> : Q p) (<span class="nv">h</span> : p = p),
x = eq_rect p Q x p h</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk50" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk50"><span class="highlight"><span class="nb">intros</span>; <span class="nb">apply</span> eq_rect_eq_dec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_dec</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A, {x0 = y} + {x0 &lt;&gt; y}</span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Q p</span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">p = p</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A, {x0 = y} + {x0 &lt;&gt; y}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> eq_dec.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Register</span> inj_pair2_eq_dec <span class="kr">as</span> core.eqdep_dec.inj_pair2.</span></span></span></pre><div class="doc">
Examples of short direct proofs of unicity of reflexivity proofs
      on specific domains 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk51" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk51"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">UIP_refl_unit</span> (<span class="nv">x</span> : tt = tt) : x = eq_refl tt.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">tt = tt</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk52" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk52"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">tt = tt</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk53" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk53"><span class="highlight"><span class="nb">change</span> (<span class="kr">match</span> tt <span class="kr">as</span> b <span class="kr">return</span> tt = b -&gt; <span class="kt">Prop</span> <span class="kr">with</span>
          | tt =&gt; <span class="kr">fun</span> <span class="nv">x</span> =&gt; x = eq_refl tt
          <span class="kr">end</span> x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">tt = tt</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> tt <span class="kr">as</span> b <span class="kr">return</span> (tt = b -&gt; <span class="kt">Prop</span>) <span class="kr">with</span>
| tt =&gt; <span class="kr">fun</span> <span class="nv">x0</span> : tt = tt =&gt; x0 = eq_refl
<span class="kr">end</span> x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> x; <span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk54" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk54"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">UIP_refl_bool</span> (<span class="nv">b</span>:bool) (<span class="nv">x</span> : b = b) : x = eq_refl.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = b</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk55" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk55"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">b = b</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk56" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk56"><span class="highlight"><span class="nb">destruct</span> b.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">true = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = eq_refl</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Eqdep-dec-v-chk57" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">false = false</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Eqdep-dec-v-chk57"><hr></label><div class="goal-conclusion"><span class="highlight">x = eq_refl</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk58" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk58"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">true = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk59" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk59"><span class="highlight"><span class="nb">change</span> (<span class="kr">match</span> true <span class="kr">as</span> b <span class="kr">return</span> true=b -&gt; <span class="kt">Prop</span> <span class="kr">with</span>
            | true =&gt; <span class="kr">fun</span> <span class="nv">x</span> =&gt; x = eq_refl
            | _ =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="kt">True</span>
            <span class="kr">end</span> x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">true = true</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">if</span> true <span class="kr">as</span> b <span class="kr">return</span> (true = b -&gt; <span class="kt">Prop</span>)
 <span class="kr">then</span> <span class="kr">fun</span> <span class="nv">x0</span> : true = true =&gt; x0 = eq_refl
 <span class="kr">else</span> <span class="kr">fun</span> <span class="nv">_</span> : true = false =&gt; <span class="kt">True</span>) x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> x; <span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk5a" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk5a"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">false = false</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk5b" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk5b"><span class="highlight"><span class="nb">change</span> (<span class="kr">match</span> false <span class="kr">as</span> b <span class="kr">return</span> false=b -&gt; <span class="kt">Prop</span> <span class="kr">with</span>
            | false =&gt; <span class="kr">fun</span> <span class="nv">x</span> =&gt; x = eq_refl
            | _ =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="kt">True</span>
            <span class="kr">end</span> x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">false = false</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">if</span> false <span class="kr">as</span> b <span class="kr">return</span> (false = b -&gt; <span class="kt">Prop</span>)
 <span class="kr">then</span> <span class="kr">fun</span> <span class="nv">_</span> : false = true =&gt; <span class="kt">True</span>
 <span class="kr">else</span> <span class="kr">fun</span> <span class="nv">x0</span> : false = false =&gt; x0 = eq_refl) x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> x; <span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk5c" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk5c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">UIP_refl_nat</span> (<span class="nv">n</span>:nat) (<span class="nv">x</span> : n = n) : x = eq_refl.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk5d" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk5d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">n = n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk5e" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk5e"><span class="highlight"><span class="nb">induction</span> n.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = eq_refl</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="Eqdep-dec-v-chk5f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n = S n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : n = n, x0 = eq_refl</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="Eqdep-dec-v-chk5f"><hr></label><div class="goal-conclusion"><span class="highlight">x = eq_refl</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk60" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk60"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk61" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk61"><span class="highlight"><span class="nb">change</span> (<span class="kr">match</span> <span class="mi">0</span> <span class="kr">as</span> n <span class="kr">return</span> <span class="mi">0</span>=n -&gt; <span class="kt">Prop</span> <span class="kr">with</span>
            | <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">x</span> =&gt; x = eq_refl
            | _ =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="kt">True</span>
            <span class="kr">end</span> x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="mi">0</span> = <span class="mi">0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> <span class="mi">0</span> <span class="kr">as</span> n <span class="kr">return</span> (<span class="mi">0</span> = n -&gt; <span class="kt">Prop</span>) <span class="kr">with</span>
| <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">x0</span> : <span class="mi">0</span> = <span class="mi">0</span> =&gt; x0 = eq_refl
| S n =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">0</span> = S n =&gt; <span class="kt">True</span>
<span class="kr">end</span> x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> x; <span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk62" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk62"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n = S n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : n = n, x0 = eq_refl</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk63" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk63"><span class="highlight"><span class="nb">specialize</span> IHn <span class="kr">with</span> (<span class="nb">f_equal</span> pred x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n = S n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="nb">f_equal</span> Nat.pred x = eq_refl</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk64" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk64"><span class="highlight"><span class="nb">change</span> eq_refl <span class="kr">with</span> (<span class="nb">f_equal</span> S (@eq_refl _ n)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n = S n</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="nb">f_equal</span> Nat.pred x = eq_refl</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = <span class="nb">f_equal</span> S eq_refl</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk65" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk65"><span class="highlight"><span class="nb">rewrite</span> &lt;- IHn; <span class="nb">clear</span> IHn.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n = S n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = <span class="nb">f_equal</span> S (<span class="nb">f_equal</span> Nat.pred x)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk66" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk66"><span class="highlight"><span class="nb">change</span> (<span class="kr">match</span> S n <span class="kr">as</span> n&#39; <span class="kr">return</span> S n = n&#39; -&gt; <span class="kt">Prop</span> <span class="kr">with</span>
            | <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="kt">True</span>
            | S n&#39; =&gt; <span class="kr">fun</span> <span class="nv">x</span> =&gt;
                x = <span class="nb">f_equal</span> S (<span class="nb">f_equal</span> pred x)
            <span class="kr">end</span> x).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n = S n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> S n <span class="kr">as</span> n&#39; <span class="kr">return</span> (S n = n&#39; -&gt; <span class="kt">Prop</span>) <span class="kr">with</span>
| <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : S n = <span class="mi">0</span> =&gt; <span class="kt">True</span>
| S n&#39; =&gt;
    <span class="kr">fun</span> <span class="nv">x0</span> : S n = S n&#39; =&gt;
    x0 = <span class="nb">f_equal</span> S (<span class="nb">f_equal</span> Nat.pred x0)
<span class="kr">end</span> x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="Eqdep-dec-v-chk67" style="display: none" type="checkbox"><label class="coq-input" for="Eqdep-dec-v-chk67"><span class="highlight"><span class="nb">pattern</span> (S n) <span class="nb">at</span> <span class="mi">2</span> <span class="mi">3</span>, x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">S n = S n</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">e</span> : S n = n0) =&gt;
 <span class="kr">match</span> n0 <span class="kr">as</span> n&#39; <span class="kr">return</span> (S n = n&#39; -&gt; <span class="kt">Prop</span>) <span class="kr">with</span>
 | <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : S n = <span class="mi">0</span> =&gt; <span class="kt">True</span>
 | S n&#39; =&gt;
     <span class="kr">fun</span> <span class="nv">x0</span> : S n = S n&#39; =&gt;
     x0 = <span class="nb">f_equal</span> S (<span class="nb">f_equal</span> Nat.pred x0)
 <span class="kr">end</span> e) (S n) x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> x; <span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Defined</span>.</span></span></span></pre></article></body></html>