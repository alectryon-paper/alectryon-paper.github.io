<!DOCTYPE html>
<html><head><title>WeakFan.v</title><meta charset="utf-8"><meta content="Alectryon v0.2" name="generator"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet"><link href="https://unpkg.com/firacode/distr/fira_code.css" rel="stylesheet"><link href="alectryon.css" rel="stylesheet"><script src="alectryon.js"></script><style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-standalone alectryon-centered alectryon-coqdoc"><div class="alectryon-header">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running <a href="https://coq.inria.fr/">Coq</a>+<a href="https://github.com/ejgallego/coq-serapi">SerAPI</a> v8.10.0+0.7.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-nc"><span class="highlight"><span class="sd">(************************************************************************)</span>
<span class="c">(*         *   The Coq Proof Assistant / The Coq Development Team       *)</span>
<span class="c">(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)</span>
<span class="c">(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)</span>
<span class="c">(*   \VV/  **************************************************************)</span>
<span class="c">(*    //   *    This file is distributed under the terms of the         *)</span>
<span class="c">(*         *     GNU Lesser General Public License Version 2.1          *)</span>
<span class="c">(*         *     (see LICENSE file for the text of the license)         *)</span>
<span class="sd">(************************************************************************)</span></span></span></pre><div class="doc">
A constructive proof of a non-standard version of the weak Fan Theorem
    in the formulation of which infinite paths are treated as
    predicates. The representation of paths as relations avoid the
    need for classical logic and unique choice. The idea of the proof
    comes from the proof of the weak K√∂nig's lemma from separation in
    second-order arithmetic <span class="inlinecode">[<span class="id" title="var">Simpson99</span>]</span>.

<div class="paragraph"> </div>
<span class="inlinecode">[<span class="id" title="var">Simpson99</span>]</span> Stephen G. Simpson. Subsystems of second order
    arithmetic, Cambridge University Press, 1999 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> List.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Import</span> ListNotations.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">inductively_barred</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> means that P eventually holds above l 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">inductively_barred</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span> :=
| <span class="bp">now</span> l : P l -&gt; inductively_barred P l
| propagate l :
    inductively_barred P (true::l) -&gt;
    inductively_barred P (false::l) -&gt;
    inductively_barred P l.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">approx</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> says that <span class="inlinecode"><span class="id" title="var">l</span></span> is a boolean representation of a prefix of <span class="inlinecode"><span class="id" title="var">X</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">approx</span> <span class="nv">X</span> (<span class="nv">l</span>:list bool) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; <span class="kt">True</span>
  | b::l =&gt; approx X l /\ (<span class="kr">if</span> b <span class="kr">then</span> X (length l) <span class="kr">else</span> ~ X (length l))
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">barred</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> means that for any infinite path represented as a predicate,
    the property <span class="inlinecode"><span class="id" title="var">P</span></span> holds for some prefix of the path 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">barred</span> <span class="nv">P</span> :=
  <span class="kr">forall</span> (<span class="nv">X</span>:nat -&gt; <span class="kt">Prop</span>), <span class="kr">exists</span> <span class="nv">l</span>, approx X l /\ P l.</span></span></span></pre><div class="doc">
The proof proceeds by building a set <span class="inlinecode"><span class="id" title="var">Y</span></span> of finite paths
   approximating either the smallest unbarred infinite path in <span class="inlinecode"><span class="id" title="var">P</span></span>, if
   there is one (taking <span class="inlinecode"><span class="id" title="var">true</span></span>&gt;<span class="inlinecode"><span class="id" title="var">false</span></span>), or the path <span class="inlinecode"><span class="id" title="var">true</span>::<span class="id" title="var">true</span>::...</span>
   if <span class="inlinecode"><span class="id" title="var">P</span></span> happens to be inductively_barred 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">Y</span> <span class="nv">P</span> (<span class="nv">l</span>:list bool) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; <span class="kt">True</span>
  | b::l =&gt;
      Y P l /\
      <span class="kr">if</span> b <span class="kr">then</span> inductively_barred P (false::l) <span class="kr">else</span> ~ inductively_barred P (false::l)
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk0" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">Y_unique</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">l1</span> <span class="nv">l2</span>, length l1 = length l2 -&gt; Y P l1 -&gt; Y P l2 -&gt; l1 = l2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : list bool -&gt; <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list bool),
length l1 = length l2 -&gt; Y P l1 -&gt; Y P l2 -&gt; l1 = l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk1" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : list bool -&gt; <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list bool),
length l1 = length l2 -&gt; Y P l1 -&gt; Y P l2 -&gt; l1 = l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk2" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk2"><span class="highlight"><span class="nb">induction</span> l1, l2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length [] = length [] -&gt; Y P [] -&gt; Y P [] -&gt; [] = []</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WeakFan-v-chk3" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WeakFan-v-chk3"><hr></label><div class="goal-conclusion"><span class="highlight">length [] = length (b :: l2) -&gt;
Y P [] -&gt; Y P (b :: l2) -&gt; [] = b :: l2</span></div></blockquote><input class="coq-extra-goal-toggle" id="WeakFan-v-chk4" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l2</span> : list bool,
length l1 = length l2 -&gt;
Y P l1 -&gt; Y P l2 -&gt; l1 = l2</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WeakFan-v-chk4"><hr></label><div class="goal-conclusion"><span class="highlight">length (a :: l1) = length [] -&gt;
Y P (a :: l1) -&gt; Y P [] -&gt; a :: l1 = []</span></div></blockquote><input class="coq-extra-goal-toggle" id="WeakFan-v-chk5" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
length l1 = length l0 -&gt;
Y P l1 -&gt; Y P l0 -&gt; l1 = l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WeakFan-v-chk5"><hr></label><div class="goal-conclusion"><span class="highlight">length (a :: l1) = length (b :: l2) -&gt;
Y P (a :: l1) -&gt; Y P (b :: l2) -&gt; a :: l1 = b :: l2</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk6" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk6"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length [] = length [] -&gt; Y P [] -&gt; Y P [] -&gt; [] = []</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk7" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk7"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length [] = length (b :: l2) -&gt;
Y P [] -&gt; Y P (b :: l2) -&gt; [] = b :: l2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk8" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk8"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l2</span> : list bool,
length l1 = length l2 -&gt;
Y P l1 -&gt; Y P l2 -&gt; l1 = l2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length (a :: l1) = length [] -&gt;
Y P (a :: l1) -&gt; Y P [] -&gt; a :: l1 = []</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">discriminate</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk9" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk9"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
length l1 = length l0 -&gt;
Y P l1 -&gt; Y P l0 -&gt; l1 = l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">length (a :: l1) = length (b :: l2) -&gt;
Y P (a :: l1) -&gt; Y P (b :: l2) -&gt; a :: l1 = b :: l2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chka" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chka"><span class="highlight"><span class="nb">intros</span> H (HY1,H1) (HY2,H2).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
length l1 = length l0 -&gt;
Y P l1 -&gt; Y P l0 -&gt; l1 = l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length (a :: l1) = length (b :: l2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span> inductively_barred P (false :: l1)
<span class="kr">else</span> ~ inductively_barred P (false :: l1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> b
<span class="kr">then</span> inductively_barred P (false :: l2)
<span class="kr">else</span> ~ inductively_barred P (false :: l2)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a :: l1 = b :: l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chkb" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chkb"><span class="highlight"><span class="nb">injection</span> H <span class="kr">as</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
length l1 = length l0 -&gt;
Y P l1 -&gt; Y P l0 -&gt; l1 = l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l1 = length l2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span> inductively_barred P (false :: l1)
<span class="kr">else</span> ~ inductively_barred P (false :: l1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> b
<span class="kr">then</span> inductively_barred P (false :: l2)
<span class="kr">else</span> ~ inductively_barred P (false :: l2)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a :: l1 = b :: l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chkc" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chkc"><span class="highlight"><span class="nb">pose proof</span> (IHl1 l2 H HY1 HY2).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">forall</span> <span class="nv">l0</span> : list bool,
length l1 = length l0 -&gt;
Y P l1 -&gt; Y P l0 -&gt; l1 = l0</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l1 = length l2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l1</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span> inductively_barred P (false :: l1)
<span class="kr">else</span> ~ inductively_barred P (false :: l1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l2</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> b
<span class="kr">then</span> inductively_barred P (false :: l2)
<span class="kr">else</span> ~ inductively_barred P (false :: l2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">l1 = l2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a :: l1 = b :: l2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chkd" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chkd"><span class="highlight"><span class="nb">clear</span> HY1 HY2 H IHl1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span> inductively_barred P (false :: l1)
<span class="kr">else</span> ~ inductively_barred P (false :: l1)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> b
<span class="kr">then</span> inductively_barred P (false :: l2)
<span class="kr">else</span> ~ inductively_barred P (false :: l2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">l1 = l2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a :: l1 = b :: l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chke" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chke"><span class="highlight"><span class="nb">subst</span> l1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span> inductively_barred P (false :: l2)
<span class="kr">else</span> ~ inductively_barred P (false :: l2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> b
<span class="kr">then</span> inductively_barred P (false :: l2)
<span class="kr">else</span> ~ inductively_barred P (false :: l2)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a :: l2 = b :: l2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chkf" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chkf"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span> inductively_barred P (false :: l2)
<span class="kr">else</span> ~ inductively_barred P (false :: l2)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> b
<span class="kr">then</span> inductively_barred P (false :: l2)
<span class="kr">else</span> ~ inductively_barred P (false :: l2)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">a = b</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> a, b; <span class="nb">firstorder</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">X</span></span> is the translation of <span class="inlinecode"><span class="id" title="var">Y</span></span> as a predicate 
</div><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">X</span> <span class="nv">P</span> <span class="nv">n</span> := <span class="kr">exists</span> <span class="nv">l</span>, length l = n /\ Y P (true::l).</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk10" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk10"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">Y_approx</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">l</span>, approx (X P) l -&gt; Y P l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : list bool -&gt; <span class="kt">Type</span>) (<span class="nv">l</span> : list bool),
approx (X P) l -&gt; Y P l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk11" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk11"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">P</span> : list bool -&gt; <span class="kt">Type</span>) (<span class="nv">l</span> : list bool),
approx (X P) l -&gt; Y P l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk12" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk12"><span class="highlight"><span class="nb">induction</span> l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">approx (X P) [] -&gt; Y P []</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WeakFan-v-chk13" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WeakFan-v-chk13"><hr></label><div class="goal-conclusion"><span class="highlight">approx (X P) (a :: l) -&gt; Y P (a :: l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk14" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk14"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">approx (X P) [] -&gt; Y P []</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk15" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk15"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">approx (X P) (a :: l) -&gt; Y P (a :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk16" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk16"><span class="highlight"><span class="nb">intros</span> (H,Hb).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a <span class="kr">then</span> X P (length l) <span class="kr">else</span> ~ X P (length l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Y P (a :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk17" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk17"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a <span class="kr">then</span> X P (length l) <span class="kr">else</span> ~ X P (length l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Y P l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WeakFan-v-chk18" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a <span class="kr">then</span> X P (length l) <span class="kr">else</span> ~ X P (length l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WeakFan-v-chk18"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span> inductively_barred P (false :: l)
<span class="kr">else</span> ~ inductively_barred P (false :: l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk19" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk19"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a <span class="kr">then</span> X P (length l) <span class="kr">else</span> ~ X P (length l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">Y P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk1a" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk1a"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a <span class="kr">then</span> X P (length l) <span class="kr">else</span> ~ X P (length l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span> inductively_barred P (false :: l)
<span class="kr">else</span> ~ inductively_barred P (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk1b"><span class="highlight"><span class="nb">unfold</span> X <span class="kr">in</span> Hb.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span>
 <span class="kr">exists</span> <span class="nv">l0</span> : list bool,
   length l0 = length l /\ Y P (true :: l0)
<span class="kr">else</span>
 ~
 (<span class="kr">exists</span> <span class="nv">l0</span> : list bool,
    length l0 = length l /\ Y P (true :: l0))</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span> inductively_barred P (false :: l)
<span class="kr">else</span> ~ inductively_barred P (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk1c"><span class="highlight"><span class="nb">destruct</span> a.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">l0</span> : list bool,
  length l0 = length l /\ Y P (true :: l0)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P (false :: l)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WeakFan-v-chk1d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(<span class="kr">exists</span> <span class="nv">l0</span> : list bool,
   length l0 = length l /\ Y P (true :: l0))</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WeakFan-v-chk1d"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred P (false :: l)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk1e"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">l0</span> : list bool,
  length l0 = length l /\ Y P (true :: l0)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk1f"><span class="highlight"><span class="nb">destruct</span> Hb <span class="kr">as</span> (l&#39;,(Hl&#39;,(HYl&#39;,HY))).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">length l&#39; = length l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HYl'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HY</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P (false :: l&#39;)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">rewrite</span> &lt;- (Y_unique P l&#39; l Hl&#39;); <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk20" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk20"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l -&gt; Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">approx (X P) l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~
(<span class="kr">exists</span> <span class="nv">l0</span> : list bool,
   length l0 = length l /\ Y P (true :: l0))</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">~ inductively_barred P (false :: l)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">firstorder</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-nc"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk21" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk21"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">WeakFanTheorem</span> : <span class="kr">forall</span> <span class="nv">P</span>, barred P -&gt; inductively_barred P [].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
barred P -&gt; inductively_barred P []</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk22" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk22"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : list bool -&gt; <span class="kt">Prop</span>,
barred P -&gt; inductively_barred P []</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk23" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk23"><span class="highlight"><span class="nb">intros</span> P Hbar.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">barred P</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P []</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk24" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk24"><span class="highlight"><span class="nb">destruct</span> Hbar <span class="kr">with</span> (X P) <span class="kr">as</span> (l,(Hd%Y_approx,HP)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">barred P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P []</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk25" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk25"><span class="highlight"><span class="nb">assert</span> (inductively_barred P l) <span class="bp">by</span> (<span class="nb">apply</span> (<span class="bp">now</span> P l), HP).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hbar</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">barred P</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P []</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk26" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk26"><span class="highlight"><span class="nb">clear</span> Hbar HP.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P l</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P []</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk27" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk27"><span class="highlight"><span class="nb">induction</span> l <span class="kr">as</span> [|a l].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P []</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P []</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WeakFan-v-chk28" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P (a :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P (a :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l -&gt;
inductively_barred P l -&gt;
inductively_barred P []</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WeakFan-v-chk28"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P []</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk29" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk29"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P []</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P []</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P []</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk2a" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk2a"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P (a :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P (a :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l -&gt;
inductively_barred P l -&gt;
inductively_barred P []</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P []</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk2b" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk2b"><span class="highlight"><span class="nb">destruct</span> Hd <span class="kr">as</span> (Hd,HX).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HX</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span> inductively_barred P (false :: l)
<span class="kr">else</span> ~ inductively_barred P (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P (a :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l -&gt;
inductively_barred P l -&gt;
inductively_barred P []</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P []</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk2c" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk2c"><span class="highlight"><span class="nb">apply</span> (IHl Hd).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HX</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span> inductively_barred P (false :: l)
<span class="kr">else</span> ~ inductively_barred P (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P (a :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l -&gt;
inductively_barred P l -&gt;
inductively_barred P []</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk2d" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk2d"><span class="highlight"><span class="nb">clear</span> IHl.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HX</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">if</span> a
<span class="kr">then</span> inductively_barred P (false :: l)
<span class="kr">else</span> ~ inductively_barred P (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P (a :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P l</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk2e"><span class="highlight"><span class="nb">destruct</span> a; <span class="nb">unfold</span> X <span class="kr">in</span> HX; <span class="nb">simpl</span> <span class="kr">in</span> HX.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HX</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="WeakFan-v-chk2f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HX</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred P (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P (false :: l)</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="WeakFan-v-chk2f"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P l</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk30" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk30"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HX</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P (true :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> propagate; <span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="WeakFan-v-chk31" style="display: none" type="checkbox"><label class="coq-input" for="WeakFan-v-chk31"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool -&gt; <span class="kt">Prop</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list bool</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Y P l</span></span></span></div><div class="goal-hyp"><span class="hyp-names">HX</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">~ inductively_barred P (false :: l)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">inductively_barred P (false :: l)</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="highlight">inductively_barred P l</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">exfalso</span>; <span class="nb">destruct</span> (HX H).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></article></body></html>